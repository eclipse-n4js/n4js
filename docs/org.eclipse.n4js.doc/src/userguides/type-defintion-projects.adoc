////
Copyright (c) 2016 NumberFour AG.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
  NumberFour AG - Initial API and implementation
////

:toc: right
:toc-title: Jump to section:
:commandkey: &#8984;


.N4JS Type Definitions Guide
= N4JS Type Definitions Guide

N4JS projects can depend on ordinary JavaScript projects by including them in the package.json file.
From there on, modules of those JavaScript projects can be imported when writing N4JS code.
However, since JavaScript is untyped there will not be any type information for e.g. classes, functions
of ordinary JavaScript projects unless this type information is provided by a type definition project.
Type definition projects do only contain n4jsd files that reflect the classes and functions of a specific npm.
To refer to a JavaScript npm, the term _implementation project_ will be used.


== Specify Type Definition

project type: definition
definesPackage: <name>

mainModule


== Name Conventions

A type definition package can have an arbitrary name and define an arbitrary npm package.
This can be handy for testing purposes or just creating some temporary type definitions for a local package.
However, we chose to use a convention to simplify finding the right type definition package for a specific implementation project.
First, the scope '@n4jsd' and second the exact name of the implementation project is used.
For instance, when a user wants to install type definitions for the implementation project 'express',
our related type definitions are called '@n4jsd/express'.


== Version Conventions


Since the implementation project will evolve over time and publish different versions, the need arises to also
publish the type definition project in different versions that reflect this evolution.
In addition to the evolution of the implementation project, a new version of the type definition project can
also become necessary in case a bug was found in a previous version or in case the language of N4JS changes
and the type definitions have to be adjusted accordingly.
Effectively, this will lead to a situation where both the implementation and the type definition project have
a version that are technically unrelated from an npm point of view, but still are somehow related to each other
from a semantical point of view.


=== Define a New Type Definition Package

We use the following convention to compute the version of type definition packages.


[source]
.Convention for initial type definition versions
Major~types~.Minor~types~.Patch~types~ = Major~impl~.Minor~impl~.0


[source]
.Example for initial type definition of express@3.3.3
Major~types~.Minor~types~.Patch~types~ = 3.3.0


Let's say that a new version of a type definition package called _types_ should be created
that defines types for an npm called _impl_ of version Major~impl~.Minor~impl~.Patch~impl~.
According to our convention, the major and minor version numbers of the type definition package
should just be copied from the version of the _impl_ package.
However, the version patch number of _types_ should not be taken from _impl_.
Instead, the patch number of _types_ starts with _0_ and increases with every update of this type definition version.
For instance when a bug was found in version Major~types~.Minor~types~.0, the definitions have been extended, or
adjusted to new language features, only the patch number increases to e.g. Major~types~.Minor~types~.1.


=== Using a Type Definition Package

On the client side, a type definition package is listed among the dependency section.
Here we use the following convention to specify the required version of a type definition package.


[source]
.Convention for dependencies
{
	"@n4jsd/Types": "<=Major~impl~.Minor~impl~.*"
}


[source]
.Example for dependencies to express and its type definition project
{
	"express": "^3.3.3",
	"@n4jsd/express": "<=3.3.*"
}


According to this convention, the major and minor version numbers of the implementation package are used,
prepended with a smaller-equals and appended with an asterisk for the patch number.
This also applies when the implementation version contains a tilde, a caret, etc., or is omitting a minor or patch number.
In case a non SemVer version is given (e.g. 'latest', empty string, url, etc.)
it is recommended to plain copy the non SemVer version when possible.


=== Rational

The rational behind this convention reflects the idea of semantic versioning:

[quote, https://semver.org/]
____
Given a version number MAJOR.MINOR.PATCH, increment the:

* MAJOR version when you make incompatible API changes,
* MINOR version when you add functionality in a backwards-compatible manner, and
* PATCH version when you make backwards-compatible bug fixes.
____


Patch version increments are always backwards compatible according to SemVer.
In addition also no further functionality is added since this would imply at least an increment of the minor version.
Consequently, patch versions do not affect the interface or type information of an implementation project.
This is why patch version number fully suffices to reflect bug fixes and language changes for a given major.minor version.

On client side, we recommend to use a smaller-equals qualifier because most probably there will not be the exact version
of a requested type definition project.
Instead, only some version major.minor versions will have type definition counter part.
Using a smaller-equals qualifier will make sure that a client will always get the latest version of a requested implementation project version.
In case a newer version of the implementation project was already published,
this convention guarantees that new versions of the type definition project are not installed.




