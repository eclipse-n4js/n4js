////
Copyright (c) 2016 NumberFour AG.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
  NumberFour AG - Initial API and implementation
////

:toc: right
:toc-title: Jump to section:
:commandkey: &#8984;


.N4JS Type Definitions Guide
= N4JS Type Definitions Guide

N4JS projects can depend on ordinary JavaScript projects by including them in the package.json file.
From there on, modules of those JavaScript projects can be imported when writing N4JS code.
However, since JavaScript is untyped there will not be any type information for e.g. classes, functions
of ordinary JavaScript projects unless this type information is provided by a type definition project.
Type definition projects do only contain n4jsd files that reflect the classes and functions of a specific npm.
To refer to the npm, the term implementation project will be used.

== Specify Type Definition

project type: definition
definesPackage: <name>

mainModule


== Name Conventions

A type definition package can have an arbitrary name and define an arbitrary npm package.
This can be handy for testing purposes or just creating some temporary type definitions for a local package.
However, we chose to use a convention to simplify finding type definition packages.
First, we use the scope '@n4jsd' and second the exact name of the typed package is used.
For instance, when a user wants to install type definitions for the package 'express', our related type definitions are called '@n4jsd/express'.


== Version Conventions


Since the implementation project will evolve over time and publish different versions, the need arises to also
publish the type definition project in different versions that reflect this evolution.
In addition to the evolution of the implementation project, a new version of the type definition project can
also become necessary in case a bug was found in a previous version or in case the language of N4JS changes
and the type definitions have to be adjusted accordingly.
Effectively, this will lead to a situation where both the implementation and the type definition project have
a version that are technically unrelated from an npm point of view, but still are somehow related to each other
from a semantical point of view.


=== Define a New Type Definition Package

We use the following convention to compute the version of type definition packages.


[source]
.Convention for versions: Scheme
Major~types~.Minor~types~.Patch~types~ = Major~impl~.Minor~impl~.0


[source]
.Convention for versions: Example for express@3.3.3
Major~types~.Minor~types~.Patch~types~ = 3.3.0


Let's say that a new version of a type definition package called _types_ should be created
that defines types for an npm called _impl_ of version Major~impl~.Minor~impl~.Patch~impl~.
According to our convention, the major and minor version numbers of the type definition package
should just be copied from the version of the _impl_ package.
However, the version patch number of _types_ should not be taken from _impl_.
Instead, the patch number of _types_ starts with _0_ and increases with every update of this type definition version.
For instance when a bug was found in version Major~types~.Minor~types~.0, the definitions have been extended, or
adjusted to new language features, only the patch number increases to e.g. Major~types~.Minor~types~.1.



=== Using a Type Definition Package

On the client side, a type definition package is listed among the dependency section.
Here we use the following convention to specify the required version of a type definition package.


[source]
.Convention for dependencies: Scheme
{
	"@n4jsd/Types": "<=Major~impl~.Minor~impl~.*"
}


[source]
.Convention for dependencies: Example
{
	"express": "^3.3.3",
	"@n4jsd/express": "<=3.3.*"
}


According to this convention, the major and minor version numbers of the implementation package are used,
prepended with a smaller-equals and appended with an asterisk for the patch number.
This also applies when the implementation version contains a tilde, a caret, etc., or is omitting minor or patch number.
In case a non SemVer version is given (e.g. 'latest', only asterisk, url, etc.)
it is recommended to plain copy the non SemVer version when possible.





