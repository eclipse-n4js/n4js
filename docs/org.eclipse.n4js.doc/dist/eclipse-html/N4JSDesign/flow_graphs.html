<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="author" content="2019-01-11 12:16:49 CET">
<title>N4JS Design Specification</title>
<link rel="stylesheet" href="styles/eclipse-help-mode-spec.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<!-- ************* Meta ************* -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- ************* OpenGraph ************-->
<meta name="description" content="N4JS Language Specification">

<!-- ************* Favicon ************-->
<link rel="icon" href="images/favicon.ico" />

<!-- ************* Back-to-top JQuery ************* -->
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.0/jquery-ui.js"></script>

<link href="styles/prism.min.css" rel="stylesheet" />

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_CHTML">
</script>
<style>
      .admonitionblock td.icon .icon-todo:before{content:"\f249";color:#f4ee42}
    </style>
</head>
<body class="book"><div class="sect1">
<h2 id="chap:flowgraphs"><a class="anchor" href="#chap:flowgraphs"></a><a class="link" href="#chap:flowgraphs">5. Flow Graphs</a></h2>
<div class="sectionbody">
<div class="sect2 language-n4js">
<h3 id="sec:flowgraphs_overview"><a class="anchor" href="#sec:flowgraphs_overview"></a><a class="link" href="#sec:flowgraphs_overview">5.1. Flow graphs overview</a></h3>
<div class="paragraph">
<p>In this chapter, the control and data flow analyses are introduced.
Since not all AST elements are relevant for the control or data flow analyses, a new marker class is introduced called <code>ControlFlowElement</code>.
All AST elements which are part of the control flow graph implement this class.
The term control flow is abbreviated as <em>CF</em> and hence <code>ControlFlowElement</code>s are abbreviated as <em>CF elements</em>.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="sidebarblock">
<div class="content">
<a href="https://github.com/eclipse/n4js/issues/120" class="gray" title="GitHub Issues"><span class="image"><img src="images/issue.svg" alt=""></span> #120</a>
</div>
</div>
<div class="paragraph">
<p>The following picture shows the control flow graph of the function <code>f</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="chapters/10_flowgraphs/images/cfg_for_loop.png" alt="cfg for loop">
</div>
<div class="title">Figure 7. Control flow graph of a simple function</div>
</div>
<div class="sect3">
<h4 id="_internal-graph"><a class="anchor" href="#_internal-graph"></a><a class="link" href="#_internal-graph">5.1.1. Internal graph</a></h4>
<div class="paragraph">
<p>Every <em>internal graph</em> refers to a single <em>control flow container</em>.
The graph consists of <em>nodes</em> and <em>edges</em>, where the edges are instances of <code>ControlFlowEdge</code>, and nodes are instances of <code>Node</code>.
Additionally, a so called <em>complex node</em> is used to group nodes that belong to the same CF element.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Internal graph</dt>
<dd>
<p>Control flow graphs are created based on the AST elements.
Nevertheless, a fine-grained abstraction is used that is called <em>internal graph</em>.
The internal graph reflects all control flows and data effects that happen implicitly and are part of the language&#8217;s semantics.
For instance, the for-of statement on iterable objects forks the control flow after invoking the <code>next()</code> method.
This is done implicitly and not part of the written source code.
Moreover, this invocation could cause side effects.
These control flows and effects are reflected using the internal graph.
To implement analyses that refer to AST elements, an API for flow analyses is provided which hides the internal graph and works with AST elements only.
In the following, the term <em>control flow graph</em> refers to the internal graph.</p>
</dd>
<dt class="hdlist1">Control flow container</dt>
<dd>
<p>At several places in the AST, an execution of statements or elements can happen.
Obviously, statements can be executed in bodies of methods or function expressions.
In addition, execution can also happen in field initializers or the <code>Script</code> itself.
Since all these AST elements can contain executable control flow elements (CF elements), they thus contain a control flow graph.
In the following, these AST elements are called <em>control flow containers</em> or CF containers.</p>
</dd>
<dt class="hdlist1">Nodes</dt>
<dd>
<p>Nodes represent complete CF elements or parts of them.
For instance, simple CF elements like a <code>break</code> statement are represented using only one node.
Regarding more complex CF elements that introduce a more complex control flow, due to e.g. nested expressions, several nodes represent one CF element.
All nodes of a single CF element are grouped within a complex node.</p>
</dd>
<dt class="hdlist1">Edges</dt>
<dd>
<p>Edges reference a start and an end node which reflects a forward control flow direction, which is in the following called forward traverse direction.
Traversing from end to start of an edge is thus called backward traverse direction.
The so called <em>next node</em> is either the end node in context of forward, or the start node in context of backward traverse direction.
Edges also reflect the reason of the control flow using a control flow type.
The default control flow type is called <code>Successor</code> and such edges connect two ordinary subsequent nodes.
Other types like <code>Return</code> or <code>Break</code> indicate control flow that happens due to return or break statements.
A special control flow type is <code>Repeat</code> that indicates the entry of a loop body.
This edge is treated specially when traversing the control flow graph to avoid infinitive traversals of loops.</p>
</dd>
<dt class="hdlist1">Complex node</dt>
<dd>
<p>The complex node always has a single entry and exit node, no matter the control flow it causes.
For instance, although the for-statement can contain various control flows among its nested CF elements, its complex node still has a single entry and exit node.
This simplifies concatenating subsequent complex nodes, since only their exit nodes have to be connected to the following entry node.
Aside from exit and entry node, a complex node usually contains additionally nodes to represent the CF element.
These nodes are connected by control flow edge so that their control flow lies within complex node.
However, regarding nested CF elements, the control flow leaves and re-enters a complex node.
To specify which CF element is nested, a delegating node (<code>DelegatingNode</code>) is created that points to the nested CF element.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Consider that source code elements can be nested like expressions that have sub-expressions as in <code>1 + 2 * 3</code>.
Also statements can contain other statements like in <code>if (true) return;</code>.
The design of the control flow graph deals with this nesting by mapping CF elements to several nodes.
All nodes of one CF element are aggregated into the <em>complex node</em>.</p>
</div>
<div id="img:internalGraph" class="imageblock">
<div class="content">
<img src="chapters/10_flowgraphs/images/internalGraph.png" alt="internalGraph">
</div>
<div class="title">Figure 8. The source code of <code>1+2</code> creates an internal graph of three complex nodes to deal with nested integer literals</div>
</div>
<div class="paragraph">
<p>The example in the <a href="#img:internalGraph">figure above</a> shows the internal graph produced by the source code <code>1+2</code>.
Additionally, a simpler version of the internal graph is shown (called <em>User Graph View</em>), with which client analyses deal.
The user graph view is only a view on the internal graph, but does not exist as an own instance.
In the figure, the nesting of the integer literals becomes obvious:
The control flow edges of delegating nodes targets entry nodes of different CF elements.
Also, there are CF edges from the exit nodes of these nested CF elements to return the control flow.</p>
</div>
<div id="img:cn_for_stmt" class="imageblock">
<div class="content">
<img src="chapters/10_flowgraphs/images/cn_for_stmt.png" alt="cn for stmt">
</div>
<div class="title">Figure 9. Complex Node of for statement</div>
</div>
<div class="paragraph">
<p>In the <a href="#img:cn_for_stmt">above figure</a>, the complex node of the for statement is shown.
The details of the complex nodes of the nested CF elements (such as the initializer or the body statement) are omitted.
The figure displays the control flow fork after the condition and also shows the <em>Repeat</em> edge that targets the for body.
The node called <em>Catch Node</em> is used in situations when there are jumping control flows introduced for instance by a continue statement.
The catch will will then be the target of an control flow edge that starts at the continue statement.</p>
</div>
<div class="paragraph">
<p>The graph of nodes and edges is constructed in the following order.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, for every CF element a complex node and all its nodes are created.
Also, the nodes within the complex node are connected according to their control flow behavior.</p>
</li>
<li>
<p>Second, all subsequent complex nodes are connected by connecting their exit and entry nodes.
Moreover, nested complex nodes are connected by interpreting the delegating nodes.</p>
</li>
<li>
<p>Third, jumping control due to <code>return</code>, <code>throw</code>, <code>break</code> or <code>continue</code> statements is computed.
This is done by first deleting the successor edge of the jumping statement and introducing a new control flow edge that ends at the jump target.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_optimizations"><a class="anchor" href="#_optimizations"></a><a class="link" href="#_optimizations">5.1.2. Optimizations</a></h4>
<div class="paragraph">
<p>The internal graph contains many nodes to simplify the graph construction.
However, these nodes carry no relevant information when traversing the graph.
Consequently, in an optimization step, they are removed from the graph for performance reasons.</p>
</div>
<div class="paragraph">
<p>A node removal for a node <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mn>2</mn></msub></math> is done by replacing the path <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mn>1</mn></msub><mo>-</mo><mo>&gt;</mo><msub><mi>n</mi><mn>2</mn></msub><mo>-</mo><mo>&gt;</mo><msub><mi>n</mi><mn>3</mn></msub></math> by the new path <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mn>1</mn></msub><mo>-</mo><mo>&gt;</mo><msub><mi>n</mi><mn>3</mn></msub></math>.
These removals are done for delegating nodes that only have one incoming and one outgoing edge.</p>
</div>
<div class="paragraph">
<p>A second kind but similar optimization reduces the number of helper nodes that are used as entry nodes.
In case a complex nodes consists only of exactly one entry and one exit node, both of these nodes are collapsed into one node.
This remaining node then is the representing node of the AST element.</p>
</div>
</div>
<div class="sect3">
<h4 id="_api-for-client-analyses"><a class="anchor" href="#_api-for-client-analyses"></a><a class="link" href="#_api-for-client-analyses">5.1.3. API for client analyses</a></h4>
<div class="paragraph">
<p>To implement client analyses based on the control flow graph, the three classes <code>GraphVisitor</code>, <code>GraphExplorer</code> and <code>BranchWalker</code> are provided.
They provide the means to visit CF elements in a control flow graph and also to traverse single control flow paths.
The method <code>N4JSFlowAnalyses#analyze</code> can execute several client analyses in one run to maintain scalability.</p>
</div>
<div class="sect4">
<h5 id="_mapping-from-internal-to-ast-elements"><a class="anchor" href="#_mapping-from-internal-to-ast-elements"></a><a class="link" href="#_mapping-from-internal-to-ast-elements">5.1.3.1. Mapping from internal to AST elements</a></h5>
<div class="paragraph">
<p>The API classes work with AST elements such as <code>ControlFlowElement</code> instead of the internally used graph classes <code>ComplexNode</code>, <code>Node</code> or <code>ControlFlowEdge</code>.
The mapping from internal classes to AST elements is done in the <code>GraphVisitor</code> class.</p>
</div>
<div class="paragraph">
<p>Note that the control flow graph has the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ExpressionStatement</code>s are not represented.
Instead, only their expressions are represented.
Nevertheless, the API can deal with calls that refer to expression statements, e.g. when requesting their successors.</p>
</li>
<li>
<p>Control statements are also not represented in the graph, but can also be used in calls to the API.
The reason is, that it is unclear when a control statement (e.g. a for loop) is visited exactly.</p>
</li>
<li>
<p>Since a <code>FlowEdge</code> which connects two <code>ControlFlowElement</code>s can represent multiple internal edges, it can have multiple <code>ControlFlowType</code>s.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_graph-visitor"><a class="anchor" href="#_graph-visitor"></a><a class="link" href="#_graph-visitor">5.1.3.2. Graph visitor</a></h5>
<div class="paragraph">
<p>Graph visitors traverse the control flow graphs of every CF container of a script instance in the following two traverse directions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Forward</em>: from the container&#8217;s start to all reachable CF graph elements.</p>
</li>
<li>
<p><em>Backward</em>: from the container&#8217;s end to all reachable CF graph elements.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In each traverse direction, the graph visitor visits every reachable CF element and edge.
Note that neither empty statements nor control statements are part of the control flow graph.
The order of visited CF elements is related to either a breadth or a depth search on the CF graph.
However, no specific order assumptions are guaranteed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="chapters/10_flowgraphs/images/deadcode.png" alt="deadcode">
</div>
<div class="title">Figure 10. The CF elements <code>"loop"</code> and <code>"end"</code> are dead code and displayed in grey.</div>
</div>
</div>
<div class="sect4">
<h5 id="_graph-explorer"><a class="anchor" href="#_graph-explorer"></a><a class="link" href="#_graph-explorer">5.1.3.3. Graph explorer</a></h5>
<div class="paragraph">
<p>Graph visitors can request a <em>graph explorer</em> to be activated under specific conditions related to the client analysis.
A graph explorer is the start point to analyze control flow branches.
The first control flow branches is started directly at the graph explorer&#8217;s creation site, but of course this first branches might fork eventually.
The graph explorer keeps track of all forked branches that originate at its activation site.
It also provides the means to join previously forked branches again.</p>
</div>
</div>
<div class="sect4">
<h5 id="_branch-walker"><a class="anchor" href="#_branch-walker"></a><a class="link" href="#_branch-walker">5.1.3.4. Branch walker</a></h5>
<div class="paragraph">
<p>With every graph explorer, a branch walker is created that traverses the control flow graph beginning from the activation site of the graph explorer.
On every such branch, the two visit methods of CF elements and edges respectively, are called in the order of the traverse direction.
Every time the branch forks, the fork method of the branch walker is invoked and creates another branch walker which will continue the traversal on the forked branch.
The fork method can be used to copy some path data or state to the newly forked branch walker.
Note that every edge is always followed by the branch walker except for repeat edges which are followed exactly twice.
The reason to follow them twice is that first, following them only once would hide those control flows that re-visit the same CF elements due to the loop.
Second, following them more than twice does not reveal more insights, but only increases the number of branches.
When control flow branches merge again, for instance at the end of an <code>if</code>-statement, two or more branch walkers are merged into a new succeeding one.
The graph explorer provides the means to do this.
In case a CF element has no next elements, the branch walker terminates.</p>
</div>
</div>
<div class="sect4">
<h5 id="_example-1-compute-string-for-each-path"><a class="anchor" href="#_example-1-compute-string-for-each-path"></a><a class="link" href="#_example-1-compute-string-for-each-path">5.1.3.5. Example 1: Compute string for each path</a></h5>
<div class="paragraph">
<p>Let&#8217;s assume that we want to compute all control flow branches of a function and use the client API for that.
The function <code>f()</code> in the following code snippet has four control flow branches: <code>1 &#8594; 2</code>, <code>&#8594; 3 &#8594;</code>, <code>&#8594; 4 &#8594;</code> and <code>5</code>.</p>
</div>
<div class="listingblock">
<div class="title">Function <code>f()</code> has four control flow branches.</div>
<div class="content">
<pre class="highlight"><code>function f() {
	1;
	if (2)
		3;
	else
		4;
	5;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To compute these control flow branches, the class <code>AllBranchPrintVisitor</code> extends the <code>GraphVisitor</code>.
Already in the method <code>initializeMode()</code> a graph explorer is activated.
Note that the method <code>requestActivation()</code> can be understood as a <code>addListener</code> method for a listener that listens to visit events on nodes and edges.
Immediately after the activation request, the first branch walker is created in the method <code>firstBranchWalker()</code>.</p>
</div>
<div class="paragraph">
<p>The first visited CF element of the branch walker will then be the expression <code>1</code>.
It is formed into a string and added to the variable <code>curString</code>.
After expression <code>1</code>, the flow edge from <code>1</code> to <code>2</code> is visited.
This will concatenate the string <code>&#8594;</code> to the path string.
Variable <code>curString</code> will eventually hold the branch string like <code>1 &#8594; 2</code>.
Since the control flow forks after <code>2</code>, the method <code>forkPath()</code> is called and creates two new instances of a branch walker.
These new instances succeed the the first branch walker instance and each traverses one of the branches of the <code>if</code>-statement.
When the <code>if</code>-statement is passed, these two branches are merged into a new succeeding branch walker.
After all branch walkers are terminated, the graph explorer and graph visitor are also terminated.
The method <code>getBranchStrings()</code> collects all four computed strings from the variable <code>curString</code> of all branch walkers.</p>
</div>
<div class="listingblock">
<div class="title">Implementation of a graph visitor that computes all control flow paths</div>
<div class="content">
<pre class="highlight"><code>class AllBranchPrintVisitor extends GraphVisitor {
	protected void initializeMode(Mode curDirection, ControlFlowElement curContainer) {
		super.requestActivation(new AllBranchPrintExplorer());
	}

	class AllBranchPrintExplorer extends GraphExplorer {
		class AllBranchPrintWalker extends BranchWalker {
			String curString = "";

			protected void visit(ControlFlowElement cfe) {
				curString += cfe.toString();
			}

			protected void visit(FlowEdge edge) {
				curString += " -&gt; ";
			}

			protected AllBranchPrintWalker forkPath() {
				return new AllBranchPrintWalker();
			}
		}

		protected BranchWalker joinBranches(List&lt;BranchWalker&gt; branchWalkers) {
			// TODO Auto-generated method stub
			return null;
		}

		protected BranchWalkerInternal firstBranchWalker() {
			return new AllBranchPrintWalker();
		}
	}

	List&lt;String&gt; getBranchStrings() {
		List&lt;String&gt; branchStrings = new LinkedList&lt;&gt;();
		for (GraphExplorerInternal app : getActivatedExplorers()) {
			for (BranchWalkerInternal ap : app.getAllBranches()) {
				AllBranchPrintWalker printPath = (AllBranchPrintWalker) ap;
				branchStrings.add(printPath.curString);
			}
		}
		return branchStrings;
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_path-quantor"><a class="anchor" href="#_path-quantor"></a><a class="link" href="#_path-quantor">5.1.3.6. Path quantor</a></h5>
<div class="paragraph">
<p>Graph explorers are typically used to reason on all branch walkers that start at a specific location.
For instance, such a reasoning might determine whether some source element is reachable or whether a variable is used or not.
To simplify this, quantors are provided.
Since branch walkers originating from a single activation point can fork, the reasoning has to include all these forked branch walkers.
Hence, graph explorers are instantiated using a quantor which can be either <em>For All</em>, <em>At Least One</em> OR <em>None</em> that refers to all branches.
After all branch walkers of an explorer are terminated, the explorer is regarded as either passed or failed.
Paths also can be aborted manually using the methods <code>pass()</code> or <code>fail()</code>.
When <em>pass</em> or <em>fail</em> are used, the graph explorer might be terminated in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the quantor of the graph explorer is <em>For All</em>, and <code>fail()</code> is called on a branch walker.</p>
</li>
<li>
<p>If the quantor of the graph explorer is <em>At Least One</em>, and <code>pass()</code> is called on a branch walker.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, a graph explorer can be aborted manually by canceling all its branches.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_control-flow-analyses"><a class="anchor" href="#_control-flow-analyses"></a><a class="link" href="#_control-flow-analyses">5.1.4. Control flow analyses</a></h4>
<div class="sect4">
<h5 id="_dead-code-analysis"><a class="anchor" href="#_dead-code-analysis"></a><a class="link" href="#_dead-code-analysis">5.1.4.1. Dead code analysis</a></h5>
<div class="paragraph">
<p>The dead code analysis uses the graph visitor in all four modes and collects all visited CF elements.
The collected CF elements are saved separately for every mode.
After the graph visitor is terminated, the unreachable CF elements are computed like follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CF elements, that are collected during forward and catch block mode are reachable.</p>
</li>
<li>
<p>CF elements, that are collected during islands mode are unreachable.</p>
</li>
<li>
<p>CF elements, that are <em>only</em> collected during backward mode, are also unreachable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In a later step, the unreachable elements are merged into unreachable text regions that are used for error markers.</p>
</div>
</div>
</div>
</div>
<div class="sect2 language-n4js">
<h3 id="sec:dataflow"><a class="anchor" href="#sec:dataflow"></a><a class="link" href="#sec:dataflow">5.2. Dataflow</a></h3>
<div class="paragraph">
<p></p>
</div>
<div class="sidebarblock">
<div class="content">
<a href="https://github.com/eclipse/n4js/issues/331" class="gray" title="GitHub Issues"><span class="image"><img src="images/issue.svg" alt=""></span> #331</a>
<a href="https://github.com/eclipse/n4js/issues/464" class="gray" title="GitHub Issues"><span class="image"><img src="images/issue.svg" alt=""></span> #464</a>
</div>
</div>
<div class="sect3">
<h4 id="_dataflow-graph"><a class="anchor" href="#_dataflow-graph"></a><a class="link" href="#_dataflow-graph">5.2.1. Dataflow graph</a></h4>
<div class="paragraph">
<p>The data flow graph provides means to reason about <em>symbols</em>, <em>effects</em>, <em>data flow</em>, <em>aliases</em> and <em>guards</em> in the control flow graph.
The main classes of the data flow API are <code>DataflowVisitor</code> and <code>Assumption</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Symbol</dt>
<dd>
<p>Symbols represent a program variable in the sence that it represents all AST elements, that bind to the same variable declaration (according to scoping).
The terms <em>symbol</em> and <em>variable</em> are used synonymously.</p>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Effects are reads, writes and declarations of symbols.
For instance, a typical CF element with a write effect is an assignment such as <code>a = null;</code>.
Every effect refers to a single symbol and graph node.
The following effects are provided:</p>
<div class="ulist">
<ul>
<li>
<p><em>Declaration</em>: is the declaration of a variable.</p>
</li>
<li>
<p><em>Write</em>: is the definition of a variable&#8217;s value, which is typically done with an assignment.</p>
</li>
<li>
<p><em>Read</em>: is the read of a variable&#8217;s value, which could happen when passing a variable as an argument to a method call.</p>
</li>
<li>
<p><em>MethodCall</em>: is the call of a property method of a variable.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Note that the term <em>value use</em> means either write or method call of a variable.
The term <em>value definition</em> means that a variable is written.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Data flow</dt>
<dd>
<p>The term data flow is used for assignments of all kind.
For instance, the assigments <code>a = b</code>, <code>a = 1</code>, <code>a = null</code> or even <code>for (let [a] of [[0],[undefined]]);</code> are data flows.
The data is always flowing from the right hand side to the left hand side.</p>
</dd>
<dt class="hdlist1">Alias</dt>
<dd>
<p>Due to data flow, other symbols can get important for an analysis.
For instance, the data flow <code>a = b</code> makes <code>b</code> important when reasoning about <code>a</code> since the value of <code>b</code> is assigned to <code>a</code>.
In the API is <code>b</code> therefore called an alias of <code>a</code>.</p>
</dd>
<dt class="hdlist1">Guard</dt>
<dd>
<p>Guards are conditions that appear in e.g. <code>it</code>-statements.
For instance, a typical guard is the null-check in the following statement: <code>if (a == null) foo();</code>.
For every CF element, guards can hold either <em>always</em>, <em>never</em> or <em>sometimes</em>.
Note that the null-check-guard always holds at the method invocation <code>foo();</code>.</p>
</dd>
<dt class="hdlist1"><code>DataflowVisitor</code></dt>
<dd>
<p>The class <code>DataflowVisitor</code> provides means to visit all code locations where either effects happen or guards are declared.
For instance, when a variable is written, the callback method <code>DataflowVisitor#visitEffect(EffectInfo effect, ControlFlowElement cfe)</code> gets called.
In case a guard is declared, the callback method <code>visitGuard(Guard guard)</code> gets called.</p>
</dd>
<dt class="hdlist1"><code>Assumption</code></dt>
<dd>
<p>The class <code>Assumption</code> provides means to track the data flow of a specific symbol from a specific code location.
For instance, assumptions are used to detect whether the symbol <code>s</code> in the property access <code>s.prop</code> is or may be undefined.
In this example, the assumption symbol is <code>s</code> and its start location is the property access.
From there, the data flow of <code>s</code> is tracked in backwards traverse direction.
Also, (transitive) aliases of <code>s</code> are tracked.
In case a data flow that happens on <code>s</code> or its aliases, the callback method <code>holdsOnDataflow(Symbol lhs, Symbol rSymbol, Expression rValue)</code> is called.
For every effect that affects <code>s</code> or one of its aliases, the callback method <code>holdsOnEffect(EffectInfo effect, ControlFlowElement container)</code> is called.
And finally, for all guards that hold always/never at the start location regarding symbol <code>s</code>, the callback method <code>holdsOnGuards(Multimap&lt;GuardType, Guard&gt; neverHolding, Multimap&lt;GuardType, Guard&gt; alwaysHolding)</code> is called.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_dataflow-analyses"><a class="anchor" href="#_dataflow-analyses"></a><a class="link" href="#_dataflow-analyses">5.2.2. Dataflow analyses</a></h4>
<div class="sect4">
<h5 id="_def-def-def-nothing-analysis"><a class="anchor" href="#_def-def-def-nothing-analysis"></a><a class="link" href="#_def-def-def-nothing-analysis">5.2.2.1. Def&#8594;Def / Def&#8594;Nothing analysis</a></h5>
<div class="paragraph">
<p>A Def&#8594;Def analysis finds all defintions of a variable that are always a predecessor of another definition.
Its result is a set of all obsolete definition sites.</p>
</div>
<div class="paragraph">
<p>A Def&#8594;!Use analysis finds all definitions of a variable that are not followed by either a read or a method call.
These definition are therefore obsolete and can be removed.</p>
</div>
<div class="paragraph">
<p>Both of these analyses are performed in traverse direction <em>Forward</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_def-use-decl-analysis"><a class="anchor" href="#_def-use-decl-analysis"></a><a class="link" href="#_def-use-decl-analysis">5.2.2.2. Def|Use&#8592;Decl analysis</a></h5>
<div class="paragraph">
<p>A Def|Use&#8592;Decl analysis finds all preceding <em>def</em> or <em>use</em> sites of a declarations of a specific variable.
The paths might contain other <em>defs</em> or <em>uses</em> of the same variable.
In case such paths exists, the variable is used before it is declared.
This analysis is done in traverse direction <em>Backward</em>.</p>
</div>
<div id="img:usedBeforeDeclaredAnalysis" class="imageblock">
<div class="content">
<img src="chapters/10_flowgraphs/images/usedBeforeDeclaredAnalysis.png" alt="usedBeforeDeclaredAnalysis">
</div>
<div class="title">Figure 11. Finding use or def sites can be done using the graph visitor in traverse direction <em>Backward</em>.</div>
</div>
<div class="paragraph">
<p>In the <a href="#img:usedBeforeDeclaredAnalysis">above figure</a> a graph visitor would visit all CF elements.
When it visits the declaration in line 8 (<code>let w</code>), it will activate a graph explorer (star 1 in the figure) for variable <code>w</code>.
Now, the first branch walker <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>1</mn></msub></math> is created and walks the control in backward traverse direction.
When <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>1</mn></msub></math> encounters the exit node of the <code>if</code>-statement, it will create two forked branches <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>2</mn></msub></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>3</mn></msub></math>.
Now, <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>2</mn></msub></math> enters then the branch of the <code>if</code>-statement (star 2), while <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>3</mn></msub></math> traverses directly to the condition of the <code>if</code>-statement.
Next, <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>2</mn></msub></math> visits the def site of variable <code>w</code> (star 3).
This means, that there exist a def site of <code>w</code> before <code>w</code> was declared and hence, an error should be shown.
Since there could exist more cases like this, neither the branch walker nor the graph explorer are terminated.
When reaching star 4, the two branch walkers <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>2</mn></msub></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>3</mn></msub></math> are joined and the follow-up branch walker <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>4</mn></msub></math> is created.
At star 5, the end the CF container is reached and the <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>b</mi><mn>4</mn></msub></math> will be terminated.
After all branch walkers are terminated, the graph explorer for the declaration site of variable <code>w</code> is evaluated:
All use or def sites, that were reachable should be marked with an error saying that the declaration has to be located before the use of a variable.</p>
</div>
<div class="paragraph">
<p>Note this analysis is currently implemented as a control flow analysis since it does not rely on guards, aliases.
Also, it only relies on local variables and hence does not need the symbols that are provided by the data flow API.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.4<br>
Last updated 2019-01-11 12:16:49 CET
</div>
</div>
<!-- ************* UI Scripts ************* -->
<script type="text/javascript" src="scripts/back-to-top.js"></script>

<!-- ************* Prism.js Syntax Highlighting ************* -->
<script src="scripts/prism.js"></script>
</body>
</html>