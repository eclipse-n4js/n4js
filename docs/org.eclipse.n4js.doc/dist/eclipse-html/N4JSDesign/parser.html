<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="author" content="2019-01-11 12:16:49 CET">
<title>N4JS Design Specification</title>
<link rel="stylesheet" href="styles/eclipse-help-mode-spec.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<!-- ************* Meta ************* -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- ************* OpenGraph ************-->
<meta name="description" content="N4JS Language Specification">

<!-- ************* Favicon ************-->
<link rel="icon" href="images/favicon.ico" />

<!-- ************* Back-to-top JQuery ************* -->
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.0/jquery-ui.js"></script>

<link href="styles/prism.min.css" rel="stylesheet" />

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_CHTML">
</script>
<style>
      .admonitionblock td.icon .icon-todo:before{content:"\f249";color:#f4ee42}
    </style>
</head>
<body class="book"><div class="sect1">
<h2 id="_parser"><a class="anchor" href="#_parser"></a><a class="link" href="#_parser">4. Parser</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some of the concepts described here were presented at
<a href="https://www.youtube.com/watch?v=Xm-7aE1UMGY&amp;feature=youtu.be">EclipseCon 2013</a> and
<a href="https://vimeo.com/channels/xtextcon/98446435">XtextCon 2014</a>. Note that the material presented at the linked videos may be outdated.</p>
</div>
<div class="sect2">
<h3 id="sec:Parser_Overview"><a class="anchor" href="#sec:Parser_Overview"></a><a class="link" href="#sec:Parser_Overview">4.1. Overview</a></h3>
<div class="paragraph">
<p>The parser is created from an Xtext grammar. Actually, there are several grammars used as shown in <a href="#fig:cd_grammars">Figure CD Grammars</a>. These grammars and the parsers generated from them are described more closely in the following sections.</p>
</div>
<div id="fig:cd_grammars" class="imageblock center">
<div class="content">
<img src="chapters/04_parser/images/cd_grammars.png" alt="cd grammars">
</div>
<div class="title">Figure 2. N4 Grammars</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:N4JS_Parser"><a class="anchor" href="#sec:N4JS_Parser"></a><a class="link" href="#sec:N4JS_Parser">4.2. N4JS Parser</a></h3>
<div class="paragraph">
<p>One of the most tricky parts of JavaScript is the parsing because there is a conceptual mismatch between the <a href="appendix_a_acronyms.html#AC">ANTLR</a> runtime and the specified grammar. Another challenge is the disambiguation of regular expressions and binary operations. Both features require significant customizing of the generated parser (see figure below).</p>
</div>
<div id="fig:cd_ASIParser" class="imageblock center">
<div class="content">
<img src="chapters/04_parser/images/cd_ASIParser.png" alt="cd ASIParser">
</div>
<div class="title">Figure 3. Overview custom parser implementation (runtime only)</div>
</div>
</div>
<div class="sect2 language-bash">
<h3 id="sec:Parser_Generation_Post_Processing"><a class="anchor" href="#sec:Parser_Generation_Post_Processing"></a><a class="link" href="#sec:Parser_Generation_Post_Processing">4.3. Parser Generation Post-Processing</a></h3>
<div class="paragraph">
<p>The ANTLR grammar that is generated by Xtext is post-processed to inject custom code into the grammar file before it is passed to the ANTLR tool. This is required in particular due to <a href="appendix_a_acronyms.html#AC">ASI</a> (Automated Semicolon Insertion), but for some other reasons as well.</p>
</div>
<div class="paragraph">
<p>Actually, there are several injections:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Due to Xtext restrictions, the generated ANTLR grammar file (<strong>*.g</strong>) is modified. This means that some some additional actions are added and some rules are rewritten.</p>
</li>
<li>
<p>Due to ANTLR restrictions, the generated ANTLR Java parser (<strong>*.java</strong>) os modified. This means that some generated rules are slightly modified to match certain requirements.</p>
</li>
<li>
<p>Due to Java restrictions, the generated Java parser needs to be preprocessed in order to reduce the size of certain methods since they must not exceed 64k characters. This is implemented by means of an MWE fragment, activated after the other post processing steps are done.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first two steps are handled by <code>AntlrGeneratorWithCustomKeywordLogic</code>, which is configured with additional helpers in <code>GenerateN4JS.mwe2</code>. shows the customized classes which modify the code generation. These classes are all part of the <code>releng.utils</code> bundle.</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="chapters/04_parser/images/cd_parsergeneration.png" alt="cd parsergeneration">
</div>
<div class="title">Figure 4. Class Diagram Parser Generation</div>
</div>
<div class="sect3">
<h4 id="sec:Automatic_Semicolon_Insertion"><a class="anchor" href="#sec:Automatic_Semicolon_Insertion"></a><a class="link" href="#sec:Automatic_Semicolon_Insertion">4.3.1. Automatic Semicolon Insertion</a></h4>
<div class="paragraph">
<p>The EcmaScript specification mandates that valid implementations automatically insert a semicolon as a statement delimiter if it is missing and the input file would become invalid due to the missing semicolon. This is known as <a href="appendix_a_acronyms.html#AC">ASI</a>. It implies that not only valid implementations have to perform this, but a valid parser has to mimic this behavior in order to parse executable code. The <a href="appendix_a_acronyms.html#AC">ASI</a> is implemented by two different means.</p>
</div>
<div class="paragraph">
<p>The parser’s error recovery strategy is customized so it attempts to insert a semicolon if it was expected. Both strategies have to work hand in hand in order to consume all sorts of legal JavaScript code.</p>
</div>
<div class="sect4">
<h5 id="sec:Injected_code_in_the_Antlr_grammar_file"><a class="anchor" href="#sec:Injected_code_in_the_Antlr_grammar_file"></a><a class="link" href="#sec:Injected_code_in_the_Antlr_grammar_file">4.3.1.1. Injected code in the Antlr grammar file</a></h5>
<div class="paragraph">
<p>Under certain circumstances, the parser has to actively promote a token to become a semicolon even though it may be a syntactically a closing brace or line break. This has to happen before that token is consumed thus the rules for return statements, continue statements and break statements are enhanced to actively promote these tokens to semicolons.</p>
</div>
<div class="paragraph">
<p>The same rule is applied to promote line breaks between an expression and a possible postfix operator <code>++</code> or <code>–</code>. At this location the line break is always treated as a semicolon even though the operator may be validly consumed and produce a postfix expression.</p>
</div>
<div class="paragraph">
<p>In both cases, the method <code>promoteEOL()</code> is used to move a token that may serve as an automatically injected semicolon from the so called hidden token channel to the semantic channel. The hidden tokens are usually not handled by the parser explicitly thus they are semantically invisible (therefore the term hidden token). Nevertheless, they can be put on the semantic channel explicitly to make them recognizable. That’s implemented in the EOL promotion. The offending tokens include the hidden line terminators and multi-line comments that include line breaks. Furthermore, closing braces (right curly brackets) are included in the set of offending tokens as well as explicit semicolons.</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:Customized_error_recovery"><a class="anchor" href="#sec:Customized_error_recovery"></a><a class="link" href="#sec:Customized_error_recovery">4.3.1.2. Customized error recovery</a></h5>
<div class="paragraph">
<p>Since the EOL promotion does not work well with Antlr prediction mode, another customization complements that feature. As soon as an invalid token sequence is attempted to be parsed and missing semicolon would make that sequence valid, an offending token is sought and moved to the semantic channel. This is implemented in the custom recovery strategy.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:_No_line_terminator_allowed_here__handling"><a class="anchor" href="#sec:_No_line_terminator_allowed_here__handling"></a><a class="link" href="#sec:_No_line_terminator_allowed_here__handling">4.3.2. Async and <code>No line terminator allowed here</code> Handling</a></h4>
<div class="paragraph">
<p>There is no way of directly defining <code>No line terminator allowed here</code>. This is required not only for <a href="appendix_a_acronyms.html#AC">ASI</a>, but also for <code>async</code>. This requires not only a special rule (using some rules from <a href="#sec:Automatic_Semicolon_Insertion">ASI</a>), but also a special error recovery since the token ’async’ may be rejected (by the manually enriched rule) which is of course unexpected behavior from the generated source code.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:Regular_Expression"><a class="anchor" href="#sec:Regular_Expression"></a><a class="link" href="#sec:Regular_Expression">4.3.3. Regular Expression</a></h4>
<div class="paragraph">
<p>The ANTLR parsing process can basically be divided into three steps. First of all, the file contents has to be read from disk. This includes the proper encoding of bytes to characters. The second step is the lexing or tokenizing of the character stream. A token is a basically a typed region in the stream, that is a triplet of token-id, offset and length. The last step is the parsing of these tokens. The result is a semantic model that is associated with a node tree. All necessary information to validate the model can be deduced from these two interlinked representations.</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="chapters/04_parser/images/ad_parsing_simplified.png" alt="ad parsing simplified">
</div>
<div class="title">Figure 5. Simplified visualization of the parsing</div>
</div>
<div class="paragraph">
<p>Since the default semantics and control flow of Antlr generated parsers do not really fit the requirements of a fully working JavaScript parser, some customizations are necessary. <strong>Regular expression literals in JavaScript cannot be syntactically disambiguated from div operations without contextual information.</strong> Nevertheless, the spec clearly describes, where a regular expression may appear and where it is prohibited. Unfortunately, it is not possible to implement these rules in the lexer alone, since it does not have enough contextual information. Therefore, the parser has been enhanced to establish a communication channel with the lexer. It announces when it expects a regular expression rather than a binary operation.</p>
</div>
<div class="paragraph">
<p>This required a reworking of the Antlr internals. Instead of a completely pre-populated <code>TokenStream</code>, the parser works on a lazy implementation that only reads as many characters as possible without a disambiguation between regular expression literals and divide operators.</p>
</div>
<div class="paragraph">
<p>Only after the parser has read this buffered tokens and potentially announced that it expects a regular expression, another batch of characters is processed by the lexer until the next ambiguous situation occurs. This is fundamentally different from the default behavior of Antlr.</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="chapters/04_parser/images/sd_parsing_sequence.png" alt="sd parsing sequence">
</div>
<div class="title">Figure 6. Abstract control flow during parsing</div>
</div>
<div class="paragraph">
<p>shows the involved classes which allow for this lexer-parser communication.</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="chapters/04_parser/images/cd_parserlexercommunication.png" alt="cd parserlexercommunication">
</div>
<div class="title">Figure 7. Class Diagram Parser-Lexer Communication</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:Unicode"><a class="anchor" href="#sec:Unicode"></a><a class="link" href="#sec:Unicode">4.3.4. Unicode</a></h4>
<div class="paragraph">
<p>Unicode support in JavaScript includes the possibility to use unicode escape sequences in identifiers, string literals and regular expression literals. Another issue in this field is the specification of valid identifiers in JavaScript. They are described by means of unicode character classes. These have to be enumerated in the terminal rules in order to fully accept or reject valid or invalid JS identifiers.</p>
</div>
<div class="paragraph">
<p>For that purpose, a small code generator is used to define the terminal fragments for certain unicode categories. The <code>UnicodeGrammarGenerator</code> basically iterates all characters from <code>Character.MIN_VALUE</code> to <code>Character.MAX_VALUE</code> and adds them as alternatives to the respective terminal fragments, e.g. <code>UNICODE_DIGIT_FRAGMENT</code>.</p>
</div>
<div class="paragraph">
<p>The real terminal rules are defined as a composition of these generated fragments. Besides that, each character in an identifier, in a string literal or in a regular expression literal may be represented by its unicode escape value, e.g. ` u0060`. These escape sequences are handled and validated by the <code>IValueConverter</code> for the corresponding terminal rules.</p>
</div>
<div class="paragraph">
<p>The second piece of the puzzle are the unicode escaped sequences that may be used in keywords. This issue is covered by the <code>UnicodeKeywordHelper</code> which replaces the default terminal representation in the generated Antlr grammar by more elaborated alternatives. The keyword <code>if</code> is not only lexed as <code>’if’</code> but as seen in snippet
<a href="#lst:terminal_if">Terminal if listing</a>.</p>
</div>
<div id="lst:terminal_if" class="listingblock">
<div class="title">Terminal if</div>
<div class="content">
<pre class="highlight"><code>If :
    ( 'i' | '\\' 'u' '0``   0``   6``   9' )
    ( 'f' | '\\' 'u' '0``   0``   6``   6' );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:Literals"><a class="anchor" href="#sec:Literals"></a><a class="link" href="#sec:Literals">4.3.5. Literals</a></h4>
<div class="paragraph">
<p>Template literals are also to be handled specially, see <code>TemplateLiteralDisambiguationInjector</code> for details.</p>
</div>
</div>
</div>
<div class="sect2 language-n4js">
<h3 id="sec:Modifiers"><a class="anchor" href="#sec:Modifiers"></a><a class="link" href="#sec:Modifiers">4.4. Modifiers</a></h3>
<div class="paragraph">
<p>On the AST side, all modifiers are included in a single enumeration <code>N4Modifier</code>. In the types model however, the individual modifiers are mapped to two different enumerations of <em>access</em> modifiers (namely <code>TypeAccessModifier</code> and <code>MemberAccessModifier</code>) and a number of boolean properties (in case of non-access modifiers such as <code>abstract</code> or <code>static</code>). This mapping is done by the types builder, mostly by calling methods in class <code>ModifierUtils</code>.</p>
</div>
<div class="paragraph">
<p>The grammar allows the use of certain modifiers in many places that are actually invalid. Rules where a certain modifier may appear in the AST are implemented in method isValid(EClass,N4Modifier) in class <code>ModifierUtils</code> and checked via several validations in <code>N4JSSyntaxValidator</code>. Those validations also check for a particular order of modifiers that is not enforced by the grammar.</p>
</div>
<div class="paragraph">
<p>See API documentation of enumeration <code>N4Modifier</code> in file <code>N4JS.xcore</code> and the utility class <code>ModifierUtils</code> for more details.</p>
</div>
</div>
<div class="sect2 language-n4js">
<h3 id="sec:Conflict_Resolutions"><a class="anchor" href="#sec:Conflict_Resolutions"></a><a class="link" href="#sec:Conflict_Resolutions">4.5. Conflict Resolutions</a></h3>
<div class="sect3">
<h4 id="sec:Reserved_Keywords_vs__Identifier_Names"><a class="anchor" href="#sec:Reserved_Keywords_vs__Identifier_Names"></a><a class="link" href="#sec:Reserved_Keywords_vs__Identifier_Names">4.5.1. Reserved Keywords vs. Identifier Names</a></h4>
<div class="paragraph">
<p>Keywords and identifiers have to be distinguished by the lexer. Therefore, there is no means to decide upfront whether a certain keyword is actually used as a keyword or whether it is used as an identifier in a given context. This limitation is idiomatically overcome by a data type rule for valid identifiers. This data type rule enumerates all keywords which may be used as identifiers and the pure IDENTIFIER terminal rule as seen in <a href="#lst:keywords_as_identifier">Keywords as Identifier listing</a>.</p>
</div>
<div id="lst:keywords_as_identifier" class="listingblock">
<div class="title">Keywords as Identifier</div>
<div class="content">
<pre class="highlight"><code class="language-ebnf" data-lang="ebnf">N4JSIdentifier: IDENTIFIER
    | 'get'
    | 'set'
    ...
;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:Operators_and_Generics"><a class="anchor" href="#sec:Operators_and_Generics"></a><a class="link" href="#sec:Operators_and_Generics">4.5.2. Operators and Generics</a></h4>
<div class="paragraph">
<p>The ambiguity between shift operators and nested generics arises also from the fact, that Antlr lexer upfront without any contextual information. When implemented naively, the grammar will be broken, since a token sequence <code>a&gt;&gt;b</code> can either be part of <code>List&lt;List&lt;a&gt;&gt; b</code> or it can be part of a binary operation <code>int c = a &gt;&gt; b</code>. Therefore the shift operator may not be defined with a single token but has to be composed from individual characters (see <a href="#lst:shift_operator">Shift Operator listing</a>).</p>
</div>
<div id="lst:shift_operator" class="listingblock">
<div class="title">Shift Operator listing</div>
<div class="content">
<pre class="highlight"><code class="language-ebnf" data-lang="ebnf">ShiftOperator:
      '&gt;' '&gt;' '&gt;'?
    | '&lt;' '&lt;'
    ;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.4<br>
Last updated 2019-01-11 12:16:49 CET
</div>
</div>
<!-- ************* UI Scripts ************* -->
<script type="text/javascript" src="scripts/back-to-top.js"></script>

<!-- ************* Prism.js Syntax Highlighting ************* -->
<script src="scripts/prism.js"></script>
</body>
</html>