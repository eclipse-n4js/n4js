<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="author" content="2019-01-11 12:16:48 CET">
<title>N4JS Language Specification</title>
<link rel="stylesheet" href="styles/eclipse-help-mode-spec.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<!-- ************* Meta ************* -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- ************* OpenGraph ************-->
<meta name="description" content="N4JS Language Specification">

<!-- ************* Favicon ************-->
<link rel="icon" href="images/favicon.ico" />

<!-- ************* Back-to-top JQuery ************* -->
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.0/jquery-ui.js"></script>

<link href="styles/prism.min.css" rel="stylesheet" />

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_CHTML">
</script>
<style>
      .admonitionblock td.icon .icon-todo:before{content:"\f249";color:#f4ee42}
    </style>
</head>
<body class="book"><div class="sect1">
<h2 id="_grammars"><a class="anchor" href="#_grammars"></a><a class="link" href="#_grammars">16. Grammars</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>N4JS extends the ECMAScript 2015 language grammar and combines it with type expression.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title=""></i>
</td>
<td class="content">
These grammars are slightly simplified versions of the "real" Xtext grammars used in the implementation.
These grammars are post-processed and combined with additional validators so not all constructs are necessarily available in N4JS.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_type-expressions-grammar"><a class="anchor" href="#_type-expressions-grammar"></a><a class="link" href="#_type-expressions-grammar">16.1. Type Expressions Grammar</a></h3>
<div id="lst:EBNFTypeExpression" class="listingblock">
<div class="title">EBNF Type Expression Grammar</div>
<div class="content">
<pre class="highlight"><code class="language-xtext" data-lang="xtext">TypeRef:
    TypeRefWithoutModifiers =&gt;undefModifier=UndefModifierToken?
    | undefModifier=UndefModifierToken;

TypeRefWithoutModifiers:
      ((ParameterizedTypeRef | ThisTypeRef) =&gt; dynamic?='+'?)
    | ConstructorTypeRef
    | ClassifierTypeRef
    | FunctionTypeExpression
    | UnionTypeExpression
    | IntersectionTypeExpression;

TypeRefFunctionTypeExpression:
      ParameterizedTypeRef
    | ConstructorTypeRef
    | ClassifierTypeRef
    | UnionTypeExpression
    | IntersectionTypeExpression
    ;

TypeRefForCast:
      ParameterizedTypeRef
    | ThisTypeRef
    | ConstructorTypeRef
    | ClassifierTypeRef
    | FunctionTypeExpression;

TypeRefInClassifierType:
      ParameterizedTypeRefNominal
    | ThisTypeRefNominal;


ThisTypeRef:
    ThisTypeRefNominal | ThisTypeRefStructural;

ThisTypeRefNominal:
    'this';

ThisTypeRefStructural:
    definedTypingStrategy=TypingStrategyUseSiteOperator
    'this'
    ('with' TStructMemberList)?;

FunctionTypeExpression:
    '{'
    ('@' 'This' '(' declaredThisType=TypeRefFunctionTypeExpression ')')?
    'function'
    ('&lt;' ownedTypeVars+=TypeVariable (',' ownedTypeVars+=TypeVariable)* '&gt;')?
    '(' TAnonymousFormalParameterList ')'
    (':' returnTypeRef=TypeRef)?
    '}';

fragment TAnonymousFormalParameterList*:
    (fpars+=TAnonymousFormalParameter (',' fpars+=TAnonymousFormalParameter)*)?
;

TAnonymousFormalParameter:
    variadic?='...'? (=&gt; name=TIdentifier ':')? typeRef=TypeRef
;

UnionTypeExpression:
    'union' '{' typeRefs+=TypeRefWithoutModifiers (',' typeRefs+=TypeRefWithoutModifiers)* '}';

IntersectionTypeExpression:
    'intersection' '{' typeRefs+=TypeRefWithoutModifiers (',' typeRefs+=TypeRefWithoutModifiers)* '}';

ParameterizedTypeRef:
    ParameterizedTypeRefNominal | ParameterizedTypeRefStructural;

ParameterizedTypeRefStructural:
    definedTypingStrategy=TypingStrategyUseSiteOperator
    declaredType=[Type|TypeReferenceName]
    (=&gt;'&lt;' typeArgs+=TypeArgument (',' typeArgs+=TypeArgument)* '&gt;')?
    ('with' TStructMemberList)?;

fragment TStructMemberList*:  '{' (astStructuralMembers+=TStructMember (';'|',')?)*  '}';

TStructMember:
      TStructGetter
    | TStructSetter
    | TStructMethod
    | TStructField;

TStructMethod:
    =&gt;
    (('&lt;' typeVars+=TypeVariable (',' typeVars+=TypeVariable)* '&gt;')?
        name=TypesIdentifier '('
    ) TAnonymousFormalParameterList ')'
    (':' returnTypeRef=TypeRef)?
;

TStructField:
    name=TypesIdentifier (':' typeRef=TypeRef)?
;

TStructGetter:
    =&gt; ('get'
    name=TypesIdentifier)
    '(' ')' (':' declaredTypeRef=TypeRef)?
;

TStructSetter:
    =&gt; ('set'
    name=TypesIdentifier)
    '(' fpar=TAnonymousFormalParameter ')'
;

ParameterizedTypeRefNominal:
    declaredType=[Type|TypeReferenceName]
    (=&gt; '&lt;' typeArgs+=TypeArgument (',' typeArgs+=TypeArgument)* '&gt;')?;

TypingStrategyUseSiteOperator:
    '~' ('~' | STRUCTMODSUFFIX)?;

TypingStrategyDefSiteOperator:
    '~';

terminal STRUCTMODSUFFIX:
    ('r' | 'i' | 'w') '~'
;

ConstructorTypeRef:
    'constructor' '{' staticTypeRef=TypeRefInClassifierType '}';

ClassifierTypeRef:
    'type' '{' staticTypeRef=TypeRefInClassifierType '}';

TypeReferenceName:
    IDENTIFIER ('.' IDENTIFIER)*;

TypeArgument:
    Wildcard | TypeRef;

Wildcard:
    =&gt; ('?') (('extends' declaredUpperBound=TypeRef) | ('super'
    declaredLowerBound=TypeRef))?;

UndefModifierToken:
    '?';

TypeVariable:
    name=IDENTIFIER ('extends' declaredUpperBounds+=ParameterizedTypeRef ('&amp;'
    declaredUpperBounds+=ParameterizedTypeRef)*)?;

TypesIdentifier:
    IDENTIFIER
    | 'get' | 'set' | 'abstract' | 'project'
    | 'union' | 'intersection'
    | 'as' | 'from' | 'type' | 'void' | 'null';

TIdentifier:
    TypesIdentifier
    | 'implements' | 'interface'
    | 'private' | 'protected' | 'public'
    | 'static'
;

terminal IDENTIFIER:
    IDENTIFIER_START IDENTIFIER_PART*;

terminal INT:
    DECIMAL_INTEGER_LITERAL_FRAGMENT;

terminal ML_COMMENT:
    ML_COMMENT_FRAGMENT;

terminal SL_COMMENT:
    '//' (!LINE_TERMINATOR_FRAGMENT)*;

terminal EOL:
    LINE_TERMINATOR_SEQUENCE_FRAGMENT;

terminal WS:
    WHITESPACE_FRAGMENT+;

terminal fragment UNICODE_ESCAPE_FRAGMENT:
    '\\' ('u' (
        HEX_DIGIT (HEX_DIGIT (HEX_DIGIT HEX_DIGIT?)?)?
      | '{' HEX_DIGIT* '}'?
    )?)?;

terminal fragment IDENTIFIER_START:
      UNICODE_LETTER_FRAGMENT
    | '$'
    | '_'
    | UNICODE_ESCAPE_FRAGMENT;

terminal fragment IDENTIFIER_PART:
      UNICODE_LETTER_FRAGMENT
    | UNICODE_ESCAPE_FRAGMENT
    | '$'
    | UNICODE_COMBINING_MARK_FRAGMENT
    | UNICODE_DIGIT_FRAGMENT
    | UNICODE_CONNECTOR_PUNCTUATION_FRAGMENT
    | ZWNJ
    | ZWJ;

terminal DOT_DOT:
    '..'
;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_n4js-language-grammar"><a class="anchor" href="#_n4js-language-grammar"></a><a class="link" href="#_n4js-language-grammar">16.2. N4JS Language Grammar</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtext" data-lang="xtext">Script: annotations+=ScriptAnnotation*
    scriptElements+=ScriptElement*;

ScriptElement:
      AnnotatedScriptElement
    | N4ClassDeclaration&lt;Yield=false&gt;
    | N4InterfaceDeclaration&lt;Yield=false&gt;
    | N4EnumDeclaration&lt;Yield=false&gt;
    | ImportDeclaration
    | ExportDeclaration
    | RootStatement&lt;Yield=false&gt;
;

AnnotatedScriptElement:
    AnnotationList (
        {ExportDeclaration.annotationList=current} ExportDeclarationImpl
    |   {ImportDeclaration.annotationList=current} ImportDeclarationImpl
    |   {FunctionDeclaration.annotationList=current}
        =&gt;((declaredModifiers+=N4Modifier)* AsyncNoTrailingLineBreak
            -&gt;FunctionImpl&lt;Yield=false,YieldIfGenerator=false,Expression=false&gt;)
    |   (
            (
                {N4ClassDeclaration.annotationList=current}
                (declaredModifiers+=N4Modifier)*
                'class' typingStrategy=TypingStrategyDefSiteOperator?
                name=BindingIdentifier&lt;Yield=false&gt;
                TypeVariables?
                ClassExtendsClause&lt;Yield=false&gt;?
            |   {N4InterfaceDeclaration.annotationList=current}
                (declaredModifiers+=N4Modifier)*
                'interface' typingStrategy=TypingStrategyDefSiteOperator? name=BindingIdentifier&lt;Yield=false&gt;
                TypeVariables?
                InterfaceImplementsList?
            )
            Members&lt;Yield=false&gt;
        )
    |   {N4EnumDeclaration.annotationList=current}
        (declaredModifiers+=N4Modifier)*
        'enum' name=BindingIdentifier&lt;Yield=false&gt;
        '{'
            literals+=N4EnumLiteral (',' literals+= N4EnumLiteral)*
        '}'
    )
;

fragment TypeVariables*:
    '&lt;' typeVars+=TypeVariable (',' typeVars+=TypeVariable)* '&gt;'
;

ExportDeclaration:
    ExportDeclarationImpl
;

fragment ExportDeclarationImpl*:
    'export' (
        wildcardExport?='*' ExportFromClause Semi
    |   ExportClause -&gt;ExportFromClause? Semi
    |   exportedElement=ExportableElement
    |   defaultExport?='default' (-&gt;exportedElement=ExportableElement | defaultExportedExpression=AssignmentExpression&lt;In=true,Yield=false&gt; Semi)
    )
;

fragment ExportFromClause*:
    'from' reexportedFrom=[types::TModule|ModuleSpecifier]
;

fragment ExportClause*:
    '{'
        (namedExports+=ExportSpecifier (',' namedExports+=ExportSpecifier)* ','?)?
    '}'
;

ExportSpecifier:
    element=IdentifierRef&lt;Yield=false&gt; ('as' alias=IdentifierName)?
;

ExportableElement:
      AnnotatedExportableElement&lt;Yield=false&gt;
    | N4ClassDeclaration&lt;Yield=false&gt;
    | N4InterfaceDeclaration&lt;Yield=false&gt;
    | N4EnumDeclaration&lt;Yield=false&gt;
    | ExportedFunctionDeclaration&lt;Yield=false&gt;
    | ExportedVariableStatement
;

AnnotatedExportableElement &lt;Yield&gt;:
    AnnotationList (
        {FunctionDeclaration.annotationList=current}
        (declaredModifiers+=N4Modifier)* AsyncNoTrailingLineBreak
        FunctionImpl&lt;Yield, Yield, Expression=false&gt;
    |   {ExportedVariableStatement.annotationList=current}
        (declaredModifiers+=N4Modifier)*
        varStmtKeyword=VariableStatementKeyword
        varDeclsOrBindings+=ExportedVariableDeclarationOrBinding&lt;Yield&gt; ( ',' varDeclsOrBindings+=ExportedVariableDeclarationOrBinding&lt;Yield&gt; )* Semi
    |   (
            (
                {N4ClassDeclaration.annotationList=current}
                (declaredModifiers+=N4Modifier)*
                'class' typingStrategy=TypingStrategyDefSiteOperator?
                name=BindingIdentifier&lt;Yield&gt;
                TypeVariables?
                ClassExtendsClause&lt;Yield&gt;?
            |   {N4InterfaceDeclaration.annotationList=current}
                (declaredModifiers+=N4Modifier)*
                ('interface') typingStrategy=TypingStrategyDefSiteOperator? name=BindingIdentifier&lt;Yield&gt;
                TypeVariables?
                InterfaceImplementsList?
            )
            Members&lt;Yield&gt;
        )
    |   {N4EnumDeclaration.annotationList=current}
        (declaredModifiers+=N4Modifier)*
        'enum' name=BindingIdentifier&lt;Yield&gt;
        '{'
            literals+=N4EnumLiteral (',' literals+= N4EnumLiteral)*
        '}'
    )
;

ImportDeclaration:
    ImportDeclarationImpl
;

fragment ImportDeclarationImpl*:
    'import' (
        ImportClause importFrom?='from'
    )? module=[types::TModule|ModuleSpecifier] Semi
;

fragment ImportClause*:
        importSpecifiers+=DefaultImportSpecifier (',' ImportSpecifiersExceptDefault)?
    |   ImportSpecifiersExceptDefault
;

fragment ImportSpecifiersExceptDefault*:
        importSpecifiers+=NamespaceImportSpecifier
    |   '{' (importSpecifiers+=NamedImportSpecifier (',' importSpecifiers+=NamedImportSpecifier)* ','?)? '}'
;

NamedImportSpecifier:
        importedElement=[types::TExportableElement|BindingIdentifier&lt;Yield=false&gt;]
    |   importedElement=[types::TExportableElement|IdentifierName] 'as' alias=BindingIdentifier&lt;Yield=false&gt;
;

DefaultImportSpecifier:
    importedElement=[types::TExportableElement|BindingIdentifier&lt;Yield=false&gt;]
;

NamespaceImportSpecifier: '*' 'as' alias=BindingIdentifier&lt;false&gt; (declaredDynamic?='+')?;

ModuleSpecifier: STRING;

FunctionDeclaration &lt;Yield&gt;:
    =&gt; ((declaredModifiers+=N4Modifier)* AsyncNoTrailingLineBreak
        -&gt; FunctionImpl &lt;Yield,Yield,Expression=false&gt;
    ) =&gt; Semi?
;

fragment AsyncNoTrailingLineBreak *: (declaredAsync?='async' NoLineTerminator)?;

fragment FunctionImpl&lt;Yield, YieldIfGenerator, Expression&gt;*:
    'function'
    (
        generator?='*' FunctionHeader&lt;YieldIfGenerator,Generator=true&gt; FunctionBody&lt;Yield=true,Expression&gt;
    |   FunctionHeader&lt;Yield,Generator=false&gt; FunctionBody&lt;Yield=false,Expression&gt;
    )
;

fragment FunctionHeader&lt;Yield, Generator&gt;*:
    TypeVariables?
    name=BindingIdentifier&lt;Yield&gt;?
    StrictFormalParameters&lt;Yield=Generator&gt;
    (-&gt; ':' returnTypeRef=TypeRef)?
;

fragment FunctionBody &lt;Yield, Expression&gt;*:
        &lt;Expression&gt; body=Block&lt;Yield&gt;
    |   &lt;!Expression&gt; body=Block&lt;Yield&gt;?
;

ExportedFunctionDeclaration&lt;Yield&gt;:
    FunctionDeclaration&lt;Yield&gt;
;

FunctionTypeExpression:
    {types::FunctionTypeExpression}
    '{'
    ('@' 'This' '(' declaredThisType=TypeRefFunctionTypeExpression ')')?
    'function'
    ('&lt;' ownedTypeVars+=TypeVariable (',' ownedTypeVars+=TypeVariable)* '&gt;')?
    '('
    (fpars+=TAnonymousFormalParameter (',' fpars+=TAnonymousFormalParameter)*)?
    ')'
    (':' returnTypeRef=TypeRef)?
    '}';

AnnotatedFunctionDeclaration &lt;Yield, Default&gt;:
    annotationList=AnnotationList
    (declaredModifiers+=N4Modifier)* AsyncNoTrailingLineBreak
    FunctionImpl&lt;Yield,Yield,Expression=false&gt;
;


FunctionExpression:
         (FunctionImpl&lt;Yield=false,YieldIfGenerator=true,Expression=true&gt;
         )
;

AsyncFunctionExpression:
     =&gt;(declaredAsync?='async' NoLineTerminator 'function')
        FunctionHeader&lt;Yield=false,Generator=false&gt; FunctionBody&lt;Yield=false,Expression=true&gt;
;

ArrowExpression &lt;In, Yield&gt;:
    =&gt; (
            (
                    '(' (fpars+=FormalParameter&lt;Yield&gt;
                        (',' fpars+=FormalParameter&lt;Yield&gt;)*)?
                    ')' (':' returnTypeRef=TypeRef)?
                |   =&gt;(declaredAsync?='async' NoLineTerminator '(')
                    (fpars+=FormalParameter&lt;Yield&gt; (',' fpars+=FormalParameter&lt;Yield&gt;)*)?
                    ')' (':' returnTypeRef=TypeRef)?
                |   fpars+=BindingIdentifierAsFormalParameter&lt;Yield&gt;
            )
            '=&gt;'
        )
        (-&gt; hasBracesAroundBody?='{' body=BlockMinusBraces&lt;Yield&gt; '}'
            | body=ExpressionDisguisedAsBlock&lt;In&gt;)
;

fragment StrictFormalParameters &lt;Yield&gt;*:
    '(' (fpars+=FormalParameter&lt;Yield&gt; (',' fpars+=FormalParameter&lt;Yield&gt;)*)? ')'
;

BindingIdentifierAsFormalParameter &lt;Yield&gt;: name=BindingIdentifier&lt;Yield&gt;;

BlockMinusBraces &lt;Yield&gt;:   statements+=Statement&lt;Yield&gt;*;

ExpressionDisguisedAsBlock &lt;In&gt;:
    statements+=AssignmentExpressionStatement&lt;In&gt;
;

AssignmentExpressionStatement &lt;In&gt;: expression=AssignmentExpression&lt;In,Yield=false&gt;;

AnnotatedExpression &lt;Yield&gt;:
    ExpressionAnnotationList (
        {N4ClassExpression.annotationList=current}
        'class' name=BindingIdentifier&lt;Yield&gt;?
        ClassExtendsClause&lt;Yield&gt;?
        Members&lt;Yield&gt;
    |   {FunctionExpression.annotationList=current} AsyncNoTrailingLineBreak
        FunctionImpl&lt;Yield=false,YieldIfGenerator=true,Expression=true&gt;
    )
;

TypeVariable:
    name=IdentifierOrThis
    (   'extends' declaredUpperBounds+=ParameterizedTypeRefNominal
        ('&amp;' declaredUpperBounds+=ParameterizedTypeRefNominal)*
    )?
;

FormalParameter &lt;Yield&gt;:
    BindingElementFragment&lt;Yield&gt;
;

fragment BindingElementFragment &lt;Yield&gt;*:
    (=&gt; bindingPattern=BindingPattern&lt;Yield&gt;
    | annotations+=Annotation*
        (
            variadic?='...'? name=BindingIdentifier&lt;Yield&gt; ColonSepTypeRef?
        )
    )
    ('=' initializer=AssignmentExpression&lt;In=true, Yield&gt;)?
;

fragment ColonSepTypeRef*:
    ':' declaredTypeRef=TypeRef
;

Block &lt;Yield&gt;: =&gt; ('{') statements+=Statement&lt;Yield&gt;* '}';
RootStatement &lt;Yield&gt;:
    Block&lt;Yield&gt;
    | FunctionDeclaration&lt;Yield&gt;
    | VariableStatement&lt;In=true,Yield&gt;
    | EmptyStatement
    | LabelledStatement&lt;Yield&gt;
    | ExpressionStatement&lt;Yield&gt;
    | IfStatement&lt;Yield&gt;
    | IterationStatement&lt;Yield&gt;
    | ContinueStatement&lt;Yield&gt;
    | BreakStatement&lt;Yield&gt;
    | ReturnStatement&lt;Yield&gt;
    | WithStatement&lt;Yield&gt;
    | SwitchStatement&lt;Yield&gt;
    | ThrowStatement&lt;Yield&gt;
    | TryStatement&lt;Yield&gt;
    | DebuggerStatement
;

Statement &lt;Yield&gt;:
    AnnotatedFunctionDeclaration&lt;Yield,Default=false&gt;
    | RootStatement&lt;Yield&gt;
;

enum VariableStatementKeyword:
    var='var' | const='const' | let='let'
;

VariableStatement &lt;In, Yield&gt;:
    =&gt;(varStmtKeyword=VariableStatementKeyword
    )
    varDeclsOrBindings+=VariableDeclarationOrBinding&lt;In,Yield,false&gt;
    (',' varDeclsOrBindings+=VariableDeclarationOrBinding&lt;In,Yield,false&gt;)* Semi
;

ExportedVariableStatement:
    (declaredModifiers+=N4Modifier)*
    varStmtKeyword=VariableStatementKeyword
    varDeclsOrBindings+=ExportedVariableDeclarationOrBinding&lt;Yield=false&gt;
    (',' varDeclsOrBindings+=ExportedVariableDeclarationOrBinding&lt;Yield=false&gt;)* Semi
;

VariableDeclarationOrBinding &lt;In, Yield, OptionalInit&gt;:
        VariableBinding&lt;In,Yield,OptionalInit&gt;
    |   VariableDeclaration&lt;In,Yield,true&gt;
;

VariableBinding &lt;In, Yield, OptionalInit&gt;:
    =&gt; pattern=BindingPattern&lt;Yield&gt; (
            &lt;OptionalInit&gt; ('=' expression=AssignmentExpression&lt;In,Yield&gt;)?
        |   &lt;!OptionalInit&gt; '=' expression=AssignmentExpression&lt;In,Yield&gt;
    )
;

VariableDeclaration &lt;In, Yield, AllowType&gt;:
    VariableDeclarationImpl&lt;In,Yield,AllowType&gt;;

fragment VariableDeclarationImpl &lt;In, Yield, AllowType&gt;*:
    annotations+=Annotation*
    (
        &lt;AllowType&gt; =&gt;(
            name=BindingIdentifier&lt;Yield&gt; ColonSepTypeRef?
        ) ('=' expression=AssignmentExpression&lt;In,Yield&gt;)?
    |   &lt;!AllowType&gt; =&gt;(
        name=BindingIdentifier&lt;Yield&gt;
        ) ('=' expression=AssignmentExpression&lt;In,Yield&gt;)?
    )
;

ExportedVariableDeclarationOrBinding &lt;Yield&gt;:
        ExportedVariableBinding&lt;Yield&gt;
    |   ExportedVariableDeclaration&lt;Yield&gt;
;

ExportedVariableBinding &lt;Yield&gt;:
    =&gt; pattern=BindingPattern&lt;Yield&gt; '=' expression=AssignmentExpression&lt;In=true,Yield&gt;
;

ExportedVariableDeclaration &lt;Yield&gt;:
    VariableDeclarationImpl&lt;In=true,Yield,AllowType=true&gt;
;
EmptyStatement: ';';
ExpressionStatement &lt;Yield&gt;: expression=Expression&lt;In=true,Yield&gt; Semi;

IfStatement &lt;Yield&gt;: 'if' '(' expression=Expression&lt;In=true,Yield&gt; ')'
    ifStmt=Statement&lt;Yield&gt; (=&gt; 'else' elseStmt=Statement&lt;Yield&gt;)?;

IterationStatement &lt;Yield&gt;:
        DoStatement&lt;Yield&gt;
    |   WhileStatement&lt;Yield&gt;
    |   ForStatement&lt;Yield&gt;
;

DoStatement &lt;Yield&gt;: 'do' statement=Statement&lt;Yield&gt; 'while'
    '(' expression=Expression&lt;In=true,Yield&gt; ')' =&gt; Semi?;
WhileStatement &lt;Yield&gt;: 'while' '(' expression=Expression&lt;In=true,Yield&gt; ')'
    statement=Statement&lt;Yield&gt;;

ForStatement &lt;Yield&gt;:
    'for' '('
    (
            =&gt;(initExpr=LetIdentifierRef forIn?='in' expression=Expression&lt;In=true,Yield&gt; ')')
        |   (   -&gt;varStmtKeyword=VariableStatementKeyword
                (
                        =&gt;(varDeclsOrBindings+=BindingIdentifierAsVariableDeclaration&lt;In=false,Yield&gt;
                        (forIn?='in' | forOf?='of') -&gt;expression=AssignmentExpression&lt;In=true,Yield&gt;?)
                    |   varDeclsOrBindings+=VariableDeclarationOrBinding&lt;In=false,Yield,OptionalInit=true&gt;
                        (
                                (',' varDeclsOrBindings+=VariableDeclarationOrBinding&lt;In=false,Yield,false&gt;)* ';'
                                expression=Expression&lt;In=true,Yield&gt;? ';' updateExpr=Expression&lt;In=true,Yield&gt;?
                            |   forIn?='in' expression=Expression&lt;In=true,Yield&gt;?
                            |   forOf?='of' expression=AssignmentExpression&lt;In=true,Yield&gt;?
                        )
                )
            |   initExpr=Expression&lt;In=false,Yield&gt;
                (
                        ';' expression=Expression&lt;In=true,Yield&gt;? ';' updateExpr=Expression&lt;In=true,Yield&gt;?
                    |   forIn?='in' expression=Expression&lt;In=true,Yield&gt;?
                    |   forOf?='of' expression=AssignmentExpression&lt;In=true,Yield&gt;?
                )
            |   ';' expression=Expression&lt;In=true,Yield&gt;? ';' updateExpr=Expression&lt;In=true,Yield&gt;?
            )
        ')'
    ) statement=Statement&lt;Yield&gt;
;

LetIdentifierRef:
    id=[types::IdentifiableElement|LetAsIdentifier]
;

LetAsIdentifier: 'let';

BindingIdentifierAsVariableDeclaration &lt;In, Yield&gt;:
    name=BindingIdentifier&lt;Yield&gt;
;

ContinueStatement &lt;Yield&gt;: 'continue' (label=[LabelledStatement|BindingIdentifier&lt;Yield&gt;])? Semi;

BreakStatement &lt;Yield&gt;: 'break' (label=[LabelledStatement|BindingIdentifier&lt;Yield&gt;])? Semi;

ReturnStatement &lt;Yield&gt;: 'return' (expression=Expression&lt;In=true,Yield&gt;)? Semi;

WithStatement &lt;Yield&gt;: 'with' '(' expression=Expression&lt;In=true,Yield&gt; ')' statement=Statement&lt;Yield&gt;;

SwitchStatement &lt;Yield&gt;:
    'switch' '(' expression=Expression&lt;In=true,Yield&gt; ')' '{'
    (cases+=CaseClause&lt;Yield&gt;)*
    ((cases+=DefaultClause&lt;Yield&gt;)
    (cases+=CaseClause&lt;Yield&gt;)*)? '}'
;

CaseClause &lt;Yield&gt;: 'case' expression=Expression&lt;In=true,Yield&gt; ':' (statements+=Statement&lt;Yield&gt;)*;

DefaultClause &lt;Yield&gt;: 'default' ':' (statements+=Statement&lt;Yield&gt;)*;

LabelledStatement &lt;Yield&gt;: =&gt; (name=BindingIdentifier&lt;Yield&gt; ':') statement=Statement&lt;Yield&gt;;

ThrowStatement &lt;Yield&gt;:
    'throw' expression=Expression&lt;In=true,Yield&gt; Semi;

TryStatement &lt;Yield&gt;:
    'try' block=Block&lt;Yield&gt;
    ((catch=CatchBlock&lt;Yield&gt; finally=FinallyBlock&lt;Yield&gt;?) | finally=FinallyBlock&lt;Yield&gt;)
;

CatchBlock &lt;Yield&gt;: 'catch' '(' catchVariable=CatchVariable&lt;Yield&gt; ')' block=Block&lt;Yield&gt;;

CatchVariable &lt;Yield&gt;:
        =&gt;bindingPattern=BindingPattern&lt;Yield&gt;
    |   =&gt;(name=BindingIdentifier&lt;Yield&gt; -&gt; ColonSepTypeRef)
    |   name=BindingIdentifier&lt;Yield&gt;
;

FinallyBlock &lt;Yield&gt;: 'finally' block=Block&lt;Yield&gt;;

DebuggerStatement:
    'debugger' Semi;

PrimaryExpression &lt;Yield&gt;:
      ThisLiteral
    | SuperLiteral
    | IdentifierRef&lt;Yield&gt;
    | ParameterizedCallExpression&lt;Yield&gt;
    | Literal
    | ArrayLiteral&lt;Yield&gt;
    | ObjectLiteral&lt;Yield&gt;
    | ParenExpression&lt;Yield&gt;
    | AnnotatedExpression&lt;Yield&gt;
    | FunctionExpression
    | AsyncFunctionExpression
    | N4ClassExpression&lt;Yield&gt;
    | TemplateLiteral&lt;Yield&gt;
;

ParenExpression &lt;Yield&gt;: '(' expression=Expression&lt;In=true,Yield&gt; ')';

IdentifierRef &lt;Yield&gt;:
    id=[types::IdentifiableElement|BindingIdentifier&lt;Yield&gt;]
;

SuperLiteral: 'super';

ThisLiteral: 'this';

ArrayLiteral &lt;Yield&gt;:
    '['
        elements+=ArrayPadding* (
            elements+=ArrayElement&lt;Yield&gt;
            (',' elements+=ArrayPadding* elements+=ArrayElement&lt;Yield&gt;)*
            (trailingComma?=',' elements+=ArrayPadding*)?
        )?
    ']'
;

ArrayPadding: ',';

ArrayElement &lt;Yield&gt;: spread?='...'? expression=AssignmentExpression&lt;In=true,Yield&gt;;

ObjectLiteral &lt;Yield&gt;: '{'
        ( propertyAssignments+=PropertyAssignment&lt;Yield&gt;
          (',' propertyAssignments+=PropertyAssignment&lt;Yield&gt;)* ','?
        )?
    '}'
;

PropertyAssignment &lt;Yield&gt;:
      AnnotatedPropertyAssignment&lt;Yield&gt;
    | PropertyNameValuePair&lt;Yield&gt;
    | PropertyGetterDeclaration&lt;Yield&gt;
    | PropertySetterDeclaration&lt;Yield&gt;
    | PropertyMethodDeclaration&lt;Yield&gt;
    | PropertyNameValuePairSingleName&lt;Yield&gt;
;

AnnotatedPropertyAssignment &lt;Yield&gt;:
    PropertyAssignmentAnnotationList (
    =&gt;( {PropertyNameValuePair.annotationList=current} declaredTypeRef=TypeRef?
            LiteralOrComputedPropertyName&lt;Yield&gt; ':'
        ) expression=AssignmentExpression&lt;In=true,Yield&gt;
    | =&gt;({PropertyGetterDeclaration.annotationList=current}
            GetterHeader&lt;Yield&gt;
        ) body=Block&lt;Yield=false&gt;
    | =&gt;({PropertySetterDeclaration.annotationList=current}
            'set' -&gt;LiteralOrComputedPropertyName &lt;Yield&gt;
        ) '(' fpar=FormalParameter&lt;Yield&gt; ')' body=Block&lt;Yield=false&gt;
    | =&gt;({PropertyMethodDeclaration.annotationList=current}
            TypeVariables? returnTypeRef=TypeRef?
            (generator?='*' LiteralOrComputedPropertyName&lt;Yield&gt; -&gt;MethodParamsAndBody &lt;Generator=true&gt;
                | LiteralOrComputedPropertyName&lt;Yield&gt; -&gt; MethodParamsAndBody &lt;Generator=false&gt;
            )
        ) ';'?
    | {PropertyNameValuePairSingleName.annotationList=current}
        declaredTypeRef=TypeRef? identifierRef=IdentifierRef&lt;Yield&gt;
        ( '=' expression=AssignmentExpression&lt;In=true,Yield&gt;)?)
;

PropertyMethodDeclaration &lt;Yield&gt;:
    =&gt; (TypeVariables? returnTypeRef=TypeRef?
            (
                generator?='*'  LiteralOrComputedPropertyName&lt;Yield&gt;
                    -&gt;MethodParamsAndBody&lt;Generator=true&gt;
                | LiteralOrComputedPropertyName&lt;Yield&gt; -&gt;MethodParamsAndBody &lt;Generator=false&gt;
            )
        )
    ';'?
;

PropertyNameValuePair &lt;Yield&gt;:
    =&gt; (
        declaredTypeRef=TypeRef? LiteralOrComputedPropertyName&lt;Yield&gt; ':'
    )
    expression=AssignmentExpression&lt;In=true,Yield&gt;
;

PropertyNameValuePairSingleName &lt;Yield&gt;:
    declaredTypeRef=TypeRef?
    identifierRef=IdentifierRef&lt;Yield&gt;
    ('=' expression=AssignmentExpression&lt;In=true,Yield&gt;)?
;

PropertyGetterDeclaration &lt;Yield&gt;:
    =&gt;(
        GetterHeader&lt;Yield&gt;
    )
    body=Block&lt;Yield=false&gt;
;

PropertySetterDeclaration &lt;Yield&gt;:
    =&gt;(
        'set'
        -&gt;LiteralOrComputedPropertyName &lt;Yield&gt;
    )
    '(' fpar=FormalParameter&lt;Yield&gt; ')' body=Block&lt;Yield=false&gt;
;

ParameterizedCallExpression &lt;Yield&gt;:
    TypeArguments
    target=IdentifierRef&lt;Yield&gt;
    ArgumentsWithParentheses&lt;Yield&gt;
;

LeftHandSideExpression &lt;Yield&gt;:
    MemberExpression&lt;Yield&gt; (
        {ParameterizedCallExpression.target=current} ArgumentsWithParentheses&lt;Yield&gt;
        (
              {ParameterizedCallExpression.target=current} ArgumentsWithParentheses&lt;Yield&gt;
            | {IndexedAccessExpression.target=current} IndexedAccessExpressionTail&lt;Yield&gt;
            | {ParameterizedPropertyAccessExpression.target=current}
                ParameterizedPropertyAccessExpressionTail&lt;Yield&gt;
            | -&gt;({TaggedTemplateString.target=current} template=TemplateLiteral&lt;Yield&gt;)
        )*
    )?
;

fragment Arguments &lt;Yield&gt;*:
      arguments+=AssignmentExpression&lt;In=true,Yield&gt;
      (',' arguments+=AssignmentExpression&lt;In=true,Yield&gt;)*
      (',' spread?='...' arguments+=AssignmentExpression&lt;In=true,Yield&gt;)?
    | spread?='...' arguments+=AssignmentExpression&lt;In=true,Yield&gt;
;

fragment TypeArguments*:
    '&lt;' typeArgs+=TypeRef (',' typeArgs+=TypeRef)* '&gt;'
;

fragment ArgumentsWithParentheses &lt;Yield&gt;*:
    '(' Arguments&lt;Yield&gt;? ')'
;

MemberExpression &lt;Yield&gt;:
    =&gt;('new' '.') 'target'
    | =&gt; ('new') callee=MemberExpression&lt;Yield&gt; (-&gt; TypeArguments)?
        (=&gt; withArgs?='(' Arguments&lt;Yield&gt;? ')'
            (
                  {IndexedAccessExpression.target=current} IndexedAccessExpressionTail&lt;Yield&gt;
                | {ParameterizedPropertyAccessExpression.target=current}
                    ParameterizedPropertyAccessExpressionTail&lt;Yield&gt;
                | {TaggedTemplateString.target=current} template=TemplateLiteral&lt;Yield&gt;
            )*
        )?
    | PrimaryExpression&lt;Yield&gt; (
          {IndexedAccessExpression.target=current} IndexedAccessExpressionTail&lt;Yield&gt;
        | {ParameterizedPropertyAccessExpression.target=current}
            ParameterizedPropertyAccessExpressionTail&lt;Yield&gt;
        | {TaggedTemplateString.target=current} template=TemplateLiteral&lt;Yield&gt;
        )*
;

fragment IndexedAccessExpressionTail &lt;Yield&gt;*:
    '[' index=Expression&lt;In=true,Yield&gt; ']'
;

fragment ParameterizedPropertyAccessExpressionTail &lt;Yield&gt;*:
    '.' TypeArguments? property=[types::IdentifiableElement|IdentifierName]
;

PostfixExpression &lt;Yield&gt;:
    LeftHandSideExpression&lt;Yield&gt; (
        =&gt;({PostfixExpression.expression=current} op=PostfixOperator
        )
    )?
;

enum PostfixOperator: inc='++' | dec='--';

CastExpression &lt;Yield&gt;: PostfixExpression&lt;Yield&gt;
    (=&gt;({CastExpression.expression=current} 'as') targetTypeRef=TypeRefForCast)?;

UnaryExpression &lt;Yield&gt;:
      CastExpression&lt;Yield&gt;
    | (op=UnaryOperator expression=UnaryExpression&lt;Yield&gt;);

enum UnaryOperator: delete | void | typeof | inc='++' | dec='--' | pos='+' | neg='-' | inv='~' | not='!';

MultiplicativeExpression &lt;Yield&gt;: UnaryExpression&lt;Yield&gt;
    (=&gt;({MultiplicativeExpression.lhs=current} op=MultiplicativeOperator)
        rhs=UnaryExpression&lt;Yield&gt;)*;

enum MultiplicativeOperator: times='*' | div='/' | mod='%';

AdditiveExpression &lt;Yield&gt;: MultiplicativeExpression&lt;Yield&gt;
    (=&gt;({AdditiveExpression.lhs=current} op=AdditiveOperator)
        rhs=MultiplicativeExpression&lt;Yield&gt;)*;

enum AdditiveOperator: add='+' | sub='-';

ShiftExpression &lt;Yield&gt;: AdditiveExpression&lt;Yield&gt;
    (=&gt;({ShiftExpression.lhs=current} op=ShiftOperator rhs=AdditiveExpression&lt;Yield&gt;))*
;

ShiftOperator:
      '&gt;' '&gt;' '&gt;'?
    | '&lt;&lt;'
;

RelationalExpression &lt;In, Yield&gt;: ShiftExpression&lt;Yield&gt;
    =&gt;({RelationalExpression.lhs=current} op=RelationalOperator&lt;In&gt;
        -&gt;rhs=ShiftExpression&lt;Yield&gt;)*;

RelationalOperator &lt;In&gt;:
    '&lt;' | '&gt;' | '&lt;=' | '&gt;=' | 'instanceof' | &lt;In&gt; 'in';

EqualityExpression &lt;In, Yield&gt;: RelationalExpression&lt;In,Yield&gt;
    (=&gt;({EqualityExpression.lhs=current} op=EqualityOperator) rhs=RelationalExpression&lt;In,Yield&gt;)*;

enum EqualityOperator: same='===' | nsame='!==' | eq='==' | neq='!=';

BitwiseANDExpression &lt;In, Yield&gt;: EqualityExpression&lt;In,Yield&gt;
    (=&gt;({BinaryBitwiseExpression.lhs=current} op=BitwiseANDOperator) rhs=EqualityExpression&lt;In,Yield&gt;)*;

BitwiseANDOperator: '&amp;';

BitwiseXORExpression &lt;In, Yield&gt;: BitwiseANDExpression&lt;In,Yield&gt;
    (=&gt;({BinaryBitwiseExpression.lhs=current} op=BitwiseXOROperator) rhs=BitwiseANDExpression&lt;In,Yield&gt;)*;

BitwiseXOROperator: '^';

BitwiseORExpression &lt;In, Yield&gt;: BitwiseXORExpression&lt;In,Yield&gt;
    (=&gt;({BinaryBitwiseExpression.lhs=current} op=BitwiseOROperator) rhs=BitwiseXORExpression&lt;In,Yield&gt;)*;

BitwiseOROperator: '|';

LogicalANDExpression &lt;In, Yield&gt;: BitwiseORExpression&lt;In,Yield&gt;
    (=&gt; ({BinaryLogicalExpression.lhs=current} op=LogicalANDOperator) rhs=BitwiseORExpression&lt;In,Yield&gt;)*;

LogicalANDOperator: '&amp;&amp;';

LogicalORExpression &lt;In, Yield&gt;: LogicalANDExpression&lt;In,Yield&gt;
    (=&gt;({BinaryLogicalExpression.lhs=current} op=LogicalOROperator) rhs=LogicalANDExpression&lt;In,Yield&gt;)*;

LogicalOROperator: '||';

ConditionalExpression &lt;In, Yield&gt;: LogicalORExpression&lt;In,Yield&gt;
    (=&gt; ({ConditionalExpression.expression=current} '?') trueExpression=AssignmentExpression&lt;In=true,Yield&gt;
        ':' falseExpression=AssignmentExpression&lt;In,Yield&gt;)?;

AssignmentExpression &lt;In, Yield&gt;:
      AwaitExpression&lt;In,Yield&gt;
    | PromisifyExpression&lt;In,Yield&gt;
    | ArrowExpression&lt;In,Yield&gt;
    | &lt;Yield&gt; YieldExpression&lt;In&gt;
    | ConditionalExpression&lt;In,Yield&gt;
        (=&gt; ({AssignmentExpression.lhs=current} op=AssignmentOperator)
            rhs=AssignmentExpression&lt;In,Yield&gt;)?
;

YieldExpression &lt;In&gt;:
    'yield' =&gt; many?='*'? -&gt; expression=AssignmentExpression&lt;In,Yield=true&gt;?
;

AssignmentOperator:
      '=' | '*=' | '/=' | '%=' | '+=' | '-='
    | '&lt;&lt;='
    | '&gt;' '&gt;'? '&gt;='
    | '&amp;=' | '^=' | '|='
;

AwaitExpression &lt;In, Yield&gt;:
    =&gt;('await') expression=AssignmentExpression&lt;In,Yield&gt;;

PromisifyExpression &lt;In, Yield&gt;:
    =&gt; ('@' 'Promisify') expression=AssignmentExpression&lt;In,Yield&gt;;

Expression &lt;In, Yield&gt;:
    AssignmentExpression&lt;In,Yield&gt; ({CommaExpression.exprs+=current}
    ',' exprs+=AssignmentExpression&lt;In,Yield&gt;
    (','    exprs+=AssignmentExpression&lt;In,Yield&gt;)*)?
;

TemplateLiteral &lt;Yield&gt;:
    (
          segments+=NoSubstitutionTemplate
        | segments+=TemplateHead segments+=Expression&lt;In=true,Yield&gt;? TemplateExpressionEnd
            (
                segments+=TemplateMiddle segments+=Expression&lt;In=true,Yield&gt;?
                TemplateExpressionEnd
            )*
            segments+=TemplateTail
    )
;

TemplateExpressionEnd:
    '}'
;

NoSubstitutionTemplate:
    rawValue=NO_SUBSTITUTION_TEMPLATE_LITERAL
;

TemplateHead:
    rawValue=TEMPLATE_HEAD
;

TemplateTail:
    rawValue=TemplateTailLiteral;

TemplateMiddle:
    rawValue=TemplateMiddleLiteral;

Literal:
      NumericLiteral | BooleanLiteral | StringLiteral
    | NullLiteral | RegularExpressionLiteral;
NullLiteral: 'null';
BooleanLiteral: (true?='true' | 'false');
StringLiteral: value=STRING;
NumericLiteral:
      DoubleLiteral | IntLiteral | BinaryIntLiteral | OctalIntLiteral
    | LegacyOctalIntLiteral | HexIntLiteral | ScientificIntLiteral;
DoubleLiteral: value=DOUBLE;
IntLiteral: value=INT;
OctalIntLiteral: value=OCTAL_INT;
LegacyOctalIntLiteral: value=LEGACY_OCTAL_INT;
HexIntLiteral: value=HEX_INT;
BinaryIntLiteral: value=BINARY_INT;
ScientificIntLiteral: value=SCIENTIFIC_INT;
RegularExpressionLiteral: value=REGEX_LITERAL;

NumericLiteralAsString:
    DOUBLE | INT | OCTAL_INT | HEX_INT | SCIENTIFIC_INT
;

IdentifierOrThis:
    IDENTIFIER
    | 'This'
    | 'Promisify'
    | 'target';

AnnotationName:
    IDENTIFIER
    | 'This'
    | 'target';

BindingIdentifier &lt;Yield&gt;:
    IDENTIFIER
    | &lt;!Yield&gt; 'yield'
    | N4Keyword
;

IdentifierName:
    IDENTIFIER | ReservedWord | N4Keyword
;

ReservedWord:
    'break' | 'case' | 'catch' | 'class' | 'const' | 'continue' | 'debugger' | 'default' | 'delete'
    | 'do' | 'else' | 'export' | 'extends' | 'finally' | 'for' | 'function' | 'if' | 'import'
    | 'in' | 'instanceof' | 'new' | 'return' | 'super' | 'switch' | 'this' | 'throw' | 'try'
    | 'typeof' | 'var' | 'void' | 'while' | 'with' | 'yield'
    | 'null'
    | 'true' | 'false'
    | 'enum';

N4Keyword:
    'get' | 'set'
    | 'let'
    | 'project'
    | 'external' | 'abstract' | 'static'
    | 'as' | 'from' | 'constructor' | 'of' | 'target'
    | 'type' | 'union' | 'intersection'
    | 'This' | 'Await' | 'Promisify'
    | 'await'
    | 'async'
    | 'implements' | 'interface'
    | 'private' | 'protected' | 'public'
;

SymbolLiteralComputedName &lt;Yield&gt;:
    BindingIdentifier&lt;Yield&gt; ('.' IdentifierName)?
;

terminal DOUBLE:
    '.' DECIMAL_DIGIT_FRAGMENT+ EXPONENT_PART?
    | DECIMAL_INTEGER_LITERAL_FRAGMENT '.' DECIMAL_DIGIT_FRAGMENT* EXPONENT_PART?
;

terminal HEX_INT: '0' ('x' | 'X') INT_SUFFIX;

terminal BINARY_INT: '0' ('b' | 'B') INT_SUFFIX;

terminal OCTAL_INT: '0' ('o' | 'O') INT_SUFFIX;

terminal LEGACY_OCTAL_INT: '0' DECIMAL_DIGIT_FRAGMENT INT_SUFFIX;

terminal fragment INT_SUFFIX: IDENTIFIER_PART*;

terminal SCIENTIFIC_INT:
    DECIMAL_INTEGER_LITERAL_FRAGMENT EXPONENT_PART
;

terminal fragment EXPONENT_PART:
      ('e' | 'E') SIGNED_INT
    | IDENTIFIER
;

terminal fragment SIGNED_INT:
    ('+' | '-') DECIMAL_DIGIT_FRAGMENT+ IDENTIFIER?
;

terminal STRING:
      '"' DOUBLE_STRING_CHAR* '"'?
    | "'" SINGLE_STRING_CHAR* "'"?
;

terminal fragment DOUBLE_STRING_CHAR:
      !(LINE_TERMINATOR_FRAGMENT | '"' | '\\')
    | '\\' (LINE_TERMINATOR_SEQUENCE_FRAGMENT | !LINE_TERMINATOR_FRAGMENT)?
;

terminal fragment SINGLE_STRING_CHAR:
      !(LINE_TERMINATOR_FRAGMENT | "'" | '\\')
    | '\\' (LINE_TERMINATOR_SEQUENCE_FRAGMENT | !LINE_TERMINATOR_FRAGMENT)?
;

terminal fragment BACKSLASH_SEQUENCE:
    '\\' !(LINE_TERMINATOR_FRAGMENT)?
;

terminal fragment REGEX_CHAR:
      !(LINE_TERMINATOR_FRAGMENT | '\\' | '/' | '[')
    | BACKSLASH_SEQUENCE
    | '[' REGEX_CHAR_OR_BRACKET* ']'?
;

terminal fragment REGEX_CHAR_OR_BRACKET:
      !(LINE_TERMINATOR_FRAGMENT | '\\' | ']')
    | BACKSLASH_SEQUENCE
;

REGEX_LITERAL:
    ('/' | '/=') REGEX_TAIL?
;

terminal fragment ACTUAL_REGEX_TAIL:
      REGEX_CHAR+ ('/' IDENTIFIER_PART*)?
    | '/' IDENTIFIER_PART*
;

terminal fragment REGEX_START:
    ('/' | '/=')
;

terminal REGEX_TAIL: // post processed
    '//1'
;
terminal TEMPLATE_HEAD:
    "`" TEMPLATE_LITERAL_CHAR* '$'+ '{'
;

terminal NO_SUBSTITUTION_TEMPLATE_LITERAL:
    '`' TEMPLATE_LITERAL_CHAR* '$'* "`"?
;

terminal fragment ACTUAL_TEMPLATE_END:
    TEMPLATE_LITERAL_CHAR* ('$'+ ('{' | '`'?) | '`'?)
;

terminal fragment TEMPLATE_LITERAL_CHAR:
      !(LINE_TERMINATOR_FRAGMENT | '`' | '\\' | '$')
    | '$'+ !('{' | '`' | '$')
    | LINE_TERMINATOR_SEQUENCE_FRAGMENT
    | '\\' (LINE_TERMINATOR_SEQUENCE_FRAGMENT | !LINE_TERMINATOR_FRAGMENT)?
;

TemplateTailLiteral:
    TEMPLATE_END?
;

TemplateMiddleLiteral:
    TEMPLATE_MIDDLE
;

terminal TEMPLATE_MIDDLE:
    '//2' // will never be lexed
;

terminal TEMPLATE_END:
    '//3' // will never be lexed
;

terminal fragment TEMPLATE_CONTINUATION:
    '//4' // actually '}'
;

Semi: ';'; // automatic semicolon instertion, post-processed

fragment NoLineTerminator*: NO_LINE_TERMINATOR?;

terminal NO_LINE_TERMINATOR:
    '//5' // post-processed, will never be lexed
;
Annotation:'@' AnnotationNoAtSign;
ScriptAnnotation: '@@' AnnotationNoAtSign;

AnnotationNoAtSign:
    name=AnnotationName (=&gt; '(' (args+=AnnotationArgument (',' args+=AnnotationArgument)*)? ')')?;

AnnotationArgument:
    LiteralAnnotationArgument | TypeRefAnnotationArgument
;

LiteralAnnotationArgument:
    literal=Literal
;

TypeRefAnnotationArgument:
    typeRef=TypeRef
;

AnnotationList:
    =&gt;('@' -&gt; annotations+=AnnotationNoAtSign) annotations+=Annotation*
;

ExpressionAnnotationList:
    annotations+=Annotation+
;

PropertyAssignmentAnnotationList:
    annotations+=Annotation+
;

N4MemberAnnotationList:
    {N4MemberAnnotationList} annotations+=Annotation+
;

TypeReferenceName:
    'void' | 'This' | 'await' | 'Promisify' | 'target' | QualifiedTypeReferenceName
;

QualifiedTypeReferenceName:
    IDENTIFIER ('.' IDENTIFIER)?
;
N4ClassDeclaration &lt;Yield&gt;:
    =&gt;(
        {N4ClassDeclaration}
        (declaredModifiers+=N4Modifier)*
        'class' typingStrategy=TypingStrategyDefSiteOperator? name=BindingIdentifier&lt;Yield&gt;?
    )
    TypeVariables?
    ClassExtendsClause&lt;Yield&gt;?
    Members&lt;Yield&gt;
;

fragment Members &lt;Yield&gt;*:
    '{'
    ownedMembersRaw+=N4MemberDeclaration&lt;Yield&gt;*
    '}'
;

fragment ClassExtendsClause &lt;Yield&gt;*:
    'extends' (
          =&gt;superClassRef=ParameterizedTypeRefNominal ('implements' ClassImplementsList)?
        | superClassExpression=LeftHandSideExpression&lt;Yield&gt;
    )
    | 'implements' ClassImplementsList
;

fragment ClassImplementsList*:
    implementedInterfaceRefs+=ParameterizedTypeRefNominal
    (',' implementedInterfaceRefs+=ParameterizedTypeRefNominal)*
;

N4ClassExpression &lt;Yield&gt;:
    {N4ClassExpression}
    'class' name=BindingIdentifier&lt;Yield&gt;?
    ClassExtendsClause&lt;Yield&gt;?
    Members&lt;Yield&gt;;
N4InterfaceDeclaration &lt;Yield&gt;:
    =&gt; (
        {N4InterfaceDeclaration}
        (declaredModifiers+=N4Modifier)*
        'interface' typingStrategy=TypingStrategyDefSiteOperator? name=BindingIdentifier&lt;Yield&gt;?
    )
    TypeVariables?
    InterfaceImplementsList?
    Members&lt;Yield&gt;
;

fragment InterfaceImplementsList*:
     'extends' superInterfaceRefs+=ParameterizedTypeRefNominal
        (',' superInterfaceRefs+=ParameterizedTypeRefNominal)*
;
N4EnumDeclaration &lt;Yield&gt;:
    =&gt;(
        {N4EnumDeclaration}
        (declaredModifiers+=N4Modifier)*
        'enum' name=BindingIdentifier&lt;Yield&gt;?
    )
    '{'
        (literals+=N4EnumLiteral (',' literals+=N4EnumLiteral)*)?
    '}'
;
N4EnumLiteral: name=IdentifierOrThis (':' value=STRING)?;

enum N4Modifier: // validator applies further checks
      private | project | protected | public
    | external | abstract | static | const;

N4MemberDeclaration &lt;Yield&gt;:
    AnnotatedN4MemberDeclaration&lt;Yield&gt;
    | N4GetterDeclaration&lt;Yield&gt;
    | N4SetterDeclaration&lt;Yield&gt;
    | N4MethodDeclaration&lt;Yield&gt;
    | N4FieldDeclaration&lt;Yield&gt;
    | N4CallableConstructorDeclaration&lt;Yield&gt;
;

AnnotatedN4MemberDeclaration &lt;Yield&gt; returns N4MemberDeclaration:
    N4MemberAnnotationList (
            =&gt; ({N4GetterDeclaration.annotationList=current}
                (declaredModifiers+=N4Modifier)* GetterHeader&lt;Yield&gt;) (body=Block&lt;Yield&gt;)? ';'?
        |   =&gt; ({N4SetterDeclaration.annotationList=current}
                (declaredModifiers+=N4Modifier)* 'set' -&gt; LiteralOrComputedPropertyName &lt;Yield&gt;)
                '(' fpar=FormalParameter&lt;Yield&gt; ')' (body=Block&lt;Yield&gt;)? ';'?
        |   =&gt; (
                {N4MethodDeclaration.annotationList=current} (declaredModifiers+=N4Modifier)* TypeVariables?
                (
                        generator?='*' LiteralOrComputedPropertyName&lt;Yield&gt;
                        -&gt;MethodParamsReturnAndBody &lt;Generator=true&gt;
                    |   AsyncNoTrailingLineBreak LiteralOrComputedPropertyName&lt;Yield&gt;
                        -&gt;MethodParamsReturnAndBody &lt;Generator=false&gt;
                )
                )';'?
        |   {N4FieldDeclaration.annotationList=current} FieldDeclarationImpl&lt;Yield&gt;
    )
;

fragment LiteralOrComputedPropertyName &lt;Yield&gt;*:
    name=IdentifierName | name=STRING | name=NumericLiteralAsString
    | '[' (=&gt;((name=SymbolLiteralComputedName&lt;Yield&gt; | name=StringLiteralAsName) ']')
        |   computeNameFrom=AssignmentExpression&lt;In=true,Yield&gt; ']')
;

fragment LiteralPropertyName &lt;Yield&gt;*:
    name=IdentifierName | name=STRING | name=NumericLiteralAsString
    | '[' (name=SymbolLiteralComputedName&lt;Yield&gt; | name=StringLiteralAsName) ']'
;

StringLiteralAsName:
    STRING
;

fragment FieldDeclarationImpl &lt;Yield&gt;*:
    (declaredModifiers+=N4Modifier)*
    LiteralPropertyName&lt;Yield&gt; ColonSepTypeRef? ('=' expression=Expression&lt;In=true,Yield&gt;)? ';'
;

N4FieldDeclaration &lt;Yield&gt;:
    {N4FieldDeclaration}
    FieldDeclarationImpl&lt;Yield&gt;
;

N4MethodDeclaration &lt;Yield&gt;:
    =&gt; ({N4MethodDeclaration} (declaredModifiers+=N4Modifier)* TypeVariables?
        (
                generator?='*' LiteralOrComputedPropertyName&lt;Yield&gt;
                -&gt;MethodParamsReturnAndBody &lt;Generator=true&gt;
            |   AsyncNoTrailingLineBreak LiteralOrComputedPropertyName&lt;Yield&gt;
                -&gt;MethodParamsReturnAndBody &lt;Generator=false&gt;
        )
    ) ';'?
;

N4CallableConstructorDeclaration &lt;Yield&gt; returns N4MethodDeclaration:
    MethodParamsReturnAndBody &lt;Generator=false&gt; ';'?
;

fragment MethodParamsAndBody &lt;Generator&gt;*:
    StrictFormalParameters&lt;Yield=Generator&gt;
    (body=Block&lt;Yield=Generator&gt;)?
;

fragment MethodParamsReturnAndBody &lt;Generator&gt;*:
    StrictFormalParameters&lt;Yield=Generator&gt;
    (':' returnTypeRef=TypeRef)?
    (body=Block&lt;Yield=Generator&gt;)?
;

N4GetterDeclaration &lt;Yield&gt;:
    =&gt; ({N4GetterDeclaration}
    (declaredModifiers+=N4Modifier)*
    GetterHeader&lt;Yield&gt;)
    (body=Block&lt;Yield&gt;)? ';'?
;

fragment GetterHeader &lt;Yield&gt;*:
    ('get' -&gt; LiteralOrComputedPropertyName &lt;Yield&gt; '(' ')' ColonSepTypeRef?)
;

N4SetterDeclaration &lt;Yield&gt;:
    =&gt;({N4SetterDeclaration}
        (declaredModifiers+=N4Modifier)*
        'set'
        -&gt;LiteralOrComputedPropertyName &lt;Yield&gt;
    )
    '(' fpar=FormalParameter&lt;Yield&gt; ')' (body=Block&lt;Yield&gt;)? ';'?
;

BindingPattern &lt;Yield&gt;:
    ObjectBindingPattern&lt;Yield&gt;
    | ArrayBindingPattern&lt;Yield&gt;
;

ObjectBindingPattern &lt;Yield&gt;:
    '{' (properties+=BindingProperty&lt;Yield,AllowType=false&gt;
        (',' properties+=BindingProperty&lt;Yield,AllowType=false&gt;)*)? '}'
;

ArrayBindingPattern &lt;Yield&gt;:
    '['
        elements+=Elision* (
            elements+=BindingRestElement&lt;Yield&gt;
            (',' elements+=Elision* elements+=BindingRestElement&lt;Yield&gt;)*
            (',' elements+=Elision*)?
        )?
    ']'
;

BindingProperty &lt;Yield, AllowType&gt;:
      =&gt;(LiteralBindingPropertyName&lt;Yield&gt; ':') value=BindingElement&lt;Yield&gt;
    | value=SingleNameBinding&lt;Yield,AllowType&gt;
;

fragment LiteralBindingPropertyName &lt;Yield&gt;*:
    declaredName=IdentifierName | declaredName=STRING | declaredName=NumericLiteralAsString
    | '[' (declaredName=SymbolLiteralComputedName&lt;Yield&gt; | declaredName=STRING) ']'
;

SingleNameBinding &lt;Yield, AllowType&gt;:
    varDecl=VariableDeclaration&lt;In=true,Yield,AllowType&gt;
;

BindingElement &lt;Yield&gt;:
      =&gt;(nestedPattern=BindingPattern&lt;Yield&gt;) ('=' expression=AssignmentExpression&lt;In=true,Yield&gt;)?
    | varDecl=VariableDeclaration&lt;In=true,Yield,AllowType=true&gt;
;

BindingRestElement &lt;Yield&gt;:
    rest?='...'?
    (
          =&gt;(nestedPattern=BindingPattern&lt;Yield&gt;)
            ('=' expression=AssignmentExpression&lt;In=true,Yield&gt;)?
        | varDecl=VariableDeclaration&lt;In=true,Yield,AllowType=true&gt;
    )
;

Elision:
    ','
;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.4<br>
Last updated 2019-01-11 12:16:48 CET
</div>
</div>
<!-- ************* UI Scripts ************* -->
<script type="text/javascript" src="scripts/back-to-top.js"></script>

<!-- ************* Prism.js Syntax Highlighting ************* -->
<script src="scripts/prism.js"></script>
</body>
</html>