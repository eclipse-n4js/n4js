////
Copyright (c) 2017 NumberFour AG.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
  NumberFour AG - Initial API and implementation
////

= Extended Fetaures
:find:

[.language-n4js]
== Array and Object Destructuring

N4JS supports array and object destructuring as provided in ES6.
This is used to conveniently assign selected elements of an array or object to a number of newly-declared or pre-existing variables or to further destructure them by using nested
destructuring patterns footnote:[Further reading on <<Acronyms,DI>> Basics: cite:[Fowler04b,Prasanna09a], Verification cite:[Zhu13a,Hudli13a], Frameworks cite:[Lesiecki08a,Betts13a,Knol13a,Dagger]].

=== Syntax

[source,ebnf]
----
BindingPattern <Yield>:
    ObjectBindingPattern<Yield>
    | ArrayBindingPattern<Yield>
;

ObjectBindingPattern <Yield> returns BindingPattern:
    {BindingPattern}
    '{' (properties+=BindingProperty<Yield,AllowType=false> (',' properties+=BindingProperty<Yield,AllowType=false>)*)? '}'
;

ArrayBindingPattern <Yield> returns BindingPattern:
    {BindingPattern}
    '['
        elements+=Elision* (
            elements+=BindingRestElement<Yield>
            (',' elements+=Elision* elements+=BindingRestElement<Yield>)*
            (',' elements+=Elision*)?
        )?
    ']'
;

BindingProperty <Yield, AllowType>:
      =>(LiteralBindingPropertyName<Yield> ':') value=BindingElement<Yield>
    | value=SingleNameBinding<Yield,AllowType>
;

fragment LiteralBindingPropertyName <Yield>*:
    declaredName=IdentifierName | declaredName=STRING | declaredName=NumericLiteralAsString
    // this is added here due to special treatment for a known set of expressions
    | '[' (declaredName=SymbolLiteralComputedName<Yield> | declaredName=STRING) ']'
;
----

=== Semantics

The following example declares four variables `a`, `b`, `x`, and `prop2`. Variables `a` and `x` will have the value `hello`, whereas `b` and `prop2` will have value 42.

[source,n4js]
----
var [a,b] = ["hello", 42];

var {prop1:x, prop2} = {prop1:"hello", prop2:42};
----

In the case of `prop2`, we do not provide a property name and variable name separately; this is useful in cases where the property name also makes for a
suitable variable name (called `single name binding`).

One of the most useful use cases of destructuring is in a `for..of` loop.
Take this example:

[source,n4js]
----
var arr1 = [ ["hello",1,2,3], ["goodbye",4,5,6] ];
for(var [head,...tail] of arr1) {
    console.log(head,'/',tail);
}
// will print:
//   hello / [ 1, 2, 3 ]
//   goodbye / [ 4, 5, 6 ]

var arr2 = [ {key:"hello", value:42}, {key:"goodbye", value:43} ];
for(var {key,value} of arr2) {
    console.log(key,'/',value);
}
// will print:
//   hello / 42
//   goodbye / 43
----

Array and object destructuring pattern can appear in many different places:

* In a variable declaration (not just in variable statements but also in other places where variable declarations are allowed, e.g. plain for loops; called _destructuring binding_; see <<_variable-statement>>).
* On the left-hand side of an assignment expression (the assignment expression is then called _destructuring assignment_; see <<_assignment-expression>>).
* In a `for..in` or `for..of` loop on the left side of the `in`/`of` (see <<_for-of-statement>>).
+
NOTE: It can also be used in plain statements, but then we actually have one of the above two use cases.
* With lists of formal parameters or function arguments (not supported yet).

For further details on array and object destructuring please refer to the ECMAScript 6 specification - cite:[ECMA15a].

Type annotations can only be added when a new variable name is introduced since the short version would be ambiguous with the long one.
For example:

[source,n4js]
----
var {x: someTypeOrNewVar} = ol
----

could either mean that a new variable `someTypeOrNewVar` is declared and `ol.x` is assigned to it, or that a new variable `x` is declared with type `someTypeOrNewVar`.
The longer form would look like this:

[source,n4js]
----
var {x: x: someType} = ol
----

We can make this more readable:

[source,n4js]
----
var {propOfOl: newVar: typeOfNewVar} = ol
----

[.language-n4js]
== Dependency Injection

This chapter describes <<Acronyms,DI>> mechanisms for N4JS.
This includes compiler, validation and language extensions that allow to achieve DI mechanisms built in into the N4JS language and IDE.

N4JS <<Acronyms,DI>> support specifies a means for obtaining objects in such a way as to maximize reusability, testability and maintainability,
especially compared to traditional approaches such as constructors, factories and service locators.
While this can be achieved manually (without tooling support) it is difficult for nontrivial applications.
The solutions that DI provides should empower N4JS users to achieve the above goals without the burden of maintaining so-called ’boilerplate’ code.

[[fig-di-terms]]
.DI Basic Terms
image::{find}fig/diBasicTerms.png[scaledwidth="60%",align="center"]

_key: pass the dependency instead of letting the client create or find it_

Core terms

* *Service* - A set of APIs describing the functionality of the service.
* **Service Implementation**s - One or more implementations of given service API.
* *Client* - Consumer of a given functionality, uses the given **Service Implementation**.
* *Injector* - Object providing *Service Implementation* of a specific *Service*, according to configuration.
* *Binding* - Part of configuration describing which interface implementing a subtype will be injected, when a given interface is requested.
* *Provider* - Factory used to create instances of a given *Service Implementation* or its sub-components, can be a method.
* *Injection Point* - Part of the user’s code that will have the given dependency injected. This is usually fields, method parameters, constructor parameters etc.
* *DI configuration* - This describes which elements of the user’s code are used in mechanisms and how they are wired.
It is derived from user code elements being marked with appropriate annotations, bindings and providers.
* *di wiring* - The code responsible for creating user objects.
These are injectors, type factories/providers, fields initiators etc.

=== DI Components and Injectors

N4JS’ <<Dependency Injection>> systems is based on the notion of <<Acronyms,DIC>>.

.DI Component
[def]
--
A <<Acronyms,DIC>> is a N4Class annotated with `@GenerateInjector`.
--

This annotation causes an _injector_ to be created for (and associated to) the <<Acronyms,DI>>.
DIC can be composed; meaning that when requested to inject an instance of a type, a DIC’s injector can delegate this request to the injector of the containing DIC.
An injector always prioritizes its own configuration before delegating to the container’s injector.
For validation purposes, a child DI can be annotated with `@WithParent` to ensure that it is always used with a proper parent.

_Injector_ is the main object of DI mechanisms responsible for creating object graphs of the application.
At runtime, injectors are instances of `N4Injector`.

.DI Component and Injector
[req,id=IDE-138,version=1]
--

The following constraints must hold for a class $C$ marked as DIC:

1.  A subclass $S$ of $C$ is a DIC as well and it must be marked with `GenerateInjector`.
2.  If a parent <<DIComponent Relations,DIC>> $P$ is specified via `WithParent`, then $P$ must be a DIC as well.
3.  The injector associated to a DIC is of type `N4Injector`. It can be retrieved via `N4Injector.of(DIC)` in which `DIC` is the `DIC`.
4.  Injectors associated to DIC a are DI-singletons (cf. <<Singleton Scope>>).
Two calls to `N4Injector.of(DIC)` are different (as different DIC are assumed).
--

.Injection Phase
[req,id=IDE-139,version=1]
--

We call the (transitive) creation and setting of values by an injector $I$ caused by the creation of an root object $R$ the __injection phase__.
If an instance $C$ is newly created by the injector $I$ (regardless of the injection point being used), the injection is transitively applied on $C$.
The following constraints have to hold:

.  Root objects are created by one of the following mechanisms:
..  Any class or interface can be created as root objects via an injector associated to a DIC: +
`var x: X = N4Injector.of(DIC).create(X);` +
in which `DIC` is a DIC.
+
Of course, an appropriate binding must exist. footnote:[Usually, only the `DIC` itself is created like that, e.g., [language-n4js]`var dic = N4Injector.of(DIC).create(DIC);`]
..  If a type has the injector being injected, e.g. via field injection `@Inject injector: N4Injector;`, then this injector can be used anytime in the control flow to create
a new root object similar as above (using `create` method).
..  If a provider has been injected (i.e. an instance of `{N4Provider}`), then its `get()` method can be used to create a root object causing a new injection phase to take place.
.  If $C.ctor$ is marked as injection point, all its arguments are set by the injector.
This is also true for an inherited constructor marked as an injection point.
See <<Req-IDE-143>> . For all arguments the injection phase constraints have to hold as well.
. All fields of $C$, including _inherited_ once, marked as injection points are set by the injector.
For all fields the injection phase constraints have to hold as well.



The injector may use a provider method (of a binder) to create nested instances.

The injector is configured with _Binders_ and it tracks _Bindings_ between types (<<Binders and Bindings>>).
An N4JS developer normally would not interact with this object directly except when defining an entry-point to his application.
__Injector__s are configured with __Binder__s which contain explicit __Binding__s defined by an N4JS developer.
A set of these combined with _implicit bindings_ creates the _di configuration_ used by a given injector.
To configure given __Injector__s with given __Binder__(s) use `@UseBinder` annotation.

--


==== DIComponent Relations

A Parent-Child relation can be established between two DIComponents.
Child DIComponents use the parent bindings but can also be configured with their own bindings or _change_ targets used by a parent.
The final circumstance is local to the child and is referred to as __rebinding__.
For more information about bindings see <<Binders and Bindings>>.
A Child-Parent relation is expressed by the `@WithParentInjector` annotation attached to a given DIComponent.
When this relation is defined between DIComponents, the user needs to take care to preserve the proper relation between injectors.
In other words, the user must provide an instance of the parent injector (the injector of the DIComponent passes as a parameter to `@WithParentInjector`) when creating the child injector
(injector of the DIComponent annotated with `@WithParentInjector`).

.Simple DIComponents Relation
[example]
====

[source,n4js]
----
@GenerateInjector
class ParentDIComponent{}

@GenerateInjector
@WithParentInjector(ParentDIComponent)
class ChildDIComponent{}

var parentInejctor = N4Inejctor.of(ParentDiCompoennt);
var childInjector = N4Inejctor.of(ChildDIComponent, parentInjector);
----
====

With complex DIComponent structures, injector instances can be created with a directly-declared parent and also with any of its children.
This is due to the fact that any child can rebind types, add new bindings, but not remove them.
Any child is, therefore, _compatible_ with its parents.

.Compatible DIComponent
[def]
--
A given DIComponent is compatible with another DIComponent if it has bindings for all keys in other component bindings.

[math]
++++
\exists DIC1,DIC2 : DIC1.\seq{binding}.\seq{key} \Rightarrow DIC2.\seq{binding}.\seq{key} \iff DIC2 \subtype DIC1
++++

NOTE: Although subtype notation $\subtype$ is used here it does *not* imply actual subtype relations.
It was used in this instance for of lack of formal notations for DI concepts and because this is similar to the Liskov Substitution principle.

A complex Child-Parent relation between components is depicted in <<fig-complex-dicomponents-relations>> and <<ex:complex-dicomponents-relations>> below.

[[fig-complex-dicomponents-relations]]
.Complex DIComponents Relations
image::{find}fig/diagDICParentChild.svg[scaledwidth="50%",align=center]

--

[[ex:complex-dicomponents-relations]]
.Complex DIComponents Relations
[example]
====


[source,n4js]
----
@GenerateInjector class A {}
@GenerateInjector @WithParentInjector(A) class B {}
@GenerateInjector @WithParentInjector(B) class C {}
@GenerateInjector @WithParentInjector(C) class D {}
@GenerateInjector @WithParentInjector(A) class B2 {}
@GenerateInjector @WithParentInjector(B2) class C2 {}
@GenerateInjector @WithParentInjector(C2) class D2 {}
@GenerateInjector @WithParentInjector(A) class X {}
@GenerateInjector @WithParentInjector(C) class Y {}

// creating injectors
var injectorA = N4Injector.of(A);
//following throws DIConfigurationError, expected parent is not provided
//var injectorB =  N4Injector.of(B);
//correct declarations
var injectorB =  N4Injector.of(B, injectorA);
var injectorC = N4Injector.of(C, injectorB);
var injectorD = N4Injector.of(D, injectorC);
var injectorB2 = N4Injector.of(B2, injectorA);
var injectorC2 = N4Injector.of(C2, injectorB2);
var injectorD2 = N4Injector.of(D2, injectorC2);

//Any injector of {A,B,C,D,b2,C2,D2} s valid parent for injector of X, e.g. D or D2
N4Injector.of(X, injectorD);//is ok as compatible parent is provided
N4Injector.of(X, injectorD2);//is ok as compatible parent is provided

N4Injector.of(Y, injectorC);//is ok as direct parent is provided
N4Injector.of(Y, injectorD);//is ok as compatible parent is provided

N4Injector.of(Y, injectorB2);//throws DIConfigurationError, incompatible parent is provided
N4Injector.of(Y, injectorC2);//throws DIConfigurationError, incompatible parent is provided
N4Injector.of(Y, injectorD2);//throws DIConfigurationError, incompatible parent is provided
----
====


=== Binders and Bindings

_Binder_ allows an N4JS developer to (explicitly) define a set of __Binding__s that will be used by an _Injector_ configured with a given _Binder_.
There are two ways for _Binder_ to define __Binding__s: `@Bind` (<<N4JS DI @Bind>>) annotations and a method annotated with `@Provides`.

_Binder_ is declared by annotating a class with the `@Binder` annotation.

A _Binding_ is part of a configuration that defines which instance of
what type should be injected into an _injection point_ (<<_injection-points>>) with an expected type.

_Provider Method_ is essentially a _factory method_ that is used to create an instance of a type.
N4JS allows a developer to declare those methods (see <<_n4js-di-provides>>) which gives them a hook in instance creation process.
Those methods will be used when creating instances by the _Injector_ configured with the corresponding _Binder_.
A provider method is a special kind of binding ($key$) in which the return type of the method is the $key$.
The $target$ type is unknown at compile time (although it may be inferred by examining the return statements of the provide method).

.Binding
[def]
--
A _binding_ is a pair $bind(key, target)$.
It defines that for a dependency with a given key which usually is the expected type at the injection point.
An instance of type $target$ is injected.

A _binding_ is called _explicit_ if it is declared in the code, i.e. via `@Bind`
annotation or `@Provides` annotation).

A _binding_ is called _implicit_ if it is not declared.
An implicit binding can only be used if the $key$ is a class and derived from the type at the injection point, i.e. the type of the field or parameter to be injected.
In that case, the $target$ equals the $key$.

A provider method $M$ (in the binder) defines a binding

[math]
++++
bind(M.returnType, X)
++++

(in which $X$ is an existential type with $\exists X \subtype target.returnType$).

For simplification, we define:

[math]
++++
\beginalign
key*=
   \begin{cases}
     target.returnType,     &\textbf{if target is provider method} \\
     key,                   &\textbf{otherwise (key is a type reference)}
   \end{cases}
\endalign
++++

and

[math]
++++
\beginalign
target*=
   \begin{cases}
     X \subtype target.returnType,  &\textbf{if target is provider method} \\
     target,                        &\textbf{otherwise (target is a type reference)}
   \end{cases}
\endalign
++++

--

.Bindings
[req,id=IDE-140,version=1]
--
For a given binding $b=(key, target)$, the following constraints must hold: footnote:[Note that other frameworks may define other constraints, e.g., arbitrary keys.]

1.  $key$ must be either a class or an interface.
2.  $target$ must either be a class or a provider method.
3.  If $b$ is implicit, then $key$ must be a class.
If $key$ references a type $T$, then $target=T$ – even if $key$ is a use-site structural type.
4.  $key$ and $target*$ can be nominal, structural or field-structural types, either definition-site or use-site.
   The injector and binder needs to take the different structural reference into account at runtime!
5.  $target* \subtype key$ must hold
6.  If during injection phase no binding for a given key is found, an `DIUnsatisfiedBindingError` is thrown.

--

.Transitive Bindings
[req,id=IDE-141,version=1]
--
If an injector contains two given bindings $b_1=(key_1, target_1)$ and
$b_2=(key_2, key_1)$, an effective binding
$b=(key_2, target_1)$ is derived (replacing
$b_1$).

N4JS <<Acronyms,DI>> mechanisms don’t allow for injection of primitives or built-in types.
Only user-defined N4Types can be used. In cases where a user needs to inject a primitive or a built-in type, the developer must wrap it into its own
class footnote:[Cf. a blog post about micro types - http://www.markhneedham.com/blog/2009/03/10/oo-micro-types/, and tiny types - http://darrenhobbs.com/2007/04/11/tiny-types/ ].
This is to say that none of the following metatypes can be bound: primitive types, enumerations, functions, object types, union- or intersection types. It is possible to (implicitly) bind to built-in classes.

While direct binding overriding or rebinding is not allowed, _Injector_ can be configured in a way where one type can be separately bound to different types with implicit binding,
_explicit binding_ and in bindings of the child injectors.
_Binding precedence_ is a mechanism of _Injector_ selecting a binding use for a type.
It operates in the following order:

1.  Try to use explicit binding, if this is not available:
2.  Try to delegate to parent injectors (order of lookup is not guaranteed, first found is selected). If this is not available then:
3.  Try to use use implicit binding, which is simply to attempt to create the instance.

If no binding for a requested type is available an error will be thrown.

--

=== Injection Points

By _injection point_ we mean a place in the source code which, at runtime, will be expected to hold a reference to a particular type instance.

==== Field Injection

In its simplest form, this is a class field annotated with `@Inject` annotation.
At runtime, an instance of the containing class will be expected to hold reference to an instance of the field declared type.
Usually that case
is called __Field Injection__.

.Field Injection
[req,id=IDE-142,version=1]
--
The injector will inject the
following fields:

1.  All directly contained fields annotated with `@Inject`.
2.  All inherited fields annotated with `@Inject`.
3.  The injected fields will be created by the injector and their fields will be injected as well.
--

.Simple Field Injection
[example]
--
<<ex:field-injection>> demonstrates simple field injection using default bindings.
Note that all inherited fields (i.e. `A.xInA`) are injected and also fields in injected fields (i.e. `x.y`)

[[ex:field-injection]]
.Simple Field Injection
[source,n4js]
----
class X {
    @Inject y: Y;
}
class Y {}

class A {
    @Inject xInA: X;
}
class B extends A {
    @Inject xInB: X;
}

@GenerateInjector
export public class DIC {
    @Inject a: B;
}

var dic = N4Injector.of(DIC).create(DIC);
console.log(dic);              // --> DIC
console.log(dic.a);            // --> B
console.log(dic.a.xInA);       // --> X
console.log(dic.a.xInA.y);     // --> Y
console.log(dic.a.xInB);       // --> X
console.log(dic.a.xInB.y);     // --> Y
----

--

==== Constructor Injection


Parameters of the constructor can also be injected, in which case this is usually referred to as __Constructor Inejction__.
This is similar to _Method Injection_ and while constructor injection is supported in N4JS, method injection is not (see remarks below).

When a constructor is annotated with `@Inject` annotation, all user-defined, non-generic types given as the parameters will be injected into the instance’s constructor created by the dependency injection framework.
Currently, optional constructor parameters are always initialized and created by the framework, therefore, they are ensured to be available at the constructor invocation time.
Unlike optional parameters, variadic parameters cannot be injected into a type’s constructor.
In case of annotating a constructor with `@Inject` that has variadic parameters, a validation error will be reported.
When a class’s constructor is annotated with `@Inject` annotation, it is highly recommended to annotate all explicitly-defined constructors at the subclass level.
If this is not done, the injection chain can break and runtime errors might occur due to undefined constructor parameters.
In the case of a possible broken injection chain due to missing `@Inject` annotations for any subclasses, a validation warning will
be reported.

.Constructor Injection
[req,id=IDE-143,version=1]
--
If a class $C$ has a constructor marked as injection point, the
following applies:

1.  If $C$ is subclassed by $S$, and if $S$ has no explicit constructor, then $S$ inherits the constructor from $C$ and it will be an injection point handled by the injector during injection phase.

2.  If $S$ provides its own injector, $C.ctor$ is no longer recognized by the injector during the injection phase.
There will be a warning generated in $S.ctor$ to mark it as injection point as well in order to prevent inconsistent injection behavior.
Still, $C.ctor$ must be called in $S.ctor$ similarly to other overridden constructors.
--

==== Method Injection

Other kinds of injector points are method parameters where (usually) all method parameters are injected when the method is called.
In a way, constructor injection is a special case of the method itself.

////
%DI mechanisms can perform
%\begin{enumerate}
%   \item Constructor Injection - where dependencies are passed as parameters to a constructor
%   \item Method Injection - where dependencies are passed as parameters to a methods
%   \item Field Injection - where dependencies are assigned to object fields
%\end{enumerate}
%
%Due to object life cycle DI can perform 1) then 2) and 3). Constructor injection (if needed) is always performed before other forms of injection. Other two can be performed in any order. There is no guarantee weather 2) will be performed before 3) or vice versa, therefore user code should not assume specific order of those injections, including order of injection within given group.
%Additionally there should be no multiple injections for the same property of the object, as 2) and 3) will always overwrite 1), and they will overwrite each other.
////

===== Provider


_Provider_ is essentially a _factory_ for a given type.
By injecting an `N4Provider` into any injection point, one can acquire new instances of a given type provided by the injected provider.
The providers prove useful when one has to solve re-injection issues since the depended type can be wired and injected via the provider rather than the dependency itself and can therefore obtain
new instances from it if required.
Provider can be also used as a means of delaying the instantiation time of a given type.

`N4Provider` is a public generic built-in interface that is used to support the re-injection.
The generic type represents the dependent type that has to be obtained.
The `N4Provider` interface has one single public method: `public T get()` which should be invoked from the client code when a new instance of the dependent type is required.
Unlike any other unbound interfaces, the `N4Provider` can be injected without any explicit binding.

The following snippet demonstrates the usage of `N4Provider`:


[source,n4js]
----
class SomeService { }

@Singleton
class SomeSingletonService { }

class SomeClass {

    @Inject serviceProvider: N4Provider<SomeService>;
    @Inject singletonServiceProvider: N4Provider<SomeSingletonService>;

    void foo() {
        console.log(serviceProvider.get() ===
            serviceProvider.get()); //false

        console.log(singletonServiceProvider.get() ===
            singletonServiceProvider.get()); //true
    }

}
----

It is important to note that the `N4Provider` interface can be extended by any user-defined interfaces and/or can be implemented by any user-defined classes.
For those user-defined providers, consider all binding-related rules; the extended interface, for example, must be explicitly bound via a binder to be injected.
The binding can be omitted only for the built-in ``N4Provider``s.

=== N4JS DI Life Cycle and Scopes

<<Acronyms,DI>> Life Cycle defines when a new instance is created by the injector as its destruction is handled by JavaScript.
The creation depends on the scope of the type.
Aside from the scopes, note that it is also possible to implement custom scopes and life cycle management via `N4JSProvider` and `Binder@Provides` methods.

==== Injection Cylces


.Injection Cycle
[def]
--
We define an injection graph $G(V,E)$ as a directed graph as follows: $V$ (the vertices) is the set types of which instances are created during the injection phase and which use .
//TODO missing annotation
$E$ (the edges) is a set of directed and labeled edges $(v_1, v_2, label)$, where label indicates the injection point:

1.  $(T_o, T_f, "field")$, if $T_f$ is the actualy type of an an injected field of an instance of type $T_o$
2.  $(T_c, T_p, "ctor")$, if $T_p$ is the type of a parameter used in a constructor injection of type $T_c$

One cycle in this graph is an injection cycle.
--

When injecting instances into an object, cycles have to be detected and handled independently from the scope.
If this is not done, the following examples would result in an infinite loop causing the entire script to freeze until the engine reports an error:

[cols=".>4a,^3a",grid=rows,frame=none]
|===
|
[source,n4js]
----
class A { @Inject b: B; }
class B { @Inject a: A; }
----
|
[[fig-field-cycle]]
.Field Cycle
image::{find}fig/injectionGraph_cycleField.svg[scaledwidth="40%",align="center"]

|
[source,n4js]
----
class C { @Inject constructor(d: D) {} }
class D { @Inject c: C; }
----

|
[[fig-ctor-field]]
.Ctor Field Cycle
image::{find}fig/injectionGraph_cycleCtorField.svg[scaledwidth="40%",align="center"]

|
[source,n4js]
----
class E { @Inject constructor(f: F) {} }
class F { @Inject constructor(e: E) {} }
----

|
[[fig-ctor-cycle]]
.Ctor Cycle
image::{find}fig/injectionGraph_cycleCtor.svg[scaledwidth="40%",align="center"]

|===
The injector needs to detect these cycles and resolve them.

.Resolution of Injection Cycles
[req,id=IDE-144,version=1]
--
A cycle $c \subset G$, with $G$ being an injection graph, is resolved as follows:

1.  If $c$ contains no edge with $label="ctor"$, the cycle is resolved using the algorithm described below.
2.  If $c$ contains at least one edge with $label="ctor"$, a runtime exception is thrown.

--

Cycles stemming from field injection are resolved by halting the creation of new instances of types which have been already created by a containing instance.
The previously-created instance is then reused.
This makes injecting the instance of a (transitive) container less complicated and without the need to pass the container instance down the entire chain.
The following pseudo code describes the algorithm to create new instances which are injected into a newly created object:


[source,n4js]
----
function injectDependencies(object) {
    doInjectionWithCylceAwareness(object, {(typeof object -> object)})
}

function doInjectionWithCylceAwareness(object, createdInstancesPerType) {
    forall v $\in$ injectedVars of object {
        var type = retrieveBoundType(v)
        var instance = createdInstancesPerType.get(type)
        if (not exists instance) {
            instance = createInstance(type, createdInstancesPerType)
            doInjectionWithCylceAwareness(instance,
                createdInstancesPerType $\cap$ {(type->instance)})
        }
        v.value = instance;
    }
}
----

The actual instance is created in line 10 via `createInstance`.
This function then takes scopes into account.
The `createdInstancesPerType` map is passed to that function in order to enable cycle detection for constructor injection.
The following scopes are supported by the N4JS DI, other scopes, cf. https://jersey.java.net/documentation/latest/ioc.html[Jersey custom scopes] and https://github.com/google/guice/wiki/CustomScopes[Guice custom scopes], may be added in the future.

This algorithm is not working for constructor injection because it is possible to already access all fields of the arguments passed to the constructor.
In the algorithm, however, the instances may not be completely initialized.

// \Rightarrowdo{add static validations for detecting injection cycles at runtime}

//\Rightarrowdo{add warning even if resolvable cycles are detected, use new scope "@PerInjectionSingleton" for A to ensure that per injection call A behaves like a singleton (what the algorithm implicitly does).



==== Default Scope


The default scope always creates a new instance.

==== Singleton Scope


The singleton scope (per injector) creates one instance (of the type with `@Singleton` scope) per injector, which is then shared between clients.

The injector will preserve a single instance of the type of `S` and will provide it to all injection points where type of `S` is used.
Assuming nested injectors without any declared binding where the second parameter is `S`, the same preserved singleton instance will be available for all nested injectors at all injection points as well.

The singleton preservation behavior changes when explicit bindings are declared for type `S` on the nested injector level.
Let's assume that the type `S` exists and the type is annotated with `@Singleton`.
Furthermore, there is a declared binding where the binding's second argument is `S`.
In that case, unlike in other dependency injection frameworks, nested injectors may preserve a singleton for itself and all descendant injectors with `@Bind` annotation.
In this case, the preserved singleton at the child injector level will be a different instance than the one at the parent injectors.

The tables below depict the expected runtime behavior of singletons used at different injector levels.
Assume the following are injectors: `C`, `D`, `E`, `F` and `G`. Injector `C` is the top most injector and its nesting injector `D`, hence injector `C` is the parent of the injector `D`.
Injector `D` is nesting `E` and so on.
The most nested injector is `G`. Let's assume `J` is an interface, class `U` implements interface `J` and class `V` extends class `U`.
Finally assume both `U` and `V` are annotated with `@Singleton` at definition-site.

<<tab:diNoBindings>> depicts the singleton preservation for nested injectors without any bindings.
All injectors use the same instance from a type.
Type `J` is not available at all since it is not bound to any concrete implementation:

[[tab:diNoBindings]]
.DI No Bindings
[cols="^2h,^,^,^,^,^"]
|===
|Binding | | | | |
|Injector nesting ($>$) |C |D |E |F |G

|J |$NaN$ |$NaN$ |$NaN$
|$NaN$ |$NaN$

|U |$U_0$ |$U_0$ |$U_0$
|$U_0$ |$U_0$

|V |$V_0$ |$V_0$ |$V_0$
|$V_0$ |$V_0$
|===

<<tab:diTransitiveBindings>> is configured by explicit bindings. At the root injector level, type `J` is bound to type `U`.
Since the second argument of the binding is declared as a singleton at the definition-site,
this explicit binding implicitly ensures that the injector and all of its descendants preserve a singleton of the bound type `U`.
At injector level `C`, `D` and `E`, the same instance is used for type `J` which is type `U` at runtime.
At injector level `E` there is an additional binding from type `U` to type `V` that overrules the binding declared at the root injector level.
With this binding, each places where `J` is declared, type `U` is used at runtime.

Furthermore, since `V` is declared as a singleton, both injector `F` and `G` are using a shared singleton instance of type `V`.
Finally, for type `V`, injector `C`, `D` and `E` should use a separate instance of `V` other than injector level `F` and `G` because `V` is preserved at injector level `F` with the `U` $\rightarrow$ `V` binding.

.DI Transitive Bindings
[[tab:diTransitiveBindings]]
[cols="^2h,^,^,^,^,^"]
|===
|Binding |J -> U | | |U -> V |

|Injector nesting (>) |C |D |E |F |G

|J |$U_0$ |$U_0$ |$U_0$
|$V_0$ |$V_0$

|U |$U_0$ |$U_0$ |$U_0$
|$V_0$ |$V_0$

|V |$V_1$ |$V_1$ |$V_1$
|$V_0$ |$V_0$
|===

<<tab:diReBinding>> depicts the singleton behaviour but unlike the above
table, the bindings are declared for the interface `J`.

[[tab:diReBinding]]
.DI Re - Binding
[cols="^2h,^,^,^,^,^"]
|===
|Binding |J -> U | | |J -> V |

|Injector nesting ($>$) |C |D |E |F |G

|J |$U_0$ |$U_0$ |$U_0$
|$V_0$ |$V_0$

|U |$U_0$ |$U_0$ |$U_0$
|$U_0$ |$U_0$

|V |$V_1$ |$V_1$ |$V_1$
|$V_0$ |$V_0$
|===

<<tab:diChildBinding>> describes the singleton behavior when both bindings are configured at child injector levels but not the root injector level.

[[tab:diChildBinding]]
.DI Child Binding
[cols="^2h,^,^,^,^,^"]
|===
|Binding | |U $\rightarrow$ V | |J $\rightarrow$ U |

|Injector nesting ($>$) |C |D |E |F |G

|J |$NaN$ |$NaN$ |$NaN$
|$U_0$ |$U_0$

|U |$U_1$ |$V_0$ |$V_0$
|$U_0$ |$U_0$

|V |$V_1$ |$V_0$ |$V_0$
|$V_0$ |$V_0$
|===

==== Per Injection Chain Singleton

The per injection chain singleton is ’between’ the default and singleton scope.
It can be used in order to explicitly describe the situation which happens when a simple cycle is resolved automatically.
It has more effects that lead to a more deterministic behavior.

Assume a provider declared as

[source,n4js]
----
var pb: Provider<B>;
----

to be available:

[source,n4js]
----
@PerInjectionSingleton
class A {  }

class B { @Inject a: A; @Inject a1: A;}

b1=pb.get();
b2=pb.get();
b1.a != b2.a
b1.a == b1.a1
b2.a == b2.a1
----

[source,n4js]
----
@Singleton
class A {  }

class B { @Inject a: A; @Inject a1: A;}

b1=pb.get();
b2=pb.get();
b1.a == b2.a
b1.a == b1.a1
b2.a == b2.a1
----

[source,n4js]
----
// no annotation
class A {  }

class B { @Inject a A; @Inject a1: A;}

b1=pb.get();
b2=pb.get();
b1.a != b2.a
b1.a != b1.a1
b2.a != b2.a1
----

=== Validation of callsites targeting N4Injector methods


Terminology for this section:

* a value is *injectable* if it
** either conforms to a user-defined class or interface (a non-parameterized one, that is),
** or conforms to Provider-of-T where T is injectable itself.
* a classifier declaring injected members is said to *require injection*

To better understand the validations in effect for callsites targeting

[source,n4js]
----
N4Injector.of(ctorOfDIC: constructor{N4Object}, parentDIC: N4Injector?, ...providedBinders: N4Object)
----

we can recap that at runtime:

* The first argument denotes a DIC constructor.
* The second (optional) argument is an injector.
* Lastly, the purpose of `providedBinders` is as follows:
** The DIC above is marked with one or more `@UseBinder`.
** Some of those binders may require injection.
** Some of those binders may have constructor(s) taking parameters.
** The set of binders described above should match the providedBinders.

Validations in effect for `pass:[N4Injector.create(type{T} ctor)]` callsites:

* `type{T}` should be injectable (in particular, it may be an `N4Provider`).

=== N4JS DI Annotations

Following annotations describe API used to configure N4JSDI.

==== N4JS DI @GenerateInjector

[cols="a,a,a",frame=none,grid=none]
|===
| name::
  @GenerateInjector
| targets::
  N4Class
| retention policy::
  RUNTIME
| transitive::
  NO
|repeatable::
  NO
| arguments::
  NO
|===

`@GenerateInjector` marks a given class as DIComponent of the graph.
The generated injector will be responsible for creating an instance of that class and all of its dependencies.

==== N4JS DI @WithParentInjector

[cols="a,a,a",frame=none,grid=none]
|===
| name::
    @WithParentInjector
| targets::
    N4Class
| retention policy::
    RUNTIME
| transitive::
    NO
| repeatable::
   NO
| arguments::
    TypeRef
| arguments are optional::
    NO
|===

`@WithParentInjector` marks given _injector_ as depended on other __injector__.
The depended _injector_ may use provided _injector_ to create instances of objects required in its object graph.

Additional _WithParentInjector_ constraints:


.DI WithParentInjector
[req,id=IDE-145,version=1]
--
1.  Allowed only on `N4ClassDeclarations` annotated with `@GenerateInjector`.
2.  Its parameter can only be `N4ClassDeclarations` annotated with .
--

==== N4JS DI @UseBinder


[cols="a,a,a",frame=none,grid=none]
|===
| name::
  @UseBinder
| targets::
  N4Class
| retention policy::
  RUNTIME
| transitive::
  NO
| arguments::
  TypeRef
| arguments are optional::
  NO
|===

`@UseBinder` describes _Binder_ to be used (configure) target __Injector__.


.DI UseInjector
[req,id=IDE-146,version=1]
--
1.  Allowed only on `N4ClassDeclarations` annotated with `@GenerateInjector`.
2.  Its parameter can only be `N4ClassDeclarations` annotated with `@Binder`.
--

==== N4JS DI @Binder

[cols="a,a,a",frame=none,grid=none]
|===
| name::
  @Binder
| targets::
  N4Class
| retention policy::
  RUNTIME
| transitive::
  NO
|repeatable::
  NO
| arguments::
  NONE
|===

`@Binder` defines a list of bind configurations.
That can be either `@Bind` annotations on `@Binder` itself or its factory methods annotated with `@Provides`.


.DI binder
[req,id=IDE-147,version=1]
--
1.  Target `N4ClassDeclaration` must not be __abstract__.
2.  Target `N4ClassDeclaration`  must not be annotated with `@GenerateInjector`.
3.  Target class cannot have __injection points__.
--

==== N4JS DI @Bind

[cols="a,a,a",frame=none,grid=none]
|===
| name::
  @Bind
| targets::
  N4ClassDeclaration
| retention policy::
  RUNTIME
| transitive::
  NO
| arguments::
  TypeRef key, TypeRef target
| arguments are optional::
  NO
|===

Defines _binding_ between type and subtype that will be used by injector when configured with target <<_n4js-di-binder>>.
See also <<_validation-of-callsites-targeting-n4injector-methods>> for description of injectable types.


.DI Bind
[req,id=IDE-148,version=1]
--
1.  Allowed only on `N4ClassDeclarations` that are annotated with `@Binder`(<<N4JS DI @Binder>>).
2.  Parameters are instances of one of the values described in <<_validation-of-callsites-targeting-n4injector-methods>>.
3.  The second parameter must be a subtype of the first one.
--

==== N4JS DI @Provides

[cols="a,a,a",frame=none,grid=none]
|===
| name::
  @Provides
| targets::
  N4MethodDeclaration
| retention policy::
  RUNTIME
| transitive::
  NO
|repeatable::
  NO
| arguments::
  NONE
| arguments are optional::
  NO
|===

`@Provides` marks _factory method_ to be used as part <<AC,DI>>.
This is treated as _explicit binding_ between declared return type and actual return type.
This method is expected to be part of the `@Binder`.
Can be used to implement custom scopes.


.DI Provides
[req,id=IDE-149,version=1]
--

1.  Allowed only on `N4MethodDeclarations` that are part of a classifier annotated with `@Binder`.
2.  Annotated method declared type returns instance of one of the types described in _injectable values_  <<_validation-of-callsites-targeting-n4injector-methods>>.
--

==== N4JS DI @Inject

[cols="a,a,a",frame=none,grid=none]
|===
| name::
  @Inject
| targets::
  N4Field, N4Method, constructor
| retention policy::
  RUNTIME
| transitive::
  NO
| repeatable::
  NO
| arguments::
  NO
|===

`@Inject` defines the injection point into which an instance object will be injected.
The specific instance depends on the injector configuration (bindings) used.
Class fields, methods and constructors can be annotated. See <<_injection-points>> for more information.


.DI Inject
[req,id=IDE-150,version=1]
--
1.  Injection point bindings need to be resolvable.
2.  Binding for given type must not be duplicated.
3.  Annotated types must be instances of one of the types described in <<_validation-of-callsites-targeting-n4injector-methods>>.
--

==== N4JS DI @Singleton


[cols="a,a,a",frame=none,grid=none]
|===
| name::
  @Singleton
| targets::
  N4Class
| retention policy::
  RUNTIME
| transitive::
  NO
| repeatable::
  NO
| arguments::
  NO
|===

In the case of annotating a class `S` with `@Singleton` on the definition-site, the singleton scope will be used as described in <<Singleton Scope>>.

[.language-n4js]
== Test Support

N4JS provides some annotations for testing. Most of these annotations are similar to annotations found in JUnit 4.
For details see our Mangelhaft test framework (stdlib specification) and the N4JS-IDE specification.

In order to enable tests for private methods, test projects may define which project they are testing.

.Test API methods and types
[req,id=IDE-151,version=1]
--

In some cases, types or methods are only provided for testing purposes.
In order to improve usability, e.g. content assist, these types and methods can be annotated with `@TestAPI`.
There are no constraints defined for that annotation at the moment.
--


[.language-n4js]
== Polyfill Definitions


In plain JavaScript, so called _polyfill_ (or sometimes called __shim__) libraries are provided in order to modify existing classes which are only prototypes in plain JavaScript.
In N4JS, this can be defined for declarations via the annotation `@Polyfill` or `@StaticPolyfill`.
One of these annotations can be added to class declarations which do not look that much different from normal classes.
In the case of polyfill classes, the extended class is modified (or filled) instead of being subclassed.

We distinguish two flavours of polyfill classes: runtime and static.

* Runtime polyfilling covers type enrichment for runtime libraries.
For type modifications the annotation `@Polyfill` is used.
* Static polyfilling covers code modifications for adapting generated code.
The annotation `@StaticPolyfill` denotes a polyfill in ordinary code, which usually provides executable implementations.

.Polyfill Class
[def]
--
A _polyfill class_ (or simply __polyfill__) is
a class modifying an existing one. The polyfill is not a new class (or type) on its own.
Instead, new members defined in the polyfill are added to the modified class and existing members can be modified similarly to overriding.
We call the modified class the _filled_ class and the modification __filling__.

We add a new pseudo property $polyfill$ to classes in order to distinguish between normal (sub-) classes and polyfill classes.
--

.Polyfill Class
[req,id=IDE-152,version=1]
--
For a polyfill class $P$ annotated with `@Polyfill` or  `@StaticPolyfill`, that is $P.polyfill=\TRUE$, all the following constraints must hold:

.  $P$ must extend a class $F$, $F$ is called the filled class:
+
[math]
++++
P.super = F
++++
. $P$’s name equals the name of the filled class and is contained in a module with same qualified name (specifier or global): +
+
[math]
++++
\beginalign
\spc P.name = F.name \\
    \spc \land P.containedModule.global=F.containedModule.global \\
    \spc \land (P.containedModule.global \\
        \spc \hspace{3em} \lor P.containedModule.specifier=F.containedModule.specifier) \\
\endalign
++++
. Both the polyfill and filled class must be top-level declarations (i.e., no class expression): +
+
[math]
++++
P.topLevel = \TRUE \land F.topLevel = \TRUE
++++
. $P$ must not implement any interfaces:
+
[math]
++++
P.implementedInterfaces=\emptyset
++++
. $P$ must have the same access modifier (access, abstract, final) as the filled class: +
+
[math]
++++
\beginalign
P.accessModifier=F.accessModifier \\
P.abstract = F.abstract \\
P.final = F.final
\endalign
++++
.  If $P$ declares a constructor, it must be override compatible with the constructor of the filled class:
+
[math]
++++
\exists P.ownedCtor: P.ownedCtor \subtype F.ctor
++++
. $P$ must define the same type variables as the filled class $F$ and the arguments must be in the same order as the parameters (with no further modifications):
+
[math]
++++
\beginalign
 \forall i, 0 \leq i<|P.typePars|:\\
   \hspace{3em} P.typePars_i=F.typePars_i \\
   \hspace{3em} \land P.typePars_i.name=P.super.typeArgs_i.name \\
\endalign
++++
. All constraints related to member redefinition (cf. <<_redefinition-of-members>>) have to hold.
In the case of polyfills, this is true for constructors (cf. <<Req-IDE-72>>) and private members.
--

=== Runtime Polyfill Definitions

(Runtime) Libraries often do not provide completely new types but modify existing types.
The ECMA-402 Internationalization Standard cite:[ECMA12a], for example, changes methods of the built-in class `Date` to be timezone aware.
Other scenarios include new functionality provided by browsers which are not part of an official standard yet.
Even ECMAScript 6 cite:[ECMA15a] extends the predecessor cite:[ECMA11a]  in terms of new methods (or new method parameters) added to existing types (it also adds completely new classes and features, of course).

Runtime polyfills are only applicable to runtime libraries or environments and thus are limited to n4jsd files.

.Runtime Polyfill Class
[req,id=IDE-153,version=1]
--
For a runtime-polyfill class $P$ annotated with `@Polyfill`, that is $P.staticpolyfill=\FALSE$, all the following constraints must hold in addition to <<Req-IDE-152>>:

1.  Both the polyfill and filled class are provided by the runtime
(annotated with `@ProvidedByRuntime`): footnote:[This restriction has two reasons: Firstly, user-defined types with implementations would require to ’bootstrap’ the polyfill, which is impossible to do automatically without serious constraints on bootstrap code in general. Secondly, instead of filling user-defined types, they can be subclasses. Mechanisms such as dependency injection could then solve almost all remaining problems.]

[math]
++++
 P.providedByRuntime = \TRUE \land F.providedByRuntime = \TRUE
++++
--

.Applying Polyfills
[req,id=IDE-154,version=1]
--

A polyfill is automatically applied if a runtime library or environment required by the current project provides it. In this case, the following constraints must hold:

1.  No member must be filled by more than one polyfill.
--

=== Static Polyfill Definitions


Static polyfilling is a compile time feature to enrich the definition and usually also the implementation of generated code in N4JS. It is related to runtime polyfilling described in <<_runtime-polyfill-definitions>> in a sense that both fillings enrich the types they address. Despite this, static polyfilling and runtime polyfilling differ in the way they are handled.

Static polyfills usually provide executable implementations and are thus usually found in n4js files. However, they are allowed in n4jsd files, as well, for example to enrich generated code in an API project.

The motivation for static polyfills is to support automatic code generation.
In many cases, automatically generated code is missing some information to make it sufficiently usable in the desired environment.
Manual enhancements usually need to be applied.
If we think of a toolchain, the question may arise how to preserve the manual work when a
regeneration is triggered. Static polyfilling allows the separation of generated code and manual adjustments in separate files.
The transpiler merges the two files into a single transpiled file.
To enable this behaviour, the statically fillable types must be contained in a module annotated with `@StaticPolyfillAware`.
The filling types must also be annotated with `@StaticPolyfill` and be contained in a different module with same specifier but annotated with `@StaticPolyfillModule`.
Static polyfilling is restricted to a project, thus the module to be filled as well as the filling module must be contained in the same project.

We add a new pseudo property $staticPolyfill$ to classes in order to distinguish between normal (sub-) classes and static polyfill classes.
We add two new pseudo properties to modules in order to modify the transpilation process.
The mutually-exclusive properties $staticPolyfillAware$ and $staticPolyfill$ signal the way these files are processed.

// TODO missing notation below
In order to support efficient transpilation, the following constraint must hold in addition to constraints:


.Static Polyfill Layout
[req,id=IDE-155,version=1]
--
For a static polyfill class $P$ annotated with `@StaticPolyfill`, that is $P.staticpolyfill=\TRUE$, all the following constraints must hold in addition to <<Req-IDE-152>>:

1.  $P$’s name equals the name of the filled class and is contained in a module with the same qualified name:
+
[math]
++++
\beginalign
P.name = F.name \\
    \land P.containedModule.specifier=F.containedModule.specifier \\
\endalign
++++
2.  Both the static polyfill and the filled class are part of the same project:
+
[math]
++++
P.project = F.project
++++
3.  The filled class must be contained in a module annotated with `@StaticPolyfillAware`:
+
[math]
++++
F.containedModule.staticPolyfillAware = \TRUE
++++
4.  The static polyfill and the filled type must both be declared in an n4js file or both in an n4jsd file.
5.  The filling class must be contained in a module annotated with `@StaticPolyfillModule`:
+
[math]
++++
P.containedModule.staticPolyfillModule = \TRUE
++++
6. For a statically-filled class $F$ there is at most one static polyfill:
+
[math]
++++
(P_1 \texttt{ is static polyfill of } F \land P_2 \texttt{ is static polyfill of } F) \rightarrow P_1=P_2
++++
--



.Restrictions on static polyfilling
[req,id=IDE-156,version=1]
--
For a static polyfilling module $M_P$ the following must hold:

1.  All top-level elements are static polyfills:
+
[math]
++++
\infer{T.staticPolyfill = \TRUE}{\forall T \in M_P \land T.topLevel = \TRUE}
++++
2.  It exists exactly one filled module $M_F$ annotated with $staticPolyfillAware$ in the same project.
3.  It is an error if two static polyfill modules for the same filled module exist in the same project:
+
[math]
++++
\infer
{M_1 = M_2}{
M_1.specifier = M_2.specifier
\land M_1.project = M_2.project \\
\land M_1.staticPolyfillModul = M_2.staticPolyfillModul = \TRUE }
++++

--


.Static polyfill
[example]
====

<<ex:staticpolyfill-genmod>> shows an example of generated code.
<<ex:staticpolyfill-polyfillmod>> demonstrates the static polyfill.

Note that the containing project has two source folders configured: +
`Project/src/n4js` and `Project/src/n4jsgen`.

[[ex:staticpolyfill-polyfillmod]]
.Static Polyfill, Polyfillmod
[source,n4js]
----
@@StaticPolyfillAware
export public class A {
    constructor() {...}
    m1(): void{...}
}
export public class B {
    constructor() {...}
    m2(): void{...}
}
----


[[ex:staticpolyfill-genmod]]
.Static Polyfill, Genmod
[source,n4js]
----
@@StaticPolyfillModule
@StaticPolyfill
export public class B extends B {
    @Override
    constructor(){ ... } // replaces generated ctor of B
    @Override
    m1(): void {...} // adds overridden method m1 to B
    @Override
    m2(): void {...} // replaces method m2 in B
    m3(): void {...} // adds new method m3 to B
}
----

====

=== Transpiling static polyfilled classes

Transpiling static polyfilled classes encounters the special case that two different `n4js` source files with the same qualified name are part of the project.
Since the current transpiler is file-based, both files would be transpiled to the same output destination and would therefore overwrite each other.
The following pre-transpilation steps handle this situation:

* Current file to transpile is $M$
* If $M.staticPolyfillAware = \TRUE $, then
** search for a second file $G$ with same qualified name: +
$G.specifier = M.specifier \land G.project = M.project$
** If $ \exists G$, then
*** merge $G$ into current file $M \rightarrow M'$
*** conventionally transpile $M'$
** else conventionally transpile $M$
* else, if $M.staticPolyfillModule = \TRUE $,
** then __do nothing__. (Transpilation will be triggered for filled type separately.)
* else, conventionally transpile $M$
