////
Copyright (c) 2017 NumberFour AG.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
  NumberFour AG - Initial API and implementation
////

= Functions

Functions, be they function declarations, expressions or even methods, are internally modeled by means of a function type.
In this chapter, the general function type is described along with its semantics and type constraints.
Function definitions and expressions are then introduced in terms of statements and expressions.
Method definitions and special usages are described in <<Methods>>.

[.language-n4js]
== Function Type


A function type is modeled as `Object` (see cite:[ECMA11a(S13,p.98)] in ECMAScript.

Function types can be defined by means of;

* A function object (<<_function-object-type>>).
* A function type expression (<<_type-expressions>>).
* A function declaration (<<_function-declaration>>).
* A method declaration (<<Methods>>).

=== Properties

In any case, a function type declares the signature of a function and allows validation of calls to that function.
A function type has the following properties:


`typePars`  ::
(0-indexed) list of type parameters (i.e. type variables) for generic functions.

`fpars`  ::
(0-indexed) list of formal parameters.

`returnType` ::
(possibly inferred) return type (expression) of the function or method.

`name` ::
Name of function or method, may be empty or automatically generated (for messages).

`body` ::
The body of the function, it contains statements $stmts$.
The body is null if a function type is defined in a type expression, and it is the last argument in case of a function object constructor, or the content of the function definition body.

Additionally, the following pseudo properties for functions are defined:


`thisTypeRef` ::
The this type ref is the type to which the `this`-keyword would be evaluated
if used inside the function or member. The inference rules are described
in <<_this-keyword>>.

`fpars` ::
List of formal parameters and the this type ref.
This is only used for sub typing rules.
If `this` is not used inside the function, then `any` is set instead of the inferred thisTypeRef to allow for more usages.
The property is computed as follows:
+
[math]
++++
tfpars = \lif \spc  \textbf{this is used or explicitly declared}
\spc \lthen thisTypeRef + fpars
\spc \lelse any + fpars
++++

Parameters (in $pars$) have the following properties:

`name` ::
Name of the parameter.

`type` ::
Type (expression) of the parameter. Note that only parameter types can
be variadic or optional.

The function definition can be annotated similar to <<Methods>> except that the `final` and `abstract` modifiers aren’t supported for function declarations.
A function declaration is always final and never abstract.
Also, a function has no property advice set.

[discrete]
=== Semantics

//\todo{FunctionRestParameter : ”...” -- semantic (ECMAScript 6)}

.Function Type
[req,id=IDE-79,version=1]
--
Type Given a function type $F$, the following constraints must be true:


// TODO check math expression "\nexists k>i:" below

1.  Optional parameters must be defined at the end of the (formal) parameter list.
In particular, an optional parameter must not be followed by a non-optional parameter:
+
[math]
++++
F.fpars_i.optional \rightarrow \nexists k>i: \lnot F.fpars_k.optvar
++++
2.  Only the last parameter of a method may be defined as variadic parameter:
+
[math]
++++
F.fpars_i.variadic \rightarrow i = |F.fpars|-1
++++
3.  If a function explicitly defines a return type, the last statement of the transitive closure of statements of the body must be a return statement:
+
[%hardbreaks]
$F.typeRef \neq Undefined \rightarrow $
$|f.body.stmts|>0 $
$\land f.body.stmts^*_{|f.body.stmts^*|-1} isa\ \lstnfbnf{ReturnStatement}$
4. If a function explicitly defines a return type, all return
statements must return a type conform to that type:
+
[%hardbreaks]
$\spc F.typeRef \neq Undefined $
$\spc \iff $
$\spc \forall r \in F.body.stmts, r\ isa\ \lstnfbnf{ReturnStatement}: $
$\spc r.expr\neq null \land \infType{r.expr.typeRef} <: \infType{F.typeRef}$

--

=== Type Inference [[function-type-inference]]

// TODO - definition title needs comma like so: ".Function Type Conformance, Non-Parameterized"
// comma currently breaks FOP PDF build, see https://github.com/NumberFour/asciispec/issues/9

[[function_type_conformance_non_parameterized]]
.Function Type Conformance Non-Parameterized
[def]
--
_For the given non-parameterized function types_
$F_{left}$ with
$F_{left}.tfpars=L_0, L_1, \dots L_k$ and
$|F_{left}.typesPars|=0$ +
$F_{right}$ with
$F_{right}.tfpars=R_0, R_1, \dots R_n$ and
$|F_{right}.typesPars|=0$, +
we say $F_{left}$ conforms to $F_{right}$,
written as $F_{left} <: F_{right}$, if and only if:

* $F_{right}.returnType = \type{void}$ +
$\lor (F_{left}.returnType = \type{void} \land F_{right}.opt)$ +
$\lor (F_{left}.returnType <: F_{right}.returnType \land \neg (F_{left}.opt \land \neg F_{right}.opt))$
* if $k\leq n$:
** $\forall\ i, 1\leq i\leq k: (R_i.opt \rightarrow (L_i.opt \lor L_i.var)) \land (R_i.var \rightarrow L_i.var)$
** $\forall\ i, 1\leq i\leq k: L_i :> R_i$
** $L_k.var=true \rightarrow \forall\ i, k<i\leq n: L_K :> R_i$
+
else ($k>n$):
** $\forall\ i, 1\leq i\leq n: (R_i.opt \rightarrow (L_i.opt \lor L_i.var)) \land (R_i.var \rightarrow L_i.var)$
** $\forall\ i, 1\leq i\leq n: L_i :> R_i$
** $\forall\ n<i\leq k: L_i.opt \lor L_i.var$
** $R_n.var=true \rightarrow \forall\ i, n<i\leq k: L_i :> R_n$

<<cdVarianceFunctionChart>> shows a simple example with the function type conformance relations.

[[cdVarianceFunctionChart]]
.Function Variance Chart
image::{find}fig/cdVarianceFunctionChart.svg[scaledwidth="60%"]

`{function()}` $<:$ `{function(A)}` $<:$ `{function(A, A)}` might be surprising for Java programmers. However, in JavaScript it is
possible to call a function with any number of arguments independently
from how many formal parameters the function defines.

If a function does not define a return type, `any` is assumed if at least one
of the (indirectly) contained return statements contains an expression.
Otherwise `void` is assumed. This is also true if there is an error due to
other constraint violations.

[math]
++++
\beginalign
\spc \infer{\tee f \lstnfbnf{'('} arglist\ \lstnfbnf{')'}: \type{any}}
        {binds(f,F) \spc F.returnType=\NULL \spc \exists r \in returns(F): r.expression \neq \NULL} \\
\spc \infer{\tee f \lstnfbnf{'('} arglist\ \lstnfbnf{')'}: \type{void}}
        {binds(f,F) \spc F.returnType=\NULL \spc \forall r \in returns(F): r.expression \neq \NULL}
\endalign
++++

with

[math]
++++
\beginalign
\spc \infer{returns(F): RETS}
        {\{r \in F.body.statements | \mu(r)=\type{ReturnStatement}\} \cup \bigcup_{s\in F.body.statements} returns(s)} \\
\spc \infer{returns(s): RETS}
        {\{sub \in s.statements | \mu(sub)=\type{ReturnStatement}\} \cup \bigcup_{sub\in s.statements} returns(sub)}
\endalign
++++

--

.Function type conformance
[example]
--

The following incomplete snippet demonstrates the usage of two function variables $f1$ and $f2$, in which $\infType{f2} <: \infType{f1}$ must hold true according to the aforementioned constraints.
A function `bar` declares a parameter $f1$, which is actually a function itself.
$f2$ is a variable, to which a function expression is a assigned.
Function `bar` is then called with $f2$ as an argument.
Thus, the type of $f2$ must be a subtype of the $f1$’s type.

[source,n4js]
----
function bar(f1: {function(A,B):C}) { ... }

var f2: {function(A,B):C} = function(p1,p2){...};
bar(f1);
----
--

The type of `this` can be explicitly set via the `@This` annotation.

.Function Subtyping
[example]
--

[source,n4js]
----
function f(): A {..}
function p(): void {..}

fAny(log: {function():any}) {...}
fVoid(f: {function():void}) {..}
fA(g: {function():A}) {...}

fAny(f);    // --> ok       A <: any
fVoid(f);   // -->error     A !<: void
fA(f);      // --> ok (easy)    A <: A

fAny(p);    // --> ok       void <: any
fVoid(p);   // --> ok       void <: void
fA(p);      // --> error    void !<: A
----
--

.Subtyping with function types
[example]
--
If classes A, B, and C are defined as previously mentioned, i.e. $C <: B <: A$, then
the following subtyping relations with function types are to be evaluated as follows:

[source,n4js]
----
       {function(B):B} <: {function(B):B}           -> true
        {function():A} <: {function():B}            -> false
        {function():C} <: {function():B}            -> true
         {function(A)} <: {function(B)}             -> true
         {function(C)} <: {function(B)}             -> false

     {function():void} <: {function():void}         -> true
{function():undefined} <: {function():void}         -> true
     {function():void} <: {function():undefined}    -> true (!)

        {function():B} <: {function():void}         -> true (!)
        {function():B} <: {function():undefined}    -> false (!)
     {function():void} <: {function():B}            -> false
{function():undefined} <: {function():B}            -> true
----



The following examples demonstrate the effect of optional and variadic parameters:

[source,n4js]
----
{function(A)} <: {function(B)}                      -> true
{function(A...)} <: {function(A)}                   -> true
{function(A, A)} <: {function(A)}                   -> false
{function(A)} <: {function(A,A)}                    -> true (!)
{function(A, A...)} <: {function(A)}                -> true
{function(A)} <: {function(A,A...)}                 -> true (!)
{function(A, A...)} <: {function(B)}                -> true
{function(A?)} <: {function(A?)}                    -> true
{function(A...)} <: {function(A...)}                -> true
{function(A?)} <: {function(A)}                     -> true
{function(A)} <: {function(A?)}                     -> false
{function(A...)} <: {function(A?)}                  -> true
{function(A?)} <: {function(A...)}                  -> true (!)
{function(A,A...)} <: {function(A...)}              -> false
{function(A,A?)} <: {function(A...)}                -> false
{function(A?,A...)} <: {function(A...)}             -> true
{function(A...)} <: {function(A?,A...)}             -> true
{function(A...)} <: {function(A?)}                  -> true
{function(A?,A?)} <: {function(A...)}               -> true (!)
{function(A?,A?,A?)} <: {function(A...)}            -> true (!)
{function(A?)} <: {function()}                      -> true (!)
{function(A...)} <: {function()}                    -> true (!)
----

The following examples demonstrate the effect of optional return types:

[source,n4js]
----
{function():void} <: {function():void}              -> true
{function():X}    <: {function():void}              -> true
{function():X?}   <: {function():void}              -> true
{function():void} <: {function():Y}                 -> false
{function():X}    <: {function():Y}                 -> X <: Y
{function():X?}   <: {function():Y}                 -> false (!)
{function():void} <: {function():Y?}                -> true (!)
{function():X}    <: {function():Y?}                -> X <: Y
{function():X?}   <: {function():Y?}                -> X <: Y
       {function():B?} <: {function():undefined}    -> false (!)
{function():undefined} <: {function():B?}           -> true
----

The following examples show the effect of the `@This` annotation:

[source,n4js]
----
{@This(A) function():void} <: {@This(X) function():void}    -> false
{@This(B) function():void} <: {@This(A) function():void}    -> false
{@This(A) function():void} <: {@This(B) function():void}    -> true
{@This(any) function():void} <: {@This(X) function():void}  -> true
{function():void} <: {@This(X) function():void}             -> true
{@This(A) function():void} <: {@This(any) function():void}  -> false
{@This(A) function():void} <: {function():void}             -> false
----
--



.Function Type Conformance
[def]
--
For the given function types +
$F_{left}$ with
$F_{left}.tfpars=L_0, L_1, \dots L_k$ +
$F_{right}$ with
$F_{right}.tfpars=R_0, R_1, \dots R_n$, +
we say $F_{left}$ conforms to $F_{right}$, written as $F_{left} <: F_{right}$, if and only if:

* if $| F_{left}.typePars |=| F_{right}.typePars |=0$:
** $F_{left} <: F_{right}$
(cf. <<function_type_conformance_non_parameterized,Function Type Conformance Non-Parameterized>>)
* else if +
$|F_{left}.typePars |>0 \land | F_{right}.typePars |=0$:
** $\exists \typeSubs: ( \typeEnvAdd \typeSubs ) \entails F_{left} <: F_{right}$ (cf. <<function_type_conformance_non_parameterized,Function Type Conformance Non-Parameterized>> )
+
(i.e. there exists a substitution $\typeSubs$ of type variables in $F_{left}$ so that after substitution it becomes a subtype of $F_{right}$ as defined by <<function_type_conformance_non_parameterized,Function Type Conformance Non-Parameterized>>)
* else if $|F_{left}.typePars|=|F_{right}.typePars|$:
** $\typeEnvAdd \{ V^r_i \leftarrow V^l_i | 0 \leq i \leq n \} \entails F_{left} <: F_{right}$
( accordingly)
** -
+
[math]
++++
\beginalign
\forall 0 \leq i \leq n : \\
        \intersection{V^l_i.\mathit{upperBounds}} :> \intersection{V^r_i.\mathit{upperBounds}}
\endalign
++++
+
with $F_{left}.typePars=V^l_0, V^l_1, \dots V^l_n$ and $F_{right}.typePars=V^r_0, V^r_1, \dots V^r_n$ +
(i.e. we replace each type variable in $F_{right}$ by the corresponding type variable at the same index in $F_{left}$
and check the constraints from <<function_type_conformance_non_parameterized,Function Type Conformance Non-Parameterized>>  as if $F_{left}$ and $F_{right}$ were non-parameterized functions and, in
addition, the upper bounds on the left side need to be supertypes of the upper bounds on the right side).
--

Note that the upper bounds on the left must be supertypes of the right-side upper bounds (for similar reasons why types of formal parameters on the left are
required to be supertypes of the formal parameters’ types in ).
Where a particular type variable is used, on co- or contra-variant position, is not relevant:

.Bounded type variable at co-variant position in function type
[example]
--

[source,n4js]
----
class A {}
class B extends A {}

class X {
    <T extends B> m(): T { return null; }
}
class Y extends X {
    @Override
    <T extends A> m(): T { return null; }
}
----

Method `m` in `Y` may return an `A`, thus breaking the contract of m in `X`, but only if it is parameterized to do so, which is not allowed for clients of `X`, only those of `Y`.
Therefore, the override in the above example is valid.
--

The subtype relation for function types is also applied for method overriding to ensure that an overriding method’s signature conforms to that of the overridden method,
see <<Req-IDE-72>> (applies to method comnsumption and implementation accordingly, see <<Req-IDE-73>> and <<Req-IDE-74>>).
Note that this is very different from Java which is far more restrictive when checking overriding methods.
As Java also supports method overloading: given two types $A, B$ with $B <: A$ and a super class method `void m(B param)`, it is valid to override `m` as `void m(A param)` in N4JS but not in Java.
In Java this would be handled as method overloading and therefore an `@Override` annotation on `m` would produce an error.


.Upper and Lower Bound of a Function Type
[req,id=IDE-80,version=1]
--
The upper bound of a function type $F$ is a function type with the lower bound types of the parameters and the upper bound of the return type: +
$upper(\lstnfjs{function}(P_1,\dots,P_n):R) := \lstnfjs{function}( lower(P_1),\dots,lower(P_n) ): upper(R)$

The lower bound of a function type $F$ is a function type with the upper bound types of the parameters and the lower bound of the return type: +
$lower(\lstnfjs{function}(P_1,\dots,P_n):R) := \lstnfjs{function}( upper(P_1),\dots,upper(P_n) ): lower(R)$
--

=== Autoboxing of Function Type


Function types, compared to other types like String, come only in on flavour: the Function object representation.
There is no primitive function type.
Nevertheless, for function type expressions and function declarations, it is possible to call the properties of Function object directly.
This is similar to autoboxing for strings.

.Access of Function properties on functions
[source,n4js]
----
// function declaration
var param: number = function(a,b){}.length // 2

function a(x: number) : number { return x*x; }
// function reference
a.length; // 1

// function variable
var f = function(m,l,b){/*...*/};
f.length; // 3

class A {
    s: string;
    sayS(): string{ return this.s; }
}

var objA: A = new A();
objA.s = "A";

var objB = {s:"B"}

// function variable
var m = objA.sayS; // method as function, detached from objA
var mA: {function(any)} = m.bind(objA); // bind to objA
var mB: {function(any)} = m.bind(objB); // bind to objB

m()  // returns: undefined
mA() // returns: A
mB() // returns: B

m.call(objA,1,2,3);  // returns: A
m.apply(objB,[1,2,3]); // returns: B
m.toString(); // returns: function sayS(){ return this.s; }
----

=== Arguments Object


//TODO missing notation below
A special arguments object is defined within the body of a function.
It is accessible through the implicitly-defined local variable named ,
unless it is shadowed by a local variable, a formal parameter or a
function named `arguments` or in the rare case that the function itself is called ’arguments’ cite:[ECMA11a(S10.5,p.59)].
The argument object has array-like behavior even though it is not of type `array`:

* All actual passed-in parameters of the current execution context can be retrieved by $0-based$ index access.
* The `length` property of the arguments object stores the actual number of passed-in arguments which may differ from the number of formally defined number of parameters $fpars$ of the containing function.
* It is possible to store custom values in the arguments object, even outside the original index boundaries.
* All obtained values from the arguments object are of type `any`.

In non-strict ES mode the `callee` property holds a reference to the function executed cite:[ECMA11a(S10.6,p.61)].

.Arguments.callee
[req,id=IDE-81,version=1]
--
In N4JS and in ES strict mode the use of `arguments.callee` is prohibited.
--


.Arguments as formal parameter name
[req,id=IDE-82,version=1]
--
In N4JS, the formal parameters of the function cannot be named `arguments`.
This applies to all variable execution environments like field accessors (getter/setter, <<_field-accessors-getter-setter>>),
methods (<<Methods>>) and constructors (<<_constructor-and-classifier-type>>), where `FormalParameter` type is used.

.Usage of Arguments Object
[example]
--
[source,n4js]
----
// regular function
function a1(s1: string, n2: number) {
    var l: number = arguments.length;
    var s: string = arguments[0] as string;
}

class A {
    // property access
    get s(): string { return ""+arguments.length; } // 0
    set s(n: number) { console.log( arguments.length ); }  // 1
    // method
    m(arg: string) {
        var l: number = arguments.length;
        var s: string = arguments[0]  as string;
    }
}

// property access in object literals
var x = {
    a:5,
    get b(): string {
        return ""+arguments.length
    }
}

// invalid:
function z(){
    arguments.length // illegal, see next lines
    // define arguments to be a plain variable of type number:
    var arguments: number = 4;
}
----

[.language-n4js]
== ECMAScript 5 Function Definition

=== Function Declaration

==== Syntax

A function can be defined as described in cite:[ECMA11a(S13,p.98)] and additional annotations can be specified.
Since N4JS is based on cite:[ECMA15a], the syntax contains constructs not available in cite:[ECMA11a].
The newer constructs defined only in cite:[ECMA15a] and proposals already implemented in N4JS are described in <<ECMAScript 2015 Function Definition>> and <<ECMAScript Proposals Function Definition>>.

NOTE: In contrast to plain JavaScript, function declarations can be used in blocks in N4JS.
This is only true, however, for N4JS files, not for plain JS files.


.Syntax Function Declaration and Expression
[source,xtext]
----
FunctionDeclaration <Yield>:
    => ({FunctionDeclaration}
        annotations+=Annotation*
        (declaredModifiers+=N4Modifier)*
        -> FunctionImpl <Yield,Yield,Expression=false>
    ) => Semi?
;


fragment AsyncNoTrailingLineBreak *: (declaredAsync?='async' NoLineTerminator)?;

fragment FunctionImpl<Yield, YieldIfGenerator, Expression>*:
    'function'
    (
        generator?='*' FunctionHeader<YieldIfGenerator,Generator=true> FunctionBody<Yield=true,Expression>
    |   FunctionHeader<Yield,Generator=false> FunctionBody<Yield=false,Expression>
    )
;

fragment FunctionHeader<Yield, Generator>*:
    TypeVariables?
    name=BindingIdentifier<Yield>?
    StrictFormalParameters<Yield=Generator>
    (-> ':' returnTypeRef=TypeRef)?
;

fragment FunctionBody <Yield, Expression>*:
        <Expression> body=Block<Yield>
    |   <!Expression> body=Block<Yield>?
;
----

Properties of the function declaration and expression are described in <<_function-type>>.

For this specification, we introduce a supertype $FunctionDefinition$ for both, $FunctionDeclaration$ and $FunctionExpression$.
This supertype contains all common properties of these two subtypes, that is, all properties of $FunctionExpression$.

.Function Declaration with Type Annotation
[example]
--
[source,n4js]
----
// plain JS
function f(p) { return p.length }
// N4JS
function f(p: string): number { return p.length }
----

--
==== Semantics


A function defined in a class’s method (or method modifier) builder is a method, see <<Methods>> for details and additional constraints.
The metatype of a function definition is function type (<<_function-type>>), as a function declaration is only a different syntax for creating a `Function` object.
Constraints for function type are described in <<_function-type>>.
Another consequence is that the inferred type of a function definition $fdecl$ is simply its function type $F$.

[math]
++++
\infer{\infType{F}}{\infType{fdecl}}
++++

Note that the type of a function definition is different from its return type $f.decl$!

.Function Declaration only on Top-Level
[req,id=IDE-83,version=1]
--

1.  In plain JavaScript, function declarations must only be located on top-level, that is they must not be nested in blocks.
Since this is supported by most JavaScript engines, only a warning is issued.

--

=== Function Expression

A function expression cite:[ECMA11a(S11.2.5)] is quite similar to a function declaration.
Thus, most details are explained in <<_ecmascript-5-function-definition>>.

==== Syntax [[function-expression-syntax]]

[source,xtext]
----
FunctionExpression:
         ({FunctionExpression}
            FunctionImpl<Yield=false,YieldIfGenerator=true,Expression=true>
         )
;
----

==== Semantics and Type Inference

In general, the inferred type of a function expression simply is the function type as described in <<_function-type>>.
Often, the signature of a function expression is not explicitly specified but it can be inferred from the context.
The following context information is used to infer the full signature:

* If the function expression is used on the right hand side of an assignment, the expected return type can be inferred from the left hand side.
* If the function expression is used as an argument in a call to another function, the full signature can be inferred from the corresponding type of the formal parameter declaration.

// todo[lb,jvp]{give some examples}

Although the signature of the function expression may be inferred from the formal parameter if the function expression is used as argument, this inference has some conceptual limitations.
This is demonstrated in the next example.

.Inference Of Function Expression’s Signature
[example]
--
In general, `{function():any}` is a subtype of `{function():void}` (cf. <<_function-type>>).
When the return type of a function expression is inferred, this relation is taken into account which may lead to unexpected results as shown in the following code snippet:

[source,n4js]
----
function f(cb: {function():void}) { cb() }
f(function() { return 1; });
----

No error is issued: The type of the function expression actually is inferred to `{function():any}`, because there is a return statement with an expression.
It is not inferred to `{function():void}`, even if the formal parameter of `f` suggests that.
Due to the previously-stated relation `{function():any} <: {function():void}` this is correct – the client (in this
case function `f`) works perfectly well even if `cb` returns something.
The contract of arguments states that the type of the argument is a subtype of the type of the formal parameter.
This is what the inferencer takes into account!
--

[.language-n4js]
== ECMAScript 2015 Function Definition


=== Formal Parameters
Parameter handling has been significantly upgraded in ECMAScript 6.
It now supports parameter default values, rest parameters (variadics) and destructuring.
Formal parameters can be modified to be either default or variadic.
In case a formal parameter has no modifier, it is called normal.
Modified parameters also become optional.

Modifiers of formal parameters such as default or rest are neither evaluated nor rewritten in the transpiler.



==== Optional Parameters [[Type_Modifiers_Optional]]

An optional formal parameter can be omitted when calling a function/method.
An omitted parameter has the value `undefined`.
In case the omitted parameter is variadic, the value is an empty array.

Parameters can not be declared as optional explicitly.
Instead, being optional is true when a parameter is declared as default or variadic.
Note that any formal parameter that follows a default parameter is itself also a default thus an optional parameter.


==== Default Parameters [[Type_Modifiers_Default]]
A default parameter value is specified for a parameter via an equals sign (`=`).
If a caller doesn’t provide a value for the parameter, the default value is used.

Default initializers of parameters are specified at a formal parameter of a function or method after the equal sign using an arbitrary initializer expression, such as `var = "s"`.
However, this default initializer can be omitted.
When a formal parameter has a declared type, the default initializer is specified at the end, such as: `var : string = "s"`.
The initializer expression is only evaluated in case no actual argument is given for the formal parameter.
Also, the initializer expression is evaluated when the actual argument value is `undefined`.

Formal parameters become default parameters implicitly when they are preceded by an explicit default parameter.
In such cases, the default initializer is `undefined`.

.Default parameters
[req,id=IDE-14501,version=1]
--
Any normal parameter which is preceded by a default parameter also becomes a default parameter.
Its initializer is `undefined`.
--

When a method is overwritten, its default parameters are not part of the overwriting method.
Consequently, initializers of default parameters in abstract methods are obsolete.


==== Variadic [[Type_Modifiers_Variadic]]


Variadic parameters are also called _rest parameters_.
Marking a parameter as variadic indicates that method accepts a variable number of parameters.
A variadic parameter implies that the parameter is also optional as the cardinality is defined as $[0..*]$.
No further parameter can be defined after a variadic parameter.
When no argument is given for a variadic parameter, an empty array is provided when using the parameter in the body of the function or method.

.Variadic and optional parameters
[req,id=IDE-16,version=1]
--
For a parameter $p$, the following condition must hold:
$p.var \rightarrow p.opt$.

A parameter can not be declared both variadic and with a default value.
That is to say that one can either write $varName=$ (default) or $\dots varName$, but not $\dots varName=$.
--


Declaring a variadic parameter of type $T$ causes the type of the method parameter to become `Array<T>`.
That is, declaring `function(...tags : string)` causes `tags` to be an `Array<string>` and not just a scalar `string` value.

To make this work at runtime, the compiler will generate code that constructs the `parameter` from the `arguments` parameter explicitly passed to the function.

.Variadic at Runtime
[req,id=IDE-17,version=1]
--

At runtime, a variadic parameter is never set to undefined.
Instead, the array may be empty.
This must be true even if preceding parameters are optional and no arguments are passed at runtime.
--

For more constraints on using the variadic modifier, see <<_function-object-type>>.




=== Generator Functions [[generator-functions]]


Generators come together with the `yield` expression and can play three roles:
the role of an iterator (data producer), of an observer (data consumer), and a combined role which is called coroutines.
When calling a generator function or method, the returned generator object of type `Generator<TYield,TReturn,TNext>` can be controlled by its methods
(cf. cite:[ECMA15a(S14.4)], also see cite:[Kuizinas14a]).

==== Syntax [[generator-functions-syntax]]

Generator functions and methods differ from ordinary functions and methods only in the additional `pass:[*]` symbol before the function or method name.
The following syntax rules are extracted from the real syntax rules.
They only display parts relevant to declaring a function or method as a generator.


[source,xtext]
----
GeneratorFunctionDeclaration <Yield>:
        (declaredModifiers+=N4Modifier)*
        'function' generator?='*'
        FunctionHeader<YieldIfGenerator,Generator=true>
        FunctionBody<Yield=true,Expression=false>
;

GeneratorFunctionExpression:
        'function' generator?='*'
        FunctionHeader<YieldIfGenerator,Generator=true>
        FunctionBody<Yield=true,Expression=true>
;

GeneratorMethodDeclaration:
    annotations+=Annotation+ (declaredModifiers+=N4Modifier)* TypeVariables?
    generator?='*' NoLineTerminator LiteralOrComputedPropertyName<Yield>
    MethodParamsReturnAndBody<Generator=true>
----




==== Semantics [[generator-functions-semantics]]

The basic idea is to make code dealing with Generators easier to write and more readable without changing their functionality.
Take this example:

[[ex:two-simple-generator-functions]]
.Two simple generator functions
[example]
====

[source,n4js]
----
// explicit form of the return type
function * countTo(iMax:int) : Generator<int,string,undefined> {
	for (int i=0; i<=iMax; i++)
		yield i;
	return "finished";
}
val genObj1 = countTo(3);
val values1 = [...genObj1]; // is [0,1,2,3]
val lastObj1 = genObj1.next(); // is {value="finished",done=true}

// shorthand form of the return type
function * countFrom(start:int) : int {
	for (int i=start; i>=0; i--)
		yield i;
	return finished;
}
val genObj2 = countFrom(3);
val values2 = [...genObj2]; // is [3,2,1,0]
val lastObj2 = genObj2.next(); // is {value="finished",done=true}
----

In the example above, two generator functions are declared.
The first declares its return type explicitly whereas the second uses a shorthand form.
====

Generator functions and methods return objects of the type `Generator<TYield,TReturn,TNext>` which is a subtype of the `Iterable<TYield>` and `Iterator<TYield>` interfaces.
Moreover, it provides the methods `throw(exception:any)` and `return(value:TNext?)` for advanced control of the generator object.
The complete interface of the generator class is given below.


.The generator class
[source,n4js]
----
public providedByRuntime interface Generator<out TYield, out TReturn, in TNext>
	extends Iterable<TYield>, Iterator<TYield> {
	public abstract next(value: TNext?): IteratorEntry<TYield>
	public abstract [Symbol.iterator](): Generator<TYield, TReturn, TNext>
	public abstract throw(exception: any): IteratorEntry<TYield>;
	public abstract return(value: TNext?): IteratorEntry<TReturn>;
}
----


.Modifier `pass:[*]`
[req,id=IDE-14370,version=1]
--
. `pass:[*]` may be used on declared functions and methods, and for function expressions.
.  A function or method _f_ with a declared return type _R_ that is declared `pass:[*]` has an actual return type of `Generator<TYield,TReturn,TNext>`.
.  A generator function or method can have no declared return type, a shorthand form of a return type or an explicitly declared return type.
..  The explicitly declared return type is of the form `Generator<TYield,TReturn,TNext>` with the type variables:
...  _TYield_ as the expected type of the yield expression argument,
...  _TReturn_ as the expected type of the return expression, and
...  _TNext_ as both the return type of the yield expression.
..  The shorthand form only declares the type of _TYield_ which implicitly translates to `Generator<TYield,TReturn,any>` as the return type.
...  The type _TReturn_ is inferred to either `undefined` or `any` from the body.
...  In case the declared type is `void`, actual return type evaluates to `Generator<undefined,undefined,any>`.
..  If no return type is declared, both _TYield_ and _TReturn_ are inferred from the body to either `any` or `undefined`. _TNext_ is `any`.
.  Given a generator function or method _f_ with an actual return type `Generator<TYield,TReturn,TNext>`:
..  all yield statements in _f_ must have an expression of type _TYield_.
..  all return statements in _f_ must have an expression of type _TReturn_.
.  Return statements in generator functions or methods are always optional.
--

.Modifier `yield` and `yield*`
[req,id=IDE-14371,version=1]
--
. `yield` and `yield*` may only be in body of generator functions or methods.
. `yield expr` takes only expressions _expr_ of type _TYield_ in a generator function or methods with the actual type `Generator<TYield,TReturn,TNext>`.
. The return type of the `yield` expression is _TNext_.
. `yield* fg()` takes only iterators of type `Iterator<TYield>`, and generator functions or methods _fg_ with the actual return type `Generator<? extends TYield,? extends TReturn,? super TNext>`.
. The return type of the `yield*` expression is _any_, since a custom iterator could return an entry `{done=true,value}` and any value for the variable `value`.
--

Similar to `async` functions, shorthand and explicit form `* function():int{};` and `* function():Generator<int,TResult,any>` are equal,
given that the inferred _TResult_ of the former functions equals to _TResult_ in the latter function).
In other words, the return type of generator functions or methods is wrapped when it is not explicitly defined as `Generator` already.
Thus, whenever a nested generator type is desired, it has to be defined explicitly.
Consider the example below.

[source,n4js]
.Type variables with async methods.
----
class C<T> {
	genFoo(): T{} // equals to genFoo(): Generator<T, undefined, any>;
				// note that TResult depends on the body of genFoo()
}
function fn(C<int> c1, C<Generator<int,any,any>> c2) {
	c1.genFoo();  // returns Generator<int, undefined, any>
	c2.genFoo();  // returns Generator<Generator<int,any,any>, undefined, any>
}
----

==== Generator Arrow Functions
As of now, generator arrow functions are not supported by EcmaScript 6 and also, the support is not planned.
However, introducing generator arrow function in EcmaScript is still under discussion.
For more information, please refer to https://esdiscuss.org/topic/generator-arrow-functions[ESDiscuss.org] and https://esdiscuss.org/topic/why-do-generator-expressions-return-generators[StackOverflow.com].



=== Arrow Function Expression


This is an ECMAScript 6 expression (see cite:[ECMA15a(S14.2)]) for simplifying the definition of anonymous function expressions, a.k.a. lambdas or closures.
The ECMAScript Specification calls this a function definition even though they may only appear in the context of expressions.

Along with Assignments, Arrow function expressions have the least precedence, e.g. they serve as the entry point for the expression tree.

Arrow function expressions can be considered syntactic window-dressing for old-school function expressions and therefore do not support the
benefits regarding parameter annotations although parameter types may be given explicitly.
The return type can be given as type hint if desired, but this is not mandatory (if left out, the return type is inferred).
The notation `pass:[@=>]` stands for an async arrow function (<<Asynchronous Arrow Functions>>).

==== Syntax [[arrow-function-expression-syntax]]

The simplified syntax reads like this:

[source,xtext]
----
ArrowExpression returns ArrowFunction:
    =>(
        {ArrowFunction}
        (
            '('
                ( fpars+=FormalParameterNoAnnotations ( ',' fpars+=FormalParameterNoAnnotations )* )?
            ')'
            (':' returnTypeRef=TypeRef)?
        |   fpars+=FormalParameterNoType
        )
        '=>'
    ) (
        (=> hasBracesAroundBody?='{' body=BlockMinusBraces '}') | body=ExpressionDisguisedAsBlock
    )
;

FormalParameterNoAnnotations returns FormalParameter:
    (declaredTypeRef=TypeRef variadic?='...'?)? name=JSIdentifier
;
FormalParameterNoType returns FormalParameter: name=JSIdentifier;

BlockMinusBraces returns Block: {Block} statements+=Statement*;

ExpressionDisguisedAsBlock returns Block:
    {Block} statements+=AssignmentExpressionStatement
;

AssignmentExpressionStatement returns ExpressionStatement: expression=AssignmentExpression;
----

==== Semantics and Type Inference [[arrow-function-expression-semantics-and-type-inference]]

Generally speaking, the semantics are very similar to the function
expressions but the devil’s in the details:

* `arguments`: Unlike normal function expressions, an arrow function does not introduce an implicit `arguments` variable (<<Arguments Object>>),
therefore any occurrence of it in the arrow function’s body has always the same binding as an occurrence of `arguments` in the lexical context enclosing the arrow function.
* `this`: An arrow function does not introduce a binding of its own for the `this` keyword. That explains why uses in the body of arrow function have the same meaning as occurrences in the enclosing lexical scope.
As a consequence, an arrow function at the top level has both usages of `arguments` and `this` flagged as error (the outer lexical context doesn’t provide definitionsfor them).
* `super`: As with function expressions in general, whether of the arrow variety or not, the usage of `super` isn’t allowed in the body of arrow functions.

.No This in Top Level Arrow Function in N4JS Mode
[req,id=IDE-84,version=1]
--
In N4JS, a top-level arrow function can’t refer to `this` as there’s no outer lexical context that provides a binding for it.
--

.No Arguments in Top Level Arrow Function
[req,id=IDE-85,version=1]
--
In N4JS, a top-level arrow function can’t include usages of `arguments` in its body, again because of the missing binding for it.
--

[.language-n4js]
== ECMAScript Proposals Function Definition


=== Asynchronous Functions


To improve language-level support for asynchronous code, there exists an ECMAScript proposal footnote:[see http://tc39.github.io/ecmascript-asyncawait/] based on Promises which are provided by ES6 as built-in types.
N4JS implements this proposal.
This concept is supported for declared functions and methods (<<_asynchronous-methods>>) as well
as for function expressions and arrow functions (<<Asynchronous Arrow Functions>>).

==== Syntax [[asynchronous-functions-syntax]]

The following syntax rules are extracted from the real syntax rules.
They only display parts relevant to declaring a function or method as
asynchronous.

[source,xtext]
----
AsyncFunctionDeclaration <Yield>:
        (declaredModifiers+=N4Modifier)*
        declaredAsync?='async' NoLineTerminator 'function'
        FunctionHeader<Yield,Generator=false>
        FunctionBody<Yield=false,Expression=false>
;

AsyncFunctionExpression:
        declaredAsync?='async' NoLineTerminator 'function'
        FunctionHeader<Yield=false,Generator=false>
        FunctionBody<Yield=false,Expression=true>
;

AsyncArrowExpression <In, Yield>:
        declaredAsync?='async' NoLineTerminator '('
            (fpars+=FormalParameter<Yield>
                (',' fpars+=FormalParameter<Yield>)*)?
        ')' (':' returnTypeRef=TypeRef)? '=>'
        (   '{' body=BlockMinusBraces<Yield> '}'
            | body=ExpressionDisguisedAsBlock<In>
        )
;

AsyncMethodDeclaration:
    annotations+=Annotation+ (declaredModifiers+=N4Modifier)* TypeVariables?
    declaredAsync?='async' NoLineTerminator LiteralOrComputedPropertyName<Yield>
    MethodParamsReturnAndBody
----

’async’ is not a reserved word in ECMAScript and it can therefore be
used either as an identifier or as a keyword, depending on the context.
When used as a modifier to declare a function as asynchronous, then
there must be no line terminator after the `async` modifier. This enables the
parser to distinguish between using `async` as an identifier reference and a
keyword, as shown in the next example.

.Async as keyword and identifier
[example]
====

[source,n4js]
----
async // <1>
function foo() {}
// vs
async function bar(); // <2>
----
<1> In this snippet, the `async` on line 1 is an identifier reference (referencing a
variable or parameter) and the function defined on line 2 is a
non-asynchronous function. The automatic semicolon insertion adds a
semicolon after the reference on line 1.
<2> In contrast, `async` on line 4 is recognized as a modifier declaring the function as asynchronous.

====

==== Semantics [[asynchronous-functions-semantics]]

The basic idea is to make code dealing with Promises easier to write and
more readable without changing the functionality of Promises. Take this
example:

[source,n4js]
.A simple asynchronous function using async/await.
----
// some asynchronous legacy API using promises
interface DB {}
interface DBAccess {
    getDataBase(): Promise<DB,?>
    loadEntry(db: DB, id: string): Promise<string,?>
}

var access: DBAccess;

// our own function using async/await
async function loadAddress(id: string) : string {
    try {
        var db: DB = await access.getDataBase();
        var entry: string = await access.loadEntry(db, id);
        return entry.address;
    }
    catch(err) {
        // either getDataBase() or loadEntry() failed
        throw err;
    }
}
----

The modifier `async` changes the return type of `loadAddress()` from `string` (the declared return type) to `Promise<string,?>` (the actual return type).
For code inside the function, the return type is still `string`:
the value in the return statement of the last line will be wrapped in a Promise.
For client code outside the function and in case of recursive invocations, the return type is `Promise<string,?>`.
To raise an error, simply throw an exception, its value will become the error value of the returned Promise.

If the expression after an `await` evaluates to a `Promise`, execution of the enclosing asynchronous function will be suspended until either a success value is available
(which will then make the entire await-expression evaluate to this success value and continue execution)
or until the Promise is rejected (which will then cause an exception to be thrown at the location of the await-expression).
If, on the other hand, the expression after an `await` evaluates to a non-promise, the value will be simply passed through.
In addition, a warning is shown to indicate the unnecessary `await` expression.

Note how method `loadAddress()` above can be implemented without any explicit references to the built-in type Promise.
In the above example we handle the errors of the nested asynchronous calls to `getDataBase()` and `loadEntry()` for demonstration purposes only;
if we are not interested in the errors we could simply remove the try/catch block and any errors would be forwarded to the caller of `loadAddress()`.

Invoking an async function commonly adopts one of two forms:

* `var p: Promise<successType,?> = asyncFn()`
* `await asyncFn()`

These patterns are so common that a warning is available whenever both

. `Promise` is omitted as expected type; and
. `await` is also omitted.

The warning aims at hinting about forgetting to wait for the result, while remaining non-noisy.

.Modifier `async` and `await`
[req,id=IDE-86,version=1]
--

.  `async` may be used on declared functions and methods as well as for function expressions and arrow functions.
.  A function or method that is declared `async` can have no declared return type, a shorthand form of a return type or an explicitly declared return type.
..  The explicitly declared return type is of the form `Promise<R,E>` where _R_ is the type of all return statements in the body, and E is the type of exceptions that are thrown in the body.
..  The shorthand form only declares the type of _R_ which implicitly translates to `Promise<R,?>` as the actual return type.
..  In case no return type is declared, the type _R_ of `Promise<R,?>` is inferred from the body.
.  A function or method _f_ with a declared return type _R_ that is declared `async` has an actual return type of
..  `R` if _R_ is a subtype of `Promise<?,?>`,
..  `Promise<undefined,?>` if _R_ is type `void`.
..  `Promise<R,?>` in all other cases (i.e. the declared return type _R_ is being wrapped in a `Promise`).
.  Return type inference is only performed when no return type is declared.
..  The return type `R` of `Promise<R,?>` is inferred either as `void` or as `any`.
.  Given a function or method _f_ that is declared `async` with a declared return type _R_, or with a declared return type `Promise<R,?>`,
all return statements in _f_ must have an expression of type _R_ (and not of type `Promise<R,?>`).
.  `await` can be used in expressions directly enclosed in an async function, and behaves like a unary operator with the same precedence as `yield` in ES6.
.  Given an expression _expr_ of type
_T_, the type of (`await` _expr_) is inferred to _T_ if
_T_ is not a Promise, or it is inferred to _S_ if
_T_ is a Promise with a success value of type
_S_, i.e. _T <: Promise<S,?>_ .

--

In other words, the return type _R_ of `async` functions and methods will always be wrapped to `Promise<R,?>` unless _R_ is a `Promise` already.
As a consequence, nested ``Promise``s as a return type of a async function or method have to be stated explicitly like `Promise<Promise<R,?>,?>`.

When a type variable `T` is used to define the the return type of an async function or method, it will always be wrapped.
Consider the example below.

.Type variables with async methods.
====

[source,n4js]
----
interface I<T> {
	async foo(): T;  // amounts to foo(): Promise<T,?>
}
function snafu(i1: I<int>, i2: I<Promise<int,?>>) {
	i1.foo();  // returns Promise<int,?>
	i2.foo();  // returns Promise<Promise<int,?>,?>
}
----

====


==== Asynchronous Arrow Functions

Also arrow functions can be declared asynchronous by using keyword `async`.
An `await` expression is allowed in the body of an async arrow function but not
in the body of a non-async arrow function.


==== Asynchronous Generator Functions

Also generator functions can be declared asynchronous with keyword `async`.

.Asynchronous Generator Functions
[req,id=GH-572,version=1]
--

For an asynchronous generator function the rules for synchronous generator functions given in <<generator-functions>>
as well as the rules for non-generator asynchronous functions (see <<asynchronous-functions-semantics>>)
apply at the same time, except for the following changes:

. built-in type `AsyncGenerator<TYield,TReturn,TNext>` is used as return type, instead of `Generator<TYield,TReturn,TNext>`.
  Regarding the inference of type arguments `TYield`, `TReturn`, and `TNext` as well as the short-hand form for declaring
  the return type, all rules apply accordingly.
. a warning is shown when type `Generator` is used as return type of a synchronous generator function.
. a warning is shown when type `AsyncGenerator` is used as return type of an asynchronous generator.
. `yield*` used inside asynchronous generator functions accepts values of type `AsyncGenerator` and then delegates to
  that given asynchronous generator until it is done, in much the same way as defined for `yield*` when used inside
  synchronous generator functions with values of type `Generator`. In addition, `yield*` used inside asynchronous
  generator functions still accepts values of type `Generator`, allowing to implement a delegation from an
  asynchronous generator function to a synchronous generator.

--

Note that an `AsyncGenerator` is an `AsyncIterable` (not an `Iterable`) returning an `AsyncIterator`, not an ordinary `Iterator`.
Method `#next()` in `AsyncIterator` returns a `Promise<IteratorEntry<T>>`, not directly an `IteratorEntry<T>`.

All the above applies equally to both declared generator functions as well as generator function expressions.



[.language-n4js]
== N4JS Extended Function Definition

=== Generic Functions

A generic function is a function with a list of generic type parameters.
These type parameters can be used in the function signature to declare the types of formal parameters and the return type.
In addition, the type parameters can be used in the function body, for example when declaring the type of a local variable.

In the following listing, a generic function `foo` is defined that has two type parameters `S` and `T`.
Thereby `S` is used as to declare the parameter type `Array<S>` and `T` is used as the return type and to construct the returned value in the function body.

.Generic Function Definition
[source,n4js]
----
function <S,T> foo(s: Array<S>): T { return new T(s); }
----

If a generic type parameter is not used as a formal parameter type or
the return type, a warning is generated.



=== Promisifiable Functions

In many existing libraries, which have been developed in pre-ES6-promise-API times, callback methods are used for asynchronous behavior.
An asynchronous function follows the following conventions:

[source,n4js]
----
'function' name '(' arbitraryParameters ',' callbackFunction ')'
----

Usually the function returns nothing (`void`).
The callback function usually takes two arguments,in which the first is an error object and the other is the result value of the asynchronous operation.
The callback function is called from the asynchronous function, leading to nested function calls (aka ’callback hell’).

In order to simplify usage of this pattern, it is possible to mark such a function or method as `@Promisifiable`.
It is then possible to ’promisify’ an invocation of this function or method, which means no callback function argument has to be provided and a will be returned.
The function or method can then be used as if it were declared with `async`.
This is particularly useful in N4JS definition files (.n4jsd) to allow using an existing callback-based API from N4JS code with the more convenient `await`.

.Promisifiable
[example]
--
Given a function with an N4JS signature

[source,n4js]
----
f(x: int, cb: {function(Error, string)}): void
----

This method can be annotated with `Promisifiable` as follows:

[source,n4js]
----
@Promisifiable f(x: int, cb: {function(Error, string)}): void
----

With this annotation, the function can be invoked in four different
ways:

[source,n4js]
----
f(42, function(err, result1) { /* ... */ });            // traditional
var promise: Promise<string,Error> = @Promisify f(42);  // promise
var result3: string = await @Promisify f(42);           // long
var result4: string = await f(42);                      // short
----

The first line is only provided for completeness and shows that a promisifiable function can still be used in the ordinary way by providing a callback - no special handling will occur in this case.
The second line shows how `f` can be promisified using the `@Promisify` annotation - no callback needs to be provided and instead, a `Promise` will be returned.
We can either use this promise directly or immediately `await` on it, as shown in line 3.
The syntax shown in line 4 is merely shorthand for `await @Promisify`, i.e. the annotation is optional after `await`.

--

.Promisifiable
[req,id=IDE-87,version=1]
--
A function or method $f$ can be annotated with `@Promisifiable` if and only if the following constraints hold:

1.  Last parameter of $f$ is a function (the $callback$).
2.  The $callback$ has a signature of
* `{function(E, T0, T1, ..., Tn): V}`, or
* `{function(T0, T1, ..., Tn): V}`
+
in which $E$ is type `Error` or a subtype thereof, $T_0, \dots, T_n$ are arbitrary types except or its subtypes.
$E$, if given, is then the type of the error value, and $T_0, \dots, T_n$ are the types of the success values of the asynchronous operation. +
Since the return value of the synchronous function call is not available when using `@Promisify`, $V$ is recommended to be `void`, but it can be any type.
3.  The callback parameter may be optional.footnote:[Even in this case, the function will actually be called with the callback method which is then created by the transpiler. However, the callback is not given in the N4JS code).]

--

According to <<Req-IDE-87>>, a promisifiable function or method may or may not have a non-void return type, and that only the first parameter of the callback is allowed to be of type `Error`, all other parameters must be of other types.

.@Promisify and await with promisifiable functions
[req,id=IDE-88,version=1]
--
A promisifiable function $f$ with one of the two valid
signatures given in <<Req-IDE-87>> can be promisified with `Promisify` or
used with `await`, if and only if the following constraints hold:

1.  Function $f$ must be annotated with `@Promisifiable`.
2.  Using `@Promisify f()` without `await` returns a promise of type `Promise<S,F>` where
* $S$ is `IterableN<T0,...,Tn>` if $n\geq 2$, `T` if $n=1$, and `undefined` if $n=0$.
* $F$ is `E` if given, `undefined` otherwise.
3.  Using `await @Promisify f()` returns a value of type `IterableN<T0,...,Tn>` if $n\geq 2$, of type `T` if $n=1$, and of type `undefined` if $n=0$.
4.  In case of using an `await`, the annotation can be omitted. +
I.e., `await @Promisify f()` is equivalent to `await f()`.
5.  Only call expressions using f as target can be promisified, in other
words this is illegal:
+
[source,n4js]
var pf = @Promisify f; // illegal code!

--
