@@Global @@ProvidedByRuntime

export external public interface ~SymbolConstructor {
	get iterator(): symbol;
}

export external public interface ~IteratorYieldResult<TYield> {
	done: false;
	value: TYield;
}

export external public interface ~IteratorReturnResult<TReturn> {
	done: true;
	value: TReturn;
}

export external public type IteratorResult = IteratorYieldResult<T> | IteratorReturnResult<TReturn>;

export external public interface ~Iterator<T,TReturn,TNext> {
	next(...args: any+ | any+): IteratorResult<T,TReturn>;
	return(value: TReturn = ): IteratorResult<T,TReturn>;
	throw(e: any = ): IteratorResult<T,TReturn>;
}

export external public interface ~Iterable<T> {
	[Symbol.iterator](): Iterator<T>;
}

export external public interface ~IterableIterator<T> extends Iterator<T> {
	[Symbol.iterator](): IterableIterator<T>;
}

@Polyfill
export external public class Array<T> extends Array<T> {
	public [Symbol.iterator](): IterableIterator<T>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<T>;
	public static <T> from(...args: any+): any+; // overloading not supported
}

export external public interface ~IArguments {
	[Symbol.iterator](): IterableIterator<any>;
}

@Polyfill
export external public class Map<K,V> extends Map<K,V> {
	public [Symbol.iterator](): IterableIterator<any+>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<K>;
	public values(): IterableIterator<V>;
	public constructor(iterable: Iterable<any+>);
}

@Polyfill
export external public class WeakMap<K,V> extends WeakMap<K,V> {
	public constructor(iterable: Iterable<any+>);
}

@Polyfill
export external public class Set<T> extends Set<T> {
	public [Symbol.iterator](): IterableIterator<T>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<T>;
	public values(): IterableIterator<T>;
	public constructor(iterable: Iterable<T> = );
}

@Polyfill
export external public class WeakSet<T> extends WeakSet<T> {
	public constructor(iterable: Iterable<T>);
}

export external public interface ~Promise<T> {}

export external public interface ~PromiseConstructor {
	<T> all(values: Iterable<T | PromiseLike<T>>): Promise<Array<Awaited<T>>>;
	<T> race(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>>;
}

@Polyfill
export external public class String extends String {
	public [Symbol.iterator](): IterableIterator<string>;
}

@Polyfill
export external public class Int8Array extends Int8Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Int8Array;
}

@Polyfill
export external public class Uint8Array extends Uint8Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Uint8Array;
}

@Polyfill
export external public class Uint8ClampedArray extends Uint8ClampedArray {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Uint8ClampedArray;
}

@Polyfill
export external public class Int16Array extends Int16Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Int16Array;
}

@Polyfill
export external public class Uint16Array extends Uint16Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Uint16Array;
}

@Polyfill
export external public class Int32Array extends Int32Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Int32Array;
}

@Polyfill
export external public class Uint32Array extends Uint32Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Uint32Array;
}

@Polyfill
export external public class Float32Array extends Float32Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Float32Array;
}

@Polyfill
export external public class Float64Array extends Float64Array {
	public [Symbol.iterator](): IterableIterator<number>;
	public entries(): IterableIterator<any+>;
	public keys(): IterableIterator<number>;
	public values(): IterableIterator<number>;
	public constructor(elements: Iterable<number>);
	public static from(arrayLike: Iterable<number>, mapfn: (v: number, k: number)=>number = , thisArg: any = ): Float64Array;
}
