/*
 * Copyright (c) 2018 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

import NodeTestCLI from "org/eclipse/n4js/mangelhaft/runner/node/NodeTestCLI";
import NodeTestOptions from "org/eclipse/n4js/mangelhaft/runner/node/NodeTestOptions";
import {TestInfo} from "org/eclipse/n4js/mangelhaft/types/TestInfo";
import {PACKAGE_JSON} from "org/eclipse/n4js/mangelhaft/util";
import {createTempDir} from "org/eclipse/n4js/mangelhaft/util";
import {fsSafeAccessSync} from "org/eclipse/n4js/mangelhaft/util";
import {isHTTP_re} from "org/eclipse/n4js/mangelhaft/util";
import {readJsonFile} from "org/eclipse/n4js/mangelhaft/util";
import * as child_process from "child_process";
import * as lib_fs from "fs";
import * as glob+ from "glob";
import * as n4js_cli from "n4js-cli";
import * as lib_path from "path";
import debug from "deps/debug";

const log = debug("mangelhaft");

export default public class NodeTestAPI {
    /**
     * Executes a test run (might include compilation) with the given set of test options.
     */
    public static async exec(options: NodeTestOptions): void {
        const pathToPackageJson = new Map<string, Object+>();

        function addProject(dir: string): void {
            pathToPackageJson.set(dir, readJsonFile(lib_path.join(dir, PACKAGE_JSON)));
        }

        (options.projects || []).forEach(addProject);

        for (const dir of (options.scan || [])) {
            for (const p of await lib_fs.readdir(dir)) {
                const prj = lib_path.join(dir, p);

                if (fsSafeAccessSync(lib_path.join(prj, PACKAGE_JSON))) {
                    addProject(prj);
                }
            }
        }

        const projectDirs = Array.from(pathToPackageJson.keys());

        log("projects:", projectDirs);

        if (options.compile) { // call n4jsc
            const n4jscTempDir = await createTempDir();

            if (isHTTP_re.test(options.testCatalog)) { // use temp file
                options.testCatalog = lib_path.join(n4jscTempDir, "test-catalog.json");
            } else {
                options.testCatalog = lib_path.resolve(process.cwd(), options.testCatalog);
            }

            await n4js_cli.n4jsc({
                buildType: "projects",
                testCatalogFile: options.testCatalog,
                nodejsLocation: process.execArgv[0],
                npmrcRootLocation: options.npmrcRootLocation,
                installMissingDependencies: options.installMissingDependencies,
                clean: options.cleanCompile,
                keepCompiling: options.keepCompiling,
                verbose: log.enabled,
                debug: log.enabled
            }, projectDirs);

            log("generated test catalog:", options.testCatalog);

            const testCatalog = options.emitProjectTestCatalogs ? JSON.parse(String(lib_fs.readFileSync(options.testCatalog, { encoding: "UTF-8" }))) as Array<TestInfo> : null;

            for (const [dir, packageJson] of pathToPackageJson) {
                if (testCatalog && options.emitProjectTestCatalogs) {
                    const tests = testCatalog.filter(test => test.origin === packageJson["name"] as string);
                    if (tests.length) {
                        const file = lib_path.join(dir, options.emitProjectTestCatalogs);
                        log("writing:", file);
                        lib_fs.writeFileSync(file, JSON.stringify(tests, null, 2), { encoding: "UTF-8" });
                    }
                }

                // HACK until we have proper support for top-level import():
                switch (packageJson["name"]) {
                    case "n4js-node":
                    case "n4js-mangelhaft-cli":
                        break;
                    default:
                        if (!packageJson.n4js) {
                            break;
                        }
                        const transpiledFiles = glob.sync("**/*.js", {
                            cwd: lib_path.join(dir, (packageJson.n4js as Object)["output"] as string),
                            absolute: true
                        }) as Array<string>;
                        for (const file of transpiledFiles) {
                            const content = lib_fs.readFileSync(file, { encoding: "UTF-8" });
                            let newContent = content.replace(/_n4jsImport/mg, "import");
                            newContent = newContent.replace(/_nodeRequire/mg, "require");
                            if (newContent !== content) {
                                log("patching:", file);
                                lib_fs.writeFileSync(file, newContent, { encoding: "UTF-8" });
                            }
                        }
                        break;
                }
            }
        }

        if (!isHTTP_re.test(options.testCatalog)) {
            // try to resolve file:
            const file = lib_path.resolve(process.cwd(), options.testCatalog);
            if (fsSafeAccessSync(file)) {
                options.testCatalog = file;
            } else { // try to resolve via NPM
                try {
                    options.testCatalog = require.resolve(options.testCatalog);
                } catch (exc) {
                    throw new Error(`Cannot resolve test catalog: ${options.testCatalog}`);
                }
            }
        }

        log("testing with test catalog:", options.testCatalog);

        const args = NodeTestCLI.toCommandLine(options);
        const env: Object+ = Object.assign({}, process.env);

        if (options.noDebugLog) {
            // giving the command line option noLog overrides the DEBUG environment value to disable all logging (if the logger is configured.)
            env.DEBUG = "-*";
        }

        await new Promise<any, any>((resolve, reject) => {
            const execArgv = process.execArgv.slice();
            if (execArgv.indexOf("esm") < 0) {
                execArgv.push("-r", "esm");
            }
            if (options.inspectBrk) {
                execArgv.push(`--inspect-brk=${options.inspectBrk}`);
            }

            const runner = lib_path.join(__dirname, "NodeTestRunner.js");
            log("TestRun fork:", runner);
            log("execArgv:", execArgv);
            log("args:", args);
            //log("env:", env);

            child_process.fork(runner, args, {
                stdio: "inherit",
                execArgv: execArgv,
                env: env
            }).on("close", code => {
                log(`TestRun exit code: ${code}`);
                if (code === 0) {
                    resolve(code);
                } else {
                    reject(code);
                }
            });
        });
    }
}
