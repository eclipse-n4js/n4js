// generated from https://github.com/microsoft/TypeScript/blob/5d0d7ae85d1ff52d3ef4cb6cac653f33f7e76724/src/lib/dom.generated.d.ts
// (for license information of original file see https://github.com/microsoft/TypeScript/blob/main/LICENSE.txt)

@@Global @@ProvidedByRuntime

export external public interface ~AddEventListenerOptions extends EventListenerOptions {
	once?: boolean;
	passive?: boolean;
	signal?: AbortSignal;
}

export external public interface ~AesCbcParams extends Algorithm {
	iv: BufferSource;
}

export external public interface ~AesCtrParams extends Algorithm {
	counter: BufferSource;
	length: number;
}

export external public interface ~AesDerivedKeyParams extends Algorithm {
	length: number;
}

export external public interface ~AesGcmParams extends Algorithm {
	additionalData?: BufferSource;
	iv: BufferSource;
	tagLength?: number;
}

export external public interface ~AesKeyAlgorithm extends KeyAlgorithm {
	length: number;
}

export external public interface ~AesKeyGenParams extends Algorithm {
	length: number;
}

export external public interface ~Algorithm {
	name: string;
}

export external public interface ~AnalyserOptions extends AudioNodeOptions {
	fftSize?: number;
	maxDecibels?: number;
	minDecibels?: number;
	smoothingTimeConstant?: number;
}

export external public interface ~AnimationEventInit extends EventInit {
	animationName?: string;
	elapsedTime?: number;
	pseudoElement?: string;
}

export external public interface ~AnimationPlaybackEventInit extends EventInit {
	currentTime?: number;
	timelineTime?: number;
}

export external public interface ~AssignedNodesOptions {
	flatten?: boolean;
}

export external public interface ~AudioBufferOptions {
	length: number;
	numberOfChannels?: number;
	sampleRate: number;
}

export external public interface ~AudioBufferSourceOptions {
	buffer?: AudioBuffer;
	detune?: number;
	loop?: boolean;
	loopEnd?: number;
	loopStart?: number;
	playbackRate?: number;
}

export external public interface ~AudioConfiguration {
	bitrate?: number;
	channels?: string;
	contentType: string;
	samplerate?: number;
	spatialRendering?: boolean;
}

export external public interface ~AudioContextOptions {
	latencyHint?: AudioContextLatencyCategory | number;
	sampleRate?: number;
}

export external public interface ~AudioNodeOptions {
	channelCount?: number;
	channelCountMode?: ChannelCountMode;
	channelInterpretation?: ChannelInterpretation;
}

export external public interface ~AudioProcessingEventInit extends EventInit {
	inputBuffer: AudioBuffer;
	outputBuffer: AudioBuffer;
	playbackTime: number;
}

export external public interface ~AudioTimestamp {
	contextTime?: number;
	performanceTime?: DOMHighResTimeStamp;
}

export external public interface ~AudioWorkletNodeOptions extends AudioNodeOptions {
	numberOfInputs?: number;
	numberOfOutputs?: number;
	outputChannelCount?: Array<number>;
	parameterData?: Record<string,number>;
	processorOptions?: any;
}

export external public interface ~AuthenticationExtensionsClientInputs {
	appid?: string;
	appidExclude?: string;
	credProps?: boolean;
	uvm?: boolean;
}

export external public interface ~AuthenticationExtensionsClientOutputs {
	appid?: boolean;
	credProps?: CredentialPropertiesOutput;
	uvm?: UvmEntries;
}

export external public interface ~AuthenticatorSelectionCriteria {
	authenticatorAttachment?: AuthenticatorAttachment;
	requireResidentKey?: boolean;
	residentKey?: ResidentKeyRequirement;
	userVerification?: UserVerificationRequirement;
}

export external public interface ~BiquadFilterOptions extends AudioNodeOptions {
	Q?: number;
	detune?: number;
	frequency?: number;
	gain?: number;
	type?: BiquadFilterType;
}

export external public interface ~BlobEventInit {
	data: Blob;
	timecode?: DOMHighResTimeStamp;
}

export external public interface ~BlobPropertyBag {
	endings?: EndingType;
	type?: string;
}

export external public interface ~CSSStyleSheetInit {
	baseURL?: string;
	disabled?: boolean;
	media?: MediaList | string;
}

export external public interface ~CacheQueryOptions {
	ignoreMethod?: boolean;
	ignoreSearch?: boolean;
	ignoreVary?: boolean;
}

export external public interface ~CanvasRenderingContext2DSettings {
	alpha?: boolean;
	colorSpace?: PredefinedColorSpace;
	desynchronized?: boolean;
	willReadFrequently?: boolean;
}

export external public interface ~ChannelMergerOptions extends AudioNodeOptions {
	numberOfInputs?: number;
}

export external public interface ~ChannelSplitterOptions extends AudioNodeOptions {
	numberOfOutputs?: number;
}

export external public interface ~ClientQueryOptions {
	includeUncontrolled?: boolean;
	type?: ClientTypes;
}

export external public interface ~ClipboardEventInit extends EventInit {
	clipboardData?: DataTransfer;
}

export external public interface ~ClipboardItemOptions {
	presentationStyle?: PresentationStyle;
}

export external public interface ~CloseEventInit extends EventInit {
	code?: number;
	reason?: string;
	wasClean?: boolean;
}

export external public interface ~CompositionEventInit extends UIEventInit {
	data?: string;
}

export external public interface ~ComputedEffectTiming extends EffectTiming {
	activeDuration?: CSSNumberish;
	currentIteration?: number;
	endTime?: CSSNumberish;
	localTime?: CSSNumberish;
	progress?: CSSNumberish;
	startTime?: CSSNumberish;
}

export external public interface ~ComputedKeyframe {
	composite: CompositeOperationOrAuto;
	computedOffset: number;
	easing: string;
	offset: number;
}

export external public interface ~ConstantSourceOptions {
	offset?: number;
}

export external public interface ~ConstrainBooleanParameters {
	exact?: boolean;
	ideal?: boolean;
}

export external public interface ~ConstrainDOMStringParameters {
	exact?: string | Array<string>;
	ideal?: string | Array<string>;
}

export external public interface ~ConstrainDoubleRange extends DoubleRange {
	exact?: number;
	ideal?: number;
}

export external public interface ~ConstrainULongRange extends ULongRange {
	exact?: number;
	ideal?: number;
}

export external public interface ~ConvolverOptions extends AudioNodeOptions {
	buffer?: AudioBuffer;
	disableNormalization?: boolean;
}

export external public interface ~CredentialCreationOptions {
	publicKey?: PublicKeyCredentialCreationOptions;
	signal?: AbortSignal;
}

export external public interface ~CredentialPropertiesOutput {
	rk?: boolean;
}

export external public interface ~CredentialRequestOptions {
	mediation?: CredentialMediationRequirement;
	publicKey?: PublicKeyCredentialRequestOptions;
	signal?: AbortSignal;
}

export external public interface ~CryptoKeyPair {
	privateKey?: CryptoKey;
	publicKey?: CryptoKey;
}

export external public interface ~CustomEventInit<T> extends EventInit {
	detail?: T;
}

export external public interface ~DOMMatrix2DInit {
	a?: number;
	b?: number;
	c?: number;
	d?: number;
	e?: number;
	f?: number;
	m11?: number;
	m12?: number;
	m21?: number;
	m22?: number;
	m41?: number;
	m42?: number;
}

export external public interface ~DOMMatrixInit extends DOMMatrix2DInit {
	is2D?: boolean;
	m13?: number;
	m14?: number;
	m23?: number;
	m24?: number;
	m31?: number;
	m32?: number;
	m33?: number;
	m34?: number;
	m43?: number;
	m44?: number;
}

export external public interface ~DOMPointInit {
	w?: number;
	x?: number;
	y?: number;
	z?: number;
}

export external public interface ~DOMQuadInit {
	p1?: DOMPointInit;
	p2?: DOMPointInit;
	p3?: DOMPointInit;
	p4?: DOMPointInit;
}

export external public interface ~DOMRectInit {
	height?: number;
	width?: number;
	x?: number;
	y?: number;
}

export external public interface ~DelayOptions extends AudioNodeOptions {
	delayTime?: number;
	maxDelayTime?: number;
}

export external public interface ~DeviceMotionEventAccelerationInit {
	x?: number;
	y?: number;
	z?: number;
}

export external public interface ~DeviceMotionEventInit extends EventInit {
	acceleration?: DeviceMotionEventAccelerationInit;
	accelerationIncludingGravity?: DeviceMotionEventAccelerationInit;
	interval?: number;
	rotationRate?: DeviceMotionEventRotationRateInit;
}

export external public interface ~DeviceMotionEventRotationRateInit {
	alpha?: number;
	beta?: number;
	gamma?: number;
}

export external public interface ~DeviceOrientationEventInit extends EventInit {
	absolute?: boolean;
	alpha?: number;
	beta?: number;
	gamma?: number;
}

export external public interface ~DisplayMediaStreamConstraints {
	audio?: boolean | MediaTrackConstraints;
	video?: boolean | MediaTrackConstraints;
}

export external public interface ~DocumentTimelineOptions {
	originTime?: DOMHighResTimeStamp;
}

export external public interface ~DoubleRange {
	max?: number;
	min?: number;
}

export external public interface ~DragEventInit extends MouseEventInit {
	dataTransfer?: DataTransfer;
}

export external public interface ~DynamicsCompressorOptions extends AudioNodeOptions {
	attack?: number;
	knee?: number;
	ratio?: number;
	release?: number;
	threshold?: number;
}

export external public interface ~EcKeyAlgorithm extends KeyAlgorithm {
	namedCurve: NamedCurve;
}

export external public interface ~EcKeyGenParams extends Algorithm {
	namedCurve: NamedCurve;
}

export external public interface ~EcKeyImportParams extends Algorithm {
	namedCurve: NamedCurve;
}

export external public interface ~EcdhKeyDeriveParams extends Algorithm {
	public: CryptoKey;
}

export external public interface ~EcdsaParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
}

export external public interface ~EffectTiming {
	delay?: number;
	direction?: PlaybackDirection;
	duration?: number | string;
	easing?: string;
	endDelay?: number;
	fill?: FillMode;
	iterationStart?: number;
	iterations?: number;
	playbackRate?: number;
}

export external public interface ~ElementCreationOptions {
	is?: string;
}

export external public interface ~ElementDefinitionOptions {
	extends?: string;
}

export external public interface ~ErrorEventInit extends EventInit {
	colno?: number;
	error?: any;
	filename?: string;
	lineno?: number;
	message?: string;
}

export external public interface ~EventInit {
	bubbles?: boolean;
	cancelable?: boolean;
	composed?: boolean;
}

export external public interface ~EventListenerOptions {
	capture?: boolean;
}

export external public interface ~EventModifierInit extends UIEventInit {
	altKey?: boolean;
	ctrlKey?: boolean;
	metaKey?: boolean;
	modifierAltGraph?: boolean;
	modifierCapsLock?: boolean;
	modifierFn?: boolean;
	modifierFnLock?: boolean;
	modifierHyper?: boolean;
	modifierNumLock?: boolean;
	modifierScrollLock?: boolean;
	modifierSuper?: boolean;
	modifierSymbol?: boolean;
	modifierSymbolLock?: boolean;
	shiftKey?: boolean;
}

export external public interface ~EventSourceInit {
	withCredentials?: boolean;
}

export external public interface ~FilePropertyBag extends BlobPropertyBag {
	lastModified?: number;
}

export external public interface ~FileSystemFlags {
	create?: boolean;
	exclusive?: boolean;
}

export external public interface ~FocusEventInit extends UIEventInit {
	relatedTarget?: EventTarget;
}

export external public interface ~FocusOptions {
	preventScroll?: boolean;
}

export external public interface ~FontFaceDescriptors {
	display?: string;
	featureSettings?: string;
	stretch?: string;
	style?: string;
	unicodeRange?: string;
	variant?: string;
	weight?: string;
}

export external public interface ~FontFaceSetLoadEventInit extends EventInit {
	fontfaces?: Array<FontFace>;
}

export external public interface ~FormDataEventInit extends EventInit {
	formData: FormData;
}

export external public interface ~FullscreenOptions {
	navigationUI?: FullscreenNavigationUI;
}

export external public interface ~GainOptions extends AudioNodeOptions {
	gain?: number;
}

export external public interface ~GamepadEventInit extends EventInit {
	gamepad: Gamepad;
}

export external public interface ~GetAnimationsOptions {
	subtree?: boolean;
}

export external public interface ~GetNotificationOptions {
	tag?: string;
}

export external public interface ~GetRootNodeOptions {
	composed?: boolean;
}

export external public interface ~HashChangeEventInit extends EventInit {
	newURL?: string;
	oldURL?: string;
}

export external public interface ~HkdfParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
	info: BufferSource;
	salt: BufferSource;
}

export external public interface ~HmacImportParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
	length?: number;
}

export external public interface ~HmacKeyAlgorithm extends KeyAlgorithm {
	hash: KeyAlgorithm;
	length: number;
}

export external public interface ~HmacKeyGenParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
	length?: number;
}

export external public interface ~IDBDatabaseInfo {
	name?: string;
	version?: number;
}

export external public interface ~IDBIndexParameters {
	multiEntry?: boolean;
	unique?: boolean;
}

export external public interface ~IDBObjectStoreParameters {
	autoIncrement?: boolean;
	keyPath?: string | Array<string>;
}

export external public interface ~IDBVersionChangeEventInit extends EventInit {
	newVersion?: number;
	oldVersion?: number;
}

export external public interface ~IIRFilterOptions extends AudioNodeOptions {
	feedback: Array<number>;
	feedforward: Array<number>;
}

export external public interface ~IdleRequestOptions {
	timeout?: number;
}

export external public interface ~ImageBitmapOptions {
	colorSpaceConversion?: ColorSpaceConversion;
	imageOrientation?: ImageOrientation;
	premultiplyAlpha?: PremultiplyAlpha;
	resizeHeight?: number;
	resizeQuality?: ResizeQuality;
	resizeWidth?: number;
}

export external public interface ~ImageBitmapRenderingContextSettings {
	alpha?: boolean;
}

export external public interface ~ImageDataSettings {
	colorSpace?: PredefinedColorSpace;
}

export external public interface ~ImportMeta {
	url: string;
}

export external public interface ~InputEventInit extends UIEventInit {
	data?: string;
	dataTransfer?: DataTransfer;
	inputType?: string;
	isComposing?: boolean;
	targetRanges?: Array<StaticRange>;
}

export external public interface ~IntersectionObserverEntryInit {
	boundingClientRect: DOMRectInit;
	intersectionRatio: number;
	intersectionRect: DOMRectInit;
	isIntersecting: boolean;
	rootBounds: DOMRectInit;
	target: Element;
	time: DOMHighResTimeStamp;
}

export external public interface ~IntersectionObserverInit {
	root?: Element | Document;
	rootMargin?: string;
	threshold?: number | Array<number>;
}

export external public interface ~JsonWebKey {
	alg?: string;
	crv?: string;
	d?: string;
	dp?: string;
	dq?: string;
	e?: string;
	ext?: boolean;
	k?: string;
	key_ops?: Array<string>;
	kty?: string;
	n?: string;
	oth?: Array<RsaOtherPrimesInfo>;
	p?: string;
	q?: string;
	qi?: string;
	use?: string;
	x?: string;
	y?: string;
}

export external public interface ~KeyAlgorithm {
	name: string;
}

export external public interface ~KeyboardEventInit extends EventModifierInit {
	charCode?: number;
	code?: string;
	isComposing?: boolean;
	key?: string;
	keyCode?: number;
	location?: number;
	repeat?: boolean;
}

export external public interface ~Keyframe {
	composite?: CompositeOperationOrAuto;
	easing?: string;
	offset?: number;
}

export external public interface ~KeyframeAnimationOptions extends KeyframeEffectOptions {
	id?: string;
}

export external public interface ~KeyframeEffectOptions extends EffectTiming {
	composite?: CompositeOperation;
	iterationComposite?: IterationCompositeOperation;
	pseudoElement?: string;
}

export external public interface ~MediaCapabilitiesDecodingInfo extends MediaCapabilitiesInfo {
	configuration?: MediaDecodingConfiguration;
}

export external public interface ~MediaCapabilitiesEncodingInfo extends MediaCapabilitiesInfo {
	configuration?: MediaEncodingConfiguration;
}

export external public interface ~MediaCapabilitiesInfo {
	powerEfficient: boolean;
	smooth: boolean;
	supported: boolean;
}

export external public interface ~MediaConfiguration {
	audio?: AudioConfiguration;
	video?: VideoConfiguration;
}

export external public interface ~MediaDecodingConfiguration extends MediaConfiguration {
	type: MediaDecodingType;
}

export external public interface ~MediaElementAudioSourceOptions {
	mediaElement: HTMLMediaElement;
}

export external public interface ~MediaEncodingConfiguration extends MediaConfiguration {
	type: MediaEncodingType;
}

export external public interface ~MediaEncryptedEventInit extends EventInit {
	initData?: ArrayBuffer;
	initDataType?: string;
}

export external public interface ~MediaImage {
	sizes?: string;
	src: string;
	type?: string;
}

export external public interface ~MediaKeyMessageEventInit extends EventInit {
	message: ArrayBuffer;
	messageType: MediaKeyMessageType;
}

export external public interface ~MediaKeySystemConfiguration {
	audioCapabilities?: Array<MediaKeySystemMediaCapability>;
	distinctiveIdentifier?: MediaKeysRequirement;
	initDataTypes?: Array<string>;
	label?: string;
	persistentState?: MediaKeysRequirement;
	sessionTypes?: Array<string>;
	videoCapabilities?: Array<MediaKeySystemMediaCapability>;
}

export external public interface ~MediaKeySystemMediaCapability {
	contentType?: string;
	encryptionScheme?: string;
	robustness?: string;
}

export external public interface ~MediaMetadataInit {
	album?: string;
	artist?: string;
	artwork?: Array<MediaImage>;
	title?: string;
}

export external public interface ~MediaPositionState {
	duration?: number;
	playbackRate?: number;
	position?: number;
}

export external public interface ~MediaQueryListEventInit extends EventInit {
	matches?: boolean;
	media?: string;
}

export external public interface ~MediaRecorderErrorEventInit extends EventInit {
	error: DOMException;
}

export external public interface ~MediaRecorderOptions {
	audioBitsPerSecond?: number;
	bitsPerSecond?: number;
	mimeType?: string;
	videoBitsPerSecond?: number;
}

export external public interface ~MediaSessionActionDetails {
	action: MediaSessionAction;
	fastSeek?: boolean;
	seekOffset?: number;
	seekTime?: number;
}

export external public interface ~MediaStreamAudioSourceOptions {
	mediaStream: MediaStream;
}

export external public interface ~MediaStreamConstraints {
	audio?: boolean | MediaTrackConstraints;
	peerIdentity?: string;
	preferCurrentTab?: boolean;
	video?: boolean | MediaTrackConstraints;
}

export external public interface ~MediaStreamTrackEventInit extends EventInit {
	track: MediaStreamTrack;
}

export external public interface ~MediaTrackCapabilities {
	aspectRatio?: DoubleRange;
	autoGainControl?: Array<boolean>;
	channelCount?: ULongRange;
	cursor?: Array<string>;
	deviceId?: string;
	displaySurface?: string;
	echoCancellation?: Array<boolean>;
	facingMode?: Array<string>;
	frameRate?: DoubleRange;
	groupId?: string;
	height?: ULongRange;
	latency?: DoubleRange;
	logicalSurface?: boolean;
	noiseSuppression?: Array<boolean>;
	resizeMode?: Array<string>;
	sampleRate?: ULongRange;
	sampleSize?: ULongRange;
	width?: ULongRange;
}

export external public interface ~MediaTrackConstraintSet {
	aspectRatio?: ConstrainDouble;
	channelCount?: ConstrainULong;
	deviceId?: ConstrainDOMString;
	echoCancellation?: ConstrainBoolean;
	facingMode?: ConstrainDOMString;
	frameRate?: ConstrainDouble;
	groupId?: ConstrainDOMString;
	height?: ConstrainULong;
	latency?: ConstrainDouble;
	sampleRate?: ConstrainULong;
	sampleSize?: ConstrainULong;
	suppressLocalAudioPlayback?: ConstrainBoolean;
	width?: ConstrainULong;
}

export external public interface ~MediaTrackConstraints extends MediaTrackConstraintSet {
	advanced?: Array<MediaTrackConstraintSet>;
}

export external public interface ~MediaTrackSettings {
	aspectRatio?: number;
	deviceId?: string;
	echoCancellation?: boolean;
	facingMode?: string;
	frameRate?: number;
	groupId?: string;
	height?: number;
	restrictOwnAudio?: boolean;
	sampleRate?: number;
	sampleSize?: number;
	width?: number;
}

export external public interface ~MediaTrackSupportedConstraints {
	aspectRatio?: boolean;
	deviceId?: boolean;
	echoCancellation?: boolean;
	facingMode?: boolean;
	frameRate?: boolean;
	groupId?: boolean;
	height?: boolean;
	sampleRate?: boolean;
	sampleSize?: boolean;
	suppressLocalAudioPlayback?: boolean;
	width?: boolean;
}

export external public interface ~MessageEventInit<T> extends EventInit {
	data?: T;
	lastEventId?: string;
	origin?: string;
	ports?: Array<MessagePort>;
	source?: MessageEventSource;
}

export external public interface ~MouseEventInit extends EventModifierInit {
	button?: number;
	buttons?: number;
	clientX?: number;
	clientY?: number;
	movementX?: number;
	movementY?: number;
	relatedTarget?: EventTarget;
	screenX?: number;
	screenY?: number;
}

export external public interface ~MultiCacheQueryOptions extends CacheQueryOptions {
	cacheName?: string;
}

export external public interface ~MutationObserverInit {
	attributeFilter?: Array<string>;
	attributeOldValue?: boolean;
	attributes?: boolean;
	characterData?: boolean;
	characterDataOldValue?: boolean;
	childList?: boolean;
	subtree?: boolean;
}

export external public interface ~NotificationAction {
	action: string;
	icon?: string;
	title: string;
}

export external public interface ~NotificationOptions {
	actions?: Array<NotificationAction>;
	badge?: string;
	body?: string;
	data?: any;
	dir?: NotificationDirection;
	icon?: string;
	image?: string;
	lang?: string;
	renotify?: boolean;
	requireInteraction?: boolean;
	silent?: boolean;
	tag?: string;
	timestamp?: DOMTimeStamp;
	vibrate?: VibratePattern;
}

export external public interface ~OfflineAudioCompletionEventInit extends EventInit {
	renderedBuffer: AudioBuffer;
}

export external public interface ~OfflineAudioContextOptions {
	length: number;
	numberOfChannels?: number;
	sampleRate: number;
}

export external public interface ~OptionalEffectTiming {
	delay?: number;
	direction?: PlaybackDirection;
	duration?: number | string;
	easing?: string;
	endDelay?: number;
	fill?: FillMode;
	iterationStart?: number;
	iterations?: number;
	playbackRate?: number;
}

export external public interface ~OscillatorOptions extends AudioNodeOptions {
	detune?: number;
	frequency?: number;
	periodicWave?: PeriodicWave;
	type?: OscillatorType;
}

export external public interface ~PageTransitionEventInit extends EventInit {
	persisted?: boolean;
}

export external public interface ~PannerOptions extends AudioNodeOptions {
	coneInnerAngle?: number;
	coneOuterAngle?: number;
	coneOuterGain?: number;
	distanceModel?: DistanceModelType;
	maxDistance?: number;
	orientationX?: number;
	orientationY?: number;
	orientationZ?: number;
	panningModel?: PanningModelType;
	positionX?: number;
	positionY?: number;
	positionZ?: number;
	refDistance?: number;
	rolloffFactor?: number;
}

export external public interface ~PaymentCurrencyAmount {
	currency: string;
	value: string;
}

export external public interface ~PaymentDetailsBase {
	displayItems?: Array<PaymentItem>;
	modifiers?: Array<PaymentDetailsModifier>;
}

export external public interface ~PaymentDetailsInit extends PaymentDetailsBase {
	id?: string;
	total: PaymentItem;
}

export external public interface ~PaymentDetailsModifier {
	additionalDisplayItems?: Array<PaymentItem>;
	data?: any;
	supportedMethods: string;
	total?: PaymentItem;
}

export external public interface ~PaymentDetailsUpdate extends PaymentDetailsBase {
	paymentMethodErrors?: any;
	total?: PaymentItem;
}

export external public interface ~PaymentItem {
	amount: PaymentCurrencyAmount;
	label: string;
	pending?: boolean;
}

export external public interface ~PaymentMethodChangeEventInit extends PaymentRequestUpdateEventInit {
	methodDetails?: any;
	methodName?: string;
}

export external public interface ~PaymentMethodData {
	data?: any;
	supportedMethods: string;
}

export external public interface ~PaymentRequestUpdateEventInit extends EventInit {}

export external public interface ~PaymentValidationErrors {
	error?: string;
	paymentMethod?: any;
}

export external public interface ~Pbkdf2Params extends Algorithm {
	hash: HashAlgorithmIdentifier;
	iterations: number;
	salt: BufferSource;
}

export external public interface ~PerformanceMarkOptions {
	detail?: any;
	startTime?: DOMHighResTimeStamp;
}

export external public interface ~PerformanceMeasureOptions {
	detail?: any;
	duration?: DOMHighResTimeStamp;
	end?: string | DOMHighResTimeStamp;
	start?: string | DOMHighResTimeStamp;
}

export external public interface ~PerformanceObserverInit {
	buffered?: boolean;
	entryTypes?: Array<string>;
	type?: string;
}

export external public interface ~PeriodicWaveConstraints {
	disableNormalization?: boolean;
}

export external public interface ~PeriodicWaveOptions extends PeriodicWaveConstraints {
	imag?: Array<number> | Float32Array;
	real?: Array<number> | Float32Array;
}

export external public interface ~PermissionDescriptor {
	name: PermissionName;
}

export external public interface ~PointerEventInit extends MouseEventInit {
	coalescedEvents?: Array<PointerEvent>;
	height?: number;
	isPrimary?: boolean;
	pointerId?: number;
	pointerType?: string;
	predictedEvents?: Array<PointerEvent>;
	pressure?: number;
	tangentialPressure?: number;
	tiltX?: number;
	tiltY?: number;
	twist?: number;
	width?: number;
}

export external public interface ~PopStateEventInit extends EventInit {
	state?: any;
}

export external public interface ~PositionOptions {
	enableHighAccuracy?: boolean;
	maximumAge?: number;
	timeout?: number;
}

export external public interface ~ProgressEventInit extends EventInit {
	lengthComputable?: boolean;
	loaded?: number;
	total?: number;
}

export external public interface ~PromiseRejectionEventInit extends EventInit {
	promise: Promise<any>;
	reason?: any;
}

export external public interface ~PropertyIndexedKeyframes {
	composite?: CompositeOperationOrAuto | Array<CompositeOperationOrAuto>;
	easing?: string | Array<string>;
	offset?: number | Array<number>;
}

export external public interface ~PublicKeyCredentialCreationOptions {
	attestation?: AttestationConveyancePreference;
	authenticatorSelection?: AuthenticatorSelectionCriteria;
	challenge: BufferSource;
	excludeCredentials?: Array<PublicKeyCredentialDescriptor>;
	extensions?: AuthenticationExtensionsClientInputs;
	pubKeyCredParams: Array<PublicKeyCredentialParameters>;
	rp: PublicKeyCredentialRpEntity;
	timeout?: number;
	user: PublicKeyCredentialUserEntity;
}

export external public interface ~PublicKeyCredentialDescriptor {
	id: BufferSource;
	transports?: Array<AuthenticatorTransport>;
	type: PublicKeyCredentialType;
}

export external public interface ~PublicKeyCredentialEntity {
	name: string;
}

export external public interface ~PublicKeyCredentialParameters {
	alg: COSEAlgorithmIdentifier;
	type: PublicKeyCredentialType;
}

export external public interface ~PublicKeyCredentialRequestOptions {
	allowCredentials?: Array<PublicKeyCredentialDescriptor>;
	challenge: BufferSource;
	extensions?: AuthenticationExtensionsClientInputs;
	rpId?: string;
	timeout?: number;
	userVerification?: UserVerificationRequirement;
}

export external public interface ~PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {
	id?: string;
}

export external public interface ~PublicKeyCredentialUserEntity extends PublicKeyCredentialEntity {
	displayName: string;
	id: BufferSource;
}

export external public interface ~PushSubscriptionJSON {
	endpoint?: string;
	expirationTime?: DOMTimeStamp;
	keys?: Record<string,string>;
}

export external public interface ~PushSubscriptionOptionsInit {
	applicationServerKey?: BufferSource | string;
	userVisibleOnly?: boolean;
}

export external public interface ~QueuingStrategy<T> {
	highWaterMark?: number;
	size?: QueuingStrategySize<T>;
}

export external public interface ~QueuingStrategyInit {
	highWaterMark: number;
}

export external public interface ~RTCAnswerOptions extends RTCOfferAnswerOptions {}

export external public interface ~RTCCertificateExpiration {
	expires?: DOMTimeStamp;
}

export external public interface ~RTCConfiguration {
	bundlePolicy?: RTCBundlePolicy;
	certificates?: Array<RTCCertificate>;
	iceCandidatePoolSize?: number;
	iceServers?: Array<RTCIceServer>;
	iceTransportPolicy?: RTCIceTransportPolicy;
	rtcpMuxPolicy?: RTCRtcpMuxPolicy;
}

export external public interface ~RTCDTMFToneChangeEventInit extends EventInit {
	tone?: string;
}

export external public interface ~RTCDataChannelEventInit extends EventInit {
	channel: RTCDataChannel;
}

export external public interface ~RTCDataChannelInit {
	id?: number;
	maxPacketLifeTime?: number;
	maxRetransmits?: number;
	negotiated?: boolean;
	ordered?: boolean;
	protocol?: string;
}

export external public interface ~RTCDtlsFingerprint {
	algorithm?: string;
	value?: string;
}

export external public interface ~RTCIceCandidateInit {
	candidate?: string;
	sdpMLineIndex?: number;
	sdpMid?: string;
	usernameFragment?: string;
}

export external public interface ~RTCIceCandidatePairStats extends RTCStats {
	availableIncomingBitrate?: number;
	availableOutgoingBitrate?: number;
	bytesReceived?: number;
	bytesSent?: number;
	currentRoundTripTime?: number;
	localCandidateId: string;
	nominated?: boolean;
	remoteCandidateId: string;
	requestsReceived?: number;
	requestsSent?: number;
	responsesReceived?: number;
	responsesSent?: number;
	state: RTCStatsIceCandidatePairState;
	totalRoundTripTime?: number;
	transportId: string;
}

export external public interface ~RTCIceServer {
	credential?: string;
	credentialType?: RTCIceCredentialType;
	urls: string | Array<string>;
	username?: string;
}

export external public interface ~RTCInboundRtpStreamStats extends RTCReceivedRtpStreamStats {
	firCount?: number;
	framesDecoded?: number;
	nackCount?: number;
	pliCount?: number;
	qpSum?: number;
	remoteId?: string;
}

export external public interface ~RTCLocalSessionDescriptionInit {
	sdp?: string;
	type?: RTCSdpType;
}

export external public interface ~RTCOfferAnswerOptions {}

export external public interface ~RTCOfferOptions extends RTCOfferAnswerOptions {
	iceRestart?: boolean;
	offerToReceiveAudio?: boolean;
	offerToReceiveVideo?: boolean;
}

export external public interface ~RTCOutboundRtpStreamStats extends RTCSentRtpStreamStats {
	firCount?: number;
	framesEncoded?: number;
	nackCount?: number;
	pliCount?: number;
	qpSum?: number;
	remoteId?: string;
}

export external public interface ~RTCPeerConnectionIceErrorEventInit extends EventInit {
	address?: string;
	errorCode: number;
	errorText?: string;
	port?: number;
	url?: string;
}

export external public interface ~RTCPeerConnectionIceEventInit extends EventInit {
	candidate?: RTCIceCandidate;
	url?: string;
}

export external public interface ~RTCReceivedRtpStreamStats extends RTCRtpStreamStats {
	jitter?: number;
	packetsDiscarded?: number;
	packetsLost?: number;
	packetsReceived?: number;
}

export external public interface ~RTCRtcpParameters {
	cname?: string;
	reducedSize?: boolean;
}

export external public interface ~RTCRtpCapabilities {
	codecs: Array<RTCRtpCodecCapability>;
	headerExtensions: Array<RTCRtpHeaderExtensionCapability>;
}

export external public interface ~RTCRtpCodecCapability {
	channels?: number;
	clockRate: number;
	mimeType: string;
	sdpFmtpLine?: string;
}

export external public interface ~RTCRtpCodecParameters {
	channels?: number;
	clockRate: number;
	mimeType: string;
	payloadType: number;
	sdpFmtpLine?: string;
}

export external public interface ~RTCRtpCodingParameters {
	rid?: string;
}

export external public interface ~RTCRtpContributingSource {
	audioLevel?: number;
	rtpTimestamp: number;
	source: number;
	timestamp: DOMHighResTimeStamp;
}

export external public interface ~RTCRtpEncodingParameters extends RTCRtpCodingParameters {
	active?: boolean;
	maxBitrate?: number;
	priority?: RTCPriorityType;
	scaleResolutionDownBy?: number;
}

export external public interface ~RTCRtpHeaderExtensionCapability {
	uri?: string;
}

export external public interface ~RTCRtpHeaderExtensionParameters {
	encrypted?: boolean;
	id: number;
	uri: string;
}

export external public interface ~RTCRtpParameters {
	codecs: Array<RTCRtpCodecParameters>;
	headerExtensions: Array<RTCRtpHeaderExtensionParameters>;
	rtcp: RTCRtcpParameters;
}

export external public interface ~RTCRtpReceiveParameters extends RTCRtpParameters {}

export external public interface ~RTCRtpSendParameters extends RTCRtpParameters {
	degradationPreference?: RTCDegradationPreference;
	encodings: Array<RTCRtpEncodingParameters>;
	transactionId: string;
}

export external public interface ~RTCRtpStreamStats extends RTCStats {
	codecId?: string;
	kind: string;
	ssrc: number;
	transportId?: string;
}

export external public interface ~RTCRtpSynchronizationSource extends RTCRtpContributingSource {}

export external public interface ~RTCRtpTransceiverInit {
	direction?: RTCRtpTransceiverDirection;
	sendEncodings?: Array<RTCRtpEncodingParameters>;
	streams?: Array<MediaStream>;
}

export external public interface ~RTCSentRtpStreamStats extends RTCRtpStreamStats {
	bytesSent?: number;
	packetsSent?: number;
}

export external public interface ~RTCSessionDescriptionInit {
	sdp?: string;
	type: RTCSdpType;
}

export external public interface ~RTCStats {
	id: string;
	timestamp: DOMHighResTimeStamp;
	type: RTCStatsType;
}

export external public interface ~RTCTrackEventInit extends EventInit {
	receiver: RTCRtpReceiver;
	streams?: Array<MediaStream>;
	track: MediaStreamTrack;
	transceiver: RTCRtpTransceiver;
}

export external public interface ~RTCTransportStats extends RTCStats {
	bytesReceived?: number;
	bytesSent?: number;
	dtlsCipher?: string;
	dtlsState: RTCDtlsTransportState;
	localCertificateId?: string;
	remoteCertificateId?: string;
	rtcpTransportStatsId?: string;
	selectedCandidatePairId?: string;
	srtpCipher?: string;
	tlsVersion?: string;
}

export external public interface ~ReadableStreamDefaultReadDoneResult {
	done: true;
	value?: undefined;
}

export external public interface ~ReadableStreamDefaultReadValueResult<T> {
	done: false;
	value: T;
}

export external public interface ~ReadableWritablePair<R,W> {
	readable: ReadableStream<R>;
	writable: WritableStream<W>;
}

export external public interface ~RegistrationOptions {
	scope?: string;
	type?: WorkerType;
	updateViaCache?: ServiceWorkerUpdateViaCache;
}

export external public interface ~RequestInit {
	body?: BodyInit;
	cache?: RequestCache;
	credentials?: RequestCredentials;
	headers?: HeadersInit;
	integrity?: string;
	keepalive?: boolean;
	method?: string;
	mode?: RequestMode;
	redirect?: RequestRedirect;
	referrer?: string;
	referrerPolicy?: ReferrerPolicy;
	signal?: AbortSignal;
	window?: any;
}

export external public interface ~ResizeObserverOptions {
	box?: ResizeObserverBoxOptions;
}

export external public interface ~ResponseInit {
	headers?: HeadersInit;
	status?: number;
	statusText?: string;
}

export external public interface ~RsaHashedImportParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
}

export external public interface ~RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {
	hash: KeyAlgorithm;
}

export external public interface ~RsaHashedKeyGenParams extends RsaKeyGenParams {
	hash: HashAlgorithmIdentifier;
}

export external public interface ~RsaKeyAlgorithm extends KeyAlgorithm {
	modulusLength: number;
	publicExponent: BigInteger;
}

export external public interface ~RsaKeyGenParams extends Algorithm {
	modulusLength: number;
	publicExponent: BigInteger;
}

export external public interface ~RsaOaepParams extends Algorithm {
	label?: BufferSource;
}

export external public interface ~RsaOtherPrimesInfo {
	d?: string;
	r?: string;
	t?: string;
}

export external public interface ~RsaPssParams extends Algorithm {
	saltLength: number;
}

export external public interface ~SVGBoundingBoxOptions {
	clipped?: boolean;
	fill?: boolean;
	markers?: boolean;
	stroke?: boolean;
}

export external public interface ~ScrollIntoViewOptions extends ScrollOptions {
	block?: ScrollLogicalPosition;
	inline?: ScrollLogicalPosition;
}

export external public interface ~ScrollOptions {
	behavior?: ScrollBehavior;
}

export external public interface ~ScrollToOptions extends ScrollOptions {
	left?: number;
	top?: number;
}

export external public interface ~SecurityPolicyViolationEventInit extends EventInit {
	blockedURI?: string;
	columnNumber?: number;
	disposition: SecurityPolicyViolationEventDisposition;
	documentURI: string;
	effectiveDirective: string;
	lineNumber?: number;
	originalPolicy: string;
	referrer?: string;
	sample?: string;
	sourceFile?: string;
	statusCode: number;
	violatedDirective: string;
}

export external public interface ~ShadowRootInit {
	delegatesFocus?: boolean;
	mode: ShadowRootMode;
	slotAssignment?: SlotAssignmentMode;
}

export external public interface ~ShareData {
	files?: Array<File>;
	text?: string;
	title?: string;
	url?: string;
}

export external public interface ~SpeechSynthesisErrorEventInit extends SpeechSynthesisEventInit {
	error: SpeechSynthesisErrorCode;
}

export external public interface ~SpeechSynthesisEventInit extends EventInit {
	charIndex?: number;
	charLength?: number;
	elapsedTime?: number;
	name?: string;
	utterance: SpeechSynthesisUtterance;
}

export external public interface ~StaticRangeInit {
	endContainer: Node;
	endOffset: number;
	startContainer: Node;
	startOffset: number;
}

export external public interface ~StereoPannerOptions extends AudioNodeOptions {
	pan?: number;
}

export external public interface ~StorageEstimate {
	quota?: number;
	usage?: number;
}

export external public interface ~StorageEventInit extends EventInit {
	key?: string;
	newValue?: string;
	oldValue?: string;
	storageArea?: Storage;
	url?: string;
}

export external public interface ~StreamPipeOptions {
	preventAbort?: boolean;
	preventCancel?: boolean;
	preventClose?: boolean;
	signal?: AbortSignal;
}

export external public interface ~StructuredSerializeOptions {
	transfer?: Array<any>;
}

export external public interface ~SubmitEventInit extends EventInit {
	submitter?: HTMLElement;
}

export external public interface ~TextDecodeOptions {
	stream?: boolean;
}

export external public interface ~TextDecoderOptions {
	fatal?: boolean;
	ignoreBOM?: boolean;
}

export external public interface ~TextEncoderEncodeIntoResult {
	read?: number;
	written?: number;
}

export external public interface ~TouchEventInit extends EventModifierInit {
	changedTouches?: Array<Touch>;
	targetTouches?: Array<Touch>;
	touches?: Array<Touch>;
}

export external public interface ~TouchInit {
	altitudeAngle?: number;
	azimuthAngle?: number;
	clientX?: number;
	clientY?: number;
	force?: number;
	identifier: number;
	pageX?: number;
	pageY?: number;
	radiusX?: number;
	radiusY?: number;
	rotationAngle?: number;
	screenX?: number;
	screenY?: number;
	target: EventTarget;
	touchType?: TouchType;
}

export external public interface ~TrackEventInit extends EventInit {
	track?: TextTrack;
}

export external public interface ~Transformer<I,O> {
	flush?: TransformerFlushCallback<O>;
	readableType?: undefined;
	start?: TransformerStartCallback<O>;
	transform?: TransformerTransformCallback<I,O>;
	writableType?: undefined;
}

export external public interface ~TransitionEventInit extends EventInit {
	elapsedTime?: number;
	propertyName?: string;
	pseudoElement?: string;
}

export external public interface ~UIEventInit extends EventInit {
	detail?: number;
	view?: Window;
	which?: number;
}

export external public interface ~ULongRange {
	max?: number;
	min?: number;
}

export external public interface ~UnderlyingSink<W> {
	abort?: UnderlyingSinkAbortCallback;
	close?: UnderlyingSinkCloseCallback;
	start?: UnderlyingSinkStartCallback;
	type?: undefined;
	write?: UnderlyingSinkWriteCallback<W>;
}

export external public interface ~UnderlyingSource<R> {
	cancel?: UnderlyingSourceCancelCallback;
	pull?: UnderlyingSourcePullCallback<R>;
	start?: UnderlyingSourceStartCallback<R>;
	type?: undefined;
}

export external public interface ~VideoConfiguration {
	bitrate: number;
	colorGamut?: ColorGamut;
	contentType: string;
	framerate: number;
	hdrMetadataType?: HdrMetadataType;
	height: number;
	scalabilityMode?: string;
	transferFunction?: TransferFunction;
	width: number;
}

export external public interface ~WaveShaperOptions extends AudioNodeOptions {
	curve?: Array<number> | Float32Array;
	oversample?: OverSampleType;
}

export external public interface ~WebGLContextAttributes {
	alpha?: boolean;
	antialias?: boolean;
	depth?: boolean;
	desynchronized?: boolean;
	failIfMajorPerformanceCaveat?: boolean;
	powerPreference?: WebGLPowerPreference;
	premultipliedAlpha?: boolean;
	preserveDrawingBuffer?: boolean;
	stencil?: boolean;
}

export external public interface ~WebGLContextEventInit extends EventInit {
	statusMessage?: string;
}

export external public interface ~WheelEventInit extends MouseEventInit {
	deltaMode?: number;
	deltaX?: number;
	deltaY?: number;
	deltaZ?: number;
}

export external public interface ~WindowPostMessageOptions extends StructuredSerializeOptions {
	targetOrigin?: string;
}

export external public interface ~WorkerOptions {
	credentials?: RequestCredentials;
	name?: string;
	type?: WorkerType;
}

export external public interface ~WorkletOptions {
	credentials?: RequestCredentials;
}

export external public type NodeFilter = ((node: Node)=>number) | ~Object with { acceptNode(node: Node): number; };

var NodeFilter: ~Object with { get FILTER_ACCEPT(): number; get FILTER_REJECT(): number; get FILTER_SKIP(): number; get SHOW_ALL(): number; get SHOW_ATTRIBUTE(): number; get SHOW_CDATA_SECTION(): number; get SHOW_COMMENT(): number; get SHOW_DOCUMENT(): number; get SHOW_DOCUMENT_FRAGMENT(): number; get SHOW_DOCUMENT_TYPE(): number; get SHOW_ELEMENT(): number; get SHOW_ENTITY(): number; get SHOW_ENTITY_REFERENCE(): number; get SHOW_NOTATION(): number; get SHOW_PROCESSING_INSTRUCTION(): number; get SHOW_TEXT(): number; };

export external public type XPathNSResolver = ((prefix: string)=>string) | ~Object with { lookupNamespaceURI(prefix: string): string; };

export external public interface ~ANGLE_instanced_arrays {
	drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei): void;
	drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, primcount: GLsizei): void;
	vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint): void;
	get VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE(): GLenum;
}

export external public interface ~ARIAMixin {
	ariaAtomic: string;
	ariaAutoComplete: string;
	ariaBusy: string;
	ariaChecked: string;
	ariaColCount: string;
	ariaColIndex: string;
	ariaColSpan: string;
	ariaCurrent: string;
	ariaDisabled: string;
	ariaExpanded: string;
	ariaHasPopup: string;
	ariaHidden: string;
	ariaKeyShortcuts: string;
	ariaLabel: string;
	ariaLevel: string;
	ariaLive: string;
	ariaModal: string;
	ariaMultiLine: string;
	ariaMultiSelectable: string;
	ariaOrientation: string;
	ariaPlaceholder: string;
	ariaPosInSet: string;
	ariaPressed: string;
	ariaReadOnly: string;
	ariaRequired: string;
	ariaRoleDescription: string;
	ariaRowCount: string;
	ariaRowIndex: string;
	ariaRowSpan: string;
	ariaSelected: string;
	ariaSetSize: string;
	ariaSort: string;
	ariaValueMax: string;
	ariaValueMin: string;
	ariaValueNow: string;
	ariaValueText: string;
}

export external public class AbortController {
	public get signal(): AbortSignal;
	public abort(): void;
	public constructor();
}

export external public interface ~AbortSignalEventMap {
	abort: Event;
}

export external public class AbortSignal extends EventTarget {
	public get aborted(): boolean;
	public onabort: ({@This(AbortSignal) function(ev: Event): any});
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class AbstractRange {
	public get collapsed(): boolean;
	public get endContainer(): Node;
	public get endOffset(): number;
	public get startContainer(): Node;
	public get startOffset(): number;
	public constructor();
}

export external public interface ~AbstractWorkerEventMap {
	error: ErrorEvent;
}

export external public interface ~AbstractWorker {
	onerror: ({@This(AbstractWorker) function(ev: ErrorEvent): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public class AnalyserNode extends AudioNode {
	public fftSize: number;
	public get frequencyBinCount(): number;
	public maxDecibels: number;
	public minDecibels: number;
	public smoothingTimeConstant: number;
	public getByteFrequencyData(array: Uint8Array): void;
	public getByteTimeDomainData(array: Uint8Array): void;
	public getFloatFrequencyData(array: Float32Array): void;
	public getFloatTimeDomainData(array: Float32Array): void;
	public constructor(context: BaseAudioContext, options: AnalyserOptions = );
}

export external public interface ~Animatable {
	animate(keyframes: Array<Keyframe> | PropertyIndexedKeyframes, options: number | KeyframeAnimationOptions = ): Animation;
	getAnimations(options: GetAnimationsOptions = ): Array<Animation>;
}

export external public interface ~AnimationEventMap {
	cancel: AnimationPlaybackEvent;
	finish: AnimationPlaybackEvent;
	remove: Event;
}

export external public class Animation extends EventTarget {
	public currentTime: number;
	public effect: AnimationEffect;
	public get finished(): Promise<Animation>;
	public id: string;
	public oncancel: ({@This(Animation) function(ev: AnimationPlaybackEvent): any});
	public onfinish: ({@This(Animation) function(ev: AnimationPlaybackEvent): any});
	public onremove: ({@This(Animation) function(ev: Event): any});
	public get pending(): boolean;
	public get playState(): AnimationPlayState;
	public playbackRate: number;
	public get ready(): Promise<Animation>;
	public get replaceState(): AnimationReplaceState;
	public startTime: number;
	public timeline: AnimationTimeline;
	public cancel(): void;
	public commitStyles(): void;
	public finish(): void;
	public pause(): void;
	public persist(): void;
	public play(): void;
	public reverse(): void;
	public updatePlaybackRate(playbackRate: number): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(effect: AnimationEffect = , timeline: AnimationTimeline = );
}

export external public class AnimationEffect {
	public getComputedTiming(): ComputedEffectTiming;
	public getTiming(): EffectTiming;
	public updateTiming(timing: OptionalEffectTiming = ): void;
	public constructor();
}

export external public class AnimationEvent extends Event {
	public get animationName(): string;
	public get elapsedTime(): number;
	public get pseudoElement(): string;
	public constructor(type: string, animationEventInitDict: AnimationEventInit = );
}

export external public interface ~AnimationFrameProvider {
	cancelAnimationFrame(handle: number): void;
	requestAnimationFrame(callback: FrameRequestCallback): number;
}

export external public class AnimationPlaybackEvent extends Event {
	public get currentTime(): number;
	public get timelineTime(): number;
	public constructor(type: string, eventInitDict: AnimationPlaybackEventInit = );
}

export external public class AnimationTimeline {
	public get currentTime(): number;
	public constructor();
}

export external public class Attr extends Node {
	public get localName(): string;
	public get name(): string;
	public get namespaceURI(): string;
	@Override
	public get ownerDocument(): Document;
	public get ownerElement(): Element;
	public get prefix(): string;
	public get specified(): boolean;
	public value: string;
	public constructor();
}

export external public class AudioBuffer {
	public get duration(): number;
	public get length(): number;
	public get numberOfChannels(): number;
	public get sampleRate(): number;
	public copyFromChannel(destination: Float32Array, channelNumber: number, bufferOffset: number = ): void;
	public copyToChannel(source: Float32Array, channelNumber: number, bufferOffset: number = ): void;
	public getChannelData(channel: number): Float32Array;
	public constructor(options: AudioBufferOptions);
}

export external public class AudioBufferSourceNode extends AudioScheduledSourceNode {
	public buffer: AudioBuffer;
	public get detune(): AudioParam;
	public loop: boolean;
	public loopEnd: number;
	public loopStart: number;
	public get playbackRate(): AudioParam;
	@Override
	public start(when: number = , offset: number = , duration: number = ): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(context: BaseAudioContext, options: AudioBufferSourceOptions = );
}

export external public class AudioContext extends BaseAudioContext {
	public get baseLatency(): number;
	public close(): Promise<void>;
	public createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode;
	public createMediaStreamDestination(): MediaStreamAudioDestinationNode;
	public createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode;
	public getOutputTimestamp(): AudioTimestamp;
	public resume(): Promise<void>;
	public suspend(): Promise<void>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(contextOptions: AudioContextOptions = );
}

export external public class AudioDestinationNode extends AudioNode {
	public get maxChannelCount(): number;
	public constructor();
}

export external public class AudioListener {
	public get forwardX(): AudioParam;
	public get forwardY(): AudioParam;
	public get forwardZ(): AudioParam;
	public get positionX(): AudioParam;
	public get positionY(): AudioParam;
	public get positionZ(): AudioParam;
	public get upX(): AudioParam;
	public get upY(): AudioParam;
	public get upZ(): AudioParam;
	public setOrientation(x: number, y: number, z: number, xUp: number, yUp: number, zUp: number): void;
	public setPosition(x: number, y: number, z: number): void;
	public constructor();
}

export external public class AudioNode extends EventTarget {
	public channelCount: number;
	public channelCountMode: ChannelCountMode;
	public channelInterpretation: ChannelInterpretation;
	public get context(): BaseAudioContext;
	public get numberOfInputs(): number;
	public get numberOfOutputs(): number;
	public connect(...args: any+): any+; // overloading not supported
	public disconnect(...args: any+): any+; // overloading not supported
	public constructor();
}

export external public class AudioParam {
	public automationRate: AutomationRate;
	public get defaultValue(): number;
	public get maxValue(): number;
	public get minValue(): number;
	public value: number;
	public cancelAndHoldAtTime(cancelTime: number): AudioParam;
	public cancelScheduledValues(cancelTime: number): AudioParam;
	public exponentialRampToValueAtTime(value: number, endTime: number): AudioParam;
	public linearRampToValueAtTime(value: number, endTime: number): AudioParam;
	public setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam;
	public setValueAtTime(value: number, startTime: number): AudioParam;
	public setValueCurveAtTime(values: Array<number> | Float32Array, startTime: number, duration: number): AudioParam;
	public constructor();
}

export external public class AudioParamMap {
	public forEach(callbackfn: (value: AudioParam, key: string, parent: AudioParamMap)=>void, thisArg: any = ): void;
	public constructor();
}

export external public class AudioProcessingEvent extends Event {
	public get inputBuffer(): AudioBuffer;
	public get outputBuffer(): AudioBuffer;
	public get playbackTime(): number;
	public constructor(type: string, eventInitDict: AudioProcessingEventInit);
}

export external public interface ~AudioScheduledSourceNodeEventMap {
	ended: Event;
}

export external public class AudioScheduledSourceNode extends AudioNode {
	public onended: ({@This(AudioScheduledSourceNode) function(ev: Event): any});
	public start(when: number = ): void;
	public stop(when: number = ): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class AudioWorklet extends Worklet {
	public constructor();
}

export external public interface ~AudioWorkletNodeEventMap {
	processorerror: Event;
}

export external public class AudioWorkletNode extends AudioNode {
	public onprocessorerror: ({@This(AudioWorkletNode) function(ev: Event): any});
	public get parameters(): AudioParamMap;
	public get port(): MessagePort;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(context: BaseAudioContext, name: string, options: AudioWorkletNodeOptions = );
}

export external public class AuthenticatorAssertionResponse extends AuthenticatorResponse {
	public get authenticatorData(): ArrayBuffer;
	public get signature(): ArrayBuffer;
	public get userHandle(): ArrayBuffer;
	public constructor();
}

export external public class AuthenticatorAttestationResponse extends AuthenticatorResponse {
	public get attestationObject(): ArrayBuffer;
	public constructor();
}

export external public class AuthenticatorResponse {
	public get clientDataJSON(): ArrayBuffer;
	public constructor();
}

export external public class BarProp {
	public get visible(): boolean;
	public constructor();
}

export external public interface ~BaseAudioContextEventMap {
	statechange: Event;
}

export external public class BaseAudioContext extends EventTarget {
	public get audioWorklet(): AudioWorklet;
	public get currentTime(): number;
	public get destination(): AudioDestinationNode;
	public get listener(): AudioListener;
	public onstatechange: ({@This(BaseAudioContext) function(ev: Event): any});
	public get sampleRate(): number;
	public get state(): AudioContextState;
	public createAnalyser(): AnalyserNode;
	public createBiquadFilter(): BiquadFilterNode;
	public createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;
	public createBufferSource(): AudioBufferSourceNode;
	public createChannelMerger(numberOfInputs: number = ): ChannelMergerNode;
	public createChannelSplitter(numberOfOutputs: number = ): ChannelSplitterNode;
	public createConstantSource(): ConstantSourceNode;
	public createConvolver(): ConvolverNode;
	public createDelay(maxDelayTime: number = ): DelayNode;
	public createDynamicsCompressor(): DynamicsCompressorNode;
	public createGain(): GainNode;
	public createIIRFilter(feedforward: Array<number>, feedback: Array<number>): IIRFilterNode;
	public createOscillator(): OscillatorNode;
	public createPanner(): PannerNode;
	public createPeriodicWave(real: Array<number> | Float32Array, imag: Array<number> | Float32Array, constraints: PeriodicWaveConstraints = ): PeriodicWave;
	public createScriptProcessor(bufferSize: number = , numberOfInputChannels: number = , numberOfOutputChannels: number = ): ScriptProcessorNode;
	public createStereoPanner(): StereoPannerNode;
	public createWaveShaper(): WaveShaperNode;
	public decodeAudioData(audioData: ArrayBuffer, successCallback: DecodeSuccessCallback = , errorCallback: DecodeErrorCallback = ): Promise<AudioBuffer>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class BeforeUnloadEvent extends Event {
	public returnValue: any;
	public constructor();
}

export external public class BiquadFilterNode extends AudioNode {
	public get Q(): AudioParam;
	public get detune(): AudioParam;
	public get frequency(): AudioParam;
	public get gain(): AudioParam;
	public type: BiquadFilterType;
	public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
	public constructor(context: BaseAudioContext, options: BiquadFilterOptions = );
}

export external public class Blob {
	public get size(): number;
	public get type(): string;
	public arrayBuffer(): Promise<ArrayBuffer>;
	public slice(start: number = , end: number = , contentType: string = ): Blob;
	public stream(): ReadableStream;
	public text(): Promise<string>;
	public constructor(blobParts: Array<BlobPart> = , options: BlobPropertyBag = );
}

export external public class BlobEvent extends Event {
	public get data(): Blob;
	public get timecode(): DOMHighResTimeStamp;
	public constructor(type: string, eventInitDict: BlobEventInit);
}

export external public interface ~Body {
	get body(): ReadableStream<Uint8Array>;
	get bodyUsed(): boolean;
	arrayBuffer(): Promise<ArrayBuffer>;
	blob(): Promise<Blob>;
	formData(): Promise<FormData>;
	json(): Promise<any>;
	text(): Promise<string>;
}

export external public interface ~BroadcastChannelEventMap {
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public class BroadcastChannel extends EventTarget {
	public get name(): string;
	public onmessage: ({@This(BroadcastChannel) function(ev: MessageEvent): any});
	public onmessageerror: ({@This(BroadcastChannel) function(ev: MessageEvent): any});
	public close(): void;
	public postMessage(message: any): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(name: string);
}

export external public class ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView> {
	public get highWaterMark(): number;
	public get size(): QueuingStrategySize<ArrayBufferView>;
	public constructor(init: QueuingStrategyInit);
}

export external public class CDATASection extends Text {
	public constructor();
}

export external public class CSSAnimation extends Animation {
	public get animationName(): string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class CSSConditionRule extends CSSGroupingRule {
	public conditionText: string;
	public constructor();
}

export external public class CSSCounterStyleRule extends CSSRule {
	public additiveSymbols: string;
	public fallback: string;
	public name: string;
	public negative: string;
	public pad: string;
	public prefix: string;
	public range: string;
	public speakAs: string;
	public suffix: string;
	public symbols: string;
	public system: string;
	public constructor();
}

export external public class CSSFontFaceRule extends CSSRule {
	public get style(): CSSStyleDeclaration;
	public constructor();
}

export external public class CSSGroupingRule extends CSSRule {
	public get cssRules(): CSSRuleList;
	public deleteRule(index: number): void;
	public insertRule(rule: string, index: number = ): number;
	public constructor();
}

export external public class CSSImportRule extends CSSRule {
	public get href(): string;
	public get media(): MediaList;
	public get styleSheet(): CSSStyleSheet;
	public constructor();
}

export external public class CSSKeyframeRule extends CSSRule {
	public keyText: string;
	public get style(): CSSStyleDeclaration;
	public constructor();
}

export external public class CSSKeyframesRule extends CSSRule {
	public get cssRules(): CSSRuleList;
	public name: string;
	public appendRule(rule: string): void;
	public deleteRule(select: string): void;
	public findRule(select: string): CSSKeyframeRule;
	public constructor();
}

export external public class CSSMediaRule extends CSSConditionRule {
	public get media(): MediaList;
	public constructor();
}

export external public class CSSNamespaceRule extends CSSRule {
	public get namespaceURI(): string;
	public get prefix(): string;
	public constructor();
}

export external public class CSSPageRule extends CSSGroupingRule {
	public selectorText: string;
	public get style(): CSSStyleDeclaration;
	public constructor();
}

export external public class CSSRule {
	public cssText: string;
	public get parentRule(): CSSRule;
	public get parentStyleSheet(): CSSStyleSheet;
	public get type(): number;
	public get CHARSET_RULE(): number;
	public get FONT_FACE_RULE(): number;
	public get IMPORT_RULE(): number;
	public get KEYFRAMES_RULE(): number;
	public get KEYFRAME_RULE(): number;
	public get MEDIA_RULE(): number;
	public get NAMESPACE_RULE(): number;
	public get PAGE_RULE(): number;
	public get STYLE_RULE(): number;
	public get SUPPORTS_RULE(): number;
	public constructor();
	public static get CHARSET_RULE(): number;
	public static get FONT_FACE_RULE(): number;
	public static get IMPORT_RULE(): number;
	public static get KEYFRAMES_RULE(): number;
	public static get KEYFRAME_RULE(): number;
	public static get MEDIA_RULE(): number;
	public static get NAMESPACE_RULE(): number;
	public static get PAGE_RULE(): number;
	public static get STYLE_RULE(): number;
	public static get SUPPORTS_RULE(): number;
}

export external public class CSSRuleList {
	public get length(): number;
	public item(index: number): CSSRule;
	public constructor();
}

export external public class CSSStyleDeclaration {
	public alignContent: string;
	public alignItems: string;
	public alignSelf: string;
	public alignmentBaseline: string;
	public all: string;
	public animation: string;
	public animationDelay: string;
	public animationDirection: string;
	public animationDuration: string;
	public animationFillMode: string;
	public animationIterationCount: string;
	public animationName: string;
	public animationPlayState: string;
	public animationTimingFunction: string;
	public appearance: string;
	public aspectRatio: string;
	public backfaceVisibility: string;
	public background: string;
	public backgroundAttachment: string;
	public backgroundBlendMode: string;
	public backgroundClip: string;
	public backgroundColor: string;
	public backgroundImage: string;
	public backgroundOrigin: string;
	public backgroundPosition: string;
	public backgroundPositionX: string;
	public backgroundPositionY: string;
	public backgroundRepeat: string;
	public backgroundSize: string;
	public baselineShift: string;
	public blockSize: string;
	public border: string;
	public borderBlock: string;
	public borderBlockColor: string;
	public borderBlockEnd: string;
	public borderBlockEndColor: string;
	public borderBlockEndStyle: string;
	public borderBlockEndWidth: string;
	public borderBlockStart: string;
	public borderBlockStartColor: string;
	public borderBlockStartStyle: string;
	public borderBlockStartWidth: string;
	public borderBlockStyle: string;
	public borderBlockWidth: string;
	public borderBottom: string;
	public borderBottomColor: string;
	public borderBottomLeftRadius: string;
	public borderBottomRightRadius: string;
	public borderBottomStyle: string;
	public borderBottomWidth: string;
	public borderCollapse: string;
	public borderColor: string;
	public borderEndEndRadius: string;
	public borderEndStartRadius: string;
	public borderImage: string;
	public borderImageOutset: string;
	public borderImageRepeat: string;
	public borderImageSlice: string;
	public borderImageSource: string;
	public borderImageWidth: string;
	public borderInline: string;
	public borderInlineColor: string;
	public borderInlineEnd: string;
	public borderInlineEndColor: string;
	public borderInlineEndStyle: string;
	public borderInlineEndWidth: string;
	public borderInlineStart: string;
	public borderInlineStartColor: string;
	public borderInlineStartStyle: string;
	public borderInlineStartWidth: string;
	public borderInlineStyle: string;
	public borderInlineWidth: string;
	public borderLeft: string;
	public borderLeftColor: string;
	public borderLeftStyle: string;
	public borderLeftWidth: string;
	public borderRadius: string;
	public borderRight: string;
	public borderRightColor: string;
	public borderRightStyle: string;
	public borderRightWidth: string;
	public borderSpacing: string;
	public borderStartEndRadius: string;
	public borderStartStartRadius: string;
	public borderStyle: string;
	public borderTop: string;
	public borderTopColor: string;
	public borderTopLeftRadius: string;
	public borderTopRightRadius: string;
	public borderTopStyle: string;
	public borderTopWidth: string;
	public borderWidth: string;
	public bottom: string;
	public boxShadow: string;
	public boxSizing: string;
	public breakAfter: string;
	public breakBefore: string;
	public breakInside: string;
	public captionSide: string;
	public caretColor: string;
	public clear: string;
	public clip: string;
	public clipPath: string;
	public clipRule: string;
	public color: string;
	public colorInterpolation: string;
	public colorInterpolationFilters: string;
	public colorScheme: string;
	public columnCount: string;
	public columnFill: string;
	public columnGap: string;
	public columnRule: string;
	public columnRuleColor: string;
	public columnRuleStyle: string;
	public columnRuleWidth: string;
	public columnSpan: string;
	public columnWidth: string;
	public columns: string;
	public contain: string;
	public content: string;
	public counterIncrement: string;
	public counterReset: string;
	public counterSet: string;
	public cssFloat: string;
	public cssText: string;
	public cursor: string;
	public direction: string;
	public display: string;
	public dominantBaseline: string;
	public emptyCells: string;
	public fill: string;
	public fillOpacity: string;
	public fillRule: string;
	public filter: string;
	public flex: string;
	public flexBasis: string;
	public flexDirection: string;
	public flexFlow: string;
	public flexGrow: string;
	public flexShrink: string;
	public flexWrap: string;
	public float: string;
	public floodColor: string;
	public floodOpacity: string;
	public font: string;
	public fontFamily: string;
	public fontFeatureSettings: string;
	public fontKerning: string;
	public fontOpticalSizing: string;
	public fontSize: string;
	public fontSizeAdjust: string;
	public fontStretch: string;
	public fontStyle: string;
	public fontSynthesis: string;
	public fontVariant: string;
	public fontVariantAlternates: string;
	public fontVariantCaps: string;
	public fontVariantEastAsian: string;
	public fontVariantLigatures: string;
	public fontVariantNumeric: string;
	public fontVariantPosition: string;
	public fontVariationSettings: string;
	public fontWeight: string;
	public gap: string;
	public grid: string;
	public gridArea: string;
	public gridAutoColumns: string;
	public gridAutoFlow: string;
	public gridAutoRows: string;
	public gridColumn: string;
	public gridColumnEnd: string;
	public gridColumnGap: string;
	public gridColumnStart: string;
	public gridGap: string;
	public gridRow: string;
	public gridRowEnd: string;
	public gridRowGap: string;
	public gridRowStart: string;
	public gridTemplate: string;
	public gridTemplateAreas: string;
	public gridTemplateColumns: string;
	public gridTemplateRows: string;
	public height: string;
	public hyphens: string;
	public imageOrientation: string;
	public imageRendering: string;
	public inlineSize: string;
	public inset: string;
	public insetBlock: string;
	public insetBlockEnd: string;
	public insetBlockStart: string;
	public insetInline: string;
	public insetInlineEnd: string;
	public insetInlineStart: string;
	public isolation: string;
	public justifyContent: string;
	public justifyItems: string;
	public justifySelf: string;
	public left: string;
	public get length(): number;
	public letterSpacing: string;
	public lightingColor: string;
	public lineBreak: string;
	public lineHeight: string;
	public listStyle: string;
	public listStyleImage: string;
	public listStylePosition: string;
	public listStyleType: string;
	public margin: string;
	public marginBlock: string;
	public marginBlockEnd: string;
	public marginBlockStart: string;
	public marginBottom: string;
	public marginInline: string;
	public marginInlineEnd: string;
	public marginInlineStart: string;
	public marginLeft: string;
	public marginRight: string;
	public marginTop: string;
	public marker: string;
	public markerEnd: string;
	public markerMid: string;
	public markerStart: string;
	public mask: string;
	public maskType: string;
	public maxBlockSize: string;
	public maxHeight: string;
	public maxInlineSize: string;
	public maxWidth: string;
	public minBlockSize: string;
	public minHeight: string;
	public minInlineSize: string;
	public minWidth: string;
	public mixBlendMode: string;
	public objectFit: string;
	public objectPosition: string;
	public offset: string;
	public offsetAnchor: string;
	public offsetDistance: string;
	public offsetPath: string;
	public offsetRotate: string;
	public opacity: string;
	public order: string;
	public orphans: string;
	public outline: string;
	public outlineColor: string;
	public outlineOffset: string;
	public outlineStyle: string;
	public outlineWidth: string;
	public overflow: string;
	public overflowAnchor: string;
	public overflowWrap: string;
	public overflowX: string;
	public overflowY: string;
	public overscrollBehavior: string;
	public overscrollBehaviorBlock: string;
	public overscrollBehaviorInline: string;
	public overscrollBehaviorX: string;
	public overscrollBehaviorY: string;
	public padding: string;
	public paddingBlock: string;
	public paddingBlockEnd: string;
	public paddingBlockStart: string;
	public paddingBottom: string;
	public paddingInline: string;
	public paddingInlineEnd: string;
	public paddingInlineStart: string;
	public paddingLeft: string;
	public paddingRight: string;
	public paddingTop: string;
	public pageBreakAfter: string;
	public pageBreakBefore: string;
	public pageBreakInside: string;
	public paintOrder: string;
	public get parentRule(): CSSRule;
	public perspective: string;
	public perspectiveOrigin: string;
	public placeContent: string;
	public placeItems: string;
	public placeSelf: string;
	public pointerEvents: string;
	public position: string;
	public quotes: string;
	public resize: string;
	public right: string;
	public rotate: string;
	public rowGap: string;
	public rubyPosition: string;
	public scale: string;
	public scrollBehavior: string;
	public scrollMargin: string;
	public scrollMarginBlock: string;
	public scrollMarginBlockEnd: string;
	public scrollMarginBlockStart: string;
	public scrollMarginBottom: string;
	public scrollMarginInline: string;
	public scrollMarginInlineEnd: string;
	public scrollMarginInlineStart: string;
	public scrollMarginLeft: string;
	public scrollMarginRight: string;
	public scrollMarginTop: string;
	public scrollPadding: string;
	public scrollPaddingBlock: string;
	public scrollPaddingBlockEnd: string;
	public scrollPaddingBlockStart: string;
	public scrollPaddingBottom: string;
	public scrollPaddingInline: string;
	public scrollPaddingInlineEnd: string;
	public scrollPaddingInlineStart: string;
	public scrollPaddingLeft: string;
	public scrollPaddingRight: string;
	public scrollPaddingTop: string;
	public scrollSnapAlign: string;
	public scrollSnapStop: string;
	public scrollSnapType: string;
	public shapeImageThreshold: string;
	public shapeMargin: string;
	public shapeOutside: string;
	public shapeRendering: string;
	public stopColor: string;
	public stopOpacity: string;
	public stroke: string;
	public strokeDasharray: string;
	public strokeDashoffset: string;
	public strokeLinecap: string;
	public strokeLinejoin: string;
	public strokeMiterlimit: string;
	public strokeOpacity: string;
	public strokeWidth: string;
	public tabSize: string;
	public tableLayout: string;
	public textAlign: string;
	public textAlignLast: string;
	public textAnchor: string;
	public textCombineUpright: string;
	public textDecoration: string;
	public textDecorationColor: string;
	public textDecorationLine: string;
	public textDecorationSkipInk: string;
	public textDecorationStyle: string;
	public textDecorationThickness: string;
	public textEmphasis: string;
	public textEmphasisColor: string;
	public textEmphasisPosition: string;
	public textEmphasisStyle: string;
	public textIndent: string;
	public textOrientation: string;
	public textOverflow: string;
	public textRendering: string;
	public textShadow: string;
	public textTransform: string;
	public textUnderlineOffset: string;
	public textUnderlinePosition: string;
	public top: string;
	public touchAction: string;
	public transform: string;
	public transformBox: string;
	public transformOrigin: string;
	public transformStyle: string;
	public transition: string;
	public transitionDelay: string;
	public transitionDuration: string;
	public transitionProperty: string;
	public transitionTimingFunction: string;
	public translate: string;
	public unicodeBidi: string;
	public userSelect: string;
	public verticalAlign: string;
	public visibility: string;
	public webkitAlignContent: string;
	public webkitAlignItems: string;
	public webkitAlignSelf: string;
	public webkitAnimation: string;
	public webkitAnimationDelay: string;
	public webkitAnimationDirection: string;
	public webkitAnimationDuration: string;
	public webkitAnimationFillMode: string;
	public webkitAnimationIterationCount: string;
	public webkitAnimationName: string;
	public webkitAnimationPlayState: string;
	public webkitAnimationTimingFunction: string;
	public webkitAppearance: string;
	public webkitBackfaceVisibility: string;
	public webkitBackgroundClip: string;
	public webkitBackgroundOrigin: string;
	public webkitBackgroundSize: string;
	public webkitBorderBottomLeftRadius: string;
	public webkitBorderBottomRightRadius: string;
	public webkitBorderRadius: string;
	public webkitBorderTopLeftRadius: string;
	public webkitBorderTopRightRadius: string;
	public webkitBoxAlign: string;
	public webkitBoxFlex: string;
	public webkitBoxOrdinalGroup: string;
	public webkitBoxOrient: string;
	public webkitBoxPack: string;
	public webkitBoxShadow: string;
	public webkitBoxSizing: string;
	public webkitFilter: string;
	public webkitFlex: string;
	public webkitFlexBasis: string;
	public webkitFlexDirection: string;
	public webkitFlexFlow: string;
	public webkitFlexGrow: string;
	public webkitFlexShrink: string;
	public webkitFlexWrap: string;
	public webkitJustifyContent: string;
	public webkitLineClamp: string;
	public webkitMask: string;
	public webkitMaskBoxImage: string;
	public webkitMaskBoxImageOutset: string;
	public webkitMaskBoxImageRepeat: string;
	public webkitMaskBoxImageSlice: string;
	public webkitMaskBoxImageSource: string;
	public webkitMaskBoxImageWidth: string;
	public webkitMaskClip: string;
	public webkitMaskComposite: string;
	public webkitMaskImage: string;
	public webkitMaskOrigin: string;
	public webkitMaskPosition: string;
	public webkitMaskRepeat: string;
	public webkitMaskSize: string;
	public webkitOrder: string;
	public webkitPerspective: string;
	public webkitPerspectiveOrigin: string;
	public webkitTextFillColor: string;
	public webkitTextStroke: string;
	public webkitTextStrokeColor: string;
	public webkitTextStrokeWidth: string;
	public webkitTransform: string;
	public webkitTransformOrigin: string;
	public webkitTransformStyle: string;
	public webkitTransition: string;
	public webkitTransitionDelay: string;
	public webkitTransitionDuration: string;
	public webkitTransitionProperty: string;
	public webkitTransitionTimingFunction: string;
	public webkitUserSelect: string;
	public whiteSpace: string;
	public widows: string;
	public width: string;
	public willChange: string;
	public wordBreak: string;
	public wordSpacing: string;
	public wordWrap: string;
	public writingMode: string;
	public zIndex: string;
	public getPropertyPriority(property: string): string;
	public getPropertyValue(property: string): string;
	public item(index: number): string;
	public removeProperty(property: string): string;
	public setProperty(property: string, value: string, priority: string = ): void;
	public constructor();
}

export external public class CSSStyleRule extends CSSRule {
	public selectorText: string;
	public get style(): CSSStyleDeclaration;
	public constructor();
}

export external public class CSSStyleSheet extends StyleSheet {
	public get cssRules(): CSSRuleList;
	public get ownerRule(): CSSRule;
	public get rules(): CSSRuleList;
	public addRule(selector: string = , style: string = , index: number = ): number;
	public deleteRule(index: number): void;
	public insertRule(rule: string, index: number = ): number;
	public removeRule(index: number = ): void;
	public constructor(options: CSSStyleSheetInit = );
}

export external public class CSSSupportsRule extends CSSConditionRule {
	public constructor();
}

export external public class CSSTransition extends Animation {
	public get transitionProperty(): string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class Cache {
	public add(request: RequestInfo): Promise<void>;
	public addAll(requests: Array<RequestInfo>): Promise<void>;
	public delete(request: RequestInfo, options: CacheQueryOptions = ): Promise<boolean>;
	public keys(request: RequestInfo = , options: CacheQueryOptions = ): Promise<ReadonlyArray<Request>>;
	public match(request: RequestInfo, options: CacheQueryOptions = ): Promise<Response>;
	public matchAll(request: RequestInfo = , options: CacheQueryOptions = ): Promise<ReadonlyArray<Response>>;
	public put(request: RequestInfo, response: Response): Promise<void>;
	public constructor();
}

export external public class CacheStorage {
	public delete(cacheName: string): Promise<boolean>;
	public has(cacheName: string): Promise<boolean>;
	public keys(): Promise<Array<string>>;
	public match(request: RequestInfo, options: MultiCacheQueryOptions = ): Promise<Response>;
	public open(cacheName: string): Promise<Cache>;
	public constructor();
}

export external public interface ~CanvasCompositing {
	globalAlpha: number;
	globalCompositeOperation: string;
}

export external public interface ~CanvasDrawImage {
	drawImage(...args: any+): any+; // overloading not supported
}

export external public interface ~CanvasDrawPath {
	beginPath(): void;
	clip(...args: any+): any+; // overloading not supported
	fill(...args: any+): any+; // overloading not supported
	isPointInPath(...args: any+): any+; // overloading not supported
	isPointInStroke(...args: any+): any+; // overloading not supported
	stroke(...args: any+): any+; // overloading not supported
}

export external public interface ~CanvasFillStrokeStyles {
	fillStyle: string | CanvasGradient | CanvasPattern;
	strokeStyle: string | CanvasGradient | CanvasPattern;
	createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
	createPattern(image: CanvasImageSource, repetition: string): CanvasPattern;
	createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
}

export external public interface ~CanvasFilters {
	filter: string;
}

export external public class CanvasGradient {
	public addColorStop(offset: number, color: string): void;
	public constructor();
}

export external public interface ~CanvasImageData {
	createImageData(...args: any+): any+; // overloading not supported
	getImageData(sx: number, sy: number, sw: number, sh: number, settings: ImageDataSettings = ): ImageData;
	putImageData(...args: any+): any+; // overloading not supported
}

export external public interface ~CanvasImageSmoothing {
	imageSmoothingEnabled: boolean;
	imageSmoothingQuality: ImageSmoothingQuality;
}

export external public interface ~CanvasPath {
	arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean = ): void;
	arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
	bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
	closePath(): void;
	ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, counterclockwise: boolean = ): void;
	lineTo(x: number, y: number): void;
	moveTo(x: number, y: number): void;
	quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
	rect(x: number, y: number, w: number, h: number): void;
}

export external public interface ~CanvasPathDrawingStyles {
	lineCap: CanvasLineCap;
	lineDashOffset: number;
	lineJoin: CanvasLineJoin;
	lineWidth: number;
	miterLimit: number;
	getLineDash(): Array<number>;
	setLineDash(segments: Array<number>): void;
}

export external public class CanvasPattern {
	public setTransform(transform: DOMMatrix2DInit = ): void;
	public constructor();
}

export external public interface ~CanvasRect {
	clearRect(x: number, y: number, w: number, h: number): void;
	fillRect(x: number, y: number, w: number, h: number): void;
	strokeRect(x: number, y: number, w: number, h: number): void;
}

export external public class CanvasRenderingContext2D extends CanvasCompositing implements CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPath, CanvasPathDrawingStyles, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform, CanvasUserInterface {
	public get canvas(): HTMLCanvasElement;
	public getContextAttributes(): CanvasRenderingContext2DSettings;
	public constructor();
}

export external public interface ~CanvasShadowStyles {
	shadowBlur: number;
	shadowColor: string;
	shadowOffsetX: number;
	shadowOffsetY: number;
}

export external public interface ~CanvasState {
	restore(): void;
	save(): void;
}

export external public interface ~CanvasText {
	fillText(text: string, x: number, y: number, maxWidth: number = ): void;
	measureText(text: string): TextMetrics;
	strokeText(text: string, x: number, y: number, maxWidth: number = ): void;
}

export external public interface ~CanvasTextDrawingStyles {
	direction: CanvasDirection;
	font: string;
	textAlign: CanvasTextAlign;
	textBaseline: CanvasTextBaseline;
}

export external public interface ~CanvasTransform {
	getTransform(): DOMMatrix;
	resetTransform(): void;
	rotate(angle: number): void;
	scale(x: number, y: number): void;
	setTransform(...args: any+): any+; // overloading not supported
	transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
	translate(x: number, y: number): void;
}

export external public interface ~CanvasUserInterface {
	drawFocusIfNeeded(...args: any+): any+; // overloading not supported
}

export external public class ChannelMergerNode extends AudioNode {
	public constructor(context: BaseAudioContext, options: ChannelMergerOptions = );
}

export external public class ChannelSplitterNode extends AudioNode {
	public constructor(context: BaseAudioContext, options: ChannelSplitterOptions = );
}

export external public class CharacterData extends Node implements ChildNode, NonDocumentTypeChildNode {
	public data: string;
	public get length(): number;
	@Override
	public get ownerDocument(): Document;
	public appendData(data: string): void;
	public deleteData(offset: number, count: number): void;
	public insertData(offset: number, data: string): void;
	public replaceData(offset: number, count: number, data: string): void;
	public substringData(offset: number, count: number): string;
	public constructor();
}

export external public interface ~ChildNode extends Node {
	after(...nodes: Node | string): void;
	before(...nodes: Node | string): void;
	remove(): void;
	replaceWith(...nodes: Node | string): void;
}

export external public interface ~ClientRect extends DOMRect {}

export external public class Clipboard extends EventTarget {
	public read(): Promise<ClipboardItems>;
	public readText(): Promise<string>;
	public write(data: ClipboardItems): Promise<void>;
	public writeText(data: string): Promise<void>;
	public constructor();
}

export external public class ClipboardEvent extends Event {
	public get clipboardData(): DataTransfer;
	public constructor(type: string, eventInitDict: ClipboardEventInit = );
}

export external public class ClipboardItem {
	public get types(): ReadonlyArray<string>;
	public getType(type: string): Promise<Blob>;
	public constructor(items: Record<string,ClipboardItemDataType | PromiseLike<ClipboardItemDataType>>, options: ClipboardItemOptions = );
}

export external public class CloseEvent extends Event {
	public get code(): number;
	public get reason(): string;
	public get wasClean(): boolean;
	public constructor(type: string, eventInitDict: CloseEventInit = );
}

export external public class Comment extends CharacterData {
	public constructor(data: string = );
}

export external public class CompositionEvent extends UIEvent {
	public get data(): string;
	public initCompositionEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , viewArg: WindowProxy = , dataArg: string = ): void;
	public constructor(type: string, eventInitDict: CompositionEventInit = );
}

export external public class ConstantSourceNode extends AudioScheduledSourceNode {
	public get offset(): AudioParam;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(context: BaseAudioContext, options: ConstantSourceOptions = );
}

export external public class ConvolverNode extends AudioNode {
	public buffer: AudioBuffer;
	public normalize: boolean;
	public constructor(context: BaseAudioContext, options: ConvolverOptions = );
}

export external public class CountQueuingStrategy extends QueuingStrategy {
	public get highWaterMark(): number;
	public get size(): QueuingStrategySize;
	public constructor(init: QueuingStrategyInit);
}

export external public class Credential {
	public get id(): string;
	public get type(): string;
	public constructor();
}

export external public class CredentialsContainer {
	public create(options: CredentialCreationOptions = ): Promise<Credential>;
	public get(options: CredentialRequestOptions = ): Promise<Credential>;
	public preventSilentAccess(): Promise<void>;
	public store(credential: Credential): Promise<Credential>;
	public constructor();
}

export external public class Crypto {
	public get subtle(): SubtleCrypto;
	public <T> getRandomValues(array: T): T;
	public constructor();
}

export external public class CryptoKey {
	public get algorithm(): KeyAlgorithm;
	public get extractable(): boolean;
	public get type(): KeyType;
	public get usages(): Array<KeyUsage>;
	public constructor();
}

export external public class CustomElementRegistry {
	public define(name: string, constructor: CustomElementConstructor, options: ElementDefinitionOptions = ): void;
	public get(name: string): CustomElementConstructor;
	public upgrade(root: Node): void;
	public whenDefined(name: string): Promise<CustomElementConstructor>;
	public constructor();
}

export external public class CustomEvent<T> extends Event {
	public get detail(): T;
	public initCustomEvent(type: string, bubbles: boolean = , cancelable: boolean = , detail: T = ): void;
	public constructor(type: string, eventInitDict: CustomEventInit<T> = );
}

export external public class DOMException extends Error {
	public get code(): number;
	public get message(): string;
	public get name(): string;
	public get ABORT_ERR(): number;
	public get DATA_CLONE_ERR(): number;
	public get DOMSTRING_SIZE_ERR(): number;
	public get HIERARCHY_REQUEST_ERR(): number;
	public get INDEX_SIZE_ERR(): number;
	public get INUSE_ATTRIBUTE_ERR(): number;
	public get INVALID_ACCESS_ERR(): number;
	public get INVALID_CHARACTER_ERR(): number;
	public get INVALID_MODIFICATION_ERR(): number;
	public get INVALID_NODE_TYPE_ERR(): number;
	public get INVALID_STATE_ERR(): number;
	public get NAMESPACE_ERR(): number;
	public get NETWORK_ERR(): number;
	public get NOT_FOUND_ERR(): number;
	public get NOT_SUPPORTED_ERR(): number;
	public get NO_DATA_ALLOWED_ERR(): number;
	public get NO_MODIFICATION_ALLOWED_ERR(): number;
	public get QUOTA_EXCEEDED_ERR(): number;
	public get SECURITY_ERR(): number;
	public get SYNTAX_ERR(): number;
	public get TIMEOUT_ERR(): number;
	public get TYPE_MISMATCH_ERR(): number;
	public get URL_MISMATCH_ERR(): number;
	public get VALIDATION_ERR(): number;
	public get WRONG_DOCUMENT_ERR(): number;
	public constructor(message: string = , name: string = );
	public static get ABORT_ERR(): number;
	public static get DATA_CLONE_ERR(): number;
	public static get DOMSTRING_SIZE_ERR(): number;
	public static get HIERARCHY_REQUEST_ERR(): number;
	public static get INDEX_SIZE_ERR(): number;
	public static get INUSE_ATTRIBUTE_ERR(): number;
	public static get INVALID_ACCESS_ERR(): number;
	public static get INVALID_CHARACTER_ERR(): number;
	public static get INVALID_MODIFICATION_ERR(): number;
	public static get INVALID_NODE_TYPE_ERR(): number;
	public static get INVALID_STATE_ERR(): number;
	public static get NAMESPACE_ERR(): number;
	public static get NETWORK_ERR(): number;
	public static get NOT_FOUND_ERR(): number;
	public static get NOT_SUPPORTED_ERR(): number;
	public static get NO_DATA_ALLOWED_ERR(): number;
	public static get NO_MODIFICATION_ALLOWED_ERR(): number;
	public static get QUOTA_EXCEEDED_ERR(): number;
	public static get SECURITY_ERR(): number;
	public static get SYNTAX_ERR(): number;
	public static get TIMEOUT_ERR(): number;
	public static get TYPE_MISMATCH_ERR(): number;
	public static get URL_MISMATCH_ERR(): number;
	public static get VALIDATION_ERR(): number;
	public static get WRONG_DOCUMENT_ERR(): number;
}

export external public class DOMImplementation {
	public createDocument(namespace: string, qualifiedName: string, doctype: DocumentType = ): XMLDocument;
	public createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;
	public createHTMLDocument(title: string = ): Document;
	public hasFeature(...args: any): true;
	public constructor();
}

export external public class DOMMatrix extends DOMMatrixReadOnly {
	@Override
	public a: number;
	@Override
	public b: number;
	@Override
	public c: number;
	@Override
	public d: number;
	@Override
	public e: number;
	@Override
	public f: number;
	@Override
	public m11: number;
	@Override
	public m12: number;
	@Override
	public m13: number;
	@Override
	public m14: number;
	@Override
	public m21: number;
	@Override
	public m22: number;
	@Override
	public m23: number;
	@Override
	public m24: number;
	@Override
	public m31: number;
	@Override
	public m32: number;
	@Override
	public m33: number;
	@Override
	public m34: number;
	@Override
	public m41: number;
	@Override
	public m42: number;
	@Override
	public m43: number;
	@Override
	public m44: number;
	public invertSelf(): DOMMatrix;
	public multiplySelf(other: DOMMatrixInit = ): DOMMatrix;
	public preMultiplySelf(other: DOMMatrixInit = ): DOMMatrix;
	public rotateAxisAngleSelf(x: number = , y: number = , z: number = , angle: number = ): DOMMatrix;
	public rotateFromVectorSelf(x: number = , y: number = ): DOMMatrix;
	public rotateSelf(rotX: number = , rotY: number = , rotZ: number = ): DOMMatrix;
	public scale3dSelf(scale: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	public scaleSelf(scaleX: number = , scaleY: number = , scaleZ: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	public setMatrixValue(transformList: string): DOMMatrix;
	public skewXSelf(sx: number = ): DOMMatrix;
	public skewYSelf(sy: number = ): DOMMatrix;
	public translateSelf(tx: number = , ty: number = , tz: number = ): DOMMatrix;
	public constructor(init: string | Array<number> = );
	@Override
	public static fromFloat32Array(array32: Float32Array): DOMMatrix;
	@Override
	public static fromFloat64Array(array64: Float64Array): DOMMatrix;
	@Override
	public static fromMatrix(other: DOMMatrixInit = ): DOMMatrix;
}

export external public type SVGMatrix = DOMMatrix;

var SVGMatrix: any+;

export external public type WebKitCSSMatrix = DOMMatrix;

var WebKitCSSMatrix: any+;

export external public class DOMMatrixReadOnly {
	public get a(): number;
	public get b(): number;
	public get c(): number;
	public get d(): number;
	public get e(): number;
	public get f(): number;
	public get is2D(): boolean;
	public get isIdentity(): boolean;
	public get m11(): number;
	public get m12(): number;
	public get m13(): number;
	public get m14(): number;
	public get m21(): number;
	public get m22(): number;
	public get m23(): number;
	public get m24(): number;
	public get m31(): number;
	public get m32(): number;
	public get m33(): number;
	public get m34(): number;
	public get m41(): number;
	public get m42(): number;
	public get m43(): number;
	public get m44(): number;
	public flipX(): DOMMatrix;
	public flipY(): DOMMatrix;
	public inverse(): DOMMatrix;
	public multiply(other: DOMMatrixInit = ): DOMMatrix;
	public rotate(rotX: number = , rotY: number = , rotZ: number = ): DOMMatrix;
	public rotateAxisAngle(x: number = , y: number = , z: number = , angle: number = ): DOMMatrix;
	public rotateFromVector(x: number = , y: number = ): DOMMatrix;
	public scale(scaleX: number = , scaleY: number = , scaleZ: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	public scale3d(scale: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	public scaleNonUniform(scaleX: number = , scaleY: number = ): DOMMatrix;
	public skewX(sx: number = ): DOMMatrix;
	public skewY(sy: number = ): DOMMatrix;
	public toFloat32Array(): Float32Array;
	public toFloat64Array(): Float64Array;
	public toJSON(): any;
	public transformPoint(point: DOMPointInit = ): DOMPoint;
	public translate(tx: number = , ty: number = , tz: number = ): DOMMatrix;
	@Override
	public toString(): string;
	public constructor(init: string | Array<number> = );
	public static fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly;
	public static fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly;
	public static fromMatrix(other: DOMMatrixInit = ): DOMMatrixReadOnly;
	@Override
	public static toString(): string;
}

export external public class DOMParser {
	public parseFromString(string: string, type: DOMParserSupportedType): Document;
	public constructor();
}

export external public class DOMPoint extends DOMPointReadOnly {
	@Override
	public w: number;
	@Override
	public x: number;
	@Override
	public y: number;
	@Override
	public z: number;
	public constructor(x: number = , y: number = , z: number = , w: number = );
	@Override
	public static fromPoint(other: DOMPointInit = ): DOMPoint;
}

export external public type SVGPoint = DOMPoint;

var SVGPoint: any+;

export external public class DOMPointReadOnly {
	public get w(): number;
	public get x(): number;
	public get y(): number;
	public get z(): number;
	public matrixTransform(matrix: DOMMatrixInit = ): DOMPoint;
	public toJSON(): any;
	public constructor(x: number = , y: number = , z: number = , w: number = );
	public static fromPoint(other: DOMPointInit = ): DOMPointReadOnly;
}

export external public class DOMQuad {
	public get p1(): DOMPoint;
	public get p2(): DOMPoint;
	public get p3(): DOMPoint;
	public get p4(): DOMPoint;
	public getBounds(): DOMRect;
	public toJSON(): any;
	public constructor(p1: DOMPointInit = , p2: DOMPointInit = , p3: DOMPointInit = , p4: DOMPointInit = );
	public static fromQuad(other: DOMQuadInit = ): DOMQuad;
	public static fromRect(other: DOMRectInit = ): DOMQuad;
}

export external public class DOMRect extends DOMRectReadOnly {
	@Override
	public height: number;
	@Override
	public width: number;
	@Override
	public x: number;
	@Override
	public y: number;
	public constructor(x: number = , y: number = , width: number = , height: number = );
	@Override
	public static fromRect(other: DOMRectInit = ): DOMRect;
}

export external public type SVGRect = DOMRect;

var SVGRect: any+;

export external public class DOMRectList {
	public get length(): number;
	public item(index: number): DOMRect;
	public constructor();
}

export external public class DOMRectReadOnly {
	public get bottom(): number;
	public get height(): number;
	public get left(): number;
	public get right(): number;
	public get top(): number;
	public get width(): number;
	public get x(): number;
	public get y(): number;
	public toJSON(): any;
	public constructor(x: number = , y: number = , width: number = , height: number = );
	public static fromRect(other: DOMRectInit = ): DOMRectReadOnly;
}

export external public class DOMStringList {
	public get length(): number;
	public contains(string: string): boolean;
	public item(index: number): string;
	public constructor();
}

export external public class DOMStringMap {
	public constructor();
}

export external public class DOMTokenList {
	public get length(): number;
	public value: string;
	@Override
	public toString(): string;
	public add(...tokens: string): void;
	public contains(token: string): boolean;
	public item(index: number): string;
	public remove(...tokens: string): void;
	public replace(token: string, newToken: string): boolean;
	public supports(token: string): boolean;
	public toggle(token: string, force: boolean = ): boolean;
	public forEach(callbackfn: (value: string, key: number, parent: DOMTokenList)=>void, thisArg: any = ): void;
	public constructor();
}

export external public class DataTransfer {
	public dropEffect: "none" | "copy" | "link" | "move";
	public effectAllowed: "none" | "copy" | "copyLink" | "copyMove" | "link" | "linkMove" | "move" | "all" | "uninitialized";
	public get files(): FileList;
	public get items(): DataTransferItemList;
	public get types(): ReadonlyArray<string>;
	public clearData(format: string = ): void;
	public getData(format: string): string;
	public setData(format: string, data: string): void;
	public setDragImage(image: Element, x: number, y: number): void;
	public constructor();
}

export external public class DataTransferItem {
	public get kind(): string;
	public get type(): string;
	public getAsFile(): File;
	public getAsString(callback: FunctionStringCallback): void;
	public webkitGetAsEntry(): FileSystemEntry;
	public constructor();
}

export external public class DataTransferItemList {
	public get length(): number;
	public add(...args: any+): any+; // overloading not supported
	public clear(): void;
	public remove(index: number): void;
	public constructor();
}

export external public class DelayNode extends AudioNode {
	public get delayTime(): AudioParam;
	public constructor(context: BaseAudioContext, options: DelayOptions = );
}

export external public class DeviceMotionEvent extends Event {
	public get acceleration(): DeviceMotionEventAcceleration;
	public get accelerationIncludingGravity(): DeviceMotionEventAcceleration;
	public get interval(): number;
	public get rotationRate(): DeviceMotionEventRotationRate;
	public constructor(type: string, eventInitDict: DeviceMotionEventInit = );
}

export external public interface ~DeviceMotionEventAcceleration {
	get x(): number;
	get y(): number;
	get z(): number;
}

export external public interface ~DeviceMotionEventRotationRate {
	get alpha(): number;
	get beta(): number;
	get gamma(): number;
}

export external public class DeviceOrientationEvent extends Event {
	public get absolute(): boolean;
	public get alpha(): number;
	public get beta(): number;
	public get gamma(): number;
	public constructor(type: string, eventInitDict: DeviceOrientationEventInit = );
}

export external public interface ~DocumentEventMap extends DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {
	fullscreenchange: Event;
	fullscreenerror: Event;
	pointerlockchange: Event;
	pointerlockerror: Event;
	readystatechange: Event;
	visibilitychange: Event;
}

export external public class Document extends Node implements DocumentAndElementEventHandlers, DocumentOrShadowRoot, FontFaceSource, GlobalEventHandlers, NonElementParentNode, ParentNode, XPathEvaluatorBase {
	public get URL(): string;
	public alinkColor: string;
	public get all(): HTMLAllCollection;
	public get anchors(): HTMLCollectionOf<HTMLAnchorElement>;
	public get applets(): HTMLCollection;
	public bgColor: string;
	public body: HTMLElement;
	public get characterSet(): string;
	public get charset(): string;
	public get compatMode(): string;
	public get contentType(): string;
	public cookie: string;
	public get currentScript(): HTMLOrSVGScriptElement;
	public get defaultView(): (WindowProxy & any+);
	public designMode: string;
	public dir: string;
	public get doctype(): DocumentType;
	public get documentElement(): HTMLElement;
	public get documentURI(): string;
	public domain: string;
	public get embeds(): HTMLCollectionOf<HTMLEmbedElement>;
	public fgColor: string;
	public get forms(): HTMLCollectionOf<HTMLFormElement>;
	public get fullscreen(): boolean;
	public get fullscreenEnabled(): boolean;
	public get head(): HTMLHeadElement;
	public get hidden(): boolean;
	public get images(): HTMLCollectionOf<HTMLImageElement>;
	public get implementation(): DOMImplementation;
	public get inputEncoding(): string;
	public get lastModified(): string;
	public linkColor: string;
	public get links(): HTMLCollectionOf<HTMLAnchorElement | HTMLAreaElement>;
	public get location(): Location;
	public onfullscreenchange: ({@This(Document) function(ev: Event): any});
	public onfullscreenerror: ({@This(Document) function(ev: Event): any});
	public onpointerlockchange: ({@This(Document) function(ev: Event): any});
	public onpointerlockerror: ({@This(Document) function(ev: Event): any});
	public onreadystatechange: ({@This(Document) function(ev: Event): any});
	public onvisibilitychange: ({@This(Document) function(ev: Event): any});
	@Override
	public get ownerDocument(): any+;
	public get pictureInPictureEnabled(): boolean;
	public get plugins(): HTMLCollectionOf<HTMLEmbedElement>;
	public get readyState(): DocumentReadyState;
	public get referrer(): string;
	public get rootElement(): SVGSVGElement;
	public get scripts(): HTMLCollectionOf<HTMLScriptElement>;
	public get scrollingElement(): Element;
	public get timeline(): DocumentTimeline;
	public title: string;
	public get visibilityState(): VisibilityState;
	public vlinkColor: string;
	public <T> adoptNode(node: T): T;
	public captureEvents(): void;
	public caretRangeFromPoint(x: number, y: number): Range;
	public clear(): void;
	public close(): void;
	public createAttribute(localName: string): Attr;
	public createAttributeNS(namespace: string, qualifiedName: string): Attr;
	public createCDATASection(data: string): CDATASection;
	public createComment(data: string): Comment;
	public createDocumentFragment(): DocumentFragment;
	public createElement(...args: any+): any+; // overloading not supported
	public createElementNS(...args: any+): any+; // overloading not supported
	public createEvent(...args: any+): any+; // overloading not supported
	public createNodeIterator(root: Node, whatToShow: number = , filter: NodeFilter = ): NodeIterator;
	public createProcessingInstruction(target: string, data: string): ProcessingInstruction;
	public createRange(): Range;
	public createTextNode(data: string): Text;
	public createTreeWalker(root: Node, whatToShow: number = , filter: NodeFilter = ): TreeWalker;
	public elementFromPoint(x: number, y: number): Element;
	public elementsFromPoint(x: number, y: number): Array<Element>;
	public execCommand(commandId: string, showUI: boolean = , value: string = ): boolean;
	public exitFullscreen(): Promise<void>;
	public exitPictureInPicture(): Promise<void>;
	public exitPointerLock(): void;
	@Override
	public getElementById(elementId: string): HTMLElement;
	public getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
	public getElementsByName(elementName: string): NodeListOf<HTMLElement>;
	public getElementsByTagName(...args: any+): any+; // overloading not supported
	public getElementsByTagNameNS(...args: any+): any+; // overloading not supported
	public getSelection(): Selection;
	public hasFocus(): boolean;
	public hasStorageAccess(): Promise<boolean>;
	public <T> importNode(node: T, deep: boolean = ): T;
	public open(...args: any+): any+; // overloading not supported
	public queryCommandEnabled(commandId: string): boolean;
	public queryCommandIndeterm(commandId: string): boolean;
	public queryCommandState(commandId: string): boolean;
	public queryCommandSupported(commandId: string): boolean;
	public queryCommandValue(commandId: string): string;
	public releaseEvents(): void;
	public requestStorageAccess(): Promise<void>;
	public write(...text: string): void;
	public writeln(...text: string): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~DocumentAndElementEventHandlersEventMap {
	copy: ClipboardEvent;
	cut: ClipboardEvent;
	paste: ClipboardEvent;
}

export external public interface ~DocumentAndElementEventHandlers {
	oncopy: ({@This(DocumentAndElementEventHandlers) function(ev: ClipboardEvent): any});
	oncut: ({@This(DocumentAndElementEventHandlers) function(ev: ClipboardEvent): any});
	onpaste: ({@This(DocumentAndElementEventHandlers) function(ev: ClipboardEvent): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public class DocumentFragment extends Node implements NonElementParentNode, ParentNode {
	@Override
	public get ownerDocument(): Document;
	@Override
	public getElementById(elementId: string): HTMLElement;
	public constructor();
}

export external public interface ~DocumentOrShadowRoot {
	get activeElement(): Element;
	get fullscreenElement(): Element;
	get pictureInPictureElement(): Element;
	get pointerLockElement(): Element;
	get styleSheets(): StyleSheetList;
	getAnimations(): Array<Animation>;
}

export external public class DocumentTimeline extends AnimationTimeline {
	public constructor(options: DocumentTimelineOptions = );
}

export external public class DocumentType extends Node implements ChildNode {
	public get name(): string;
	@Override
	public get ownerDocument(): Document;
	public get publicId(): string;
	public get systemId(): string;
	public constructor();
}

export external public class DragEvent extends MouseEvent {
	public get dataTransfer(): DataTransfer;
	public constructor(type: string, eventInitDict: DragEventInit = );
}

export external public class DynamicsCompressorNode extends AudioNode {
	public get attack(): AudioParam;
	public get knee(): AudioParam;
	public get ratio(): AudioParam;
	public get reduction(): number;
	public get release(): AudioParam;
	public get threshold(): AudioParam;
	public constructor(context: BaseAudioContext, options: DynamicsCompressorOptions = );
}

export external public interface ~EXT_blend_minmax {
	get MAX_EXT(): GLenum;
	get MIN_EXT(): GLenum;
}

export external public interface ~EXT_color_buffer_float {}

export external public interface ~EXT_color_buffer_half_float {
	get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT(): GLenum;
	get RGB16F_EXT(): GLenum;
	get RGBA16F_EXT(): GLenum;
	get UNSIGNED_NORMALIZED_EXT(): GLenum;
}

export external public interface ~EXT_float_blend {}

export external public interface ~EXT_frag_depth {}

export external public interface ~EXT_sRGB {
	get FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT(): GLenum;
	get SRGB8_ALPHA8_EXT(): GLenum;
	get SRGB_ALPHA_EXT(): GLenum;
	get SRGB_EXT(): GLenum;
}

export external public interface ~EXT_shader_texture_lod {}

export external public interface ~EXT_texture_compression_rgtc {
	get COMPRESSED_RED_GREEN_RGTC2_EXT(): GLenum;
	get COMPRESSED_RED_RGTC1_EXT(): GLenum;
	get COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT(): GLenum;
	get COMPRESSED_SIGNED_RED_RGTC1_EXT(): GLenum;
}

export external public interface ~EXT_texture_filter_anisotropic {
	get MAX_TEXTURE_MAX_ANISOTROPY_EXT(): GLenum;
	get TEXTURE_MAX_ANISOTROPY_EXT(): GLenum;
}

export external public interface ~ElementEventMap {
	fullscreenchange: Event;
	fullscreenerror: Event;
}

export external public class Element extends Node implements ARIAMixin, Animatable, ChildNode, InnerHTML, NonDocumentTypeChildNode, ParentNode, Slottable {
	public get attributes(): NamedNodeMap;
	public get classList(): DOMTokenList;
	public className: string;
	public get clientHeight(): number;
	public get clientLeft(): number;
	public get clientTop(): number;
	public get clientWidth(): number;
	public id: string;
	public get localName(): string;
	public get namespaceURI(): string;
	public onfullscreenchange: ({@This(Element) function(ev: Event): any});
	public onfullscreenerror: ({@This(Element) function(ev: Event): any});
	public outerHTML: string;
	@Override
	public get ownerDocument(): Document;
	public get part(): DOMTokenList;
	public get prefix(): string;
	public get scrollHeight(): number;
	public scrollLeft: number;
	public scrollTop: number;
	public get scrollWidth(): number;
	public get shadowRoot(): ShadowRoot;
	public slot: string;
	public get tagName(): string;
	public attachShadow(init: ShadowRootInit): ShadowRoot;
	public closest(...args: any+): any+; // overloading not supported
	public getAttribute(qualifiedName: string): string;
	public getAttributeNS(namespace: string, localName: string): string;
	public getAttributeNames(): Array<string>;
	public getAttributeNode(qualifiedName: string): Attr;
	public getAttributeNodeNS(namespace: string, localName: string): Attr;
	public getBoundingClientRect(): DOMRect;
	public getClientRects(): DOMRectList;
	public getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
	public getElementsByTagName(...args: any+): any+; // overloading not supported
	public getElementsByTagNameNS(...args: any+): any+; // overloading not supported
	public hasAttribute(qualifiedName: string): boolean;
	public hasAttributeNS(namespace: string, localName: string): boolean;
	public hasAttributes(): boolean;
	public hasPointerCapture(pointerId: number): boolean;
	public insertAdjacentElement(where: InsertPosition, element: Element): Element;
	public insertAdjacentHTML(position: InsertPosition, text: string): void;
	public insertAdjacentText(where: InsertPosition, data: string): void;
	public matches(selectors: string): boolean;
	public releasePointerCapture(pointerId: number): void;
	public removeAttribute(qualifiedName: string): void;
	public removeAttributeNS(namespace: string, localName: string): void;
	public removeAttributeNode(attr: Attr): Attr;
	public requestFullscreen(options: FullscreenOptions = ): Promise<void>;
	public requestPointerLock(): void;
	public scroll(...args: any+): any+; // overloading not supported
	public scrollBy(...args: any+): any+; // overloading not supported
	public scrollIntoView(arg: boolean | ScrollIntoViewOptions = ): void;
	public scrollTo(...args: any+): any+; // overloading not supported
	public setAttribute(qualifiedName: string, value: string): void;
	public setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
	public setAttributeNode(attr: Attr): Attr;
	public setAttributeNodeNS(attr: Attr): Attr;
	public setPointerCapture(pointerId: number): void;
	public toggleAttribute(qualifiedName: string, force: boolean = ): boolean;
	public webkitMatchesSelector(selectors: string): boolean;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~ElementCSSInlineStyle {
	get style(): CSSStyleDeclaration;
}

export external public interface ~ElementContentEditable {
	contentEditable: string;
	enterKeyHint: string;
	inputMode: string;
	get isContentEditable(): boolean;
}

export external public class ErrorEvent extends Event {
	public get colno(): number;
	public get error(): any;
	public get filename(): string;
	public get lineno(): number;
	public get message(): string;
	public constructor(type: string, eventInitDict: ErrorEventInit = );
}

export external public class Event {
	public get bubbles(): boolean;
	public cancelBubble: boolean;
	public get cancelable(): boolean;
	public get composed(): boolean;
	public get currentTarget(): EventTarget;
	public get defaultPrevented(): boolean;
	public get eventPhase(): number;
	public get isTrusted(): boolean;
	public returnValue: boolean;
	public get srcElement(): EventTarget;
	public get target(): EventTarget;
	public get timeStamp(): DOMHighResTimeStamp;
	public get type(): string;
	public composedPath(): Array<EventTarget>;
	public initEvent(type: string, bubbles: boolean = , cancelable: boolean = ): void;
	public preventDefault(): void;
	public stopImmediatePropagation(): void;
	public stopPropagation(): void;
	public get AT_TARGET(): number;
	public get BUBBLING_PHASE(): number;
	public get CAPTURING_PHASE(): number;
	public get NONE(): number;
	public constructor(type: string, eventInitDict: EventInit = );
	public static get AT_TARGET(): number;
	public static get BUBBLING_PHASE(): number;
	public static get CAPTURING_PHASE(): number;
	public static get NONE(): number;
}

export external public interface ~EventListener {
	(evt: Event): void;
}

export external public interface ~EventListenerObject {
	handleEvent(object: Event): void;
}

export external public interface ~EventSourceEventMap {
	error: Event;
	message: MessageEvent;
	open: Event;
}

export external public class EventSource extends EventTarget {
	public onerror: ({@This(EventSource) function(ev: Event): any});
	public onmessage: ({@This(EventSource) function(ev: MessageEvent): any});
	public onopen: ({@This(EventSource) function(ev: Event): any});
	public get readyState(): number;
	public get url(): string;
	public get withCredentials(): boolean;
	public close(): void;
	public get CLOSED(): number;
	public get CONNECTING(): number;
	public get OPEN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(url: string | URL, eventSourceInitDict: EventSourceInit = );
	public static get CLOSED(): number;
	public static get CONNECTING(): number;
	public static get OPEN(): number;
}

export external public class EventTarget {
	public addEventListener(type: string, callback: EventListenerOrEventListenerObject, options: AddEventListenerOptions | boolean = ): void;
	public dispatchEvent(event: Event): boolean;
	public removeEventListener(type: string, callback: EventListenerOrEventListenerObject, options: EventListenerOptions | boolean = ): void;
	public constructor();
}

export external public class External {
	public AddSearchProvider(): void;
	public IsSearchProviderInstalled(): void;
	public constructor();
}

export external public class File extends Blob {
	public get lastModified(): number;
	public get name(): string;
	public get webkitRelativePath(): string;
	public constructor(fileBits: Array<BlobPart>, fileName: string, options: FilePropertyBag = );
}

export external public class FileList {
	public get length(): number;
	public item(index: number): File;
	public constructor();
}

export external public interface ~FileReaderEventMap {
	abort: ProgressEvent<FileReader>;
	error: ProgressEvent<FileReader>;
	load: ProgressEvent<FileReader>;
	loadend: ProgressEvent<FileReader>;
	loadstart: ProgressEvent<FileReader>;
	progress: ProgressEvent<FileReader>;
}

export external public class FileReader extends EventTarget {
	public get error(): DOMException;
	public onabort: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	public onerror: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	public onload: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	public onloadend: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	public onloadstart: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	public onprogress: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	public get readyState(): number;
	public get result(): string | ArrayBuffer;
	public abort(): void;
	public readAsArrayBuffer(blob: Blob): void;
	public readAsBinaryString(blob: Blob): void;
	public readAsDataURL(blob: Blob): void;
	public readAsText(blob: Blob, encoding: string = ): void;
	public get DONE(): number;
	public get EMPTY(): number;
	public get LOADING(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get DONE(): number;
	public static get EMPTY(): number;
	public static get LOADING(): number;
}

export external public class FileSystem {
	public get name(): string;
	public get root(): FileSystemDirectoryEntry;
	public constructor();
}

export external public class FileSystemDirectoryEntry extends FileSystemEntry {
	public createReader(): FileSystemDirectoryReader;
	public getDirectory(path: string = , options: FileSystemFlags = , successCallback: FileSystemEntryCallback = , errorCallback: ErrorCallback = ): void;
	public getFile(path: string = , options: FileSystemFlags = , successCallback: FileSystemEntryCallback = , errorCallback: ErrorCallback = ): void;
	public constructor();
}

export external public class FileSystemDirectoryReader {
	public readEntries(successCallback: FileSystemEntriesCallback, errorCallback: ErrorCallback = ): void;
	public constructor();
}

export external public class FileSystemEntry {
	public get filesystem(): FileSystem;
	public get fullPath(): string;
	public get isDirectory(): boolean;
	public get isFile(): boolean;
	public get name(): string;
	public getParent(successCallback: FileSystemEntryCallback = , errorCallback: ErrorCallback = ): void;
	public constructor();
}

export external public class FileSystemFileEntry extends FileSystemEntry {
	public file(successCallback: FileCallback, errorCallback: ErrorCallback = ): void;
	public constructor();
}

export external public class FocusEvent extends UIEvent {
	public get relatedTarget(): EventTarget;
	public constructor(type: string, eventInitDict: FocusEventInit = );
}

export external public class FontFace {
	public ascentOverride: string;
	public descentOverride: string;
	public display: string;
	public family: string;
	public featureSettings: string;
	public lineGapOverride: string;
	public get loaded(): Promise<FontFace>;
	public get status(): FontFaceLoadStatus;
	public stretch: string;
	public style: string;
	public unicodeRange: string;
	public variant: string;
	public variationSettings: string;
	public weight: string;
	public load(): Promise<FontFace>;
	public constructor(family: string, source: string | BinaryData, descriptors: FontFaceDescriptors = );
}

export external public interface ~FontFaceSetEventMap {
	loading: Event;
	loadingdone: Event;
	loadingerror: Event;
}

export external public class FontFaceSet extends EventTarget {
	public onloading: ({@This(FontFaceSet) function(ev: Event): any});
	public onloadingdone: ({@This(FontFaceSet) function(ev: Event): any});
	public onloadingerror: ({@This(FontFaceSet) function(ev: Event): any});
	public get ready(): Promise<FontFaceSet>;
	public get status(): FontFaceSetLoadStatus;
	public check(font: string, text: string = ): boolean;
	public load(font: string, text: string = ): Promise<Array<FontFace>>;
	public forEach(callbackfn: (value: FontFace, key: FontFace, parent: FontFaceSet)=>void, thisArg: any = ): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(initialFaces: Array<FontFace>);
}

export external public class FontFaceSetLoadEvent extends Event {
	public get fontfaces(): ReadonlyArray<FontFace>;
	public constructor(type: string, eventInitDict: FontFaceSetLoadEventInit = );
}

export external public interface ~FontFaceSource {
	get fonts(): FontFaceSet;
}

export external public class FormData {
	public append(name: string, value: string | Blob, fileName: string = ): void;
	public delete(name: string): void;
	public get(name: string): FormDataEntryValue;
	public getAll(name: string): Array<FormDataEntryValue>;
	public has(name: string): boolean;
	public set(name: string, value: string | Blob, fileName: string = ): void;
	public forEach(callbackfn: (value: FormDataEntryValue, key: string, parent: FormData)=>void, thisArg: any = ): void;
	public constructor(form: HTMLFormElement = );
}

export external public class FormDataEvent extends Event {
	public get formData(): FormData;
	public constructor(type: string, eventInitDict: FormDataEventInit);
}

export external public class GainNode extends AudioNode {
	public get gain(): AudioParam;
	public constructor(context: BaseAudioContext, options: GainOptions = );
}

export external public class Gamepad {
	public get axes(): ReadonlyArray<number>;
	public get buttons(): ReadonlyArray<GamepadButton>;
	public get connected(): boolean;
	public get hapticActuators(): ReadonlyArray<GamepadHapticActuator>;
	public get id(): string;
	public get index(): number;
	public get mapping(): GamepadMappingType;
	public get timestamp(): DOMHighResTimeStamp;
	public constructor();
}

export external public class GamepadButton {
	public get pressed(): boolean;
	public get touched(): boolean;
	public get value(): number;
	public constructor();
}

export external public class GamepadEvent extends Event {
	public get gamepad(): Gamepad;
	public constructor(type: string, eventInitDict: GamepadEventInit);
}

export external public class GamepadHapticActuator {
	public get type(): GamepadHapticActuatorType;
	public constructor();
}

export external public interface ~GenericTransformStream {
	get readable(): ReadableStream;
	get writable(): WritableStream;
}

export external public class Geolocation {
	public clearWatch(watchId: number): void;
	public getCurrentPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback = , options: PositionOptions = ): void;
	public watchPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback = , options: PositionOptions = ): number;
	public constructor();
}

export external public class GeolocationCoordinates {
	public get accuracy(): number;
	public get altitude(): number;
	public get altitudeAccuracy(): number;
	public get heading(): number;
	public get latitude(): number;
	public get longitude(): number;
	public get speed(): number;
	public constructor();
}

export external public class GeolocationPosition {
	public get coords(): GeolocationCoordinates;
	public get timestamp(): DOMTimeStamp;
	public constructor();
}

export external public class GeolocationPositionError {
	public get code(): number;
	public get message(): string;
	public get PERMISSION_DENIED(): number;
	public get POSITION_UNAVAILABLE(): number;
	public get TIMEOUT(): number;
	public constructor();
	public static get PERMISSION_DENIED(): number;
	public static get POSITION_UNAVAILABLE(): number;
	public static get TIMEOUT(): number;
}

export external public interface ~GlobalEventHandlersEventMap {
	abort: UIEvent;
	animationcancel: AnimationEvent;
	animationend: AnimationEvent;
	animationiteration: AnimationEvent;
	animationstart: AnimationEvent;
	auxclick: MouseEvent;
	beforeinput: InputEvent;
	blur: FocusEvent;
	canplay: Event;
	canplaythrough: Event;
	change: Event;
	click: MouseEvent;
	close: Event;
	compositionend: CompositionEvent;
	compositionstart: CompositionEvent;
	compositionupdate: CompositionEvent;
	contextmenu: MouseEvent;
	cuechange: Event;
	dblclick: MouseEvent;
	drag: DragEvent;
	dragend: DragEvent;
	dragenter: DragEvent;
	dragleave: DragEvent;
	dragover: DragEvent;
	dragstart: DragEvent;
	drop: DragEvent;
	durationchange: Event;
	emptied: Event;
	ended: Event;
	error: ErrorEvent;
	focus: FocusEvent;
	focusin: FocusEvent;
	focusout: FocusEvent;
	formdata: FormDataEvent;
	gotpointercapture: PointerEvent;
	input: Event;
	invalid: Event;
	keydown: KeyboardEvent;
	keypress: KeyboardEvent;
	keyup: KeyboardEvent;
	load: Event;
	loadeddata: Event;
	loadedmetadata: Event;
	loadstart: Event;
	lostpointercapture: PointerEvent;
	mousedown: MouseEvent;
	mouseenter: MouseEvent;
	mouseleave: MouseEvent;
	mousemove: MouseEvent;
	mouseout: MouseEvent;
	mouseover: MouseEvent;
	mouseup: MouseEvent;
	pause: Event;
	play: Event;
	playing: Event;
	pointercancel: PointerEvent;
	pointerdown: PointerEvent;
	pointerenter: PointerEvent;
	pointerleave: PointerEvent;
	pointermove: PointerEvent;
	pointerout: PointerEvent;
	pointerover: PointerEvent;
	pointerup: PointerEvent;
	progress: ProgressEvent;
	ratechange: Event;
	reset: Event;
	resize: UIEvent;
	scroll: Event;
	securitypolicyviolation: SecurityPolicyViolationEvent;
	seeked: Event;
	seeking: Event;
	select: Event;
	selectionchange: Event;
	selectstart: Event;
	stalled: Event;
	submit: SubmitEvent;
	suspend: Event;
	timeupdate: Event;
	toggle: Event;
	touchcancel: TouchEvent;
	touchend: TouchEvent;
	touchmove: TouchEvent;
	touchstart: TouchEvent;
	transitioncancel: TransitionEvent;
	transitionend: TransitionEvent;
	transitionrun: TransitionEvent;
	transitionstart: TransitionEvent;
	volumechange: Event;
	waiting: Event;
	webkitanimationend: Event;
	webkitanimationiteration: Event;
	webkitanimationstart: Event;
	webkittransitionend: Event;
	wheel: WheelEvent;
}

export external public interface ~GlobalEventHandlers {
	onabort: ({@This(GlobalEventHandlers) function(ev: UIEvent): any});
	onanimationcancel: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onanimationend: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onanimationiteration: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onanimationstart: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onauxclick: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onblur: ({@This(GlobalEventHandlers) function(ev: FocusEvent): any});
	oncanplay: ({@This(GlobalEventHandlers) function(ev: Event): any});
	oncanplaythrough: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onchange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onclick: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onclose: ({@This(GlobalEventHandlers) function(ev: Event): any});
	oncontextmenu: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	oncuechange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ondblclick: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	ondrag: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragend: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragenter: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragleave: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragover: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragstart: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondrop: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondurationchange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onemptied: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onended: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onerror: OnErrorEventHandler;
	onfocus: ({@This(GlobalEventHandlers) function(ev: FocusEvent): any});
	onformdata: ({@This(GlobalEventHandlers) function(ev: FormDataEvent): any});
	ongotpointercapture: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	oninput: ({@This(GlobalEventHandlers) function(ev: Event): any});
	oninvalid: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onkeydown: ({@This(GlobalEventHandlers) function(ev: KeyboardEvent): any});
	onkeypress: ({@This(GlobalEventHandlers) function(ev: KeyboardEvent): any});
	onkeyup: ({@This(GlobalEventHandlers) function(ev: KeyboardEvent): any});
	onload: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onloadeddata: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onloadedmetadata: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onloadstart: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onlostpointercapture: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onmousedown: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseenter: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseleave: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmousemove: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseout: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseover: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseup: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onpause: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onplay: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onplaying: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onpointercancel: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerdown: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerenter: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerleave: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointermove: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerout: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerover: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerup: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onprogress: ({@This(GlobalEventHandlers) function(ev: ProgressEvent): any});
	onratechange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onreset: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onresize: ({@This(GlobalEventHandlers) function(ev: UIEvent): any});
	onscroll: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onseeked: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onseeking: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onselect: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onselectionchange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onselectstart: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onstalled: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onsubmit: ({@This(GlobalEventHandlers) function(ev: SubmitEvent): any});
	onsuspend: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ontimeupdate: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ontoggle: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ontouchcancel?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontouchend?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontouchmove?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontouchstart?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontransitioncancel: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	ontransitionend: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	ontransitionrun: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	ontransitionstart: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	onvolumechange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwaiting: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkitanimationend: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkitanimationiteration: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkitanimationstart: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkittransitionend: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwheel: ({@This(GlobalEventHandlers) function(ev: WheelEvent): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public class HTMLAllCollection {
	public get length(): number;
	public item(nameOrIndex: string = ): HTMLCollection | Element;
	public namedItem(name: string): HTMLCollection | Element;
	public constructor();
}

export external public class HTMLAnchorElement extends HTMLElement implements HTMLHyperlinkElementUtils {
	public charset: string;
	public coords: string;
	public download: string;
	public hreflang: string;
	public name: string;
	public ping: string;
	public referrerPolicy: string;
	public rel: string;
	public get relList(): DOMTokenList;
	public rev: string;
	public shape: string;
	public target: string;
	public text: string;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLAreaElement extends HTMLElement implements HTMLHyperlinkElementUtils {
	public alt: string;
	public coords: string;
	public download: string;
	public noHref: boolean;
	public ping: string;
	public referrerPolicy: string;
	public rel: string;
	public get relList(): DOMTokenList;
	public shape: string;
	public target: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLAudioElement extends HTMLMediaElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLBRElement extends HTMLElement {
	public clear: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLBaseElement extends HTMLElement {
	public href: string;
	public target: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLBodyElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {
	orientationchange: Event;
}

export external public class HTMLBodyElement extends HTMLElement implements WindowEventHandlers {
	public aLink: string;
	public background: string;
	public bgColor: string;
	public link: string;
	public onorientationchange: ({@This(HTMLBodyElement) function(ev: Event): any});
	public text: string;
	public vLink: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLButtonElement extends HTMLElement {
	public disabled: boolean;
	public get form(): HTMLFormElement;
	public formAction: string;
	public formEnctype: string;
	public formMethod: string;
	public formNoValidate: boolean;
	public formTarget: string;
	public get labels(): NodeListOf<HTMLLabelElement>;
	public name: string;
	public type: string;
	public get validationMessage(): string;
	public get validity(): ValidityState;
	public value: string;
	public get willValidate(): boolean;
	public checkValidity(): boolean;
	public reportValidity(): boolean;
	public setCustomValidity(error: string): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLCanvasElement extends HTMLElement {
	public height: number;
	public width: number;
	public captureStream(frameRequestRate: number = ): MediaStream;
	public getContext(...args: any+): any+; // overloading not supported
	public toBlob(callback: BlobCallback, type: string = , quality: any = ): void;
	public toDataURL(type: string = , quality: any = ): string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLCollectionBase {
	get length(): number;
	item(index: number): Element;
}

export external public class HTMLCollection extends HTMLCollectionBase {
	public namedItem(name: string): Element;
	public constructor();
}

export external public interface ~HTMLCollectionOf<T> extends HTMLCollectionBase {
	item(index: number): T;
	namedItem(name: string): T;
}

export external public class HTMLDListElement extends HTMLElement {
	public compact: boolean;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLDataElement extends HTMLElement {
	public value: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLDataListElement extends HTMLElement {
	public get options(): HTMLCollectionOf<HTMLOptionElement>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLDetailsElement extends HTMLElement {
	public open: boolean;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLDialogElement extends HTMLElement {
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public class HTMLDirectoryElement extends HTMLElement {
	public compact: boolean;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLDivElement extends HTMLElement {
	public align: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLDocument extends Document {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLElementEventMap extends ElementEventMap, DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {}

export external public class HTMLElement extends Element implements DocumentAndElementEventHandlers, ElementCSSInlineStyle, ElementContentEditable, GlobalEventHandlers, HTMLOrSVGElement {
	public accessKey: string;
	public get accessKeyLabel(): string;
	public autocapitalize: string;
	public dir: string;
	public draggable: boolean;
	public hidden: boolean;
	public innerText: string;
	public lang: string;
	public get offsetHeight(): number;
	public get offsetLeft(): number;
	public get offsetParent(): Element;
	public get offsetTop(): number;
	public get offsetWidth(): number;
	public outerText: string;
	public spellcheck: boolean;
	public title: string;
	public translate: boolean;
	public click(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLEmbedElement extends HTMLElement {
	public align: string;
	public height: string;
	public name: string;
	public src: string;
	public type: string;
	public width: string;
	public getSVGDocument(): Document;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLFieldSetElement extends HTMLElement {
	public disabled: boolean;
	public get elements(): HTMLCollection;
	public get form(): HTMLFormElement;
	public name: string;
	public get type(): string;
	public get validationMessage(): string;
	public get validity(): ValidityState;
	public get willValidate(): boolean;
	public checkValidity(): boolean;
	public reportValidity(): boolean;
	public setCustomValidity(error: string): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLFontElement extends HTMLElement {
	public color: string;
	public face: string;
	public size: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLFormControlsCollection extends HTMLCollectionBase {
	public namedItem(name: string): RadioNodeList | Element;
	public constructor();
}

export external public class HTMLFormElement extends HTMLElement {
	public acceptCharset: string;
	public action: string;
	public autocomplete: string;
	public get elements(): HTMLFormControlsCollection;
	public encoding: string;
	public enctype: string;
	public get length(): number;
	public method: string;
	public name: string;
	public noValidate: boolean;
	public target: string;
	public checkValidity(): boolean;
	public reportValidity(): boolean;
	public requestSubmit(submitter: HTMLElement = ): void;
	public reset(): void;
	public submit(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLFrameElement extends HTMLElement {
	public get contentDocument(): Document;
	public get contentWindow(): WindowProxy;
	public frameBorder: string;
	public longDesc: string;
	public marginHeight: string;
	public marginWidth: string;
	public name: string;
	public noResize: boolean;
	public scrolling: string;
	public src: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLFrameSetElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {}

export external public class HTMLFrameSetElement extends HTMLElement implements WindowEventHandlers {
	public cols: string;
	public rows: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLHRElement extends HTMLElement {
	public align: string;
	public color: string;
	public noShade: boolean;
	public size: string;
	public width: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLHeadElement extends HTMLElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLHeadingElement extends HTMLElement {
	public align: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLHtmlElement extends HTMLElement {
	public version: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLHyperlinkElementUtils {
	hash: string;
	host: string;
	hostname: string;
	href: string;
	toString(): string;
	get origin(): string;
	password: string;
	pathname: string;
	port: string;
	protocol: string;
	search: string;
	username: string;
}

export external public class HTMLIFrameElement extends HTMLElement {
	public align: string;
	public allow: string;
	public allowFullscreen: boolean;
	public get contentDocument(): Document;
	public get contentWindow(): WindowProxy;
	public frameBorder: string;
	public height: string;
	public longDesc: string;
	public marginHeight: string;
	public marginWidth: string;
	public name: string;
	public referrerPolicy: ReferrerPolicy;
	public get sandbox(): DOMTokenList;
	public scrolling: string;
	public src: string;
	public srcdoc: string;
	public width: string;
	public getSVGDocument(): Document;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLImageElement extends HTMLElement {
	public align: string;
	public alt: string;
	public border: string;
	public get complete(): boolean;
	public crossOrigin: string;
	public get currentSrc(): string;
	public decoding: "async" | "sync" | "auto";
	public height: number;
	public hspace: number;
	public isMap: boolean;
	public loading: string;
	public longDesc: string;
	public lowsrc: string;
	public name: string;
	public get naturalHeight(): number;
	public get naturalWidth(): number;
	public referrerPolicy: string;
	public sizes: string;
	public src: string;
	public srcset: string;
	public useMap: string;
	public vspace: number;
	public width: number;
	public get x(): number;
	public get y(): number;
	public decode(): Promise<void>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLInputElement extends HTMLElement {
	public accept: string;
	public align: string;
	public alt: string;
	public autocomplete: string;
	public capture: string;
	public checked: boolean;
	public defaultChecked: boolean;
	public defaultValue: string;
	public dirName: string;
	public disabled: boolean;
	public files: FileList;
	public get form(): HTMLFormElement;
	public formAction: string;
	public formEnctype: string;
	public formMethod: string;
	public formNoValidate: boolean;
	public formTarget: string;
	public height: number;
	public indeterminate: boolean;
	public get labels(): NodeListOf<HTMLLabelElement>;
	public get list(): HTMLElement;
	public max: string;
	public maxLength: number;
	public min: string;
	public minLength: number;
	public multiple: boolean;
	public name: string;
	public pattern: string;
	public placeholder: string;
	public readOnly: boolean;
	public required: boolean;
	public selectionDirection: "forward" | "backward" | "none";
	public selectionEnd: number;
	public selectionStart: number;
	public size: number;
	public src: string;
	public step: string;
	public type: string;
	public useMap: string;
	public get validationMessage(): string;
	public get validity(): ValidityState;
	public value: string;
	public valueAsDate: Date;
	public valueAsNumber: number;
	public get webkitEntries(): ReadonlyArray<FileSystemEntry>;
	public webkitdirectory: boolean;
	public width: number;
	public get willValidate(): boolean;
	public checkValidity(): boolean;
	public reportValidity(): boolean;
	public select(): void;
	public setCustomValidity(error: string): void;
	public setRangeText(...args: any+): any+; // overloading not supported
	public setSelectionRange(start: number, end: number, direction: "forward" | "backward" | "none" = ): void;
	public stepDown(n: number = ): void;
	public stepUp(n: number = ): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLLIElement extends HTMLElement {
	public type: string;
	public value: number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLLabelElement extends HTMLElement {
	public get control(): HTMLElement;
	public get form(): HTMLFormElement;
	public htmlFor: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLLegendElement extends HTMLElement {
	public align: string;
	public get form(): HTMLFormElement;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLLinkElement extends HTMLElement implements LinkStyle {
	public as: string;
	public charset: string;
	public crossOrigin: string;
	public disabled: boolean;
	public href: string;
	public hreflang: string;
	public imageSizes: string;
	public imageSrcset: string;
	public integrity: string;
	public media: string;
	public referrerPolicy: string;
	public rel: string;
	public get relList(): DOMTokenList;
	public rev: string;
	public get sizes(): DOMTokenList;
	public target: string;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLMapElement extends HTMLElement {
	public get areas(): HTMLCollection;
	public name: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLMarqueeElement extends HTMLElement {
	public behavior: string;
	public bgColor: string;
	public direction: string;
	public height: string;
	public hspace: number;
	public loop: number;
	public scrollAmount: number;
	public scrollDelay: number;
	public trueSpeed: boolean;
	public vspace: number;
	public width: string;
	public start(): void;
	public stop(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLMediaElementEventMap extends HTMLElementEventMap {
	encrypted: MediaEncryptedEvent;
	waitingforkey: Event;
}

export external public class HTMLMediaElement extends HTMLElement {
	public autoplay: boolean;
	public get buffered(): TimeRanges;
	public controls: boolean;
	public crossOrigin: string;
	public get currentSrc(): string;
	public currentTime: number;
	public defaultMuted: boolean;
	public defaultPlaybackRate: number;
	public disableRemotePlayback: boolean;
	public get duration(): number;
	public get ended(): boolean;
	public get error(): MediaError;
	public loop: boolean;
	public get mediaKeys(): MediaKeys;
	public muted: boolean;
	public get networkState(): number;
	public onencrypted: ({@This(HTMLMediaElement) function(ev: MediaEncryptedEvent): any});
	public onwaitingforkey: ({@This(HTMLMediaElement) function(ev: Event): any});
	public get paused(): boolean;
	public playbackRate: number;
	public get played(): TimeRanges;
	public preload: "none" | "metadata" | "auto" | "";
	public get readyState(): number;
	public get remote(): RemotePlayback;
	public get seekable(): TimeRanges;
	public get seeking(): boolean;
	public src: string;
	public srcObject: MediaProvider;
	public get textTracks(): TextTrackList;
	public volume: number;
	public addTextTrack(kind: TextTrackKind, label: string = , language: string = ): TextTrack;
	public canPlayType(type: string): CanPlayTypeResult;
	public fastSeek(time: number): void;
	public load(): void;
	public pause(): void;
	public play(): Promise<void>;
	public setMediaKeys(mediaKeys: MediaKeys): Promise<void>;
	public get HAVE_CURRENT_DATA(): number;
	public get HAVE_ENOUGH_DATA(): number;
	public get HAVE_FUTURE_DATA(): number;
	public get HAVE_METADATA(): number;
	public get HAVE_NOTHING(): number;
	public get NETWORK_EMPTY(): number;
	public get NETWORK_IDLE(): number;
	public get NETWORK_LOADING(): number;
	public get NETWORK_NO_SOURCE(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get HAVE_CURRENT_DATA(): number;
	public static get HAVE_ENOUGH_DATA(): number;
	public static get HAVE_FUTURE_DATA(): number;
	public static get HAVE_METADATA(): number;
	public static get HAVE_NOTHING(): number;
	public static get NETWORK_EMPTY(): number;
	public static get NETWORK_IDLE(): number;
	public static get NETWORK_LOADING(): number;
	public static get NETWORK_NO_SOURCE(): number;
}

export external public class HTMLMenuElement extends HTMLElement {
	public compact: boolean;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLMetaElement extends HTMLElement {
	public content: string;
	public httpEquiv: string;
	public name: string;
	public scheme: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLMeterElement extends HTMLElement {
	public high: number;
	public get labels(): NodeListOf<HTMLLabelElement>;
	public low: number;
	public max: number;
	public min: number;
	public optimum: number;
	public value: number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLModElement extends HTMLElement {
	public cite: string;
	public dateTime: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLOListElement extends HTMLElement {
	public compact: boolean;
	public reversed: boolean;
	public start: number;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLObjectElement extends HTMLElement {
	public align: string;
	public archive: string;
	public border: string;
	public code: string;
	public codeBase: string;
	public codeType: string;
	public get contentDocument(): Document;
	public get contentWindow(): WindowProxy;
	public data: string;
	public declare: boolean;
	public get form(): HTMLFormElement;
	public height: string;
	public hspace: number;
	public name: string;
	public standby: string;
	public type: string;
	public useMap: string;
	public get validationMessage(): string;
	public get validity(): ValidityState;
	public vspace: number;
	public width: string;
	public get willValidate(): boolean;
	public checkValidity(): boolean;
	public getSVGDocument(): Document;
	public reportValidity(): boolean;
	public setCustomValidity(error: string): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLOptGroupElement extends HTMLElement {
	public disabled: boolean;
	public label: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLOptionElement extends HTMLElement {
	public defaultSelected: boolean;
	public disabled: boolean;
	public get form(): HTMLFormElement;
	public get index(): number;
	public label: string;
	public selected: boolean;
	public text: string;
	public value: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLOptionsCollection extends HTMLCollectionOf<HTMLOptionElement> {
	@Override
	public length: number;
	public selectedIndex: number;
	public add(element: HTMLOptionElement | HTMLOptGroupElement, before: HTMLElement | number = ): void;
	public remove(index: number): void;
	public constructor();
}

export external public interface ~HTMLOrSVGElement {
	autofocus: boolean;
	get dataset(): DOMStringMap;
	nonce?: string;
	tabIndex: number;
	blur(): void;
	focus(options: FocusOptions = ): void;
}

export external public class HTMLOutputElement extends HTMLElement {
	public defaultValue: string;
	public get form(): HTMLFormElement;
	public get htmlFor(): DOMTokenList;
	public get labels(): NodeListOf<HTMLLabelElement>;
	public name: string;
	public get type(): string;
	public get validationMessage(): string;
	public get validity(): ValidityState;
	public value: string;
	public get willValidate(): boolean;
	public checkValidity(): boolean;
	public reportValidity(): boolean;
	public setCustomValidity(error: string): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLParagraphElement extends HTMLElement {
	public align: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLParamElement extends HTMLElement {
	public name: string;
	public type: string;
	public value: string;
	public valueType: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLPictureElement extends HTMLElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLPreElement extends HTMLElement {
	public width: number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLProgressElement extends HTMLElement {
	public get labels(): NodeListOf<HTMLLabelElement>;
	public max: number;
	public get position(): number;
	public value: number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLQuoteElement extends HTMLElement {
	public cite: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLScriptElement extends HTMLElement {
	public async: boolean;
	public charset: string;
	public crossOrigin: string;
	public defer: boolean;
	public event: string;
	public htmlFor: string;
	public integrity: string;
	public noModule: boolean;
	public referrerPolicy: string;
	public src: string;
	public text: string;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLSelectElement extends HTMLElement {
	public autocomplete: string;
	public disabled: boolean;
	public get form(): HTMLFormElement;
	public get labels(): NodeListOf<HTMLLabelElement>;
	public length: number;
	public multiple: boolean;
	public name: string;
	public get options(): HTMLOptionsCollection;
	public required: boolean;
	public selectedIndex: number;
	public get selectedOptions(): HTMLCollectionOf<HTMLOptionElement>;
	public size: number;
	public get type(): string;
	public get validationMessage(): string;
	public get validity(): ValidityState;
	public value: string;
	public get willValidate(): boolean;
	public add(element: HTMLOptionElement | HTMLOptGroupElement, before: HTMLElement | number = ): void;
	public checkValidity(): boolean;
	public item(index: number): HTMLOptionElement;
	public namedItem(name: string): HTMLOptionElement;
	@Override
	public remove(...args: any+): any+; // overloading not supported
	public reportValidity(): boolean;
	public setCustomValidity(error: string): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLSlotElement extends HTMLElement {
	public name: string;
	public assignedElements(options: AssignedNodesOptions = ): Array<Element>;
	public assignedNodes(options: AssignedNodesOptions = ): Array<Node>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLSourceElement extends HTMLElement {
	public media: string;
	public sizes: string;
	public src: string;
	public srcset: string;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLSpanElement extends HTMLElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLStyleElement extends HTMLElement implements LinkStyle {
	public media: string;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTableCaptionElement extends HTMLElement {
	public align: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTableCellElement extends HTMLElement {
	public abbr: string;
	public align: string;
	public axis: string;
	public bgColor: string;
	public get cellIndex(): number;
	public ch: string;
	public chOff: string;
	public colSpan: number;
	public headers: string;
	public height: string;
	public noWrap: boolean;
	public rowSpan: number;
	public scope: string;
	public vAlign: string;
	public width: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTableColElement extends HTMLElement {
	public align: string;
	public ch: string;
	public chOff: string;
	public span: number;
	public vAlign: string;
	public width: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLTableDataCellElement extends HTMLTableCellElement {
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public class HTMLTableElement extends HTMLElement {
	public align: string;
	public bgColor: string;
	public border: string;
	public caption: HTMLTableCaptionElement;
	public cellPadding: string;
	public cellSpacing: string;
	public frame: string;
	public get rows(): HTMLCollectionOf<HTMLTableRowElement>;
	public rules: string;
	public summary: string;
	public get tBodies(): HTMLCollectionOf<HTMLTableSectionElement>;
	public tFoot: HTMLTableSectionElement;
	public tHead: HTMLTableSectionElement;
	public width: string;
	public createCaption(): HTMLTableCaptionElement;
	public createTBody(): HTMLTableSectionElement;
	public createTFoot(): HTMLTableSectionElement;
	public createTHead(): HTMLTableSectionElement;
	public deleteCaption(): void;
	public deleteRow(index: number): void;
	public deleteTFoot(): void;
	public deleteTHead(): void;
	public insertRow(index: number = ): HTMLTableRowElement;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLTableHeaderCellElement extends HTMLTableCellElement {
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public class HTMLTableRowElement extends HTMLElement {
	public align: string;
	public bgColor: string;
	public get cells(): HTMLCollectionOf<HTMLTableCellElement>;
	public ch: string;
	public chOff: string;
	public get rowIndex(): number;
	public get sectionRowIndex(): number;
	public vAlign: string;
	public deleteCell(index: number): void;
	public insertCell(index: number = ): HTMLTableCellElement;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTableSectionElement extends HTMLElement {
	public align: string;
	public ch: string;
	public chOff: string;
	public get rows(): HTMLCollectionOf<HTMLTableRowElement>;
	public vAlign: string;
	public deleteRow(index: number): void;
	public insertRow(index: number = ): HTMLTableRowElement;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTemplateElement extends HTMLElement {
	public get content(): DocumentFragment;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTextAreaElement extends HTMLElement {
	public autocomplete: string;
	public cols: number;
	public defaultValue: string;
	public dirName: string;
	public disabled: boolean;
	public get form(): HTMLFormElement;
	public get labels(): NodeListOf<HTMLLabelElement>;
	public maxLength: number;
	public minLength: number;
	public name: string;
	public placeholder: string;
	public readOnly: boolean;
	public required: boolean;
	public rows: number;
	public selectionDirection: "forward" | "backward" | "none";
	public selectionEnd: number;
	public selectionStart: number;
	public get textLength(): number;
	public get type(): string;
	public get validationMessage(): string;
	public get validity(): ValidityState;
	public value: string;
	public get willValidate(): boolean;
	public wrap: string;
	public checkValidity(): boolean;
	public reportValidity(): boolean;
	public select(): void;
	public setCustomValidity(error: string): void;
	public setRangeText(...args: any+): any+; // overloading not supported
	public setSelectionRange(start: number, end: number, direction: "forward" | "backward" | "none" = ): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTimeElement extends HTMLElement {
	public dateTime: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTitleElement extends HTMLElement {
	public text: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLTrackElement extends HTMLElement {
	public default: boolean;
	public kind: string;
	public label: string;
	public get readyState(): number;
	public src: string;
	public srclang: string;
	public get track(): TextTrack;
	public get ERROR(): number;
	public get LOADED(): number;
	public get LOADING(): number;
	public get NONE(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get ERROR(): number;
	public static get LOADED(): number;
	public static get LOADING(): number;
	public static get NONE(): number;
}

export external public class HTMLUListElement extends HTMLElement {
	public compact: boolean;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HTMLUnknownElement extends HTMLElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~HTMLVideoElementEventMap extends HTMLMediaElementEventMap {
	enterpictureinpicture: Event;
	leavepictureinpicture: Event;
}

export external public class HTMLVideoElement extends HTMLMediaElement {
	public disablePictureInPicture: boolean;
	public height: number;
	public onenterpictureinpicture: ({@This(HTMLVideoElement) function(ev: Event): any});
	public onleavepictureinpicture: ({@This(HTMLVideoElement) function(ev: Event): any});
	public playsInline: boolean;
	public poster: string;
	public get videoHeight(): number;
	public get videoWidth(): number;
	public width: number;
	public getVideoPlaybackQuality(): VideoPlaybackQuality;
	public requestPictureInPicture(): Promise<PictureInPictureWindow>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class HashChangeEvent extends Event {
	public get newURL(): string;
	public get oldURL(): string;
	public constructor(type: string, eventInitDict: HashChangeEventInit = );
}

export external public class Headers {
	public append(name: string, value: string): void;
	public delete(name: string): void;
	public get(name: string): string;
	public has(name: string): boolean;
	public set(name: string, value: string): void;
	public forEach(callbackfn: (value: string, key: string, parent: Headers)=>void, thisArg: any = ): void;
	public constructor(init: HeadersInit = );
}

export external public class History {
	public get length(): number;
	public scrollRestoration: ScrollRestoration;
	public get state(): any;
	public back(): void;
	public forward(): void;
	public go(delta: number = ): void;
	public pushState(data: any, unused: string, url: string | URL = ): void;
	public replaceState(data: any, unused: string, url: string | URL = ): void;
	public constructor();
}

export external public class IDBCursor {
	public get direction(): IDBCursorDirection;
	public get key(): IDBValidKey;
	public get primaryKey(): IDBValidKey;
	public get request(): IDBRequest;
	public get source(): IDBObjectStore | IDBIndex;
	public advance(count: number): void;
	public continue(key: IDBValidKey = ): void;
	public continuePrimaryKey(key: IDBValidKey, primaryKey: IDBValidKey): void;
	public delete(): IDBRequest<undefined>;
	public update(value: any): IDBRequest<IDBValidKey>;
	public constructor();
}

export external public class IDBCursorWithValue extends IDBCursor {
	public get value(): any;
	public constructor();
}

export external public interface ~IDBDatabaseEventMap {
	abort: Event;
	close: Event;
	error: Event;
	versionchange: IDBVersionChangeEvent;
}

export external public class IDBDatabase extends EventTarget {
	public get name(): string;
	public get objectStoreNames(): DOMStringList;
	public onabort: ({@This(IDBDatabase) function(ev: Event): any});
	public onclose: ({@This(IDBDatabase) function(ev: Event): any});
	public onerror: ({@This(IDBDatabase) function(ev: Event): any});
	public onversionchange: ({@This(IDBDatabase) function(ev: IDBVersionChangeEvent): any});
	public get version(): number;
	public close(): void;
	public createObjectStore(name: string, options: IDBObjectStoreParameters = ): IDBObjectStore;
	public deleteObjectStore(name: string): void;
	public transaction(storeNames: string | Array<string>, mode: IDBTransactionMode = ): IDBTransaction;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class IDBFactory {
	public cmp(first: any, second: any): number;
	public databases(): Promise<Array<IDBDatabaseInfo>>;
	public deleteDatabase(name: string): IDBOpenDBRequest;
	public open(name: string, version: number = ): IDBOpenDBRequest;
	public constructor();
}

export external public class IDBIndex {
	public get keyPath(): string | Array<string>;
	public get multiEntry(): boolean;
	public name: string;
	public get objectStore(): IDBObjectStore;
	public get unique(): boolean;
	public count(query: IDBValidKey | IDBKeyRange = ): IDBRequest<number>;
	public get(query: IDBValidKey | IDBKeyRange): IDBRequest<any>;
	public getAll(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<any>>;
	public getAllKeys(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<IDBValidKey>>;
	public getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;
	public openCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursorWithValue>;
	public openKeyCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursor>;
	public constructor();
}

export external public class IDBKeyRange {
	public get lower(): any;
	public get lowerOpen(): boolean;
	public get upper(): any;
	public get upperOpen(): boolean;
	public includes(key: any): boolean;
	public constructor();
	public static bound(lower: any, upper: any, lowerOpen: boolean = , upperOpen: boolean = ): IDBKeyRange;
	public static lowerBound(lower: any, open: boolean = ): IDBKeyRange;
	public static only(value: any): IDBKeyRange;
	public static upperBound(upper: any, open: boolean = ): IDBKeyRange;
}

export external public class IDBObjectStore {
	public get autoIncrement(): boolean;
	public get indexNames(): DOMStringList;
	public get keyPath(): string | Array<string>;
	public name: string;
	public get transaction(): IDBTransaction;
	public add(value: any, key: IDBValidKey = ): IDBRequest<IDBValidKey>;
	public clear(): IDBRequest<undefined>;
	public count(query: IDBValidKey | IDBKeyRange = ): IDBRequest<number>;
	public createIndex(name: string, keyPath: string | Array<string>, options: IDBIndexParameters = ): IDBIndex;
	public delete(query: IDBValidKey | IDBKeyRange): IDBRequest<undefined>;
	public deleteIndex(name: string): void;
	public get(query: IDBValidKey | IDBKeyRange): IDBRequest<any>;
	public getAll(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<any>>;
	public getAllKeys(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<IDBValidKey>>;
	public getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;
	public index(name: string): IDBIndex;
	public openCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursorWithValue>;
	public openKeyCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursor>;
	public put(value: any, key: IDBValidKey = ): IDBRequest<IDBValidKey>;
	public constructor();
}

export external public interface ~IDBOpenDBRequestEventMap extends IDBRequestEventMap {
	blocked: Event;
	upgradeneeded: IDBVersionChangeEvent;
}

export external public class IDBOpenDBRequest extends IDBRequest<IDBDatabase> {
	public onblocked: ({@This(IDBOpenDBRequest) function(ev: Event): any});
	public onupgradeneeded: ({@This(IDBOpenDBRequest) function(ev: IDBVersionChangeEvent): any});
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~IDBRequestEventMap {
	error: Event;
	success: Event;
}

export external public class IDBRequest<T> extends EventTarget {
	public get error(): DOMException;
	public onerror: ({@This(IDBRequest<T>) function(ev: Event): any});
	public onsuccess: ({@This(IDBRequest<T>) function(ev: Event): any});
	public get readyState(): IDBRequestReadyState;
	public get result(): T;
	public get source(): IDBObjectStore | IDBIndex | IDBCursor;
	public get transaction(): IDBTransaction;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~IDBTransactionEventMap {
	abort: Event;
	complete: Event;
	error: Event;
}

export external public class IDBTransaction extends EventTarget {
	public get db(): IDBDatabase;
	public get error(): DOMException;
	public get mode(): IDBTransactionMode;
	public get objectStoreNames(): DOMStringList;
	public onabort: ({@This(IDBTransaction) function(ev: Event): any});
	public oncomplete: ({@This(IDBTransaction) function(ev: Event): any});
	public onerror: ({@This(IDBTransaction) function(ev: Event): any});
	public abort(): void;
	public commit(): void;
	public objectStore(name: string): IDBObjectStore;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class IDBVersionChangeEvent extends Event {
	public get newVersion(): number;
	public get oldVersion(): number;
	public constructor(type: string, eventInitDict: IDBVersionChangeEventInit = );
}

export external public class IIRFilterNode extends AudioNode {
	public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
	public constructor(context: BaseAudioContext, options: IIRFilterOptions);
}

export external public class IdleDeadline {
	public get didTimeout(): boolean;
	public timeRemaining(): DOMHighResTimeStamp;
	public constructor();
}

export external public class ImageBitmap {
	public get height(): number;
	public get width(): number;
	public close(): void;
	public constructor();
}

export external public class ImageBitmapRenderingContext {
	public get canvas(): HTMLCanvasElement;
	public transferFromImageBitmap(bitmap: ImageBitmap): void;
	public constructor();
}

export external public class ImageData {
	public get data(): Uint8ClampedArray;
	public get height(): number;
	public get width(): number;
	public constructor(...args: any+); // overloading not supported
}

export external public interface ~InnerHTML {
	innerHTML: string;
}

export external public class InputEvent extends UIEvent {
	public get data(): string;
	public get dataTransfer(): DataTransfer;
	public get inputType(): string;
	public get isComposing(): boolean;
	public getTargetRanges(): Array<StaticRange>;
	public constructor(type: string, eventInitDict: InputEventInit = );
}

export external public class IntersectionObserver {
	public get root(): Element | Document;
	public get rootMargin(): string;
	public get thresholds(): ReadonlyArray<number>;
	public disconnect(): void;
	public observe(target: Element): void;
	public takeRecords(): Array<IntersectionObserverEntry>;
	public unobserve(target: Element): void;
	public constructor(callback: IntersectionObserverCallback, options: IntersectionObserverInit = );
}

export external public class IntersectionObserverEntry {
	public get boundingClientRect(): DOMRectReadOnly;
	public get intersectionRatio(): number;
	public get intersectionRect(): DOMRectReadOnly;
	public get isIntersecting(): boolean;
	public get rootBounds(): DOMRectReadOnly;
	public get target(): Element;
	public get time(): DOMHighResTimeStamp;
	public constructor(intersectionObserverEntryInit: IntersectionObserverEntryInit);
}

export external public interface ~KHR_parallel_shader_compile {
	get COMPLETION_STATUS_KHR(): GLenum;
}

export external public class KeyboardEvent extends UIEvent {
	public get altKey(): boolean;
	public get charCode(): number;
	public get code(): string;
	public get ctrlKey(): boolean;
	public get isComposing(): boolean;
	public get key(): string;
	public get keyCode(): number;
	public get location(): number;
	public get metaKey(): boolean;
	public get repeat(): boolean;
	public get shiftKey(): boolean;
	public getModifierState(keyArg: string): boolean;
	public initKeyboardEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , viewArg: Window = , keyArg: string = , locationArg: number = , ctrlKey: boolean = , altKey: boolean = , shiftKey: boolean = , metaKey: boolean = ): void;
	public get DOM_KEY_LOCATION_LEFT(): number;
	public get DOM_KEY_LOCATION_NUMPAD(): number;
	public get DOM_KEY_LOCATION_RIGHT(): number;
	public get DOM_KEY_LOCATION_STANDARD(): number;
	public constructor(type: string, eventInitDict: KeyboardEventInit = );
	public static get DOM_KEY_LOCATION_LEFT(): number;
	public static get DOM_KEY_LOCATION_NUMPAD(): number;
	public static get DOM_KEY_LOCATION_RIGHT(): number;
	public static get DOM_KEY_LOCATION_STANDARD(): number;
}

export external public class KeyframeEffect extends AnimationEffect {
	public composite: CompositeOperation;
	public iterationComposite: IterationCompositeOperation;
	public pseudoElement: string;
	public target: Element;
	public getKeyframes(): Array<ComputedKeyframe>;
	public setKeyframes(keyframes: Array<Keyframe> | PropertyIndexedKeyframes): void;
	public constructor(...args: any+); // overloading not supported
}

export external public interface ~LinkStyle {
	get sheet(): CSSStyleSheet;
}

export external public class Location {
	public get ancestorOrigins(): DOMStringList;
	public hash: string;
	public host: string;
	public hostname: string;
	public href: string;
	@Override
	public toString(): string;
	public get origin(): string;
	public pathname: string;
	public port: string;
	public protocol: string;
	public search: string;
	public assign(url: string | URL): void;
	public reload(): void;
	public replace(url: string | URL): void;
	public constructor();
}

export external public interface ~MathMLElementEventMap extends ElementEventMap, DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {}

export external public class MathMLElement extends Element implements DocumentAndElementEventHandlers, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrSVGElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class MediaCapabilities {
	public decodingInfo(configuration: MediaDecodingConfiguration): Promise<MediaCapabilitiesDecodingInfo>;
	public encodingInfo(configuration: MediaEncodingConfiguration): Promise<MediaCapabilitiesEncodingInfo>;
	public constructor();
}

export external public class MediaDeviceInfo {
	public get deviceId(): string;
	public get groupId(): string;
	public get kind(): MediaDeviceKind;
	public get label(): string;
	public toJSON(): any;
	public constructor();
}

export external public interface ~MediaDevicesEventMap {
	devicechange: Event;
}

export external public class MediaDevices extends EventTarget {
	public ondevicechange: ({@This(MediaDevices) function(ev: Event): any});
	public enumerateDevices(): Promise<Array<MediaDeviceInfo>>;
	public getDisplayMedia(constraints: DisplayMediaStreamConstraints = ): Promise<MediaStream>;
	public getSupportedConstraints(): MediaTrackSupportedConstraints;
	public getUserMedia(constraints: MediaStreamConstraints = ): Promise<MediaStream>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class MediaElementAudioSourceNode extends AudioNode {
	public get mediaElement(): HTMLMediaElement;
	public constructor(context: AudioContext, options: MediaElementAudioSourceOptions);
}

export external public class MediaEncryptedEvent extends Event {
	public get initData(): ArrayBuffer;
	public get initDataType(): string;
	public constructor(type: string, eventInitDict: MediaEncryptedEventInit = );
}

export external public class MediaError {
	public get code(): number;
	public get message(): string;
	public get MEDIA_ERR_ABORTED(): number;
	public get MEDIA_ERR_DECODE(): number;
	public get MEDIA_ERR_NETWORK(): number;
	public get MEDIA_ERR_SRC_NOT_SUPPORTED(): number;
	public constructor();
	public static get MEDIA_ERR_ABORTED(): number;
	public static get MEDIA_ERR_DECODE(): number;
	public static get MEDIA_ERR_NETWORK(): number;
	public static get MEDIA_ERR_SRC_NOT_SUPPORTED(): number;
}

export external public class MediaKeyMessageEvent extends Event {
	public get message(): ArrayBuffer;
	public get messageType(): MediaKeyMessageType;
	public constructor(type: string, eventInitDict: MediaKeyMessageEventInit);
}

export external public interface ~MediaKeySessionEventMap {
	keystatuseschange: Event;
	message: MediaKeyMessageEvent;
}

export external public class MediaKeySession extends EventTarget {
	public get closed(): Promise<MediaKeySessionClosedReason>;
	public get expiration(): number;
	public get keyStatuses(): MediaKeyStatusMap;
	public onkeystatuseschange: ({@This(MediaKeySession) function(ev: Event): any});
	public onmessage: ({@This(MediaKeySession) function(ev: MediaKeyMessageEvent): any});
	public get sessionId(): string;
	public close(): Promise<void>;
	public generateRequest(initDataType: string, initData: BufferSource): Promise<void>;
	public load(sessionId: string): Promise<boolean>;
	public remove(): Promise<void>;
	public update(response: BufferSource): Promise<void>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class MediaKeyStatusMap {
	public get size(): number;
	public get(keyId: BufferSource): MediaKeyStatus;
	public has(keyId: BufferSource): boolean;
	public forEach(callbackfn: (value: MediaKeyStatus, key: BufferSource, parent: MediaKeyStatusMap)=>void, thisArg: any = ): void;
	public constructor();
}

export external public class MediaKeySystemAccess {
	public get keySystem(): string;
	public createMediaKeys(): Promise<MediaKeys>;
	public getConfiguration(): MediaKeySystemConfiguration;
	public constructor();
}

export external public class MediaKeys {
	public createSession(sessionType: MediaKeySessionType = ): MediaKeySession;
	public setServerCertificate(serverCertificate: BufferSource): Promise<boolean>;
	public constructor();
}

export external public class MediaList {
	public get length(): number;
	public mediaText: string;
	@Override
	public toString(): string;
	public appendMedium(medium: string): void;
	public deleteMedium(medium: string): void;
	public item(index: number): string;
	public constructor();
}

export external public class MediaMetadata {
	public album: string;
	public artist: string;
	public artwork: ReadonlyArray<MediaImage>;
	public title: string;
	public constructor(init: MediaMetadataInit = );
}

export external public interface ~MediaQueryListEventMap {
	change: MediaQueryListEvent;
}

export external public class MediaQueryList extends EventTarget {
	public get matches(): boolean;
	public get media(): string;
	public onchange: ({@This(MediaQueryList) function(ev: MediaQueryListEvent): any});
	public addListener(callback: ({@This(MediaQueryList) function(ev: MediaQueryListEvent): any})): void;
	public removeListener(callback: ({@This(MediaQueryList) function(ev: MediaQueryListEvent): any})): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class MediaQueryListEvent extends Event {
	public get matches(): boolean;
	public get media(): string;
	public constructor(type: string, eventInitDict: MediaQueryListEventInit = );
}

export external public interface ~MediaRecorderEventMap {
	dataavailable: BlobEvent;
	error: Event;
	pause: Event;
	resume: Event;
	start: Event;
	stop: Event;
}

export external public class MediaRecorder extends EventTarget {
	public get audioBitsPerSecond(): number;
	public get mimeType(): string;
	public ondataavailable: ({@This(MediaRecorder) function(ev: BlobEvent): any});
	public onerror: ({@This(MediaRecorder) function(ev: Event): any});
	public onpause: ({@This(MediaRecorder) function(ev: Event): any});
	public onresume: ({@This(MediaRecorder) function(ev: Event): any});
	public onstart: ({@This(MediaRecorder) function(ev: Event): any});
	public onstop: ({@This(MediaRecorder) function(ev: Event): any});
	public get state(): RecordingState;
	public get stream(): MediaStream;
	public get videoBitsPerSecond(): number;
	public pause(): void;
	public requestData(): void;
	public resume(): void;
	public start(timeslice: number = ): void;
	public stop(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(stream: MediaStream, options: MediaRecorderOptions = );
	public static isTypeSupported(type: string): boolean;
}

export external public class MediaRecorderErrorEvent extends Event {
	public get error(): DOMException;
	public constructor(type: string, eventInitDict: MediaRecorderErrorEventInit);
}

export external public class MediaSession {
	public metadata: MediaMetadata;
	public playbackState: MediaSessionPlaybackState;
	public setActionHandler(action: MediaSessionAction, handler: MediaSessionActionHandler): void;
	public setPositionState(state: MediaPositionState = ): void;
	public constructor();
}

export external public interface ~MediaSourceEventMap {
	sourceclose: Event;
	sourceended: Event;
	sourceopen: Event;
}

export external public class MediaSource extends EventTarget {
	public get activeSourceBuffers(): SourceBufferList;
	public duration: number;
	public onsourceclose: ({@This(MediaSource) function(ev: Event): any});
	public onsourceended: ({@This(MediaSource) function(ev: Event): any});
	public onsourceopen: ({@This(MediaSource) function(ev: Event): any});
	public get readyState(): ReadyState;
	public get sourceBuffers(): SourceBufferList;
	public addSourceBuffer(type: string): SourceBuffer;
	public clearLiveSeekableRange(): void;
	public endOfStream(error: EndOfStreamError = ): void;
	public removeSourceBuffer(sourceBuffer: SourceBuffer): void;
	public setLiveSeekableRange(start: number, end: number): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static isTypeSupported(type: string): boolean;
}

export external public interface ~MediaStreamEventMap {
	addtrack: MediaStreamTrackEvent;
	removetrack: MediaStreamTrackEvent;
}

export external public class MediaStream extends EventTarget {
	public get active(): boolean;
	public get id(): string;
	public onaddtrack: ({@This(MediaStream) function(ev: MediaStreamTrackEvent): any});
	public onremovetrack: ({@This(MediaStream) function(ev: MediaStreamTrackEvent): any});
	public addTrack(track: MediaStreamTrack): void;
	public clone(): MediaStream;
	public getAudioTracks(): Array<MediaStreamTrack>;
	public getTrackById(trackId: string): MediaStreamTrack;
	public getTracks(): Array<MediaStreamTrack>;
	public getVideoTracks(): Array<MediaStreamTrack>;
	public removeTrack(track: MediaStreamTrack): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(...args: any+); // overloading not supported
}

export external public class MediaStreamAudioDestinationNode extends AudioNode {
	public get stream(): MediaStream;
	public constructor(context: AudioContext, options: AudioNodeOptions = );
}

export external public class MediaStreamAudioSourceNode extends AudioNode {
	public get mediaStream(): MediaStream;
	public constructor(context: AudioContext, options: MediaStreamAudioSourceOptions);
}

export external public interface ~MediaStreamTrackEventMap {
	ended: Event;
	mute: Event;
	unmute: Event;
}

export external public class MediaStreamTrack extends EventTarget {
	public contentHint: string;
	public enabled: boolean;
	public get id(): string;
	public get kind(): string;
	public get label(): string;
	public get muted(): boolean;
	public onended: ({@This(MediaStreamTrack) function(ev: Event): any});
	public onmute: ({@This(MediaStreamTrack) function(ev: Event): any});
	public onunmute: ({@This(MediaStreamTrack) function(ev: Event): any});
	public get readyState(): MediaStreamTrackState;
	public applyConstraints(constraints: MediaTrackConstraints = ): Promise<void>;
	public clone(): MediaStreamTrack;
	public getCapabilities(): MediaTrackCapabilities;
	public getConstraints(): MediaTrackConstraints;
	public getSettings(): MediaTrackSettings;
	public stop(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class MediaStreamTrackEvent extends Event {
	public get track(): MediaStreamTrack;
	public constructor(type: string, eventInitDict: MediaStreamTrackEventInit);
}

export external public class MessageChannel {
	public get port1(): MessagePort;
	public get port2(): MessagePort;
	public constructor();
}

export external public class MessageEvent<T> extends Event {
	public get data(): T;
	public get lastEventId(): string;
	public get origin(): string;
	public get ports(): ReadonlyArray<MessagePort>;
	public get source(): MessageEventSource;
	public initMessageEvent(type: string, bubbles: boolean = , cancelable: boolean = , data: any = , origin: string = , lastEventId: string = , source: MessageEventSource = , ports: Array<MessagePort> = ): void;
	public constructor(type: string, eventInitDict: MessageEventInit<T> = );
}

export external public interface ~MessagePortEventMap {
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public class MessagePort extends EventTarget {
	public onmessage: ({@This(MessagePort) function(ev: MessageEvent): any});
	public onmessageerror: ({@This(MessagePort) function(ev: MessageEvent): any});
	public close(): void;
	public postMessage(...args: any+): any+; // overloading not supported
	public start(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class MimeType {
	public get description(): string;
	public get enabledPlugin(): Plugin;
	public get suffixes(): string;
	public get type(): string;
	public constructor();
}

export external public class MimeTypeArray {
	public get length(): number;
	public item(index: number): MimeType;
	public namedItem(name: string): MimeType;
	public constructor();
}

export external public class MouseEvent extends UIEvent {
	public get altKey(): boolean;
	public get button(): number;
	public get buttons(): number;
	public get clientX(): number;
	public get clientY(): number;
	public get ctrlKey(): boolean;
	public get metaKey(): boolean;
	public get movementX(): number;
	public get movementY(): number;
	public get offsetX(): number;
	public get offsetY(): number;
	public get pageX(): number;
	public get pageY(): number;
	public get relatedTarget(): EventTarget;
	public get screenX(): number;
	public get screenY(): number;
	public get shiftKey(): boolean;
	public get x(): number;
	public get y(): number;
	public getModifierState(keyArg: string): boolean;
	public initMouseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget): void;
	public constructor(type: string, eventInitDict: MouseEventInit = );
}

export external public class MutationEvent extends Event {
	public get attrChange(): number;
	public get attrName(): string;
	public get newValue(): string;
	public get prevValue(): string;
	public get relatedNode(): Node;
	public initMutationEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , relatedNodeArg: Node = , prevValueArg: string = , newValueArg: string = , attrNameArg: string = , attrChangeArg: number = ): void;
	public get ADDITION(): number;
	public get MODIFICATION(): number;
	public get REMOVAL(): number;
	public constructor();
	public static get ADDITION(): number;
	public static get MODIFICATION(): number;
	public static get REMOVAL(): number;
}

export external public class MutationObserver {
	public disconnect(): void;
	public observe(target: Node, options: MutationObserverInit = ): void;
	public takeRecords(): Array<MutationRecord>;
	public constructor(callback: MutationCallback);
}

export external public class MutationRecord {
	public get addedNodes(): NodeList;
	public get attributeName(): string;
	public get attributeNamespace(): string;
	public get nextSibling(): Node;
	public get oldValue(): string;
	public get previousSibling(): Node;
	public get removedNodes(): NodeList;
	public get target(): Node;
	public get type(): MutationRecordType;
	public constructor();
}

export external public class NamedNodeMap {
	public get length(): number;
	public getNamedItem(qualifiedName: string): Attr;
	public getNamedItemNS(namespace: string, localName: string): Attr;
	public item(index: number): Attr;
	public removeNamedItem(qualifiedName: string): Attr;
	public removeNamedItemNS(namespace: string, localName: string): Attr;
	public setNamedItem(attr: Attr): Attr;
	public setNamedItemNS(attr: Attr): Attr;
	public constructor();
}

export external public class Navigator extends NavigatorAutomationInformation implements NavigatorConcurrentHardware, NavigatorContentUtils, NavigatorCookies, NavigatorID, NavigatorLanguage, NavigatorNetworkInformation, NavigatorOnLine, NavigatorPlugins, NavigatorStorage {
	public get clipboard(): Clipboard;
	public get credentials(): CredentialsContainer;
	public get doNotTrack(): string;
	public get geolocation(): Geolocation;
	public get maxTouchPoints(): number;
	public get mediaCapabilities(): MediaCapabilities;
	public get mediaDevices(): MediaDevices;
	public get mediaSession(): MediaSession;
	public get permissions(): Permissions;
	public get pointerEnabled(): boolean;
	public get serviceWorker(): ServiceWorkerContainer;
	public getGamepads(): Array<Gamepad>;
	public requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: Array<MediaKeySystemConfiguration>): Promise<MediaKeySystemAccess>;
	public sendBeacon(url: string | URL, data: BodyInit = ): boolean;
	public share(data: ShareData = ): Promise<void>;
	public vibrate(pattern: VibratePattern): boolean;
	public constructor();
}

export external public interface ~NavigatorAutomationInformation {
	get webdriver(): boolean;
}

export external public interface ~NavigatorConcurrentHardware {
	get hardwareConcurrency(): number;
}

export external public interface ~NavigatorContentUtils {
	registerProtocolHandler(scheme: string, url: string | URL): void;
}

export external public interface ~NavigatorCookies {
	get cookieEnabled(): boolean;
}

export external public interface ~NavigatorID {
	get appCodeName(): string;
	get appName(): string;
	get appVersion(): string;
	get platform(): string;
	get product(): string;
	get productSub(): string;
	get userAgent(): string;
	get vendor(): string;
	get vendorSub(): string;
}

export external public interface ~NavigatorLanguage {
	get language(): string;
	get languages(): ReadonlyArray<string>;
}

export external public interface ~NavigatorNetworkInformation {
	get connection(): NetworkInformation;
}

export external public interface ~NavigatorOnLine {
	get onLine(): boolean;
}

export external public interface ~NavigatorPlugins {
	get mimeTypes(): MimeTypeArray;
	get plugins(): PluginArray;
	javaEnabled(): boolean;
}

export external public interface ~NavigatorStorage {
	get storage(): StorageManager;
}

export external public class NetworkInformation extends EventTarget {
	public get type(): ConnectionType;
	public constructor();
}

export external public class Node extends EventTarget {
	public get baseURI(): string;
	public get childNodes(): NodeListOf<ChildNode>;
	public get firstChild(): ChildNode;
	public get isConnected(): boolean;
	public get lastChild(): ChildNode;
	public get nextSibling(): ChildNode;
	public get nodeName(): string;
	public get nodeType(): number;
	public nodeValue: string;
	public get ownerDocument(): Document;
	public get parentElement(): HTMLElement;
	public get parentNode(): ParentNode;
	public get previousSibling(): ChildNode;
	public textContent: string;
	public <T> appendChild(node: T): T;
	public cloneNode(deep: boolean = ): Node;
	public compareDocumentPosition(other: Node): number;
	public contains(other: Node): boolean;
	public getRootNode(options: GetRootNodeOptions = ): Node;
	public hasChildNodes(): boolean;
	public <T> insertBefore(node: T, child: Node): T;
	public isDefaultNamespace(namespace: string): boolean;
	public isEqualNode(otherNode: Node): boolean;
	public isSameNode(otherNode: Node): boolean;
	public lookupNamespaceURI(prefix: string): string;
	public lookupPrefix(namespace: string): string;
	public normalize(): void;
	public <T> removeChild(child: T): T;
	public <T> replaceChild(node: Node, child: T): T;
	public get ATTRIBUTE_NODE(): number;
	public get CDATA_SECTION_NODE(): number;
	public get COMMENT_NODE(): number;
	public get DOCUMENT_FRAGMENT_NODE(): number;
	public get DOCUMENT_NODE(): number;
	public get DOCUMENT_POSITION_CONTAINED_BY(): number;
	public get DOCUMENT_POSITION_CONTAINS(): number;
	public get DOCUMENT_POSITION_DISCONNECTED(): number;
	public get DOCUMENT_POSITION_FOLLOWING(): number;
	public get DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC(): number;
	public get DOCUMENT_POSITION_PRECEDING(): number;
	public get DOCUMENT_TYPE_NODE(): number;
	public get ELEMENT_NODE(): number;
	public get ENTITY_NODE(): number;
	public get ENTITY_REFERENCE_NODE(): number;
	public get NOTATION_NODE(): number;
	public get PROCESSING_INSTRUCTION_NODE(): number;
	public get TEXT_NODE(): number;
	public constructor();
	public static get ATTRIBUTE_NODE(): number;
	public static get CDATA_SECTION_NODE(): number;
	public static get COMMENT_NODE(): number;
	public static get DOCUMENT_FRAGMENT_NODE(): number;
	public static get DOCUMENT_NODE(): number;
	public static get DOCUMENT_POSITION_CONTAINED_BY(): number;
	public static get DOCUMENT_POSITION_CONTAINS(): number;
	public static get DOCUMENT_POSITION_DISCONNECTED(): number;
	public static get DOCUMENT_POSITION_FOLLOWING(): number;
	public static get DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC(): number;
	public static get DOCUMENT_POSITION_PRECEDING(): number;
	public static get DOCUMENT_TYPE_NODE(): number;
	public static get ELEMENT_NODE(): number;
	public static get ENTITY_NODE(): number;
	public static get ENTITY_REFERENCE_NODE(): number;
	public static get NOTATION_NODE(): number;
	public static get PROCESSING_INSTRUCTION_NODE(): number;
	public static get TEXT_NODE(): number;
}

export external public class NodeIterator {
	public get filter(): NodeFilter;
	public get pointerBeforeReferenceNode(): boolean;
	public get referenceNode(): Node;
	public get root(): Node;
	public get whatToShow(): number;
	public detach(): void;
	public nextNode(): Node;
	public previousNode(): Node;
	public constructor();
}

export external public class NodeList {
	public get length(): number;
	public item(index: number): Node;
	public forEach(callbackfn: (value: Node, key: number, parent: NodeList)=>void, thisArg: any = ): void;
	public constructor();
}

export external public interface ~NodeListOf<TNode> extends NodeList {
	item(index: number): TNode;
	forEach(callbackfn: (value: TNode, key: number, parent: NodeListOf<TNode>)=>void, thisArg: any = ): void;
}

export external public interface ~NonDocumentTypeChildNode {
	get nextElementSibling(): Element;
	get previousElementSibling(): Element;
}

export external public interface ~NonElementParentNode {
	getElementById(elementId: string): Element;
}

export external public interface ~NotificationEventMap {
	click: Event;
	close: Event;
	error: Event;
	show: Event;
}

export external public class Notification extends EventTarget {
	public get body(): string;
	public get data(): any;
	public get dir(): NotificationDirection;
	public get icon(): string;
	public get lang(): string;
	public onclick: ({@This(Notification) function(ev: Event): any});
	public onclose: ({@This(Notification) function(ev: Event): any});
	public onerror: ({@This(Notification) function(ev: Event): any});
	public onshow: ({@This(Notification) function(ev: Event): any});
	public get tag(): string;
	public get title(): string;
	public close(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(title: string, options: NotificationOptions = );
	public static get permission(): NotificationPermission;
	public static requestPermission(deprecatedCallback: NotificationPermissionCallback = ): Promise<NotificationPermission>;
}

export external public interface ~OES_element_index_uint {}

export external public interface ~OES_fbo_render_mipmap {}

export external public interface ~OES_standard_derivatives {
	get FRAGMENT_SHADER_DERIVATIVE_HINT_OES(): GLenum;
}

export external public interface ~OES_texture_float {}

export external public interface ~OES_texture_float_linear {}

export external public interface ~OES_texture_half_float {
	get HALF_FLOAT_OES(): GLenum;
}

export external public interface ~OES_texture_half_float_linear {}

export external public interface ~OES_vertex_array_object {
	bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
	createVertexArrayOES(): WebGLVertexArrayObjectOES;
	deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
	isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): GLboolean;
	get VERTEX_ARRAY_BINDING_OES(): GLenum;
}

export external public interface ~OVR_multiview2 {
	framebufferTextureMultiviewOVR(target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint, baseViewIndex: GLint, numViews: GLsizei): void;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR(): GLenum;
	get MAX_VIEWS_OVR(): GLenum;
}

export external public class OfflineAudioCompletionEvent extends Event {
	public get renderedBuffer(): AudioBuffer;
	public constructor(type: string, eventInitDict: OfflineAudioCompletionEventInit);
}

export external public interface ~OfflineAudioContextEventMap extends BaseAudioContextEventMap {
	complete: OfflineAudioCompletionEvent;
}

export external public class OfflineAudioContext extends BaseAudioContext {
	public get length(): number;
	public oncomplete: ({@This(OfflineAudioContext) function(ev: OfflineAudioCompletionEvent): any});
	public resume(): Promise<void>;
	public startRendering(): Promise<AudioBuffer>;
	public suspend(suspendTime: number): Promise<void>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(...args: any+); // overloading not supported
}

export external public class OscillatorNode extends AudioScheduledSourceNode {
	public get detune(): AudioParam;
	public get frequency(): AudioParam;
	public type: OscillatorType;
	public setPeriodicWave(periodicWave: PeriodicWave): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(context: BaseAudioContext, options: OscillatorOptions = );
}

export external public class OverconstrainedError extends Error {
	public get constraint(): string;
	public constructor(constraint: string, message: string = );
}

export external public class PageTransitionEvent extends Event {
	public get persisted(): boolean;
	public constructor(type: string, eventInitDict: PageTransitionEventInit = );
}

export external public class PannerNode extends AudioNode {
	public coneInnerAngle: number;
	public coneOuterAngle: number;
	public coneOuterGain: number;
	public distanceModel: DistanceModelType;
	public maxDistance: number;
	public get orientationX(): AudioParam;
	public get orientationY(): AudioParam;
	public get orientationZ(): AudioParam;
	public panningModel: PanningModelType;
	public get positionX(): AudioParam;
	public get positionY(): AudioParam;
	public get positionZ(): AudioParam;
	public refDistance: number;
	public rolloffFactor: number;
	public setOrientation(x: number, y: number, z: number): void;
	public setPosition(x: number, y: number, z: number): void;
	public constructor(context: BaseAudioContext, options: PannerOptions = );
}

export external public interface ~ParentNode extends Node {
	get childElementCount(): number;
	get children(): HTMLCollection;
	get firstElementChild(): Element;
	get lastElementChild(): Element;
	append(...nodes: Node | string): void;
	prepend(...nodes: Node | string): void;
	querySelector(...args: any+): any+; // overloading not supported
	querySelectorAll(...args: any+): any+; // overloading not supported
	replaceChildren(...nodes: Node | string): void;
}

export external public class Path2D extends CanvasPath {
	public addPath(path: Path2D, transform: DOMMatrix2DInit = ): void;
	public constructor(path: Path2D | string = );
}

export external public class PaymentAddress {
	public get addressLine(): ReadonlyArray<string>;
	public get city(): string;
	public get country(): string;
	public get dependentLocality(): string;
	public get organization(): string;
	public get phone(): string;
	public get postalCode(): string;
	public get recipient(): string;
	public get region(): string;
	public get sortingCode(): string;
	public toJSON(): any;
	public constructor();
}

export external public class PaymentMethodChangeEvent extends PaymentRequestUpdateEvent {
	public get methodDetails(): any;
	public get methodName(): string;
	public constructor(type: string, eventInitDict: PaymentMethodChangeEventInit = );
}

export external public interface ~PaymentRequestEventMap {
	paymentmethodchange: Event;
}

export external public class PaymentRequest extends EventTarget {
	public get id(): string;
	public onpaymentmethodchange: ({@This(PaymentRequest) function(ev: Event): any});
	public abort(): Promise<void>;
	public canMakePayment(): Promise<boolean>;
	public show(detailsPromise: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate> = ): Promise<PaymentResponse>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(methodData: Array<PaymentMethodData>, details: PaymentDetailsInit);
}

export external public class PaymentRequestUpdateEvent extends Event {
	public updateWith(detailsPromise: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate>): void;
	public constructor(type: string, eventInitDict: PaymentRequestUpdateEventInit = );
}

export external public class PaymentResponse extends EventTarget {
	public get details(): any;
	public get methodName(): string;
	public get requestId(): string;
	public complete(result: PaymentComplete = ): Promise<void>;
	public retry(errorFields: PaymentValidationErrors = ): Promise<void>;
	public toJSON(): any;
	public constructor();
}

export external public interface ~PerformanceEventMap {
	resourcetimingbufferfull: Event;
}

export external public class Performance extends EventTarget {
	public get navigation(): PerformanceNavigation;
	public onresourcetimingbufferfull: ({@This(Performance) function(ev: Event): any});
	public get timeOrigin(): DOMHighResTimeStamp;
	public get timing(): PerformanceTiming;
	public clearMarks(markName: string = ): void;
	public clearMeasures(measureName: string = ): void;
	public clearResourceTimings(): void;
	public getEntries(): PerformanceEntryList;
	public getEntriesByName(name: string, type: string = ): PerformanceEntryList;
	public getEntriesByType(type: string): PerformanceEntryList;
	public mark(markName: string, markOptions: PerformanceMarkOptions = ): PerformanceMark;
	public measure(measureName: string, startOrMeasureOptions: string | PerformanceMeasureOptions = , endMark: string = ): PerformanceMeasure;
	public now(): DOMHighResTimeStamp;
	public setResourceTimingBufferSize(maxSize: number): void;
	public toJSON(): any;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class PerformanceEntry {
	public get duration(): DOMHighResTimeStamp;
	public get entryType(): string;
	public get name(): string;
	public get startTime(): DOMHighResTimeStamp;
	public toJSON(): any;
	public constructor();
}

export external public class PerformanceEventTiming extends PerformanceEntry {
	public get cancelable(): boolean;
	public get processingEnd(): DOMHighResTimeStamp;
	public get processingStart(): DOMHighResTimeStamp;
	public get target(): Node;
	public constructor();
}

export external public class PerformanceMark extends PerformanceEntry {
	public get detail(): any;
	public constructor(markName: string, markOptions: PerformanceMarkOptions = );
}

export external public class PerformanceMeasure extends PerformanceEntry {
	public get detail(): any;
	public constructor();
}

export external public class PerformanceNavigation {
	public get redirectCount(): number;
	public get type(): number;
	public toJSON(): any;
	public get TYPE_BACK_FORWARD(): number;
	public get TYPE_NAVIGATE(): number;
	public get TYPE_RELOAD(): number;
	public get TYPE_RESERVED(): number;
	public constructor();
	public static get TYPE_BACK_FORWARD(): number;
	public static get TYPE_NAVIGATE(): number;
	public static get TYPE_RELOAD(): number;
	public static get TYPE_RESERVED(): number;
}

export external public class PerformanceNavigationTiming extends PerformanceResourceTiming {
	public get domComplete(): DOMHighResTimeStamp;
	public get domContentLoadedEventEnd(): DOMHighResTimeStamp;
	public get domContentLoadedEventStart(): DOMHighResTimeStamp;
	public get domInteractive(): DOMHighResTimeStamp;
	public get loadEventEnd(): DOMHighResTimeStamp;
	public get loadEventStart(): DOMHighResTimeStamp;
	public get redirectCount(): number;
	public get type(): NavigationType;
	public get unloadEventEnd(): DOMHighResTimeStamp;
	public get unloadEventStart(): DOMHighResTimeStamp;
	@Override
	public toJSON(): any;
	public constructor();
}

export external public class PerformanceObserver {
	public disconnect(): void;
	public observe(options: PerformanceObserverInit = ): void;
	public takeRecords(): PerformanceEntryList;
	public constructor(callback: PerformanceObserverCallback);
	public static get supportedEntryTypes(): ReadonlyArray<string>;
}

export external public class PerformanceObserverEntryList {
	public getEntries(): PerformanceEntryList;
	public getEntriesByName(name: string, type: string = ): PerformanceEntryList;
	public getEntriesByType(type: string): PerformanceEntryList;
	public constructor();
}

export external public class PerformancePaintTiming extends PerformanceEntry {
	public constructor();
}

export external public class PerformanceResourceTiming extends PerformanceEntry {
	public get connectEnd(): DOMHighResTimeStamp;
	public get connectStart(): DOMHighResTimeStamp;
	public get decodedBodySize(): number;
	public get domainLookupEnd(): DOMHighResTimeStamp;
	public get domainLookupStart(): DOMHighResTimeStamp;
	public get encodedBodySize(): number;
	public get fetchStart(): DOMHighResTimeStamp;
	public get initiatorType(): string;
	public get nextHopProtocol(): string;
	public get redirectEnd(): DOMHighResTimeStamp;
	public get redirectStart(): DOMHighResTimeStamp;
	public get requestStart(): DOMHighResTimeStamp;
	public get responseEnd(): DOMHighResTimeStamp;
	public get responseStart(): DOMHighResTimeStamp;
	public get secureConnectionStart(): DOMHighResTimeStamp;
	public get serverTiming(): ReadonlyArray<PerformanceServerTiming>;
	public get transferSize(): number;
	public get workerStart(): DOMHighResTimeStamp;
	@Override
	public toJSON(): any;
	public constructor();
}

export external public class PerformanceServerTiming {
	public get description(): string;
	public get duration(): DOMHighResTimeStamp;
	public get name(): string;
	public toJSON(): any;
	public constructor();
}

export external public class PerformanceTiming {
	public get connectEnd(): number;
	public get connectStart(): number;
	public get domComplete(): number;
	public get domContentLoadedEventEnd(): number;
	public get domContentLoadedEventStart(): number;
	public get domInteractive(): number;
	public get domLoading(): number;
	public get domainLookupEnd(): number;
	public get domainLookupStart(): number;
	public get fetchStart(): number;
	public get loadEventEnd(): number;
	public get loadEventStart(): number;
	public get navigationStart(): number;
	public get redirectEnd(): number;
	public get redirectStart(): number;
	public get requestStart(): number;
	public get responseEnd(): number;
	public get responseStart(): number;
	public get secureConnectionStart(): number;
	public get unloadEventEnd(): number;
	public get unloadEventStart(): number;
	public toJSON(): any;
	public constructor();
}

export external public class PeriodicWave {
	public constructor(context: BaseAudioContext, options: PeriodicWaveOptions = );
}

export external public interface ~PermissionStatusEventMap {
	change: Event;
}

export external public class PermissionStatus extends EventTarget {
	public onchange: ({@This(PermissionStatus) function(ev: Event): any});
	public get state(): PermissionState;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class Permissions {
	public query(permissionDesc: PermissionDescriptor): Promise<PermissionStatus>;
	public constructor();
}

export external public interface ~PictureInPictureWindowEventMap {
	resize: Event;
}

export external public class PictureInPictureWindow extends EventTarget {
	public get height(): number;
	public onresize: ({@This(PictureInPictureWindow) function(ev: Event): any});
	public get width(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class Plugin {
	public get description(): string;
	public get filename(): string;
	public get length(): number;
	public get name(): string;
	public item(index: number): MimeType;
	public namedItem(name: string): MimeType;
	public constructor();
}

export external public class PluginArray {
	public get length(): number;
	public item(index: number): Plugin;
	public namedItem(name: string): Plugin;
	public refresh(): void;
	public constructor();
}

export external public class PointerEvent extends MouseEvent {
	public get height(): number;
	public get isPrimary(): boolean;
	public get pointerId(): number;
	public get pointerType(): string;
	public get pressure(): number;
	public get tangentialPressure(): number;
	public get tiltX(): number;
	public get tiltY(): number;
	public get twist(): number;
	public get width(): number;
	public getCoalescedEvents(): Array<PointerEvent>;
	public getPredictedEvents(): Array<PointerEvent>;
	public constructor(type: string, eventInitDict: PointerEventInit = );
}

export external public class PopStateEvent extends Event {
	public get state(): any;
	public constructor(type: string, eventInitDict: PopStateEventInit = );
}

export external public class ProcessingInstruction extends CharacterData implements LinkStyle {
	@Override
	public get ownerDocument(): Document;
	public get target(): string;
	public constructor();
}

export external public class ProgressEvent<T> extends Event {
	public get lengthComputable(): boolean;
	public get loaded(): number;
	public get target(): T;
	public get total(): number;
	public constructor(type: string, eventInitDict: ProgressEventInit = );
}

export external public class PromiseRejectionEvent extends Event {
	public get promise(): Promise<any>;
	public get reason(): any;
	public constructor(type: string, eventInitDict: PromiseRejectionEventInit);
}

export external public class PublicKeyCredential extends Credential {
	public get rawId(): ArrayBuffer;
	public get response(): AuthenticatorResponse;
	public getClientExtensionResults(): AuthenticationExtensionsClientOutputs;
	public constructor();
	public static isUserVerifyingPlatformAuthenticatorAvailable(): Promise<boolean>;
}

export external public class PushManager {
	public getSubscription(): Promise<PushSubscription>;
	public permissionState(options: PushSubscriptionOptionsInit = ): Promise<PushPermissionState>;
	public subscribe(options: PushSubscriptionOptionsInit = ): Promise<PushSubscription>;
	public constructor();
	public static get supportedContentEncodings(): ReadonlyArray<string>;
}

export external public class PushSubscription {
	public get endpoint(): string;
	public get options(): PushSubscriptionOptions;
	public getKey(name: PushEncryptionKeyName): ArrayBuffer;
	public toJSON(): PushSubscriptionJSON;
	public unsubscribe(): Promise<boolean>;
	public constructor();
}

export external public class PushSubscriptionOptions {
	public get applicationServerKey(): ArrayBuffer;
	public constructor();
}

export external public class RTCCertificate {
	public get expires(): DOMTimeStamp;
	public getFingerprints(): Array<RTCDtlsFingerprint>;
	public constructor();
}

export external public interface ~RTCDTMFSenderEventMap {
	tonechange: RTCDTMFToneChangeEvent;
}

export external public class RTCDTMFSender extends EventTarget {
	public get canInsertDTMF(): boolean;
	public ontonechange: ({@This(RTCDTMFSender) function(ev: RTCDTMFToneChangeEvent): any});
	public get toneBuffer(): string;
	public insertDTMF(tones: string, duration: number = , interToneGap: number = ): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class RTCDTMFToneChangeEvent extends Event {
	public get tone(): string;
	public constructor(type: string, eventInitDict: RTCDTMFToneChangeEventInit = );
}

export external public interface ~RTCDataChannelEventMap {
	bufferedamountlow: Event;
	close: Event;
	error: Event;
	message: MessageEvent;
	open: Event;
}

export external public class RTCDataChannel extends EventTarget {
	public binaryType: BinaryType;
	public get bufferedAmount(): number;
	public bufferedAmountLowThreshold: number;
	public get id(): number;
	public get label(): string;
	public get maxPacketLifeTime(): number;
	public get maxRetransmits(): number;
	public get negotiated(): boolean;
	public onbufferedamountlow: ({@This(RTCDataChannel) function(ev: Event): any});
	public onclose: ({@This(RTCDataChannel) function(ev: Event): any});
	public onerror: ({@This(RTCDataChannel) function(ev: Event): any});
	public onmessage: ({@This(RTCDataChannel) function(ev: MessageEvent): any});
	public onopen: ({@This(RTCDataChannel) function(ev: Event): any});
	public get ordered(): boolean;
	public get protocol(): string;
	public get readyState(): RTCDataChannelState;
	public close(): void;
	public send(...args: any+): any+; // overloading not supported
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class RTCDataChannelEvent extends Event {
	public get channel(): RTCDataChannel;
	public constructor(type: string, eventInitDict: RTCDataChannelEventInit);
}

export external public interface ~RTCDtlsTransportEventMap {
	statechange: Event;
}

export external public class RTCDtlsTransport extends EventTarget {
	public onstatechange: ({@This(RTCDtlsTransport) function(ev: Event): any});
	public get state(): RTCDtlsTransportState;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class RTCIceCandidate {
	public get address(): string;
	public get candidate(): string;
	public get component(): RTCIceComponent;
	public get foundation(): string;
	public get port(): number;
	public get priority(): number;
	public get protocol(): RTCIceProtocol;
	public get relatedAddress(): string;
	public get relatedPort(): number;
	public get sdpMLineIndex(): number;
	public get sdpMid(): string;
	public get tcpType(): RTCIceTcpCandidateType;
	public get type(): RTCIceCandidateType;
	public get usernameFragment(): string;
	public toJSON(): RTCIceCandidateInit;
	public constructor(candidateInitDict: RTCIceCandidateInit = );
}

export external public class RTCIceTransport extends EventTarget {
	public get gatheringState(): RTCIceGathererState;
	public get state(): RTCIceTransportState;
	public constructor();
}

export external public interface ~RTCPeerConnectionEventMap {
	connectionstatechange: Event;
	datachannel: RTCDataChannelEvent;
	icecandidate: RTCPeerConnectionIceEvent;
	icecandidateerror: Event;
	iceconnectionstatechange: Event;
	icegatheringstatechange: Event;
	negotiationneeded: Event;
	signalingstatechange: Event;
	track: RTCTrackEvent;
}

export external public class RTCPeerConnection extends EventTarget {
	public get canTrickleIceCandidates(): boolean;
	public get connectionState(): RTCPeerConnectionState;
	public get currentLocalDescription(): RTCSessionDescription;
	public get currentRemoteDescription(): RTCSessionDescription;
	public get iceConnectionState(): RTCIceConnectionState;
	public get iceGatheringState(): RTCIceGatheringState;
	public get localDescription(): RTCSessionDescription;
	public onconnectionstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	public ondatachannel: ({@This(RTCPeerConnection) function(ev: RTCDataChannelEvent): any});
	public onicecandidate: ({@This(RTCPeerConnection) function(ev: RTCPeerConnectionIceEvent): any});
	public onicecandidateerror: ({@This(RTCPeerConnection) function(ev: Event): any});
	public oniceconnectionstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	public onicegatheringstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	public onnegotiationneeded: ({@This(RTCPeerConnection) function(ev: Event): any});
	public onsignalingstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	public ontrack: ({@This(RTCPeerConnection) function(ev: RTCTrackEvent): any});
	public get pendingLocalDescription(): RTCSessionDescription;
	public get pendingRemoteDescription(): RTCSessionDescription;
	public get remoteDescription(): RTCSessionDescription;
	public get signalingState(): RTCSignalingState;
	public addIceCandidate(...args: any+): any+; // overloading not supported
	public addTrack(track: MediaStreamTrack, ...streams: MediaStream): RTCRtpSender;
	public addTransceiver(trackOrKind: MediaStreamTrack | string, init: RTCRtpTransceiverInit = ): RTCRtpTransceiver;
	public close(): void;
	public createAnswer(...args: any+): any+; // overloading not supported
	public createDataChannel(label: string, dataChannelDict: RTCDataChannelInit = ): RTCDataChannel;
	public createOffer(...args: any+): any+; // overloading not supported
	public getConfiguration(): RTCConfiguration;
	public getReceivers(): Array<RTCRtpReceiver>;
	public getSenders(): Array<RTCRtpSender>;
	public getStats(selector: MediaStreamTrack = ): Promise<RTCStatsReport>;
	public getTransceivers(): Array<RTCRtpTransceiver>;
	public removeTrack(sender: RTCRtpSender): void;
	public restartIce(): void;
	public setConfiguration(configuration: RTCConfiguration = ): void;
	public setLocalDescription(...args: any+): any+; // overloading not supported
	public setRemoteDescription(...args: any+): any+; // overloading not supported
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(configuration: RTCConfiguration = );
	public static generateCertificate(keygenAlgorithm: AlgorithmIdentifier): Promise<RTCCertificate>;
}

export external public class RTCPeerConnectionIceErrorEvent extends Event {
	public get address(): string;
	public get errorCode(): number;
	public get errorText(): string;
	public get port(): number;
	public get url(): string;
	public constructor(type: string, eventInitDict: RTCPeerConnectionIceErrorEventInit);
}

export external public class RTCPeerConnectionIceEvent extends Event {
	public get candidate(): RTCIceCandidate;
	public constructor(type: string, eventInitDict: RTCPeerConnectionIceEventInit = );
}

export external public class RTCRtpReceiver {
	public get track(): MediaStreamTrack;
	public get transport(): RTCDtlsTransport;
	public getContributingSources(): Array<RTCRtpContributingSource>;
	public getParameters(): RTCRtpReceiveParameters;
	public getStats(): Promise<RTCStatsReport>;
	public getSynchronizationSources(): Array<RTCRtpSynchronizationSource>;
	public constructor();
	public static getCapabilities(kind: string): RTCRtpCapabilities;
}

export external public class RTCRtpSender {
	public get dtmf(): RTCDTMFSender;
	public get track(): MediaStreamTrack;
	public get transport(): RTCDtlsTransport;
	public getParameters(): RTCRtpSendParameters;
	public getStats(): Promise<RTCStatsReport>;
	public replaceTrack(withTrack: MediaStreamTrack): Promise<void>;
	public setParameters(parameters: RTCRtpSendParameters): Promise<void>;
	public setStreams(...streams: MediaStream): void;
	public constructor();
	public static getCapabilities(kind: string): RTCRtpCapabilities;
}

export external public class RTCRtpTransceiver {
	public get currentDirection(): RTCRtpTransceiverDirection;
	public direction: RTCRtpTransceiverDirection;
	public get mid(): string;
	public get receiver(): RTCRtpReceiver;
	public get sender(): RTCRtpSender;
	public stop(): void;
	public constructor();
}

export external public class RTCSessionDescription {
	public get sdp(): string;
	public get type(): RTCSdpType;
	public toJSON(): any;
	public constructor(descriptionInitDict: RTCSessionDescriptionInit);
}

export external public class RTCStatsReport {
	public forEach(callbackfn: (value: any, key: string, parent: RTCStatsReport)=>void, thisArg: any = ): void;
	public constructor();
}

export external public class RTCTrackEvent extends Event {
	public get receiver(): RTCRtpReceiver;
	public get streams(): ReadonlyArray<MediaStream>;
	public get track(): MediaStreamTrack;
	public get transceiver(): RTCRtpTransceiver;
	public constructor(type: string, eventInitDict: RTCTrackEventInit);
}

export external public class RadioNodeList extends NodeList {
	public value: string;
	public constructor();
}

export external public class Range extends AbstractRange {
	public get commonAncestorContainer(): Node;
	public cloneContents(): DocumentFragment;
	public cloneRange(): Range;
	public collapse(toStart: boolean = ): void;
	public compareBoundaryPoints(how: number, sourceRange: Range): number;
	public comparePoint(node: Node, offset: number): number;
	public createContextualFragment(fragment: string): DocumentFragment;
	public deleteContents(): void;
	public detach(): void;
	public extractContents(): DocumentFragment;
	public getBoundingClientRect(): DOMRect;
	public getClientRects(): DOMRectList;
	public insertNode(node: Node): void;
	public intersectsNode(node: Node): boolean;
	public isPointInRange(node: Node, offset: number): boolean;
	public selectNode(node: Node): void;
	public selectNodeContents(node: Node): void;
	public setEnd(node: Node, offset: number): void;
	public setEndAfter(node: Node): void;
	public setEndBefore(node: Node): void;
	public setStart(node: Node, offset: number): void;
	public setStartAfter(node: Node): void;
	public setStartBefore(node: Node): void;
	public surroundContents(newParent: Node): void;
	@Override
	public toString(): string;
	public get END_TO_END(): number;
	public get END_TO_START(): number;
	public get START_TO_END(): number;
	public get START_TO_START(): number;
	public constructor();
	public static get END_TO_END(): number;
	public static get END_TO_START(): number;
	public static get START_TO_END(): number;
	public static get START_TO_START(): number;
	@Override
	public static toString(): string;
}

export external public class ReadableStream<R> {
	public get locked(): boolean;
	public cancel(reason: any = ): Promise<void>;
	public getReader(): ReadableStreamDefaultReader<R>;
	public <T> pipeThrough(transform: ReadableWritablePair<T,R>, options: StreamPipeOptions = ): ReadableStream<T>;
	public pipeTo(destination: WritableStream<R>, options: StreamPipeOptions = ): Promise<void>;
	public tee(): [ReadableStream<R>,ReadableStream<R>];
	public forEach(callbackfn: (value: any, key: number, parent: ReadableStream<R>)=>void, thisArg: any = ): void;
	public constructor(underlyingSource: UnderlyingSource<R> = , strategy: QueuingStrategy<R> = );
}

export external public class ReadableStreamDefaultController<R> {
	public get desiredSize(): number;
	public close(): void;
	public enqueue(chunk: R = ): void;
	public error(e: any = ): void;
	public constructor();
}

export external public class ReadableStreamDefaultReader<R> extends ReadableStreamGenericReader {
	public read(): Promise<ReadableStreamDefaultReadResult<R>>;
	public releaseLock(): void;
	public constructor(stream: ReadableStream<R>);
}

export external public interface ~ReadableStreamGenericReader {
	get closed(): Promise<undefined>;
	cancel(reason: any = ): Promise<void>;
}

export external public interface ~RemotePlaybackEventMap {
	connect: Event;
	connecting: Event;
	disconnect: Event;
}

export external public class RemotePlayback extends EventTarget {
	public onconnect: ({@This(RemotePlayback) function(ev: Event): any});
	public onconnecting: ({@This(RemotePlayback) function(ev: Event): any});
	public ondisconnect: ({@This(RemotePlayback) function(ev: Event): any});
	public get state(): RemotePlaybackState;
	public cancelWatchAvailability(id: number = ): Promise<void>;
	public prompt(): Promise<void>;
	public watchAvailability(callback: RemotePlaybackAvailabilityCallback): Promise<number>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class Request extends Body {
	public get cache(): RequestCache;
	public get credentials(): RequestCredentials;
	public get destination(): RequestDestination;
	public get headers(): Headers;
	public get integrity(): string;
	public get keepalive(): boolean;
	public get method(): string;
	public get mode(): RequestMode;
	public get redirect(): RequestRedirect;
	public get referrer(): string;
	public get referrerPolicy(): ReferrerPolicy;
	public get signal(): AbortSignal;
	public get url(): string;
	public clone(): Request;
	public constructor(input: RequestInfo, init: RequestInit = );
}

export external public class ResizeObserver {
	public disconnect(): void;
	public observe(target: Element, options: ResizeObserverOptions = ): void;
	public unobserve(target: Element): void;
	public constructor(callback: ResizeObserverCallback);
}

export external public class ResizeObserverEntry {
	public get borderBoxSize(): ReadonlyArray<ResizeObserverSize>;
	public get contentBoxSize(): ReadonlyArray<ResizeObserverSize>;
	public get contentRect(): DOMRectReadOnly;
	public get target(): Element;
	public constructor();
}

export external public class ResizeObserverSize {
	public get blockSize(): number;
	public get inlineSize(): number;
	public constructor();
}

export external public class Response extends Body {
	public get headers(): Headers;
	public get ok(): boolean;
	public get redirected(): boolean;
	public get status(): number;
	public get statusText(): string;
	public get type(): ResponseType;
	public get url(): string;
	public clone(): Response;
	public constructor(body: BodyInit = , init: ResponseInit = );
	public static error(): Response;
	public static redirect(url: string | URL, status: number = ): Response;
}

export external public class SVGAElement extends SVGGraphicsElement implements SVGURIReference {
	public rel: string;
	public get relList(): DOMTokenList;
	public get target(): SVGAnimatedString;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGAngle {
	public get unitType(): number;
	public value: number;
	public valueAsString: string;
	public valueInSpecifiedUnits: number;
	public convertToSpecifiedUnits(unitType: number): void;
	public newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
	public get SVG_ANGLETYPE_DEG(): number;
	public get SVG_ANGLETYPE_GRAD(): number;
	public get SVG_ANGLETYPE_RAD(): number;
	public get SVG_ANGLETYPE_UNKNOWN(): number;
	public get SVG_ANGLETYPE_UNSPECIFIED(): number;
	public constructor();
	public static get SVG_ANGLETYPE_DEG(): number;
	public static get SVG_ANGLETYPE_GRAD(): number;
	public static get SVG_ANGLETYPE_RAD(): number;
	public static get SVG_ANGLETYPE_UNKNOWN(): number;
	public static get SVG_ANGLETYPE_UNSPECIFIED(): number;
}

export external public class SVGAnimateElement extends SVGAnimationElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGAnimateMotionElement extends SVGAnimationElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGAnimateTransformElement extends SVGAnimationElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGAnimatedAngle {
	public get animVal(): SVGAngle;
	public get baseVal(): SVGAngle;
	public constructor();
}

export external public class SVGAnimatedBoolean {
	public get animVal(): boolean;
	public baseVal: boolean;
	public constructor();
}

export external public class SVGAnimatedEnumeration {
	public get animVal(): number;
	public baseVal: number;
	public constructor();
}

export external public class SVGAnimatedInteger {
	public get animVal(): number;
	public baseVal: number;
	public constructor();
}

export external public class SVGAnimatedLength {
	public get animVal(): SVGLength;
	public get baseVal(): SVGLength;
	public constructor();
}

export external public class SVGAnimatedLengthList {
	public get animVal(): SVGLengthList;
	public get baseVal(): SVGLengthList;
	public constructor();
}

export external public class SVGAnimatedNumber {
	public get animVal(): number;
	public baseVal: number;
	public constructor();
}

export external public class SVGAnimatedNumberList {
	public get animVal(): SVGNumberList;
	public get baseVal(): SVGNumberList;
	public constructor();
}

export external public interface ~SVGAnimatedPoints {
	get animatedPoints(): SVGPointList;
	get points(): SVGPointList;
}

export external public class SVGAnimatedPreserveAspectRatio {
	public get animVal(): SVGPreserveAspectRatio;
	public get baseVal(): SVGPreserveAspectRatio;
	public constructor();
}

export external public class SVGAnimatedRect {
	public get animVal(): DOMRectReadOnly;
	public get baseVal(): DOMRect;
	public constructor();
}

export external public class SVGAnimatedString {
	public get animVal(): string;
	public baseVal: string;
	public constructor();
}

export external public class SVGAnimatedTransformList {
	public get animVal(): SVGTransformList;
	public get baseVal(): SVGTransformList;
	public constructor();
}

export external public class SVGAnimationElement extends SVGElement implements SVGTests {
	public get targetElement(): SVGElement;
	public beginElement(): void;
	public beginElementAt(offset: number): void;
	public endElement(): void;
	public endElementAt(offset: number): void;
	public getCurrentTime(): number;
	public getSimpleDuration(): number;
	public getStartTime(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGCircleElement extends SVGGeometryElement {
	public get cx(): SVGAnimatedLength;
	public get cy(): SVGAnimatedLength;
	public get r(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGClipPathElement extends SVGElement {
	public get clipPathUnits(): SVGAnimatedEnumeration;
	public get transform(): SVGAnimatedTransformList;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGComponentTransferFunctionElement extends SVGElement {
	public get amplitude(): SVGAnimatedNumber;
	public get exponent(): SVGAnimatedNumber;
	public get intercept(): SVGAnimatedNumber;
	public get offset(): SVGAnimatedNumber;
	public get slope(): SVGAnimatedNumber;
	public get tableValues(): SVGAnimatedNumberList;
	public get type(): SVGAnimatedEnumeration;
	public get SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE(): number;
	public get SVG_FECOMPONENTTRANSFER_TYPE_GAMMA(): number;
	public get SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY(): number;
	public get SVG_FECOMPONENTTRANSFER_TYPE_LINEAR(): number;
	public get SVG_FECOMPONENTTRANSFER_TYPE_TABLE(): number;
	public get SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE(): number;
	public static get SVG_FECOMPONENTTRANSFER_TYPE_GAMMA(): number;
	public static get SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY(): number;
	public static get SVG_FECOMPONENTTRANSFER_TYPE_LINEAR(): number;
	public static get SVG_FECOMPONENTTRANSFER_TYPE_TABLE(): number;
	public static get SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN(): number;
}

export external public class SVGDefsElement extends SVGGraphicsElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGDescElement extends SVGElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~SVGElementEventMap extends ElementEventMap, DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {}

export external public class SVGElement extends Element implements DocumentAndElementEventHandlers, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrSVGElement {
	public get className(): any;
	public get ownerSVGElement(): SVGSVGElement;
	public get viewportElement(): SVGElement;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGEllipseElement extends SVGGeometryElement {
	public get cx(): SVGAnimatedLength;
	public get cy(): SVGAnimatedLength;
	public get rx(): SVGAnimatedLength;
	public get ry(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEBlendElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	public get in2(): SVGAnimatedString;
	public get mode(): SVGAnimatedEnumeration;
	public get SVG_FEBLEND_MODE_COLOR(): number;
	public get SVG_FEBLEND_MODE_COLOR_BURN(): number;
	public get SVG_FEBLEND_MODE_COLOR_DODGE(): number;
	public get SVG_FEBLEND_MODE_DARKEN(): number;
	public get SVG_FEBLEND_MODE_DIFFERENCE(): number;
	public get SVG_FEBLEND_MODE_EXCLUSION(): number;
	public get SVG_FEBLEND_MODE_HARD_LIGHT(): number;
	public get SVG_FEBLEND_MODE_HUE(): number;
	public get SVG_FEBLEND_MODE_LIGHTEN(): number;
	public get SVG_FEBLEND_MODE_LUMINOSITY(): number;
	public get SVG_FEBLEND_MODE_MULTIPLY(): number;
	public get SVG_FEBLEND_MODE_NORMAL(): number;
	public get SVG_FEBLEND_MODE_OVERLAY(): number;
	public get SVG_FEBLEND_MODE_SATURATION(): number;
	public get SVG_FEBLEND_MODE_SCREEN(): number;
	public get SVG_FEBLEND_MODE_SOFT_LIGHT(): number;
	public get SVG_FEBLEND_MODE_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_FEBLEND_MODE_COLOR(): number;
	public static get SVG_FEBLEND_MODE_COLOR_BURN(): number;
	public static get SVG_FEBLEND_MODE_COLOR_DODGE(): number;
	public static get SVG_FEBLEND_MODE_DARKEN(): number;
	public static get SVG_FEBLEND_MODE_DIFFERENCE(): number;
	public static get SVG_FEBLEND_MODE_EXCLUSION(): number;
	public static get SVG_FEBLEND_MODE_HARD_LIGHT(): number;
	public static get SVG_FEBLEND_MODE_HUE(): number;
	public static get SVG_FEBLEND_MODE_LIGHTEN(): number;
	public static get SVG_FEBLEND_MODE_LUMINOSITY(): number;
	public static get SVG_FEBLEND_MODE_MULTIPLY(): number;
	public static get SVG_FEBLEND_MODE_NORMAL(): number;
	public static get SVG_FEBLEND_MODE_OVERLAY(): number;
	public static get SVG_FEBLEND_MODE_SATURATION(): number;
	public static get SVG_FEBLEND_MODE_SCREEN(): number;
	public static get SVG_FEBLEND_MODE_SOFT_LIGHT(): number;
	public static get SVG_FEBLEND_MODE_UNKNOWN(): number;
}

export external public class SVGFEColorMatrixElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	public get type(): SVGAnimatedEnumeration;
	public get values(): SVGAnimatedNumberList;
	public get SVG_FECOLORMATRIX_TYPE_HUEROTATE(): number;
	public get SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA(): number;
	public get SVG_FECOLORMATRIX_TYPE_MATRIX(): number;
	public get SVG_FECOLORMATRIX_TYPE_SATURATE(): number;
	public get SVG_FECOLORMATRIX_TYPE_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_FECOLORMATRIX_TYPE_HUEROTATE(): number;
	public static get SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA(): number;
	public static get SVG_FECOLORMATRIX_TYPE_MATRIX(): number;
	public static get SVG_FECOLORMATRIX_TYPE_SATURATE(): number;
	public static get SVG_FECOLORMATRIX_TYPE_UNKNOWN(): number;
}

export external public class SVGFEComponentTransferElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFECompositeElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	public get in2(): SVGAnimatedString;
	public get k1(): SVGAnimatedNumber;
	public get k2(): SVGAnimatedNumber;
	public get k3(): SVGAnimatedNumber;
	public get k4(): SVGAnimatedNumber;
	public get operator(): SVGAnimatedEnumeration;
	public get SVG_FECOMPOSITE_OPERATOR_ARITHMETIC(): number;
	public get SVG_FECOMPOSITE_OPERATOR_ATOP(): number;
	public get SVG_FECOMPOSITE_OPERATOR_IN(): number;
	public get SVG_FECOMPOSITE_OPERATOR_OUT(): number;
	public get SVG_FECOMPOSITE_OPERATOR_OVER(): number;
	public get SVG_FECOMPOSITE_OPERATOR_UNKNOWN(): number;
	public get SVG_FECOMPOSITE_OPERATOR_XOR(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_FECOMPOSITE_OPERATOR_ARITHMETIC(): number;
	public static get SVG_FECOMPOSITE_OPERATOR_ATOP(): number;
	public static get SVG_FECOMPOSITE_OPERATOR_IN(): number;
	public static get SVG_FECOMPOSITE_OPERATOR_OUT(): number;
	public static get SVG_FECOMPOSITE_OPERATOR_OVER(): number;
	public static get SVG_FECOMPOSITE_OPERATOR_UNKNOWN(): number;
	public static get SVG_FECOMPOSITE_OPERATOR_XOR(): number;
}

export external public class SVGFEConvolveMatrixElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get bias(): SVGAnimatedNumber;
	public get divisor(): SVGAnimatedNumber;
	public get edgeMode(): SVGAnimatedEnumeration;
	public get in1(): SVGAnimatedString;
	public get kernelMatrix(): SVGAnimatedNumberList;
	public get kernelUnitLengthX(): SVGAnimatedNumber;
	public get kernelUnitLengthY(): SVGAnimatedNumber;
	public get orderX(): SVGAnimatedInteger;
	public get orderY(): SVGAnimatedInteger;
	public get preserveAlpha(): SVGAnimatedBoolean;
	public get targetX(): SVGAnimatedInteger;
	public get targetY(): SVGAnimatedInteger;
	public get SVG_EDGEMODE_DUPLICATE(): number;
	public get SVG_EDGEMODE_NONE(): number;
	public get SVG_EDGEMODE_UNKNOWN(): number;
	public get SVG_EDGEMODE_WRAP(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_EDGEMODE_DUPLICATE(): number;
	public static get SVG_EDGEMODE_NONE(): number;
	public static get SVG_EDGEMODE_UNKNOWN(): number;
	public static get SVG_EDGEMODE_WRAP(): number;
}

export external public class SVGFEDiffuseLightingElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get diffuseConstant(): SVGAnimatedNumber;
	public get in1(): SVGAnimatedString;
	public get kernelUnitLengthX(): SVGAnimatedNumber;
	public get kernelUnitLengthY(): SVGAnimatedNumber;
	public get surfaceScale(): SVGAnimatedNumber;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEDisplacementMapElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	public get in2(): SVGAnimatedString;
	public get scale(): SVGAnimatedNumber;
	public get xChannelSelector(): SVGAnimatedEnumeration;
	public get yChannelSelector(): SVGAnimatedEnumeration;
	public get SVG_CHANNEL_A(): number;
	public get SVG_CHANNEL_B(): number;
	public get SVG_CHANNEL_G(): number;
	public get SVG_CHANNEL_R(): number;
	public get SVG_CHANNEL_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_CHANNEL_A(): number;
	public static get SVG_CHANNEL_B(): number;
	public static get SVG_CHANNEL_G(): number;
	public static get SVG_CHANNEL_R(): number;
	public static get SVG_CHANNEL_UNKNOWN(): number;
}

export external public class SVGFEDistantLightElement extends SVGElement {
	public get azimuth(): SVGAnimatedNumber;
	public get elevation(): SVGAnimatedNumber;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEDropShadowElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get dx(): SVGAnimatedNumber;
	public get dy(): SVGAnimatedNumber;
	public get in1(): SVGAnimatedString;
	public get stdDeviationX(): SVGAnimatedNumber;
	public get stdDeviationY(): SVGAnimatedNumber;
	public setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEFloodElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEFuncAElement extends SVGComponentTransferFunctionElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEFuncBElement extends SVGComponentTransferFunctionElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEFuncGElement extends SVGComponentTransferFunctionElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEFuncRElement extends SVGComponentTransferFunctionElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEGaussianBlurElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	public get stdDeviationX(): SVGAnimatedNumber;
	public get stdDeviationY(): SVGAnimatedNumber;
	public setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEImageElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes, SVGURIReference {
	public get preserveAspectRatio(): SVGAnimatedPreserveAspectRatio;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEMergeElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEMergeNodeElement extends SVGElement {
	public get in1(): SVGAnimatedString;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEMorphologyElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	public get operator(): SVGAnimatedEnumeration;
	public get radiusX(): SVGAnimatedNumber;
	public get radiusY(): SVGAnimatedNumber;
	public get SVG_MORPHOLOGY_OPERATOR_DILATE(): number;
	public get SVG_MORPHOLOGY_OPERATOR_ERODE(): number;
	public get SVG_MORPHOLOGY_OPERATOR_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_MORPHOLOGY_OPERATOR_DILATE(): number;
	public static get SVG_MORPHOLOGY_OPERATOR_ERODE(): number;
	public static get SVG_MORPHOLOGY_OPERATOR_UNKNOWN(): number;
}

export external public class SVGFEOffsetElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get dx(): SVGAnimatedNumber;
	public get dy(): SVGAnimatedNumber;
	public get in1(): SVGAnimatedString;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFEPointLightElement extends SVGElement {
	public get x(): SVGAnimatedNumber;
	public get y(): SVGAnimatedNumber;
	public get z(): SVGAnimatedNumber;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFESpecularLightingElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	public get kernelUnitLengthX(): SVGAnimatedNumber;
	public get kernelUnitLengthY(): SVGAnimatedNumber;
	public get specularConstant(): SVGAnimatedNumber;
	public get specularExponent(): SVGAnimatedNumber;
	public get surfaceScale(): SVGAnimatedNumber;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFESpotLightElement extends SVGElement {
	public get limitingConeAngle(): SVGAnimatedNumber;
	public get pointsAtX(): SVGAnimatedNumber;
	public get pointsAtY(): SVGAnimatedNumber;
	public get pointsAtZ(): SVGAnimatedNumber;
	public get specularExponent(): SVGAnimatedNumber;
	public get x(): SVGAnimatedNumber;
	public get y(): SVGAnimatedNumber;
	public get z(): SVGAnimatedNumber;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFETileElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get in1(): SVGAnimatedString;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGFETurbulenceElement extends SVGElement implements SVGFilterPrimitiveStandardAttributes {
	public get baseFrequencyX(): SVGAnimatedNumber;
	public get baseFrequencyY(): SVGAnimatedNumber;
	public get numOctaves(): SVGAnimatedInteger;
	public get seed(): SVGAnimatedNumber;
	public get stitchTiles(): SVGAnimatedEnumeration;
	public get type(): SVGAnimatedEnumeration;
	public get SVG_STITCHTYPE_NOSTITCH(): number;
	public get SVG_STITCHTYPE_STITCH(): number;
	public get SVG_STITCHTYPE_UNKNOWN(): number;
	public get SVG_TURBULENCE_TYPE_FRACTALNOISE(): number;
	public get SVG_TURBULENCE_TYPE_TURBULENCE(): number;
	public get SVG_TURBULENCE_TYPE_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_STITCHTYPE_NOSTITCH(): number;
	public static get SVG_STITCHTYPE_STITCH(): number;
	public static get SVG_STITCHTYPE_UNKNOWN(): number;
	public static get SVG_TURBULENCE_TYPE_FRACTALNOISE(): number;
	public static get SVG_TURBULENCE_TYPE_TURBULENCE(): number;
	public static get SVG_TURBULENCE_TYPE_UNKNOWN(): number;
}

export external public class SVGFilterElement extends SVGElement implements SVGURIReference {
	public get filterUnits(): SVGAnimatedEnumeration;
	public get height(): SVGAnimatedLength;
	public get primitiveUnits(): SVGAnimatedEnumeration;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~SVGFilterPrimitiveStandardAttributes {
	get height(): SVGAnimatedLength;
	get result(): SVGAnimatedString;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
}

export external public interface ~SVGFitToViewBox {
	get preserveAspectRatio(): SVGAnimatedPreserveAspectRatio;
	get viewBox(): SVGAnimatedRect;
}

export external public class SVGForeignObjectElement extends SVGGraphicsElement {
	public get height(): SVGAnimatedLength;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGGElement extends SVGGraphicsElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGGeometryElement extends SVGGraphicsElement {
	public get pathLength(): SVGAnimatedNumber;
	public getPointAtLength(distance: number): DOMPoint;
	public getTotalLength(): number;
	public isPointInFill(point: DOMPointInit = ): boolean;
	public isPointInStroke(point: DOMPointInit = ): boolean;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGGradientElement extends SVGElement implements SVGURIReference {
	public get gradientTransform(): SVGAnimatedTransformList;
	public get gradientUnits(): SVGAnimatedEnumeration;
	public get spreadMethod(): SVGAnimatedEnumeration;
	public get SVG_SPREADMETHOD_PAD(): number;
	public get SVG_SPREADMETHOD_REFLECT(): number;
	public get SVG_SPREADMETHOD_REPEAT(): number;
	public get SVG_SPREADMETHOD_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_SPREADMETHOD_PAD(): number;
	public static get SVG_SPREADMETHOD_REFLECT(): number;
	public static get SVG_SPREADMETHOD_REPEAT(): number;
	public static get SVG_SPREADMETHOD_UNKNOWN(): number;
}

export external public class SVGGraphicsElement extends SVGElement implements SVGTests {
	public get transform(): SVGAnimatedTransformList;
	public getBBox(options: SVGBoundingBoxOptions = ): DOMRect;
	public getCTM(): DOMMatrix;
	public getScreenCTM(): DOMMatrix;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGImageElement extends SVGGraphicsElement implements SVGURIReference {
	public get height(): SVGAnimatedLength;
	public get preserveAspectRatio(): SVGAnimatedPreserveAspectRatio;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGLength {
	public get unitType(): number;
	public value: number;
	public valueAsString: string;
	public valueInSpecifiedUnits: number;
	public convertToSpecifiedUnits(unitType: number): void;
	public newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
	public get SVG_LENGTHTYPE_CM(): number;
	public get SVG_LENGTHTYPE_EMS(): number;
	public get SVG_LENGTHTYPE_EXS(): number;
	public get SVG_LENGTHTYPE_IN(): number;
	public get SVG_LENGTHTYPE_MM(): number;
	public get SVG_LENGTHTYPE_NUMBER(): number;
	public get SVG_LENGTHTYPE_PC(): number;
	public get SVG_LENGTHTYPE_PERCENTAGE(): number;
	public get SVG_LENGTHTYPE_PT(): number;
	public get SVG_LENGTHTYPE_PX(): number;
	public get SVG_LENGTHTYPE_UNKNOWN(): number;
	public constructor();
	public static get SVG_LENGTHTYPE_CM(): number;
	public static get SVG_LENGTHTYPE_EMS(): number;
	public static get SVG_LENGTHTYPE_EXS(): number;
	public static get SVG_LENGTHTYPE_IN(): number;
	public static get SVG_LENGTHTYPE_MM(): number;
	public static get SVG_LENGTHTYPE_NUMBER(): number;
	public static get SVG_LENGTHTYPE_PC(): number;
	public static get SVG_LENGTHTYPE_PERCENTAGE(): number;
	public static get SVG_LENGTHTYPE_PT(): number;
	public static get SVG_LENGTHTYPE_PX(): number;
	public static get SVG_LENGTHTYPE_UNKNOWN(): number;
}

export external public class SVGLengthList {
	public get length(): number;
	public get numberOfItems(): number;
	public appendItem(newItem: SVGLength): SVGLength;
	public clear(): void;
	public getItem(index: number): SVGLength;
	public initialize(newItem: SVGLength): SVGLength;
	public insertItemBefore(newItem: SVGLength, index: number): SVGLength;
	public removeItem(index: number): SVGLength;
	public replaceItem(newItem: SVGLength, index: number): SVGLength;
	public constructor();
}

export external public class SVGLineElement extends SVGGeometryElement {
	public get x1(): SVGAnimatedLength;
	public get x2(): SVGAnimatedLength;
	public get y1(): SVGAnimatedLength;
	public get y2(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGLinearGradientElement extends SVGGradientElement {
	public get x1(): SVGAnimatedLength;
	public get x2(): SVGAnimatedLength;
	public get y1(): SVGAnimatedLength;
	public get y2(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGMPathElement extends SVGElement implements SVGURIReference {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGMarkerElement extends SVGElement implements SVGFitToViewBox {
	public get markerHeight(): SVGAnimatedLength;
	public get markerUnits(): SVGAnimatedEnumeration;
	public get markerWidth(): SVGAnimatedLength;
	public get orientAngle(): SVGAnimatedAngle;
	public get orientType(): SVGAnimatedEnumeration;
	public get refX(): SVGAnimatedLength;
	public get refY(): SVGAnimatedLength;
	public setOrientToAngle(angle: SVGAngle): void;
	public setOrientToAuto(): void;
	public get SVG_MARKERUNITS_STROKEWIDTH(): number;
	public get SVG_MARKERUNITS_UNKNOWN(): number;
	public get SVG_MARKERUNITS_USERSPACEONUSE(): number;
	public get SVG_MARKER_ORIENT_ANGLE(): number;
	public get SVG_MARKER_ORIENT_AUTO(): number;
	public get SVG_MARKER_ORIENT_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get SVG_MARKERUNITS_STROKEWIDTH(): number;
	public static get SVG_MARKERUNITS_UNKNOWN(): number;
	public static get SVG_MARKERUNITS_USERSPACEONUSE(): number;
	public static get SVG_MARKER_ORIENT_ANGLE(): number;
	public static get SVG_MARKER_ORIENT_AUTO(): number;
	public static get SVG_MARKER_ORIENT_UNKNOWN(): number;
}

export external public class SVGMaskElement extends SVGElement {
	public get height(): SVGAnimatedLength;
	public get maskContentUnits(): SVGAnimatedEnumeration;
	public get maskUnits(): SVGAnimatedEnumeration;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGMetadataElement extends SVGElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGNumber {
	public value: number;
	public constructor();
}

export external public class SVGNumberList {
	public get length(): number;
	public get numberOfItems(): number;
	public appendItem(newItem: SVGNumber): SVGNumber;
	public clear(): void;
	public getItem(index: number): SVGNumber;
	public initialize(newItem: SVGNumber): SVGNumber;
	public insertItemBefore(newItem: SVGNumber, index: number): SVGNumber;
	public removeItem(index: number): SVGNumber;
	public replaceItem(newItem: SVGNumber, index: number): SVGNumber;
	public constructor();
}

export external public class SVGPathElement extends SVGGeometryElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGPatternElement extends SVGElement implements SVGFitToViewBox, SVGURIReference {
	public get height(): SVGAnimatedLength;
	public get patternContentUnits(): SVGAnimatedEnumeration;
	public get patternTransform(): SVGAnimatedTransformList;
	public get patternUnits(): SVGAnimatedEnumeration;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGPointList {
	public get length(): number;
	public get numberOfItems(): number;
	public appendItem(newItem: DOMPoint): DOMPoint;
	public clear(): void;
	public getItem(index: number): DOMPoint;
	public initialize(newItem: DOMPoint): DOMPoint;
	public insertItemBefore(newItem: DOMPoint, index: number): DOMPoint;
	public removeItem(index: number): DOMPoint;
	public replaceItem(newItem: DOMPoint, index: number): DOMPoint;
	public constructor();
}

export external public class SVGPolygonElement extends SVGGeometryElement implements SVGAnimatedPoints {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGPolylineElement extends SVGGeometryElement implements SVGAnimatedPoints {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGPreserveAspectRatio {
	public align: number;
	public meetOrSlice: number;
	public get SVG_MEETORSLICE_MEET(): number;
	public get SVG_MEETORSLICE_SLICE(): number;
	public get SVG_MEETORSLICE_UNKNOWN(): number;
	public get SVG_PRESERVEASPECTRATIO_NONE(): number;
	public get SVG_PRESERVEASPECTRATIO_UNKNOWN(): number;
	public get SVG_PRESERVEASPECTRATIO_XMAXYMAX(): number;
	public get SVG_PRESERVEASPECTRATIO_XMAXYMID(): number;
	public get SVG_PRESERVEASPECTRATIO_XMAXYMIN(): number;
	public get SVG_PRESERVEASPECTRATIO_XMIDYMAX(): number;
	public get SVG_PRESERVEASPECTRATIO_XMIDYMID(): number;
	public get SVG_PRESERVEASPECTRATIO_XMIDYMIN(): number;
	public get SVG_PRESERVEASPECTRATIO_XMINYMAX(): number;
	public get SVG_PRESERVEASPECTRATIO_XMINYMID(): number;
	public get SVG_PRESERVEASPECTRATIO_XMINYMIN(): number;
	public constructor();
	public static get SVG_MEETORSLICE_MEET(): number;
	public static get SVG_MEETORSLICE_SLICE(): number;
	public static get SVG_MEETORSLICE_UNKNOWN(): number;
	public static get SVG_PRESERVEASPECTRATIO_NONE(): number;
	public static get SVG_PRESERVEASPECTRATIO_UNKNOWN(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMAXYMAX(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMAXYMID(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMAXYMIN(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMIDYMAX(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMIDYMID(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMIDYMIN(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMINYMAX(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMINYMID(): number;
	public static get SVG_PRESERVEASPECTRATIO_XMINYMIN(): number;
}

export external public class SVGRadialGradientElement extends SVGGradientElement {
	public get cx(): SVGAnimatedLength;
	public get cy(): SVGAnimatedLength;
	public get fr(): SVGAnimatedLength;
	public get fx(): SVGAnimatedLength;
	public get fy(): SVGAnimatedLength;
	public get r(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGRectElement extends SVGGeometryElement {
	public get height(): SVGAnimatedLength;
	public get rx(): SVGAnimatedLength;
	public get ry(): SVGAnimatedLength;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~SVGSVGElementEventMap extends SVGElementEventMap, WindowEventHandlersEventMap {}

export external public class SVGSVGElement extends SVGGraphicsElement implements SVGFitToViewBox, WindowEventHandlers {
	public currentScale: number;
	public get currentTranslate(): DOMPointReadOnly;
	public get height(): SVGAnimatedLength;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	public animationsPaused(): boolean;
	public checkEnclosure(element: SVGElement, rect: DOMRectReadOnly): boolean;
	public checkIntersection(element: SVGElement, rect: DOMRectReadOnly): boolean;
	public createSVGAngle(): SVGAngle;
	public createSVGLength(): SVGLength;
	public createSVGMatrix(): DOMMatrix;
	public createSVGNumber(): SVGNumber;
	public createSVGPoint(): DOMPoint;
	public createSVGRect(): DOMRect;
	public createSVGTransform(): SVGTransform;
	public createSVGTransformFromMatrix(matrix: DOMMatrix2DInit = ): SVGTransform;
	public deselectAll(): void;
	public forceRedraw(): void;
	public getCurrentTime(): number;
	public getElementById(elementId: string): Element;
	public getEnclosureList(rect: DOMRectReadOnly, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;
	public getIntersectionList(rect: DOMRectReadOnly, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;
	public pauseAnimations(): void;
	public setCurrentTime(seconds: number): void;
	public suspendRedraw(maxWaitMilliseconds: number): number;
	public unpauseAnimations(): void;
	public unsuspendRedraw(suspendHandleID: number): void;
	public unsuspendRedrawAll(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGScriptElement extends SVGElement implements SVGURIReference {
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGSetElement extends SVGAnimationElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGStopElement extends SVGElement {
	public get offset(): SVGAnimatedNumber;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGStringList {
	public get length(): number;
	public get numberOfItems(): number;
	public appendItem(newItem: string): string;
	public clear(): void;
	public getItem(index: number): string;
	public initialize(newItem: string): string;
	public insertItemBefore(newItem: string, index: number): string;
	public removeItem(index: number): string;
	public replaceItem(newItem: string, index: number): string;
	public constructor();
}

export external public class SVGStyleElement extends SVGElement implements LinkStyle {
	public disabled: boolean;
	public media: string;
	public title: string;
	public type: string;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGSwitchElement extends SVGGraphicsElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGSymbolElement extends SVGElement implements SVGFitToViewBox {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGTSpanElement extends SVGTextPositioningElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~SVGTests {
	get requiredExtensions(): SVGStringList;
	get systemLanguage(): SVGStringList;
}

export external public class SVGTextContentElement extends SVGGraphicsElement {
	public get lengthAdjust(): SVGAnimatedEnumeration;
	public get textLength(): SVGAnimatedLength;
	public getCharNumAtPosition(point: DOMPointInit = ): number;
	public getComputedTextLength(): number;
	public getEndPositionOfChar(charnum: number): DOMPoint;
	public getExtentOfChar(charnum: number): DOMRect;
	public getNumberOfChars(): number;
	public getRotationOfChar(charnum: number): number;
	public getStartPositionOfChar(charnum: number): DOMPoint;
	public getSubStringLength(charnum: number, nchars: number): number;
	public selectSubString(charnum: number, nchars: number): void;
	public get LENGTHADJUST_SPACING(): number;
	public get LENGTHADJUST_SPACINGANDGLYPHS(): number;
	public get LENGTHADJUST_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get LENGTHADJUST_SPACING(): number;
	public static get LENGTHADJUST_SPACINGANDGLYPHS(): number;
	public static get LENGTHADJUST_UNKNOWN(): number;
}

export external public class SVGTextElement extends SVGTextPositioningElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGTextPathElement extends SVGTextContentElement implements SVGURIReference {
	public get method(): SVGAnimatedEnumeration;
	public get spacing(): SVGAnimatedEnumeration;
	public get startOffset(): SVGAnimatedLength;
	public get TEXTPATH_METHODTYPE_ALIGN(): number;
	public get TEXTPATH_METHODTYPE_STRETCH(): number;
	public get TEXTPATH_METHODTYPE_UNKNOWN(): number;
	public get TEXTPATH_SPACINGTYPE_AUTO(): number;
	public get TEXTPATH_SPACINGTYPE_EXACT(): number;
	public get TEXTPATH_SPACINGTYPE_UNKNOWN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get TEXTPATH_METHODTYPE_ALIGN(): number;
	public static get TEXTPATH_METHODTYPE_STRETCH(): number;
	public static get TEXTPATH_METHODTYPE_UNKNOWN(): number;
	public static get TEXTPATH_SPACINGTYPE_AUTO(): number;
	public static get TEXTPATH_SPACINGTYPE_EXACT(): number;
	public static get TEXTPATH_SPACINGTYPE_UNKNOWN(): number;
}

export external public class SVGTextPositioningElement extends SVGTextContentElement {
	public get dx(): SVGAnimatedLengthList;
	public get dy(): SVGAnimatedLengthList;
	public get rotate(): SVGAnimatedNumberList;
	public get x(): SVGAnimatedLengthList;
	public get y(): SVGAnimatedLengthList;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGTitleElement extends SVGElement {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGTransform {
	public get angle(): number;
	public get matrix(): DOMMatrix;
	public get type(): number;
	public setMatrix(matrix: DOMMatrix2DInit = ): void;
	public setRotate(angle: number, cx: number, cy: number): void;
	public setScale(sx: number, sy: number): void;
	public setSkewX(angle: number): void;
	public setSkewY(angle: number): void;
	public setTranslate(tx: number, ty: number): void;
	public get SVG_TRANSFORM_MATRIX(): number;
	public get SVG_TRANSFORM_ROTATE(): number;
	public get SVG_TRANSFORM_SCALE(): number;
	public get SVG_TRANSFORM_SKEWX(): number;
	public get SVG_TRANSFORM_SKEWY(): number;
	public get SVG_TRANSFORM_TRANSLATE(): number;
	public get SVG_TRANSFORM_UNKNOWN(): number;
	public constructor();
	public static get SVG_TRANSFORM_MATRIX(): number;
	public static get SVG_TRANSFORM_ROTATE(): number;
	public static get SVG_TRANSFORM_SCALE(): number;
	public static get SVG_TRANSFORM_SKEWX(): number;
	public static get SVG_TRANSFORM_SKEWY(): number;
	public static get SVG_TRANSFORM_TRANSLATE(): number;
	public static get SVG_TRANSFORM_UNKNOWN(): number;
}

export external public class SVGTransformList {
	public get length(): number;
	public get numberOfItems(): number;
	public appendItem(newItem: SVGTransform): SVGTransform;
	public clear(): void;
	public consolidate(): SVGTransform;
	public createSVGTransformFromMatrix(matrix: DOMMatrix2DInit = ): SVGTransform;
	public getItem(index: number): SVGTransform;
	public initialize(newItem: SVGTransform): SVGTransform;
	public insertItemBefore(newItem: SVGTransform, index: number): SVGTransform;
	public removeItem(index: number): SVGTransform;
	public replaceItem(newItem: SVGTransform, index: number): SVGTransform;
	public constructor();
}

export external public interface ~SVGURIReference {
	get href(): SVGAnimatedString;
}

export external public class SVGUnitTypes {
	public get SVG_UNIT_TYPE_OBJECTBOUNDINGBOX(): number;
	public get SVG_UNIT_TYPE_UNKNOWN(): number;
	public get SVG_UNIT_TYPE_USERSPACEONUSE(): number;
	public constructor();
	public static get SVG_UNIT_TYPE_OBJECTBOUNDINGBOX(): number;
	public static get SVG_UNIT_TYPE_UNKNOWN(): number;
	public static get SVG_UNIT_TYPE_USERSPACEONUSE(): number;
}

export external public class SVGUseElement extends SVGGraphicsElement implements SVGURIReference {
	public get height(): SVGAnimatedLength;
	public get width(): SVGAnimatedLength;
	public get x(): SVGAnimatedLength;
	public get y(): SVGAnimatedLength;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SVGViewElement extends SVGElement implements SVGFitToViewBox {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class Screen {
	public get availHeight(): number;
	public get availWidth(): number;
	public get colorDepth(): number;
	public get height(): number;
	public get orientation(): ScreenOrientation;
	public get pixelDepth(): number;
	public get width(): number;
	public constructor();
}

export external public interface ~ScreenOrientationEventMap {
	change: Event;
}

export external public class ScreenOrientation extends EventTarget {
	public get angle(): number;
	public onchange: ({@This(ScreenOrientation) function(ev: Event): any});
	public get type(): OrientationType;
	public lock(orientation: OrientationLockType): Promise<void>;
	public unlock(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~ScriptProcessorNodeEventMap {
	audioprocess: AudioProcessingEvent;
}

export external public class ScriptProcessorNode extends AudioNode {
	public get bufferSize(): number;
	public onaudioprocess: ({@This(ScriptProcessorNode) function(ev: AudioProcessingEvent): any});
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SecurityPolicyViolationEvent extends Event {
	public get blockedURI(): string;
	public get columnNumber(): number;
	public get disposition(): SecurityPolicyViolationEventDisposition;
	public get documentURI(): string;
	public get effectiveDirective(): string;
	public get lineNumber(): number;
	public get originalPolicy(): string;
	public get referrer(): string;
	public get sample(): string;
	public get sourceFile(): string;
	public get statusCode(): number;
	public get violatedDirective(): string;
	public constructor(type: string, eventInitDict: SecurityPolicyViolationEventInit = );
}

export external public class Selection {
	public get anchorNode(): Node;
	public get anchorOffset(): number;
	public get focusNode(): Node;
	public get focusOffset(): number;
	public get isCollapsed(): boolean;
	public get rangeCount(): number;
	public get type(): string;
	public addRange(range: Range): void;
	public collapse(node: Node, offset: number = ): void;
	public collapseToEnd(): void;
	public collapseToStart(): void;
	public containsNode(node: Node, allowPartialContainment: boolean = ): boolean;
	public deleteFromDocument(): void;
	public empty(): void;
	public extend(node: Node, offset: number = ): void;
	public getRangeAt(index: number): Range;
	public removeAllRanges(): void;
	public removeRange(range: Range): void;
	public selectAllChildren(node: Node): void;
	public setBaseAndExtent(anchorNode: Node, anchorOffset: number, focusNode: Node, focusOffset: number): void;
	public setPosition(node: Node, offset: number = ): void;
	@Override
	public toString(): string;
	public constructor();
	@Override
	public static toString(): string;
}

export external public interface ~ServiceWorkerEventMap extends AbstractWorkerEventMap {
	statechange: Event;
}

export external public class ServiceWorker extends EventTarget implements AbstractWorker {
	public onstatechange: ({@This(ServiceWorker) function(ev: Event): any});
	public get scriptURL(): string;
	public get state(): ServiceWorkerState;
	public postMessage(...args: any+): any+; // overloading not supported
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~ServiceWorkerContainerEventMap {
	controllerchange: Event;
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public class ServiceWorkerContainer extends EventTarget {
	public get controller(): ServiceWorker;
	public oncontrollerchange: ({@This(ServiceWorkerContainer) function(ev: Event): any});
	public onmessage: ({@This(ServiceWorkerContainer) function(ev: MessageEvent): any});
	public onmessageerror: ({@This(ServiceWorkerContainer) function(ev: MessageEvent): any});
	public get ready(): Promise<ServiceWorkerRegistration>;
	public getRegistration(clientURL: string | URL = ): Promise<ServiceWorkerRegistration>;
	public getRegistrations(): Promise<ReadonlyArray<ServiceWorkerRegistration>>;
	public register(scriptURL: string | URL, options: RegistrationOptions = ): Promise<ServiceWorkerRegistration>;
	public startMessages(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~ServiceWorkerRegistrationEventMap {
	updatefound: Event;
}

export external public class ServiceWorkerRegistration extends EventTarget {
	public get active(): ServiceWorker;
	public get installing(): ServiceWorker;
	public onupdatefound: ({@This(ServiceWorkerRegistration) function(ev: Event): any});
	public get pushManager(): PushManager;
	public get scope(): string;
	public get updateViaCache(): ServiceWorkerUpdateViaCache;
	public get waiting(): ServiceWorker;
	public getNotifications(filter: GetNotificationOptions = ): Promise<Array<Notification>>;
	public showNotification(title: string, options: NotificationOptions = ): Promise<void>;
	public unregister(): Promise<boolean>;
	public update(): Promise<void>;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class ShadowRoot extends DocumentFragment implements DocumentOrShadowRoot, InnerHTML {
	public get delegatesFocus(): boolean;
	public get host(): Element;
	public get mode(): ShadowRootMode;
	public constructor();
}

export external public class SharedWorker extends EventTarget implements AbstractWorker {
	public get port(): MessagePort;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(scriptURL: string | URL, options: string | WorkerOptions = );
}

export external public interface ~Slottable {
	get assignedSlot(): HTMLSlotElement;
}

export external public interface ~SourceBufferEventMap {
	abort: Event;
	error: Event;
	update: Event;
	updateend: Event;
	updatestart: Event;
}

export external public class SourceBuffer extends EventTarget {
	public appendWindowEnd: number;
	public appendWindowStart: number;
	public get buffered(): TimeRanges;
	public mode: AppendMode;
	public onabort: ({@This(SourceBuffer) function(ev: Event): any});
	public onerror: ({@This(SourceBuffer) function(ev: Event): any});
	public onupdate: ({@This(SourceBuffer) function(ev: Event): any});
	public onupdateend: ({@This(SourceBuffer) function(ev: Event): any});
	public onupdatestart: ({@This(SourceBuffer) function(ev: Event): any});
	public timestampOffset: number;
	public get updating(): boolean;
	public abort(): void;
	public appendBuffer(data: BufferSource): void;
	public changeType(type: string): void;
	public remove(start: number, end: number): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~SourceBufferListEventMap {
	addsourcebuffer: Event;
	removesourcebuffer: Event;
}

export external public class SourceBufferList extends EventTarget {
	public get length(): number;
	public onaddsourcebuffer: ({@This(SourceBufferList) function(ev: Event): any});
	public onremovesourcebuffer: ({@This(SourceBufferList) function(ev: Event): any});
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SpeechRecognitionAlternative {
	public get confidence(): number;
	public get transcript(): string;
	public constructor();
}

export external public class SpeechRecognitionResult {
	public get isFinal(): boolean;
	public get length(): number;
	public item(index: number): SpeechRecognitionAlternative;
	public constructor();
}

export external public class SpeechRecognitionResultList {
	public get length(): number;
	public item(index: number): SpeechRecognitionResult;
	public constructor();
}

export external public interface ~SpeechSynthesisEventMap {
	voiceschanged: Event;
}

export external public class SpeechSynthesis extends EventTarget {
	public onvoiceschanged: ({@This(SpeechSynthesis) function(ev: Event): any});
	public get paused(): boolean;
	public get pending(): boolean;
	public get speaking(): boolean;
	public cancel(): void;
	public getVoices(): Array<SpeechSynthesisVoice>;
	public pause(): void;
	public resume(): void;
	public speak(utterance: SpeechSynthesisUtterance): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class SpeechSynthesisErrorEvent extends SpeechSynthesisEvent {
	public get error(): SpeechSynthesisErrorCode;
	public constructor(type: string, eventInitDict: SpeechSynthesisErrorEventInit);
}

export external public class SpeechSynthesisEvent extends Event {
	public get charIndex(): number;
	public get charLength(): number;
	public get elapsedTime(): number;
	public get name(): string;
	public get utterance(): SpeechSynthesisUtterance;
	public constructor(type: string, eventInitDict: SpeechSynthesisEventInit);
}

export external public interface ~SpeechSynthesisUtteranceEventMap {
	boundary: SpeechSynthesisEvent;
	end: SpeechSynthesisEvent;
	error: SpeechSynthesisErrorEvent;
	mark: SpeechSynthesisEvent;
	pause: SpeechSynthesisEvent;
	resume: SpeechSynthesisEvent;
	start: SpeechSynthesisEvent;
}

export external public class SpeechSynthesisUtterance extends EventTarget {
	public lang: string;
	public onboundary: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	public onend: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	public onerror: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisErrorEvent): any});
	public onmark: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	public onpause: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	public onresume: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	public onstart: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	public pitch: number;
	public rate: number;
	public text: string;
	public voice: SpeechSynthesisVoice;
	public volume: number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(text: string = );
}

export external public class SpeechSynthesisVoice {
	public get default(): boolean;
	public get lang(): string;
	public get localService(): boolean;
	public get name(): string;
	public get voiceURI(): string;
	public constructor();
}

export external public class StaticRange extends AbstractRange {
	public constructor(init: StaticRangeInit);
}

export external public class StereoPannerNode extends AudioNode {
	public get pan(): AudioParam;
	public constructor(context: BaseAudioContext, options: StereoPannerOptions = );
}

export external public class Storage {
	public get length(): number;
	public clear(): void;
	public getItem(key: string): string;
	public key(index: number): string;
	public removeItem(key: string): void;
	public setItem(key: string, value: string): void;
	public constructor();
}

export external public class StorageEvent extends Event {
	public get key(): string;
	public get newValue(): string;
	public get oldValue(): string;
	public get storageArea(): Storage;
	public get url(): string;
	public initStorageEvent(type: string, bubbles: boolean = , cancelable: boolean = , key: string = , oldValue: string = , newValue: string = , url: string | URL = , storageArea: Storage = ): void;
	public constructor(type: string, eventInitDict: StorageEventInit = );
}

export external public class StorageManager {
	public estimate(): Promise<StorageEstimate>;
	public persist(): Promise<boolean>;
	public persisted(): Promise<boolean>;
	public constructor();
}

export external public interface ~StyleMedia {
	type: string;
	matchMedium(mediaquery: string): boolean;
}

export external public class StyleSheet {
	public disabled: boolean;
	public get href(): string;
	public get media(): MediaList;
	public get ownerNode(): Element | ProcessingInstruction;
	public get parentStyleSheet(): CSSStyleSheet;
	public get title(): string;
	public get type(): string;
	public constructor();
}

export external public class StyleSheetList {
	public get length(): number;
	public item(index: number): CSSStyleSheet;
	public constructor();
}

export external public class SubmitEvent extends Event {
	public get submitter(): HTMLElement;
	public constructor(type: string, eventInitDict: SubmitEventInit = );
}

export external public class SubtleCrypto {
	public decrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<any>;
	public deriveBits(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, length: number): Promise<ArrayBuffer>;
	public deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: boolean, keyUsages: Array<KeyUsage>): Promise<CryptoKey>;
	public digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>;
	public encrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<any>;
	public exportKey(...args: any+): any+; // overloading not supported
	public generateKey(...args: any+): any+; // overloading not supported
	public importKey(...args: any+): any+; // overloading not supported
	public sign(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>;
	public unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Array<KeyUsage>): Promise<CryptoKey>;
	public verify(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, signature: BufferSource, data: BufferSource): Promise<boolean>;
	public wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<ArrayBuffer>;
	public constructor();
}

export external public class Text extends CharacterData implements Slottable {
	@Override
	public get assignedSlot(): HTMLSlotElement;
	public get wholeText(): string;
	public splitText(offset: number): Text;
	public constructor(data: string = );
}

export external public class TextDecoder extends TextDecoderCommon {
	public decode(input: BufferSource = , options: TextDecodeOptions = ): string;
	public constructor(label: string = , options: TextDecoderOptions = );
}

export external public interface ~TextDecoderCommon {
	get encoding(): string;
	get fatal(): boolean;
	get ignoreBOM(): boolean;
}

export external public class TextDecoderStream extends GenericTransformStream implements TextDecoderCommon {
	@Override
	public get readable(): ReadableStream<string>;
	@Override
	public get writable(): WritableStream<BufferSource>;
	public constructor(label: string = , options: TextDecoderOptions = );
}

export external public class TextEncoder extends TextEncoderCommon {
	public encode(input: string = ): Uint8Array;
	public encodeInto(source: string, destination: Uint8Array): TextEncoderEncodeIntoResult;
	public constructor();
}

export external public interface ~TextEncoderCommon {
	get encoding(): string;
}

export external public class TextEncoderStream extends GenericTransformStream implements TextEncoderCommon {
	@Override
	public get readable(): ReadableStream<Uint8Array>;
	@Override
	public get writable(): WritableStream<string>;
	public constructor();
}

export external public class TextMetrics {
	public get actualBoundingBoxAscent(): number;
	public get actualBoundingBoxDescent(): number;
	public get actualBoundingBoxLeft(): number;
	public get actualBoundingBoxRight(): number;
	public get fontBoundingBoxAscent(): number;
	public get fontBoundingBoxDescent(): number;
	public get width(): number;
	public constructor();
}

export external public interface ~TextTrackEventMap {
	cuechange: Event;
}

export external public class TextTrack extends EventTarget {
	public get activeCues(): TextTrackCueList;
	public get cues(): TextTrackCueList;
	public get id(): string;
	public get inBandMetadataTrackDispatchType(): string;
	public get kind(): TextTrackKind;
	public get label(): string;
	public get language(): string;
	public mode: TextTrackMode;
	public oncuechange: ({@This(TextTrack) function(ev: Event): any});
	public addCue(cue: TextTrackCue): void;
	public removeCue(cue: TextTrackCue): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~TextTrackCueEventMap {
	enter: Event;
	exit: Event;
}

export external public class TextTrackCue extends EventTarget {
	public endTime: number;
	public id: string;
	public onenter: ({@This(TextTrackCue) function(ev: Event): any});
	public onexit: ({@This(TextTrackCue) function(ev: Event): any});
	public pauseOnExit: boolean;
	public startTime: number;
	public get track(): TextTrack;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class TextTrackCueList {
	public get length(): number;
	public getCueById(id: string): TextTrackCue;
	public constructor();
}

export external public interface ~TextTrackListEventMap {
	addtrack: TrackEvent;
	change: Event;
	removetrack: TrackEvent;
}

export external public class TextTrackList extends EventTarget {
	public get length(): number;
	public onaddtrack: ({@This(TextTrackList) function(ev: TrackEvent): any});
	public onchange: ({@This(TextTrackList) function(ev: Event): any});
	public onremovetrack: ({@This(TextTrackList) function(ev: TrackEvent): any});
	public getTrackById(id: string): TextTrack;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class TimeRanges {
	public get length(): number;
	public end(index: number): number;
	public start(index: number): number;
	public constructor();
}

export external public class Touch {
	public get clientX(): number;
	public get clientY(): number;
	public get force(): number;
	public get identifier(): number;
	public get pageX(): number;
	public get pageY(): number;
	public get radiusX(): number;
	public get radiusY(): number;
	public get rotationAngle(): number;
	public get screenX(): number;
	public get screenY(): number;
	public get target(): EventTarget;
	public constructor(touchInitDict: TouchInit);
}

export external public class TouchEvent extends UIEvent {
	public get altKey(): boolean;
	public get changedTouches(): TouchList;
	public get ctrlKey(): boolean;
	public get metaKey(): boolean;
	public get shiftKey(): boolean;
	public get targetTouches(): TouchList;
	public get touches(): TouchList;
	public constructor(type: string, eventInitDict: TouchEventInit = );
}

export external public class TouchList {
	public get length(): number;
	public item(index: number): Touch;
	public constructor();
}

export external public class TrackEvent extends Event {
	public get track(): TextTrack;
	public constructor(type: string, eventInitDict: TrackEventInit = );
}

export external public class TransformStream<I,O> {
	public get readable(): ReadableStream<O>;
	public get writable(): WritableStream<I>;
	public constructor(transformer: Transformer<I,O> = , writableStrategy: QueuingStrategy<I> = , readableStrategy: QueuingStrategy<O> = );
}

export external public class TransformStreamDefaultController<O> {
	public get desiredSize(): number;
	public enqueue(chunk: O = ): void;
	public error(reason: any = ): void;
	public terminate(): void;
	public constructor();
}

export external public class TransitionEvent extends Event {
	public get elapsedTime(): number;
	public get propertyName(): string;
	public get pseudoElement(): string;
	public constructor(type: string, transitionEventInitDict: TransitionEventInit = );
}

export external public class TreeWalker {
	public currentNode: Node;
	public get filter(): NodeFilter;
	public get root(): Node;
	public get whatToShow(): number;
	public firstChild(): Node;
	public lastChild(): Node;
	public nextNode(): Node;
	public nextSibling(): Node;
	public parentNode(): Node;
	public previousNode(): Node;
	public previousSibling(): Node;
	public constructor();
}

export external public class UIEvent extends Event {
	public get detail(): number;
	public get view(): Window;
	public get which(): number;
	public initUIEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , viewArg: Window = , detailArg: number = ): void;
	public constructor(type: string, eventInitDict: UIEventInit = );
}

export external public class URL {
	public hash: string;
	public host: string;
	public hostname: string;
	public href: string;
	@Override
	public toString(): string;
	public get origin(): string;
	public password: string;
	public pathname: string;
	public port: string;
	public protocol: string;
	public search: string;
	public get searchParams(): URLSearchParams;
	public username: string;
	public toJSON(): string;
	public constructor(url: string | URL, base: string | URL = );
	public static createObjectURL(obj: Blob | MediaSource): string;
	public static revokeObjectURL(url: string): void;
}

export external public type webkitURL = URL;

var webkitURL: any+;

export external public class URLSearchParams {
	public append(name: string, value: string): void;
	public delete(name: string): void;
	public get(name: string): string;
	public getAll(name: string): Array<string>;
	public has(name: string): boolean;
	public set(name: string, value: string): void;
	public sort(): void;
	@Override
	public toString(): string;
	public forEach(callbackfn: (value: string, key: string, parent: URLSearchParams)=>void, thisArg: any = ): void;
	public constructor(init: Array<Array<string>> | Record<string,string> | string | URLSearchParams = );
	@Override
	public static toString(): string;
}

export external public class VTTCue extends TextTrackCue {
	public align: AlignSetting;
	public line: LineAndPositionSetting;
	public lineAlign: LineAlignSetting;
	public position: LineAndPositionSetting;
	public positionAlign: PositionAlignSetting;
	public region: VTTRegion;
	public size: number;
	public snapToLines: boolean;
	public text: string;
	public vertical: DirectionSetting;
	public getCueAsHTML(): DocumentFragment;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(startTime: number, endTime: number, text: string);
}

export external public class VTTRegion {
	public id: string;
	public lines: number;
	public regionAnchorX: number;
	public regionAnchorY: number;
	public scroll: ScrollSetting;
	public viewportAnchorX: number;
	public viewportAnchorY: number;
	public width: number;
	public constructor();
}

export external public class ValidityState {
	public get badInput(): boolean;
	public get customError(): boolean;
	public get patternMismatch(): boolean;
	public get rangeOverflow(): boolean;
	public get rangeUnderflow(): boolean;
	public get stepMismatch(): boolean;
	public get tooLong(): boolean;
	public get tooShort(): boolean;
	public get typeMismatch(): boolean;
	public get valid(): boolean;
	public get valueMissing(): boolean;
	public constructor();
}

export external public class VideoPlaybackQuality {
	public get corruptedVideoFrames(): number;
	public get creationTime(): DOMHighResTimeStamp;
	public get droppedVideoFrames(): number;
	public get totalVideoFrames(): number;
	public constructor();
}

export external public interface ~VisualViewportEventMap {
	resize: Event;
	scroll: Event;
}

export external public class VisualViewport extends EventTarget {
	public get height(): number;
	public get offsetLeft(): number;
	public get offsetTop(): number;
	public onresize: ({@This(VisualViewport) function(ev: Event): any});
	public onscroll: ({@This(VisualViewport) function(ev: Event): any});
	public get pageLeft(): number;
	public get pageTop(): number;
	public get scale(): number;
	public get width(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~WEBGL_color_buffer_float {
	get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT(): GLenum;
	get RGBA32F_EXT(): GLenum;
	get UNSIGNED_NORMALIZED_EXT(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_astc {
	getSupportedProfiles(): Array<string>;
	get COMPRESSED_RGBA_ASTC_10x10_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_10x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_10x6_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_10x8_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_12x10_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_12x12_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_4x4_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_5x4_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_5x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_6x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_6x6_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_8x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_8x6_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_8x8_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_etc {
	get COMPRESSED_R11_EAC(): GLenum;
	get COMPRESSED_RG11_EAC(): GLenum;
	get COMPRESSED_RGB8_ETC2(): GLenum;
	get COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2(): GLenum;
	get COMPRESSED_RGBA8_ETC2_EAC(): GLenum;
	get COMPRESSED_SIGNED_R11_EAC(): GLenum;
	get COMPRESSED_SIGNED_RG11_EAC(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ETC2_EAC(): GLenum;
	get COMPRESSED_SRGB8_ETC2(): GLenum;
	get COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_etc1 {
	get COMPRESSED_RGB_ETC1_WEBGL(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_pvrtc {
	get COMPRESSED_RGBA_PVRTC_2BPPV1_IMG(): GLenum;
	get COMPRESSED_RGBA_PVRTC_4BPPV1_IMG(): GLenum;
	get COMPRESSED_RGB_PVRTC_2BPPV1_IMG(): GLenum;
	get COMPRESSED_RGB_PVRTC_4BPPV1_IMG(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_s3tc {
	get COMPRESSED_RGBA_S3TC_DXT1_EXT(): GLenum;
	get COMPRESSED_RGBA_S3TC_DXT3_EXT(): GLenum;
	get COMPRESSED_RGBA_S3TC_DXT5_EXT(): GLenum;
	get COMPRESSED_RGB_S3TC_DXT1_EXT(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_s3tc_srgb {
	get COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT(): GLenum;
	get COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT(): GLenum;
	get COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT(): GLenum;
	get COMPRESSED_SRGB_S3TC_DXT1_EXT(): GLenum;
}

export external public interface ~WEBGL_debug_renderer_info {
	get UNMASKED_RENDERER_WEBGL(): GLenum;
	get UNMASKED_VENDOR_WEBGL(): GLenum;
}

export external public interface ~WEBGL_debug_shaders {
	getTranslatedShaderSource(shader: WebGLShader): string;
}

export external public interface ~WEBGL_depth_texture {
	get UNSIGNED_INT_24_8_WEBGL(): GLenum;
}

export external public interface ~WEBGL_draw_buffers {
	drawBuffersWEBGL(buffers: Array<GLenum>): void;
	get COLOR_ATTACHMENT0_WEBGL(): GLenum;
	get COLOR_ATTACHMENT10_WEBGL(): GLenum;
	get COLOR_ATTACHMENT11_WEBGL(): GLenum;
	get COLOR_ATTACHMENT12_WEBGL(): GLenum;
	get COLOR_ATTACHMENT13_WEBGL(): GLenum;
	get COLOR_ATTACHMENT14_WEBGL(): GLenum;
	get COLOR_ATTACHMENT15_WEBGL(): GLenum;
	get COLOR_ATTACHMENT1_WEBGL(): GLenum;
	get COLOR_ATTACHMENT2_WEBGL(): GLenum;
	get COLOR_ATTACHMENT3_WEBGL(): GLenum;
	get COLOR_ATTACHMENT4_WEBGL(): GLenum;
	get COLOR_ATTACHMENT5_WEBGL(): GLenum;
	get COLOR_ATTACHMENT6_WEBGL(): GLenum;
	get COLOR_ATTACHMENT7_WEBGL(): GLenum;
	get COLOR_ATTACHMENT8_WEBGL(): GLenum;
	get COLOR_ATTACHMENT9_WEBGL(): GLenum;
	get DRAW_BUFFER0_WEBGL(): GLenum;
	get DRAW_BUFFER10_WEBGL(): GLenum;
	get DRAW_BUFFER11_WEBGL(): GLenum;
	get DRAW_BUFFER12_WEBGL(): GLenum;
	get DRAW_BUFFER13_WEBGL(): GLenum;
	get DRAW_BUFFER14_WEBGL(): GLenum;
	get DRAW_BUFFER15_WEBGL(): GLenum;
	get DRAW_BUFFER1_WEBGL(): GLenum;
	get DRAW_BUFFER2_WEBGL(): GLenum;
	get DRAW_BUFFER3_WEBGL(): GLenum;
	get DRAW_BUFFER4_WEBGL(): GLenum;
	get DRAW_BUFFER5_WEBGL(): GLenum;
	get DRAW_BUFFER6_WEBGL(): GLenum;
	get DRAW_BUFFER7_WEBGL(): GLenum;
	get DRAW_BUFFER8_WEBGL(): GLenum;
	get DRAW_BUFFER9_WEBGL(): GLenum;
	get MAX_COLOR_ATTACHMENTS_WEBGL(): GLenum;
	get MAX_DRAW_BUFFERS_WEBGL(): GLenum;
}

export external public interface ~WEBGL_lose_context {
	loseContext(): void;
	restoreContext(): void;
}

export external public class WaveShaperNode extends AudioNode {
	public curve: Float32Array;
	public oversample: OverSampleType;
	public constructor(context: BaseAudioContext, options: WaveShaperOptions = );
}

export external public class WebGL2RenderingContext extends WebGL2RenderingContextBase implements WebGL2RenderingContextOverloads, WebGLRenderingContextBase {
	public constructor();
	public static get ACTIVE_UNIFORM_BLOCKS(): GLenum;
	public static get ALREADY_SIGNALED(): GLenum;
	public static get ANY_SAMPLES_PASSED(): GLenum;
	public static get ANY_SAMPLES_PASSED_CONSERVATIVE(): GLenum;
	public static get COLOR(): GLenum;
	public static get COLOR_ATTACHMENT1(): GLenum;
	public static get COLOR_ATTACHMENT10(): GLenum;
	public static get COLOR_ATTACHMENT11(): GLenum;
	public static get COLOR_ATTACHMENT12(): GLenum;
	public static get COLOR_ATTACHMENT13(): GLenum;
	public static get COLOR_ATTACHMENT14(): GLenum;
	public static get COLOR_ATTACHMENT15(): GLenum;
	public static get COLOR_ATTACHMENT2(): GLenum;
	public static get COLOR_ATTACHMENT3(): GLenum;
	public static get COLOR_ATTACHMENT4(): GLenum;
	public static get COLOR_ATTACHMENT5(): GLenum;
	public static get COLOR_ATTACHMENT6(): GLenum;
	public static get COLOR_ATTACHMENT7(): GLenum;
	public static get COLOR_ATTACHMENT8(): GLenum;
	public static get COLOR_ATTACHMENT9(): GLenum;
	public static get COMPARE_REF_TO_TEXTURE(): GLenum;
	public static get CONDITION_SATISFIED(): GLenum;
	public static get COPY_READ_BUFFER(): GLenum;
	public static get COPY_READ_BUFFER_BINDING(): GLenum;
	public static get COPY_WRITE_BUFFER(): GLenum;
	public static get COPY_WRITE_BUFFER_BINDING(): GLenum;
	public static get CURRENT_QUERY(): GLenum;
	public static get DEPTH(): GLenum;
	public static get DEPTH24_STENCIL8(): GLenum;
	public static get DEPTH32F_STENCIL8(): GLenum;
	public static get DEPTH_COMPONENT24(): GLenum;
	public static get DEPTH_COMPONENT32F(): GLenum;
	public static get DRAW_BUFFER0(): GLenum;
	public static get DRAW_BUFFER1(): GLenum;
	public static get DRAW_BUFFER10(): GLenum;
	public static get DRAW_BUFFER11(): GLenum;
	public static get DRAW_BUFFER12(): GLenum;
	public static get DRAW_BUFFER13(): GLenum;
	public static get DRAW_BUFFER14(): GLenum;
	public static get DRAW_BUFFER15(): GLenum;
	public static get DRAW_BUFFER2(): GLenum;
	public static get DRAW_BUFFER3(): GLenum;
	public static get DRAW_BUFFER4(): GLenum;
	public static get DRAW_BUFFER5(): GLenum;
	public static get DRAW_BUFFER6(): GLenum;
	public static get DRAW_BUFFER7(): GLenum;
	public static get DRAW_BUFFER8(): GLenum;
	public static get DRAW_BUFFER9(): GLenum;
	public static get DRAW_FRAMEBUFFER(): GLenum;
	public static get DRAW_FRAMEBUFFER_BINDING(): GLenum;
	public static get DYNAMIC_COPY(): GLenum;
	public static get DYNAMIC_READ(): GLenum;
	public static get FLOAT_32_UNSIGNED_INT_24_8_REV(): GLenum;
	public static get FLOAT_MAT2x3(): GLenum;
	public static get FLOAT_MAT2x4(): GLenum;
	public static get FLOAT_MAT3x2(): GLenum;
	public static get FLOAT_MAT3x4(): GLenum;
	public static get FLOAT_MAT4x2(): GLenum;
	public static get FLOAT_MAT4x3(): GLenum;
	public static get FRAGMENT_SHADER_DERIVATIVE_HINT(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_BLUE_SIZE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_GREEN_SIZE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_RED_SIZE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER(): GLenum;
	public static get FRAMEBUFFER_DEFAULT(): GLenum;
	public static get FRAMEBUFFER_INCOMPLETE_MULTISAMPLE(): GLenum;
	public static get HALF_FLOAT(): GLenum;
	public static get INTERLEAVED_ATTRIBS(): GLenum;
	public static get INT_2_10_10_10_REV(): GLenum;
	public static get INT_SAMPLER_2D(): GLenum;
	public static get INT_SAMPLER_2D_ARRAY(): GLenum;
	public static get INT_SAMPLER_3D(): GLenum;
	public static get INT_SAMPLER_CUBE(): GLenum;
	public static get INVALID_INDEX(): GLenum;
	public static get MAX(): GLenum;
	public static get MAX_3D_TEXTURE_SIZE(): GLenum;
	public static get MAX_ARRAY_TEXTURE_LAYERS(): GLenum;
	public static get MAX_CLIENT_WAIT_TIMEOUT_WEBGL(): GLenum;
	public static get MAX_COLOR_ATTACHMENTS(): GLenum;
	public static get MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS(): GLenum;
	public static get MAX_COMBINED_UNIFORM_BLOCKS(): GLenum;
	public static get MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS(): GLenum;
	public static get MAX_DRAW_BUFFERS(): GLenum;
	public static get MAX_ELEMENTS_INDICES(): GLenum;
	public static get MAX_ELEMENTS_VERTICES(): GLenum;
	public static get MAX_ELEMENT_INDEX(): GLenum;
	public static get MAX_FRAGMENT_INPUT_COMPONENTS(): GLenum;
	public static get MAX_FRAGMENT_UNIFORM_BLOCKS(): GLenum;
	public static get MAX_FRAGMENT_UNIFORM_COMPONENTS(): GLenum;
	public static get MAX_PROGRAM_TEXEL_OFFSET(): GLenum;
	public static get MAX_SAMPLES(): GLenum;
	public static get MAX_SERVER_WAIT_TIMEOUT(): GLenum;
	public static get MAX_TEXTURE_LOD_BIAS(): GLenum;
	public static get MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS(): GLenum;
	public static get MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS(): GLenum;
	public static get MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS(): GLenum;
	public static get MAX_UNIFORM_BLOCK_SIZE(): GLenum;
	public static get MAX_UNIFORM_BUFFER_BINDINGS(): GLenum;
	public static get MAX_VARYING_COMPONENTS(): GLenum;
	public static get MAX_VERTEX_OUTPUT_COMPONENTS(): GLenum;
	public static get MAX_VERTEX_UNIFORM_BLOCKS(): GLenum;
	public static get MAX_VERTEX_UNIFORM_COMPONENTS(): GLenum;
	public static get MIN(): GLenum;
	public static get MIN_PROGRAM_TEXEL_OFFSET(): GLenum;
	public static get OBJECT_TYPE(): GLenum;
	public static get PACK_ROW_LENGTH(): GLenum;
	public static get PACK_SKIP_PIXELS(): GLenum;
	public static get PACK_SKIP_ROWS(): GLenum;
	public static get PIXEL_PACK_BUFFER(): GLenum;
	public static get PIXEL_PACK_BUFFER_BINDING(): GLenum;
	public static get PIXEL_UNPACK_BUFFER(): GLenum;
	public static get PIXEL_UNPACK_BUFFER_BINDING(): GLenum;
	public static get QUERY_RESULT(): GLenum;
	public static get QUERY_RESULT_AVAILABLE(): GLenum;
	public static get R11F_G11F_B10F(): GLenum;
	public static get R16F(): GLenum;
	public static get R16I(): GLenum;
	public static get R16UI(): GLenum;
	public static get R32F(): GLenum;
	public static get R32I(): GLenum;
	public static get R32UI(): GLenum;
	public static get R8(): GLenum;
	public static get R8I(): GLenum;
	public static get R8UI(): GLenum;
	public static get R8_SNORM(): GLenum;
	public static get RASTERIZER_DISCARD(): GLenum;
	public static get READ_BUFFER(): GLenum;
	public static get READ_FRAMEBUFFER(): GLenum;
	public static get READ_FRAMEBUFFER_BINDING(): GLenum;
	public static get RED(): GLenum;
	public static get RED_INTEGER(): GLenum;
	public static get RENDERBUFFER_SAMPLES(): GLenum;
	public static get RG(): GLenum;
	public static get RG16F(): GLenum;
	public static get RG16I(): GLenum;
	public static get RG16UI(): GLenum;
	public static get RG32F(): GLenum;
	public static get RG32I(): GLenum;
	public static get RG32UI(): GLenum;
	public static get RG8(): GLenum;
	public static get RG8I(): GLenum;
	public static get RG8UI(): GLenum;
	public static get RG8_SNORM(): GLenum;
	public static get RGB10_A2(): GLenum;
	public static get RGB10_A2UI(): GLenum;
	public static get RGB16F(): GLenum;
	public static get RGB16I(): GLenum;
	public static get RGB16UI(): GLenum;
	public static get RGB32F(): GLenum;
	public static get RGB32I(): GLenum;
	public static get RGB32UI(): GLenum;
	public static get RGB8(): GLenum;
	public static get RGB8I(): GLenum;
	public static get RGB8UI(): GLenum;
	public static get RGB8_SNORM(): GLenum;
	public static get RGB9_E5(): GLenum;
	public static get RGBA16F(): GLenum;
	public static get RGBA16I(): GLenum;
	public static get RGBA16UI(): GLenum;
	public static get RGBA32F(): GLenum;
	public static get RGBA32I(): GLenum;
	public static get RGBA32UI(): GLenum;
	public static get RGBA8(): GLenum;
	public static get RGBA8I(): GLenum;
	public static get RGBA8UI(): GLenum;
	public static get RGBA8_SNORM(): GLenum;
	public static get RGBA_INTEGER(): GLenum;
	public static get RGB_INTEGER(): GLenum;
	public static get RG_INTEGER(): GLenum;
	public static get SAMPLER_2D_ARRAY(): GLenum;
	public static get SAMPLER_2D_ARRAY_SHADOW(): GLenum;
	public static get SAMPLER_2D_SHADOW(): GLenum;
	public static get SAMPLER_3D(): GLenum;
	public static get SAMPLER_BINDING(): GLenum;
	public static get SAMPLER_CUBE_SHADOW(): GLenum;
	public static get SEPARATE_ATTRIBS(): GLenum;
	public static get SIGNALED(): GLenum;
	public static get SIGNED_NORMALIZED(): GLenum;
	public static get SRGB(): GLenum;
	public static get SRGB8(): GLenum;
	public static get SRGB8_ALPHA8(): GLenum;
	public static get STATIC_COPY(): GLenum;
	public static get STATIC_READ(): GLenum;
	public static get STENCIL(): GLenum;
	public static get STREAM_COPY(): GLenum;
	public static get STREAM_READ(): GLenum;
	public static get SYNC_CONDITION(): GLenum;
	public static get SYNC_FENCE(): GLenum;
	public static get SYNC_FLAGS(): GLenum;
	public static get SYNC_FLUSH_COMMANDS_BIT(): GLenum;
	public static get SYNC_GPU_COMMANDS_COMPLETE(): GLenum;
	public static get SYNC_STATUS(): GLenum;
	public static get TEXTURE_2D_ARRAY(): GLenum;
	public static get TEXTURE_3D(): GLenum;
	public static get TEXTURE_BASE_LEVEL(): GLenum;
	public static get TEXTURE_BINDING_2D_ARRAY(): GLenum;
	public static get TEXTURE_BINDING_3D(): GLenum;
	public static get TEXTURE_COMPARE_FUNC(): GLenum;
	public static get TEXTURE_COMPARE_MODE(): GLenum;
	public static get TEXTURE_IMMUTABLE_FORMAT(): GLenum;
	public static get TEXTURE_IMMUTABLE_LEVELS(): GLenum;
	public static get TEXTURE_MAX_LEVEL(): GLenum;
	public static get TEXTURE_MAX_LOD(): GLenum;
	public static get TEXTURE_MIN_LOD(): GLenum;
	public static get TEXTURE_WRAP_R(): GLenum;
	public static get TIMEOUT_EXPIRED(): GLenum;
	public static get TIMEOUT_IGNORED(): GLint64;
	public static get TRANSFORM_FEEDBACK(): GLenum;
	public static get TRANSFORM_FEEDBACK_ACTIVE(): GLenum;
	public static get TRANSFORM_FEEDBACK_BINDING(): GLenum;
	public static get TRANSFORM_FEEDBACK_BUFFER(): GLenum;
	public static get TRANSFORM_FEEDBACK_BUFFER_BINDING(): GLenum;
	public static get TRANSFORM_FEEDBACK_BUFFER_MODE(): GLenum;
	public static get TRANSFORM_FEEDBACK_BUFFER_SIZE(): GLenum;
	public static get TRANSFORM_FEEDBACK_BUFFER_START(): GLenum;
	public static get TRANSFORM_FEEDBACK_PAUSED(): GLenum;
	public static get TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN(): GLenum;
	public static get TRANSFORM_FEEDBACK_VARYINGS(): GLenum;
	public static get UNIFORM_ARRAY_STRIDE(): GLenum;
	public static get UNIFORM_BLOCK_ACTIVE_UNIFORMS(): GLenum;
	public static get UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES(): GLenum;
	public static get UNIFORM_BLOCK_BINDING(): GLenum;
	public static get UNIFORM_BLOCK_DATA_SIZE(): GLenum;
	public static get UNIFORM_BLOCK_INDEX(): GLenum;
	public static get UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER(): GLenum;
	public static get UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER(): GLenum;
	public static get UNIFORM_BUFFER(): GLenum;
	public static get UNIFORM_BUFFER_BINDING(): GLenum;
	public static get UNIFORM_BUFFER_OFFSET_ALIGNMENT(): GLenum;
	public static get UNIFORM_BUFFER_SIZE(): GLenum;
	public static get UNIFORM_BUFFER_START(): GLenum;
	public static get UNIFORM_IS_ROW_MAJOR(): GLenum;
	public static get UNIFORM_MATRIX_STRIDE(): GLenum;
	public static get UNIFORM_OFFSET(): GLenum;
	public static get UNIFORM_SIZE(): GLenum;
	public static get UNIFORM_TYPE(): GLenum;
	public static get UNPACK_IMAGE_HEIGHT(): GLenum;
	public static get UNPACK_ROW_LENGTH(): GLenum;
	public static get UNPACK_SKIP_IMAGES(): GLenum;
	public static get UNPACK_SKIP_PIXELS(): GLenum;
	public static get UNPACK_SKIP_ROWS(): GLenum;
	public static get UNSIGNALED(): GLenum;
	public static get UNSIGNED_INT_10F_11F_11F_REV(): GLenum;
	public static get UNSIGNED_INT_24_8(): GLenum;
	public static get UNSIGNED_INT_2_10_10_10_REV(): GLenum;
	public static get UNSIGNED_INT_5_9_9_9_REV(): GLenum;
	public static get UNSIGNED_INT_SAMPLER_2D(): GLenum;
	public static get UNSIGNED_INT_SAMPLER_2D_ARRAY(): GLenum;
	public static get UNSIGNED_INT_SAMPLER_3D(): GLenum;
	public static get UNSIGNED_INT_SAMPLER_CUBE(): GLenum;
	public static get UNSIGNED_INT_VEC2(): GLenum;
	public static get UNSIGNED_INT_VEC3(): GLenum;
	public static get UNSIGNED_INT_VEC4(): GLenum;
	public static get UNSIGNED_NORMALIZED(): GLenum;
	public static get VERTEX_ARRAY_BINDING(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_DIVISOR(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_INTEGER(): GLenum;
	public static get WAIT_FAILED(): GLenum;
	public static get ACTIVE_ATTRIBUTES(): GLenum;
	public static get ACTIVE_TEXTURE(): GLenum;
	public static get ACTIVE_UNIFORMS(): GLenum;
	public static get ALIASED_LINE_WIDTH_RANGE(): GLenum;
	public static get ALIASED_POINT_SIZE_RANGE(): GLenum;
	public static get ALPHA(): GLenum;
	public static get ALPHA_BITS(): GLenum;
	public static get ALWAYS(): GLenum;
	public static get ARRAY_BUFFER(): GLenum;
	public static get ARRAY_BUFFER_BINDING(): GLenum;
	public static get ATTACHED_SHADERS(): GLenum;
	public static get BACK(): GLenum;
	public static get BLEND(): GLenum;
	public static get BLEND_COLOR(): GLenum;
	public static get BLEND_DST_ALPHA(): GLenum;
	public static get BLEND_DST_RGB(): GLenum;
	public static get BLEND_EQUATION(): GLenum;
	public static get BLEND_EQUATION_ALPHA(): GLenum;
	public static get BLEND_EQUATION_RGB(): GLenum;
	public static get BLEND_SRC_ALPHA(): GLenum;
	public static get BLEND_SRC_RGB(): GLenum;
	public static get BLUE_BITS(): GLenum;
	public static get BOOL(): GLenum;
	public static get BOOL_VEC2(): GLenum;
	public static get BOOL_VEC3(): GLenum;
	public static get BOOL_VEC4(): GLenum;
	public static get BROWSER_DEFAULT_WEBGL(): GLenum;
	public static get BUFFER_SIZE(): GLenum;
	public static get BUFFER_USAGE(): GLenum;
	public static get BYTE(): GLenum;
	public static get CCW(): GLenum;
	public static get CLAMP_TO_EDGE(): GLenum;
	public static get COLOR_ATTACHMENT0(): GLenum;
	public static get COLOR_BUFFER_BIT(): GLenum;
	public static get COLOR_CLEAR_VALUE(): GLenum;
	public static get COLOR_WRITEMASK(): GLenum;
	public static get COMPILE_STATUS(): GLenum;
	public static get COMPRESSED_TEXTURE_FORMATS(): GLenum;
	public static get CONSTANT_ALPHA(): GLenum;
	public static get CONSTANT_COLOR(): GLenum;
	public static get CONTEXT_LOST_WEBGL(): GLenum;
	public static get CULL_FACE(): GLenum;
	public static get CULL_FACE_MODE(): GLenum;
	public static get CURRENT_PROGRAM(): GLenum;
	public static get CURRENT_VERTEX_ATTRIB(): GLenum;
	public static get CW(): GLenum;
	public static get DECR(): GLenum;
	public static get DECR_WRAP(): GLenum;
	public static get DELETE_STATUS(): GLenum;
	public static get DEPTH_ATTACHMENT(): GLenum;
	public static get DEPTH_BITS(): GLenum;
	public static get DEPTH_BUFFER_BIT(): GLenum;
	public static get DEPTH_CLEAR_VALUE(): GLenum;
	public static get DEPTH_COMPONENT(): GLenum;
	public static get DEPTH_COMPONENT16(): GLenum;
	public static get DEPTH_FUNC(): GLenum;
	public static get DEPTH_RANGE(): GLenum;
	public static get DEPTH_STENCIL(): GLenum;
	public static get DEPTH_STENCIL_ATTACHMENT(): GLenum;
	public static get DEPTH_TEST(): GLenum;
	public static get DEPTH_WRITEMASK(): GLenum;
	public static get DITHER(): GLenum;
	public static get DONT_CARE(): GLenum;
	public static get DST_ALPHA(): GLenum;
	public static get DST_COLOR(): GLenum;
	public static get DYNAMIC_DRAW(): GLenum;
	public static get ELEMENT_ARRAY_BUFFER(): GLenum;
	public static get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum;
	public static get EQUAL(): GLenum;
	public static get FASTEST(): GLenum;
	public static get FLOAT(): GLenum;
	public static get FLOAT_MAT2(): GLenum;
	public static get FLOAT_MAT3(): GLenum;
	public static get FLOAT_MAT4(): GLenum;
	public static get FLOAT_VEC2(): GLenum;
	public static get FLOAT_VEC3(): GLenum;
	public static get FLOAT_VEC4(): GLenum;
	public static get FRAGMENT_SHADER(): GLenum;
	public static get FRAMEBUFFER(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum;
	public static get FRAMEBUFFER_BINDING(): GLenum;
	public static get FRAMEBUFFER_COMPLETE(): GLenum;
	public static get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum;
	public static get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum;
	public static get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum;
	public static get FRAMEBUFFER_UNSUPPORTED(): GLenum;
	public static get FRONT(): GLenum;
	public static get FRONT_AND_BACK(): GLenum;
	public static get FRONT_FACE(): GLenum;
	public static get FUNC_ADD(): GLenum;
	public static get FUNC_REVERSE_SUBTRACT(): GLenum;
	public static get FUNC_SUBTRACT(): GLenum;
	public static get GENERATE_MIPMAP_HINT(): GLenum;
	public static get GEQUAL(): GLenum;
	public static get GREATER(): GLenum;
	public static get GREEN_BITS(): GLenum;
	public static get HIGH_FLOAT(): GLenum;
	public static get HIGH_INT(): GLenum;
	public static get IMPLEMENTATION_COLOR_READ_FORMAT(): GLenum;
	public static get IMPLEMENTATION_COLOR_READ_TYPE(): GLenum;
	public static get INCR(): GLenum;
	public static get INCR_WRAP(): GLenum;
	public static get INT(): GLenum;
	public static get INT_VEC2(): GLenum;
	public static get INT_VEC3(): GLenum;
	public static get INT_VEC4(): GLenum;
	public static get INVALID_ENUM(): GLenum;
	public static get INVALID_FRAMEBUFFER_OPERATION(): GLenum;
	public static get INVALID_OPERATION(): GLenum;
	public static get INVALID_VALUE(): GLenum;
	public static get INVERT(): GLenum;
	public static get KEEP(): GLenum;
	public static get LEQUAL(): GLenum;
	public static get LESS(): GLenum;
	public static get LINEAR(): GLenum;
	public static get LINEAR_MIPMAP_LINEAR(): GLenum;
	public static get LINEAR_MIPMAP_NEAREST(): GLenum;
	public static get LINES(): GLenum;
	public static get LINE_LOOP(): GLenum;
	public static get LINE_STRIP(): GLenum;
	public static get LINE_WIDTH(): GLenum;
	public static get LINK_STATUS(): GLenum;
	public static get LOW_FLOAT(): GLenum;
	public static get LOW_INT(): GLenum;
	public static get LUMINANCE(): GLenum;
	public static get LUMINANCE_ALPHA(): GLenum;
	public static get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum;
	public static get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum;
	public static get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum;
	public static get MAX_RENDERBUFFER_SIZE(): GLenum;
	public static get MAX_TEXTURE_IMAGE_UNITS(): GLenum;
	public static get MAX_TEXTURE_SIZE(): GLenum;
	public static get MAX_VARYING_VECTORS(): GLenum;
	public static get MAX_VERTEX_ATTRIBS(): GLenum;
	public static get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum;
	public static get MAX_VERTEX_UNIFORM_VECTORS(): GLenum;
	public static get MAX_VIEWPORT_DIMS(): GLenum;
	public static get MEDIUM_FLOAT(): GLenum;
	public static get MEDIUM_INT(): GLenum;
	public static get MIRRORED_REPEAT(): GLenum;
	public static get NEAREST(): GLenum;
	public static get NEAREST_MIPMAP_LINEAR(): GLenum;
	public static get NEAREST_MIPMAP_NEAREST(): GLenum;
	public static get NEVER(): GLenum;
	public static get NICEST(): GLenum;
	public static get NONE(): GLenum;
	public static get NOTEQUAL(): GLenum;
	public static get NO_ERROR(): GLenum;
	public static get ONE(): GLenum;
	public static get ONE_MINUS_CONSTANT_ALPHA(): GLenum;
	public static get ONE_MINUS_CONSTANT_COLOR(): GLenum;
	public static get ONE_MINUS_DST_ALPHA(): GLenum;
	public static get ONE_MINUS_DST_COLOR(): GLenum;
	public static get ONE_MINUS_SRC_ALPHA(): GLenum;
	public static get ONE_MINUS_SRC_COLOR(): GLenum;
	public static get OUT_OF_MEMORY(): GLenum;
	public static get PACK_ALIGNMENT(): GLenum;
	public static get POINTS(): GLenum;
	public static get POLYGON_OFFSET_FACTOR(): GLenum;
	public static get POLYGON_OFFSET_FILL(): GLenum;
	public static get POLYGON_OFFSET_UNITS(): GLenum;
	public static get RED_BITS(): GLenum;
	public static get RENDERBUFFER(): GLenum;
	public static get RENDERBUFFER_ALPHA_SIZE(): GLenum;
	public static get RENDERBUFFER_BINDING(): GLenum;
	public static get RENDERBUFFER_BLUE_SIZE(): GLenum;
	public static get RENDERBUFFER_DEPTH_SIZE(): GLenum;
	public static get RENDERBUFFER_GREEN_SIZE(): GLenum;
	public static get RENDERBUFFER_HEIGHT(): GLenum;
	public static get RENDERBUFFER_INTERNAL_FORMAT(): GLenum;
	public static get RENDERBUFFER_RED_SIZE(): GLenum;
	public static get RENDERBUFFER_STENCIL_SIZE(): GLenum;
	public static get RENDERBUFFER_WIDTH(): GLenum;
	public static get RENDERER(): GLenum;
	public static get REPEAT(): GLenum;
	public static get REPLACE(): GLenum;
	public static get RGB(): GLenum;
	public static get RGB565(): GLenum;
	public static get RGB5_A1(): GLenum;
	public static get RGBA(): GLenum;
	public static get RGBA4(): GLenum;
	public static get SAMPLER_2D(): GLenum;
	public static get SAMPLER_CUBE(): GLenum;
	public static get SAMPLES(): GLenum;
	public static get SAMPLE_ALPHA_TO_COVERAGE(): GLenum;
	public static get SAMPLE_BUFFERS(): GLenum;
	public static get SAMPLE_COVERAGE(): GLenum;
	public static get SAMPLE_COVERAGE_INVERT(): GLenum;
	public static get SAMPLE_COVERAGE_VALUE(): GLenum;
	public static get SCISSOR_BOX(): GLenum;
	public static get SCISSOR_TEST(): GLenum;
	public static get SHADER_TYPE(): GLenum;
	public static get SHADING_LANGUAGE_VERSION(): GLenum;
	public static get SHORT(): GLenum;
	public static get SRC_ALPHA(): GLenum;
	public static get SRC_ALPHA_SATURATE(): GLenum;
	public static get SRC_COLOR(): GLenum;
	public static get STATIC_DRAW(): GLenum;
	public static get STENCIL_ATTACHMENT(): GLenum;
	public static get STENCIL_BACK_FAIL(): GLenum;
	public static get STENCIL_BACK_FUNC(): GLenum;
	public static get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum;
	public static get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum;
	public static get STENCIL_BACK_REF(): GLenum;
	public static get STENCIL_BACK_VALUE_MASK(): GLenum;
	public static get STENCIL_BACK_WRITEMASK(): GLenum;
	public static get STENCIL_BITS(): GLenum;
	public static get STENCIL_BUFFER_BIT(): GLenum;
	public static get STENCIL_CLEAR_VALUE(): GLenum;
	public static get STENCIL_FAIL(): GLenum;
	public static get STENCIL_FUNC(): GLenum;
	public static get STENCIL_INDEX8(): GLenum;
	public static get STENCIL_PASS_DEPTH_FAIL(): GLenum;
	public static get STENCIL_PASS_DEPTH_PASS(): GLenum;
	public static get STENCIL_REF(): GLenum;
	public static get STENCIL_TEST(): GLenum;
	public static get STENCIL_VALUE_MASK(): GLenum;
	public static get STENCIL_WRITEMASK(): GLenum;
	public static get STREAM_DRAW(): GLenum;
	public static get SUBPIXEL_BITS(): GLenum;
	public static get TEXTURE(): GLenum;
	public static get TEXTURE0(): GLenum;
	public static get TEXTURE1(): GLenum;
	public static get TEXTURE10(): GLenum;
	public static get TEXTURE11(): GLenum;
	public static get TEXTURE12(): GLenum;
	public static get TEXTURE13(): GLenum;
	public static get TEXTURE14(): GLenum;
	public static get TEXTURE15(): GLenum;
	public static get TEXTURE16(): GLenum;
	public static get TEXTURE17(): GLenum;
	public static get TEXTURE18(): GLenum;
	public static get TEXTURE19(): GLenum;
	public static get TEXTURE2(): GLenum;
	public static get TEXTURE20(): GLenum;
	public static get TEXTURE21(): GLenum;
	public static get TEXTURE22(): GLenum;
	public static get TEXTURE23(): GLenum;
	public static get TEXTURE24(): GLenum;
	public static get TEXTURE25(): GLenum;
	public static get TEXTURE26(): GLenum;
	public static get TEXTURE27(): GLenum;
	public static get TEXTURE28(): GLenum;
	public static get TEXTURE29(): GLenum;
	public static get TEXTURE3(): GLenum;
	public static get TEXTURE30(): GLenum;
	public static get TEXTURE31(): GLenum;
	public static get TEXTURE4(): GLenum;
	public static get TEXTURE5(): GLenum;
	public static get TEXTURE6(): GLenum;
	public static get TEXTURE7(): GLenum;
	public static get TEXTURE8(): GLenum;
	public static get TEXTURE9(): GLenum;
	public static get TEXTURE_2D(): GLenum;
	public static get TEXTURE_BINDING_2D(): GLenum;
	public static get TEXTURE_BINDING_CUBE_MAP(): GLenum;
	public static get TEXTURE_CUBE_MAP(): GLenum;
	public static get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum;
	public static get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum;
	public static get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum;
	public static get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum;
	public static get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum;
	public static get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum;
	public static get TEXTURE_MAG_FILTER(): GLenum;
	public static get TEXTURE_MIN_FILTER(): GLenum;
	public static get TEXTURE_WRAP_S(): GLenum;
	public static get TEXTURE_WRAP_T(): GLenum;
	public static get TRIANGLES(): GLenum;
	public static get TRIANGLE_FAN(): GLenum;
	public static get TRIANGLE_STRIP(): GLenum;
	public static get UNPACK_ALIGNMENT(): GLenum;
	public static get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum;
	public static get UNPACK_FLIP_Y_WEBGL(): GLenum;
	public static get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum;
	public static get UNSIGNED_BYTE(): GLenum;
	public static get UNSIGNED_INT(): GLenum;
	public static get UNSIGNED_SHORT(): GLenum;
	public static get UNSIGNED_SHORT_4_4_4_4(): GLenum;
	public static get UNSIGNED_SHORT_5_5_5_1(): GLenum;
	public static get UNSIGNED_SHORT_5_6_5(): GLenum;
	public static get VALIDATE_STATUS(): GLenum;
	public static get VENDOR(): GLenum;
	public static get VERSION(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum;
	public static get VERTEX_SHADER(): GLenum;
	public static get VIEWPORT(): GLenum;
	public static get ZERO(): GLenum;
}

export external public interface ~WebGL2RenderingContextBase {
	beginQuery(target: GLenum, query: WebGLQuery): void;
	beginTransformFeedback(primitiveMode: GLenum): void;
	bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer): void;
	bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer, offset: GLintptr, size: GLsizeiptr): void;
	bindSampler(unit: GLuint, sampler: WebGLSampler): void;
	bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback): void;
	bindVertexArray(array: WebGLVertexArrayObject): void;
	blitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void;
	clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void;
	clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint = ): void;
	clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint = ): void;
	clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint = ): void;
	clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum;
	compressedTexImage3D(...args: any+): any+; // overloading not supported
	compressedTexSubImage3D(...args: any+): any+; // overloading not supported
	copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void;
	copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	createQuery(): WebGLQuery;
	createSampler(): WebGLSampler;
	createTransformFeedback(): WebGLTransformFeedback;
	createVertexArray(): WebGLVertexArrayObject;
	deleteQuery(query: WebGLQuery): void;
	deleteSampler(sampler: WebGLSampler): void;
	deleteSync(sync: WebGLSync): void;
	deleteTransformFeedback(tf: WebGLTransformFeedback): void;
	deleteVertexArray(vertexArray: WebGLVertexArrayObject): void;
	drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void;
	drawBuffers(buffers: Array<GLenum>): void;
	drawElementsInstanced(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, instanceCount: GLsizei): void;
	drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type: GLenum, offset: GLintptr): void;
	endQuery(target: GLenum): void;
	endTransformFeedback(): void;
	fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync;
	framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint, layer: GLint): void;
	getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): string;
	getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): any;
	getActiveUniforms(program: WebGLProgram, uniformIndices: Array<GLuint>, pname: GLenum): any;
	getBufferSubData(target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView, dstOffset: GLuint = , length: GLuint = ): void;
	getFragDataLocation(program: WebGLProgram, name: string): GLint;
	getIndexedParameter(target: GLenum, index: GLuint): any;
	getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): any;
	getQuery(target: GLenum, pname: GLenum): WebGLQuery;
	getQueryParameter(query: WebGLQuery, pname: GLenum): any;
	getSamplerParameter(sampler: WebGLSampler, pname: GLenum): any;
	getSyncParameter(sync: WebGLSync, pname: GLenum): any;
	getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo;
	getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): GLuint;
	getUniformIndices(program: WebGLProgram, uniformNames: Array<string>): Array<GLuint>;
	invalidateFramebuffer(target: GLenum, attachments: Array<GLenum>): void;
	invalidateSubFramebuffer(target: GLenum, attachments: Array<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	isQuery(query: WebGLQuery): GLboolean;
	isSampler(sampler: WebGLSampler): GLboolean;
	isSync(sync: WebGLSync): GLboolean;
	isTransformFeedback(tf: WebGLTransformFeedback): GLboolean;
	isVertexArray(vertexArray: WebGLVertexArrayObject): GLboolean;
	pauseTransformFeedback(): void;
	readBuffer(src: GLenum): void;
	renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
	resumeTransformFeedback(): void;
	samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat): void;
	samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint): void;
	texImage3D(...args: any+): any+; // overloading not supported
	texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
	texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void;
	texSubImage3D(...args: any+): any+; // overloading not supported
	transformFeedbackVaryings(program: WebGLProgram, varyings: Array<string>, bufferMode: GLenum): void;
	uniform1ui(location: WebGLUniformLocation, v0: GLuint): void;
	uniform1uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform2ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint): void;
	uniform2uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform3ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint): void;
	uniform3uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform4ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void;
	uniform4uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void;
	uniformMatrix2x3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix2x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix3x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix3x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix4x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix4x3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	vertexAttribDivisor(index: GLuint, divisor: GLuint): void;
	vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void;
	vertexAttribI4iv(index: GLuint, values: Int32List): void;
	vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void;
	vertexAttribI4uiv(index: GLuint, values: Uint32List): void;
	vertexAttribIPointer(index: GLuint, size: GLint, type: GLenum, stride: GLsizei, offset: GLintptr): void;
	waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64): void;
	get ACTIVE_UNIFORM_BLOCKS(): GLenum;
	get ALREADY_SIGNALED(): GLenum;
	get ANY_SAMPLES_PASSED(): GLenum;
	get ANY_SAMPLES_PASSED_CONSERVATIVE(): GLenum;
	get COLOR(): GLenum;
	get COLOR_ATTACHMENT1(): GLenum;
	get COLOR_ATTACHMENT10(): GLenum;
	get COLOR_ATTACHMENT11(): GLenum;
	get COLOR_ATTACHMENT12(): GLenum;
	get COLOR_ATTACHMENT13(): GLenum;
	get COLOR_ATTACHMENT14(): GLenum;
	get COLOR_ATTACHMENT15(): GLenum;
	get COLOR_ATTACHMENT2(): GLenum;
	get COLOR_ATTACHMENT3(): GLenum;
	get COLOR_ATTACHMENT4(): GLenum;
	get COLOR_ATTACHMENT5(): GLenum;
	get COLOR_ATTACHMENT6(): GLenum;
	get COLOR_ATTACHMENT7(): GLenum;
	get COLOR_ATTACHMENT8(): GLenum;
	get COLOR_ATTACHMENT9(): GLenum;
	get COMPARE_REF_TO_TEXTURE(): GLenum;
	get CONDITION_SATISFIED(): GLenum;
	get COPY_READ_BUFFER(): GLenum;
	get COPY_READ_BUFFER_BINDING(): GLenum;
	get COPY_WRITE_BUFFER(): GLenum;
	get COPY_WRITE_BUFFER_BINDING(): GLenum;
	get CURRENT_QUERY(): GLenum;
	get DEPTH(): GLenum;
	get DEPTH24_STENCIL8(): GLenum;
	get DEPTH32F_STENCIL8(): GLenum;
	get DEPTH_COMPONENT24(): GLenum;
	get DEPTH_COMPONENT32F(): GLenum;
	get DRAW_BUFFER0(): GLenum;
	get DRAW_BUFFER1(): GLenum;
	get DRAW_BUFFER10(): GLenum;
	get DRAW_BUFFER11(): GLenum;
	get DRAW_BUFFER12(): GLenum;
	get DRAW_BUFFER13(): GLenum;
	get DRAW_BUFFER14(): GLenum;
	get DRAW_BUFFER15(): GLenum;
	get DRAW_BUFFER2(): GLenum;
	get DRAW_BUFFER3(): GLenum;
	get DRAW_BUFFER4(): GLenum;
	get DRAW_BUFFER5(): GLenum;
	get DRAW_BUFFER6(): GLenum;
	get DRAW_BUFFER7(): GLenum;
	get DRAW_BUFFER8(): GLenum;
	get DRAW_BUFFER9(): GLenum;
	get DRAW_FRAMEBUFFER(): GLenum;
	get DRAW_FRAMEBUFFER_BINDING(): GLenum;
	get DYNAMIC_COPY(): GLenum;
	get DYNAMIC_READ(): GLenum;
	get FLOAT_32_UNSIGNED_INT_24_8_REV(): GLenum;
	get FLOAT_MAT2x3(): GLenum;
	get FLOAT_MAT2x4(): GLenum;
	get FLOAT_MAT3x2(): GLenum;
	get FLOAT_MAT3x4(): GLenum;
	get FLOAT_MAT4x2(): GLenum;
	get FLOAT_MAT4x3(): GLenum;
	get FRAGMENT_SHADER_DERIVATIVE_HINT(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_BLUE_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_GREEN_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_RED_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER(): GLenum;
	get FRAMEBUFFER_DEFAULT(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_MULTISAMPLE(): GLenum;
	get HALF_FLOAT(): GLenum;
	get INTERLEAVED_ATTRIBS(): GLenum;
	get INT_2_10_10_10_REV(): GLenum;
	get INT_SAMPLER_2D(): GLenum;
	get INT_SAMPLER_2D_ARRAY(): GLenum;
	get INT_SAMPLER_3D(): GLenum;
	get INT_SAMPLER_CUBE(): GLenum;
	get INVALID_INDEX(): GLenum;
	get MAX(): GLenum;
	get MAX_3D_TEXTURE_SIZE(): GLenum;
	get MAX_ARRAY_TEXTURE_LAYERS(): GLenum;
	get MAX_CLIENT_WAIT_TIMEOUT_WEBGL(): GLenum;
	get MAX_COLOR_ATTACHMENTS(): GLenum;
	get MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS(): GLenum;
	get MAX_COMBINED_UNIFORM_BLOCKS(): GLenum;
	get MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS(): GLenum;
	get MAX_DRAW_BUFFERS(): GLenum;
	get MAX_ELEMENTS_INDICES(): GLenum;
	get MAX_ELEMENTS_VERTICES(): GLenum;
	get MAX_ELEMENT_INDEX(): GLenum;
	get MAX_FRAGMENT_INPUT_COMPONENTS(): GLenum;
	get MAX_FRAGMENT_UNIFORM_BLOCKS(): GLenum;
	get MAX_FRAGMENT_UNIFORM_COMPONENTS(): GLenum;
	get MAX_PROGRAM_TEXEL_OFFSET(): GLenum;
	get MAX_SAMPLES(): GLenum;
	get MAX_SERVER_WAIT_TIMEOUT(): GLenum;
	get MAX_TEXTURE_LOD_BIAS(): GLenum;
	get MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS(): GLenum;
	get MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS(): GLenum;
	get MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS(): GLenum;
	get MAX_UNIFORM_BLOCK_SIZE(): GLenum;
	get MAX_UNIFORM_BUFFER_BINDINGS(): GLenum;
	get MAX_VARYING_COMPONENTS(): GLenum;
	get MAX_VERTEX_OUTPUT_COMPONENTS(): GLenum;
	get MAX_VERTEX_UNIFORM_BLOCKS(): GLenum;
	get MAX_VERTEX_UNIFORM_COMPONENTS(): GLenum;
	get MIN(): GLenum;
	get MIN_PROGRAM_TEXEL_OFFSET(): GLenum;
	get OBJECT_TYPE(): GLenum;
	get PACK_ROW_LENGTH(): GLenum;
	get PACK_SKIP_PIXELS(): GLenum;
	get PACK_SKIP_ROWS(): GLenum;
	get PIXEL_PACK_BUFFER(): GLenum;
	get PIXEL_PACK_BUFFER_BINDING(): GLenum;
	get PIXEL_UNPACK_BUFFER(): GLenum;
	get PIXEL_UNPACK_BUFFER_BINDING(): GLenum;
	get QUERY_RESULT(): GLenum;
	get QUERY_RESULT_AVAILABLE(): GLenum;
	get R11F_G11F_B10F(): GLenum;
	get R16F(): GLenum;
	get R16I(): GLenum;
	get R16UI(): GLenum;
	get R32F(): GLenum;
	get R32I(): GLenum;
	get R32UI(): GLenum;
	get R8(): GLenum;
	get R8I(): GLenum;
	get R8UI(): GLenum;
	get R8_SNORM(): GLenum;
	get RASTERIZER_DISCARD(): GLenum;
	get READ_BUFFER(): GLenum;
	get READ_FRAMEBUFFER(): GLenum;
	get READ_FRAMEBUFFER_BINDING(): GLenum;
	get RED(): GLenum;
	get RED_INTEGER(): GLenum;
	get RENDERBUFFER_SAMPLES(): GLenum;
	get RG(): GLenum;
	get RG16F(): GLenum;
	get RG16I(): GLenum;
	get RG16UI(): GLenum;
	get RG32F(): GLenum;
	get RG32I(): GLenum;
	get RG32UI(): GLenum;
	get RG8(): GLenum;
	get RG8I(): GLenum;
	get RG8UI(): GLenum;
	get RG8_SNORM(): GLenum;
	get RGB10_A2(): GLenum;
	get RGB10_A2UI(): GLenum;
	get RGB16F(): GLenum;
	get RGB16I(): GLenum;
	get RGB16UI(): GLenum;
	get RGB32F(): GLenum;
	get RGB32I(): GLenum;
	get RGB32UI(): GLenum;
	get RGB8(): GLenum;
	get RGB8I(): GLenum;
	get RGB8UI(): GLenum;
	get RGB8_SNORM(): GLenum;
	get RGB9_E5(): GLenum;
	get RGBA16F(): GLenum;
	get RGBA16I(): GLenum;
	get RGBA16UI(): GLenum;
	get RGBA32F(): GLenum;
	get RGBA32I(): GLenum;
	get RGBA32UI(): GLenum;
	get RGBA8(): GLenum;
	get RGBA8I(): GLenum;
	get RGBA8UI(): GLenum;
	get RGBA8_SNORM(): GLenum;
	get RGBA_INTEGER(): GLenum;
	get RGB_INTEGER(): GLenum;
	get RG_INTEGER(): GLenum;
	get SAMPLER_2D_ARRAY(): GLenum;
	get SAMPLER_2D_ARRAY_SHADOW(): GLenum;
	get SAMPLER_2D_SHADOW(): GLenum;
	get SAMPLER_3D(): GLenum;
	get SAMPLER_BINDING(): GLenum;
	get SAMPLER_CUBE_SHADOW(): GLenum;
	get SEPARATE_ATTRIBS(): GLenum;
	get SIGNALED(): GLenum;
	get SIGNED_NORMALIZED(): GLenum;
	get SRGB(): GLenum;
	get SRGB8(): GLenum;
	get SRGB8_ALPHA8(): GLenum;
	get STATIC_COPY(): GLenum;
	get STATIC_READ(): GLenum;
	get STENCIL(): GLenum;
	get STREAM_COPY(): GLenum;
	get STREAM_READ(): GLenum;
	get SYNC_CONDITION(): GLenum;
	get SYNC_FENCE(): GLenum;
	get SYNC_FLAGS(): GLenum;
	get SYNC_FLUSH_COMMANDS_BIT(): GLenum;
	get SYNC_GPU_COMMANDS_COMPLETE(): GLenum;
	get SYNC_STATUS(): GLenum;
	get TEXTURE_2D_ARRAY(): GLenum;
	get TEXTURE_3D(): GLenum;
	get TEXTURE_BASE_LEVEL(): GLenum;
	get TEXTURE_BINDING_2D_ARRAY(): GLenum;
	get TEXTURE_BINDING_3D(): GLenum;
	get TEXTURE_COMPARE_FUNC(): GLenum;
	get TEXTURE_COMPARE_MODE(): GLenum;
	get TEXTURE_IMMUTABLE_FORMAT(): GLenum;
	get TEXTURE_IMMUTABLE_LEVELS(): GLenum;
	get TEXTURE_MAX_LEVEL(): GLenum;
	get TEXTURE_MAX_LOD(): GLenum;
	get TEXTURE_MIN_LOD(): GLenum;
	get TEXTURE_WRAP_R(): GLenum;
	get TIMEOUT_EXPIRED(): GLenum;
	get TIMEOUT_IGNORED(): GLint64;
	get TRANSFORM_FEEDBACK(): GLenum;
	get TRANSFORM_FEEDBACK_ACTIVE(): GLenum;
	get TRANSFORM_FEEDBACK_BINDING(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_BINDING(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_MODE(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_SIZE(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_START(): GLenum;
	get TRANSFORM_FEEDBACK_PAUSED(): GLenum;
	get TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN(): GLenum;
	get TRANSFORM_FEEDBACK_VARYINGS(): GLenum;
	get UNIFORM_ARRAY_STRIDE(): GLenum;
	get UNIFORM_BLOCK_ACTIVE_UNIFORMS(): GLenum;
	get UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES(): GLenum;
	get UNIFORM_BLOCK_BINDING(): GLenum;
	get UNIFORM_BLOCK_DATA_SIZE(): GLenum;
	get UNIFORM_BLOCK_INDEX(): GLenum;
	get UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER(): GLenum;
	get UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER(): GLenum;
	get UNIFORM_BUFFER(): GLenum;
	get UNIFORM_BUFFER_BINDING(): GLenum;
	get UNIFORM_BUFFER_OFFSET_ALIGNMENT(): GLenum;
	get UNIFORM_BUFFER_SIZE(): GLenum;
	get UNIFORM_BUFFER_START(): GLenum;
	get UNIFORM_IS_ROW_MAJOR(): GLenum;
	get UNIFORM_MATRIX_STRIDE(): GLenum;
	get UNIFORM_OFFSET(): GLenum;
	get UNIFORM_SIZE(): GLenum;
	get UNIFORM_TYPE(): GLenum;
	get UNPACK_IMAGE_HEIGHT(): GLenum;
	get UNPACK_ROW_LENGTH(): GLenum;
	get UNPACK_SKIP_IMAGES(): GLenum;
	get UNPACK_SKIP_PIXELS(): GLenum;
	get UNPACK_SKIP_ROWS(): GLenum;
	get UNSIGNALED(): GLenum;
	get UNSIGNED_INT_10F_11F_11F_REV(): GLenum;
	get UNSIGNED_INT_24_8(): GLenum;
	get UNSIGNED_INT_2_10_10_10_REV(): GLenum;
	get UNSIGNED_INT_5_9_9_9_REV(): GLenum;
	get UNSIGNED_INT_SAMPLER_2D(): GLenum;
	get UNSIGNED_INT_SAMPLER_2D_ARRAY(): GLenum;
	get UNSIGNED_INT_SAMPLER_3D(): GLenum;
	get UNSIGNED_INT_SAMPLER_CUBE(): GLenum;
	get UNSIGNED_INT_VEC2(): GLenum;
	get UNSIGNED_INT_VEC3(): GLenum;
	get UNSIGNED_INT_VEC4(): GLenum;
	get UNSIGNED_NORMALIZED(): GLenum;
	get VERTEX_ARRAY_BINDING(): GLenum;
	get VERTEX_ATTRIB_ARRAY_DIVISOR(): GLenum;
	get VERTEX_ATTRIB_ARRAY_INTEGER(): GLenum;
	get WAIT_FAILED(): GLenum;
}

export external public interface ~WebGL2RenderingContextOverloads {
	bufferData(...args: any+): any+; // overloading not supported
	bufferSubData(...args: any+): any+; // overloading not supported
	compressedTexImage2D(...args: any+): any+; // overloading not supported
	compressedTexSubImage2D(...args: any+): any+; // overloading not supported
	readPixels(...args: any+): any+; // overloading not supported
	texImage2D(...args: any+): any+; // overloading not supported
	texSubImage2D(...args: any+): any+; // overloading not supported
	uniform1fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform1iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform2fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform2iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform3fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform3iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform4fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform4iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
}

export external public class WebGLActiveInfo {
	public get name(): string;
	public get size(): GLint;
	public get type(): GLenum;
	public constructor();
}

export external public class WebGLBuffer {
	public constructor();
}

export external public class WebGLContextEvent extends Event {
	public get statusMessage(): string;
	public constructor(type: string, eventInit: WebGLContextEventInit = );
}

export external public class WebGLFramebuffer {
	public constructor();
}

export external public class WebGLProgram {
	public constructor();
}

export external public class WebGLQuery {
	public constructor();
}

export external public class WebGLRenderbuffer {
	public constructor();
}

export external public class WebGLRenderingContext extends WebGLRenderingContextBase implements WebGLRenderingContextOverloads {
	public constructor();
	public static get ACTIVE_ATTRIBUTES(): GLenum;
	public static get ACTIVE_TEXTURE(): GLenum;
	public static get ACTIVE_UNIFORMS(): GLenum;
	public static get ALIASED_LINE_WIDTH_RANGE(): GLenum;
	public static get ALIASED_POINT_SIZE_RANGE(): GLenum;
	public static get ALPHA(): GLenum;
	public static get ALPHA_BITS(): GLenum;
	public static get ALWAYS(): GLenum;
	public static get ARRAY_BUFFER(): GLenum;
	public static get ARRAY_BUFFER_BINDING(): GLenum;
	public static get ATTACHED_SHADERS(): GLenum;
	public static get BACK(): GLenum;
	public static get BLEND(): GLenum;
	public static get BLEND_COLOR(): GLenum;
	public static get BLEND_DST_ALPHA(): GLenum;
	public static get BLEND_DST_RGB(): GLenum;
	public static get BLEND_EQUATION(): GLenum;
	public static get BLEND_EQUATION_ALPHA(): GLenum;
	public static get BLEND_EQUATION_RGB(): GLenum;
	public static get BLEND_SRC_ALPHA(): GLenum;
	public static get BLEND_SRC_RGB(): GLenum;
	public static get BLUE_BITS(): GLenum;
	public static get BOOL(): GLenum;
	public static get BOOL_VEC2(): GLenum;
	public static get BOOL_VEC3(): GLenum;
	public static get BOOL_VEC4(): GLenum;
	public static get BROWSER_DEFAULT_WEBGL(): GLenum;
	public static get BUFFER_SIZE(): GLenum;
	public static get BUFFER_USAGE(): GLenum;
	public static get BYTE(): GLenum;
	public static get CCW(): GLenum;
	public static get CLAMP_TO_EDGE(): GLenum;
	public static get COLOR_ATTACHMENT0(): GLenum;
	public static get COLOR_BUFFER_BIT(): GLenum;
	public static get COLOR_CLEAR_VALUE(): GLenum;
	public static get COLOR_WRITEMASK(): GLenum;
	public static get COMPILE_STATUS(): GLenum;
	public static get COMPRESSED_TEXTURE_FORMATS(): GLenum;
	public static get CONSTANT_ALPHA(): GLenum;
	public static get CONSTANT_COLOR(): GLenum;
	public static get CONTEXT_LOST_WEBGL(): GLenum;
	public static get CULL_FACE(): GLenum;
	public static get CULL_FACE_MODE(): GLenum;
	public static get CURRENT_PROGRAM(): GLenum;
	public static get CURRENT_VERTEX_ATTRIB(): GLenum;
	public static get CW(): GLenum;
	public static get DECR(): GLenum;
	public static get DECR_WRAP(): GLenum;
	public static get DELETE_STATUS(): GLenum;
	public static get DEPTH_ATTACHMENT(): GLenum;
	public static get DEPTH_BITS(): GLenum;
	public static get DEPTH_BUFFER_BIT(): GLenum;
	public static get DEPTH_CLEAR_VALUE(): GLenum;
	public static get DEPTH_COMPONENT(): GLenum;
	public static get DEPTH_COMPONENT16(): GLenum;
	public static get DEPTH_FUNC(): GLenum;
	public static get DEPTH_RANGE(): GLenum;
	public static get DEPTH_STENCIL(): GLenum;
	public static get DEPTH_STENCIL_ATTACHMENT(): GLenum;
	public static get DEPTH_TEST(): GLenum;
	public static get DEPTH_WRITEMASK(): GLenum;
	public static get DITHER(): GLenum;
	public static get DONT_CARE(): GLenum;
	public static get DST_ALPHA(): GLenum;
	public static get DST_COLOR(): GLenum;
	public static get DYNAMIC_DRAW(): GLenum;
	public static get ELEMENT_ARRAY_BUFFER(): GLenum;
	public static get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum;
	public static get EQUAL(): GLenum;
	public static get FASTEST(): GLenum;
	public static get FLOAT(): GLenum;
	public static get FLOAT_MAT2(): GLenum;
	public static get FLOAT_MAT3(): GLenum;
	public static get FLOAT_MAT4(): GLenum;
	public static get FLOAT_VEC2(): GLenum;
	public static get FLOAT_VEC3(): GLenum;
	public static get FLOAT_VEC4(): GLenum;
	public static get FRAGMENT_SHADER(): GLenum;
	public static get FRAMEBUFFER(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum;
	public static get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum;
	public static get FRAMEBUFFER_BINDING(): GLenum;
	public static get FRAMEBUFFER_COMPLETE(): GLenum;
	public static get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum;
	public static get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum;
	public static get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum;
	public static get FRAMEBUFFER_UNSUPPORTED(): GLenum;
	public static get FRONT(): GLenum;
	public static get FRONT_AND_BACK(): GLenum;
	public static get FRONT_FACE(): GLenum;
	public static get FUNC_ADD(): GLenum;
	public static get FUNC_REVERSE_SUBTRACT(): GLenum;
	public static get FUNC_SUBTRACT(): GLenum;
	public static get GENERATE_MIPMAP_HINT(): GLenum;
	public static get GEQUAL(): GLenum;
	public static get GREATER(): GLenum;
	public static get GREEN_BITS(): GLenum;
	public static get HIGH_FLOAT(): GLenum;
	public static get HIGH_INT(): GLenum;
	public static get IMPLEMENTATION_COLOR_READ_FORMAT(): GLenum;
	public static get IMPLEMENTATION_COLOR_READ_TYPE(): GLenum;
	public static get INCR(): GLenum;
	public static get INCR_WRAP(): GLenum;
	public static get INT(): GLenum;
	public static get INT_VEC2(): GLenum;
	public static get INT_VEC3(): GLenum;
	public static get INT_VEC4(): GLenum;
	public static get INVALID_ENUM(): GLenum;
	public static get INVALID_FRAMEBUFFER_OPERATION(): GLenum;
	public static get INVALID_OPERATION(): GLenum;
	public static get INVALID_VALUE(): GLenum;
	public static get INVERT(): GLenum;
	public static get KEEP(): GLenum;
	public static get LEQUAL(): GLenum;
	public static get LESS(): GLenum;
	public static get LINEAR(): GLenum;
	public static get LINEAR_MIPMAP_LINEAR(): GLenum;
	public static get LINEAR_MIPMAP_NEAREST(): GLenum;
	public static get LINES(): GLenum;
	public static get LINE_LOOP(): GLenum;
	public static get LINE_STRIP(): GLenum;
	public static get LINE_WIDTH(): GLenum;
	public static get LINK_STATUS(): GLenum;
	public static get LOW_FLOAT(): GLenum;
	public static get LOW_INT(): GLenum;
	public static get LUMINANCE(): GLenum;
	public static get LUMINANCE_ALPHA(): GLenum;
	public static get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum;
	public static get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum;
	public static get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum;
	public static get MAX_RENDERBUFFER_SIZE(): GLenum;
	public static get MAX_TEXTURE_IMAGE_UNITS(): GLenum;
	public static get MAX_TEXTURE_SIZE(): GLenum;
	public static get MAX_VARYING_VECTORS(): GLenum;
	public static get MAX_VERTEX_ATTRIBS(): GLenum;
	public static get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum;
	public static get MAX_VERTEX_UNIFORM_VECTORS(): GLenum;
	public static get MAX_VIEWPORT_DIMS(): GLenum;
	public static get MEDIUM_FLOAT(): GLenum;
	public static get MEDIUM_INT(): GLenum;
	public static get MIRRORED_REPEAT(): GLenum;
	public static get NEAREST(): GLenum;
	public static get NEAREST_MIPMAP_LINEAR(): GLenum;
	public static get NEAREST_MIPMAP_NEAREST(): GLenum;
	public static get NEVER(): GLenum;
	public static get NICEST(): GLenum;
	public static get NONE(): GLenum;
	public static get NOTEQUAL(): GLenum;
	public static get NO_ERROR(): GLenum;
	public static get ONE(): GLenum;
	public static get ONE_MINUS_CONSTANT_ALPHA(): GLenum;
	public static get ONE_MINUS_CONSTANT_COLOR(): GLenum;
	public static get ONE_MINUS_DST_ALPHA(): GLenum;
	public static get ONE_MINUS_DST_COLOR(): GLenum;
	public static get ONE_MINUS_SRC_ALPHA(): GLenum;
	public static get ONE_MINUS_SRC_COLOR(): GLenum;
	public static get OUT_OF_MEMORY(): GLenum;
	public static get PACK_ALIGNMENT(): GLenum;
	public static get POINTS(): GLenum;
	public static get POLYGON_OFFSET_FACTOR(): GLenum;
	public static get POLYGON_OFFSET_FILL(): GLenum;
	public static get POLYGON_OFFSET_UNITS(): GLenum;
	public static get RED_BITS(): GLenum;
	public static get RENDERBUFFER(): GLenum;
	public static get RENDERBUFFER_ALPHA_SIZE(): GLenum;
	public static get RENDERBUFFER_BINDING(): GLenum;
	public static get RENDERBUFFER_BLUE_SIZE(): GLenum;
	public static get RENDERBUFFER_DEPTH_SIZE(): GLenum;
	public static get RENDERBUFFER_GREEN_SIZE(): GLenum;
	public static get RENDERBUFFER_HEIGHT(): GLenum;
	public static get RENDERBUFFER_INTERNAL_FORMAT(): GLenum;
	public static get RENDERBUFFER_RED_SIZE(): GLenum;
	public static get RENDERBUFFER_STENCIL_SIZE(): GLenum;
	public static get RENDERBUFFER_WIDTH(): GLenum;
	public static get RENDERER(): GLenum;
	public static get REPEAT(): GLenum;
	public static get REPLACE(): GLenum;
	public static get RGB(): GLenum;
	public static get RGB565(): GLenum;
	public static get RGB5_A1(): GLenum;
	public static get RGBA(): GLenum;
	public static get RGBA4(): GLenum;
	public static get SAMPLER_2D(): GLenum;
	public static get SAMPLER_CUBE(): GLenum;
	public static get SAMPLES(): GLenum;
	public static get SAMPLE_ALPHA_TO_COVERAGE(): GLenum;
	public static get SAMPLE_BUFFERS(): GLenum;
	public static get SAMPLE_COVERAGE(): GLenum;
	public static get SAMPLE_COVERAGE_INVERT(): GLenum;
	public static get SAMPLE_COVERAGE_VALUE(): GLenum;
	public static get SCISSOR_BOX(): GLenum;
	public static get SCISSOR_TEST(): GLenum;
	public static get SHADER_TYPE(): GLenum;
	public static get SHADING_LANGUAGE_VERSION(): GLenum;
	public static get SHORT(): GLenum;
	public static get SRC_ALPHA(): GLenum;
	public static get SRC_ALPHA_SATURATE(): GLenum;
	public static get SRC_COLOR(): GLenum;
	public static get STATIC_DRAW(): GLenum;
	public static get STENCIL_ATTACHMENT(): GLenum;
	public static get STENCIL_BACK_FAIL(): GLenum;
	public static get STENCIL_BACK_FUNC(): GLenum;
	public static get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum;
	public static get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum;
	public static get STENCIL_BACK_REF(): GLenum;
	public static get STENCIL_BACK_VALUE_MASK(): GLenum;
	public static get STENCIL_BACK_WRITEMASK(): GLenum;
	public static get STENCIL_BITS(): GLenum;
	public static get STENCIL_BUFFER_BIT(): GLenum;
	public static get STENCIL_CLEAR_VALUE(): GLenum;
	public static get STENCIL_FAIL(): GLenum;
	public static get STENCIL_FUNC(): GLenum;
	public static get STENCIL_INDEX8(): GLenum;
	public static get STENCIL_PASS_DEPTH_FAIL(): GLenum;
	public static get STENCIL_PASS_DEPTH_PASS(): GLenum;
	public static get STENCIL_REF(): GLenum;
	public static get STENCIL_TEST(): GLenum;
	public static get STENCIL_VALUE_MASK(): GLenum;
	public static get STENCIL_WRITEMASK(): GLenum;
	public static get STREAM_DRAW(): GLenum;
	public static get SUBPIXEL_BITS(): GLenum;
	public static get TEXTURE(): GLenum;
	public static get TEXTURE0(): GLenum;
	public static get TEXTURE1(): GLenum;
	public static get TEXTURE10(): GLenum;
	public static get TEXTURE11(): GLenum;
	public static get TEXTURE12(): GLenum;
	public static get TEXTURE13(): GLenum;
	public static get TEXTURE14(): GLenum;
	public static get TEXTURE15(): GLenum;
	public static get TEXTURE16(): GLenum;
	public static get TEXTURE17(): GLenum;
	public static get TEXTURE18(): GLenum;
	public static get TEXTURE19(): GLenum;
	public static get TEXTURE2(): GLenum;
	public static get TEXTURE20(): GLenum;
	public static get TEXTURE21(): GLenum;
	public static get TEXTURE22(): GLenum;
	public static get TEXTURE23(): GLenum;
	public static get TEXTURE24(): GLenum;
	public static get TEXTURE25(): GLenum;
	public static get TEXTURE26(): GLenum;
	public static get TEXTURE27(): GLenum;
	public static get TEXTURE28(): GLenum;
	public static get TEXTURE29(): GLenum;
	public static get TEXTURE3(): GLenum;
	public static get TEXTURE30(): GLenum;
	public static get TEXTURE31(): GLenum;
	public static get TEXTURE4(): GLenum;
	public static get TEXTURE5(): GLenum;
	public static get TEXTURE6(): GLenum;
	public static get TEXTURE7(): GLenum;
	public static get TEXTURE8(): GLenum;
	public static get TEXTURE9(): GLenum;
	public static get TEXTURE_2D(): GLenum;
	public static get TEXTURE_BINDING_2D(): GLenum;
	public static get TEXTURE_BINDING_CUBE_MAP(): GLenum;
	public static get TEXTURE_CUBE_MAP(): GLenum;
	public static get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum;
	public static get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum;
	public static get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum;
	public static get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum;
	public static get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum;
	public static get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum;
	public static get TEXTURE_MAG_FILTER(): GLenum;
	public static get TEXTURE_MIN_FILTER(): GLenum;
	public static get TEXTURE_WRAP_S(): GLenum;
	public static get TEXTURE_WRAP_T(): GLenum;
	public static get TRIANGLES(): GLenum;
	public static get TRIANGLE_FAN(): GLenum;
	public static get TRIANGLE_STRIP(): GLenum;
	public static get UNPACK_ALIGNMENT(): GLenum;
	public static get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum;
	public static get UNPACK_FLIP_Y_WEBGL(): GLenum;
	public static get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum;
	public static get UNSIGNED_BYTE(): GLenum;
	public static get UNSIGNED_INT(): GLenum;
	public static get UNSIGNED_SHORT(): GLenum;
	public static get UNSIGNED_SHORT_4_4_4_4(): GLenum;
	public static get UNSIGNED_SHORT_5_5_5_1(): GLenum;
	public static get UNSIGNED_SHORT_5_6_5(): GLenum;
	public static get VALIDATE_STATUS(): GLenum;
	public static get VENDOR(): GLenum;
	public static get VERSION(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum;
	public static get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum;
	public static get VERTEX_SHADER(): GLenum;
	public static get VIEWPORT(): GLenum;
	public static get ZERO(): GLenum;
}

export external public interface ~WebGLRenderingContextBase {
	get canvas(): HTMLCanvasElement;
	get drawingBufferHeight(): GLsizei;
	get drawingBufferWidth(): GLsizei;
	activeTexture(texture: GLenum): void;
	attachShader(program: WebGLProgram, shader: WebGLShader): void;
	bindAttribLocation(program: WebGLProgram, index: GLuint, name: string): void;
	bindBuffer(target: GLenum, buffer: WebGLBuffer): void;
	bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer): void;
	bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer): void;
	bindTexture(target: GLenum, texture: WebGLTexture): void;
	blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;
	blendEquation(mode: GLenum): void;
	blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum): void;
	blendFunc(sfactor: GLenum, dfactor: GLenum): void;
	blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;
	checkFramebufferStatus(target: GLenum): GLenum;
	clear(mask: GLbitfield): void;
	clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;
	clearDepth(depth: GLclampf): void;
	clearStencil(s: GLint): void;
	colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void;
	compileShader(shader: WebGLShader): void;
	copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void;
	copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	createBuffer(): WebGLBuffer;
	createFramebuffer(): WebGLFramebuffer;
	createProgram(): WebGLProgram;
	createRenderbuffer(): WebGLRenderbuffer;
	createShader(type: GLenum): WebGLShader;
	createTexture(): WebGLTexture;
	cullFace(mode: GLenum): void;
	deleteBuffer(buffer: WebGLBuffer): void;
	deleteFramebuffer(framebuffer: WebGLFramebuffer): void;
	deleteProgram(program: WebGLProgram): void;
	deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void;
	deleteShader(shader: WebGLShader): void;
	deleteTexture(texture: WebGLTexture): void;
	depthFunc(func: GLenum): void;
	depthMask(flag: GLboolean): void;
	depthRange(zNear: GLclampf, zFar: GLclampf): void;
	detachShader(program: WebGLProgram, shader: WebGLShader): void;
	disable(cap: GLenum): void;
	disableVertexAttribArray(index: GLuint): void;
	drawArrays(mode: GLenum, first: GLint, count: GLsizei): void;
	drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr): void;
	enable(cap: GLenum): void;
	enableVertexAttribArray(index: GLuint): void;
	finish(): void;
	flush(): void;
	framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer): void;
	framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture, level: GLint): void;
	frontFace(mode: GLenum): void;
	generateMipmap(target: GLenum): void;
	getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo;
	getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo;
	getAttachedShaders(program: WebGLProgram): Array<WebGLShader>;
	getAttribLocation(program: WebGLProgram, name: string): GLint;
	getBufferParameter(target: GLenum, pname: GLenum): any;
	getContextAttributes(): WebGLContextAttributes;
	getError(): GLenum;
	getExtension(...args: any+): any+; // overloading not supported
	getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): any;
	getParameter(pname: GLenum): any;
	getProgramInfoLog(program: WebGLProgram): string;
	getProgramParameter(program: WebGLProgram, pname: GLenum): any;
	getRenderbufferParameter(target: GLenum, pname: GLenum): any;
	getShaderInfoLog(shader: WebGLShader): string;
	getShaderParameter(shader: WebGLShader, pname: GLenum): any;
	getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat;
	getShaderSource(shader: WebGLShader): string;
	getSupportedExtensions(): Array<string>;
	getTexParameter(target: GLenum, pname: GLenum): any;
	getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;
	getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation;
	getVertexAttrib(index: GLuint, pname: GLenum): any;
	getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr;
	hint(target: GLenum, mode: GLenum): void;
	isBuffer(buffer: WebGLBuffer): GLboolean;
	isContextLost(): boolean;
	isEnabled(cap: GLenum): GLboolean;
	isFramebuffer(framebuffer: WebGLFramebuffer): GLboolean;
	isProgram(program: WebGLProgram): GLboolean;
	isRenderbuffer(renderbuffer: WebGLRenderbuffer): GLboolean;
	isShader(shader: WebGLShader): GLboolean;
	isTexture(texture: WebGLTexture): GLboolean;
	lineWidth(width: GLfloat): void;
	linkProgram(program: WebGLProgram): void;
	pixelStorei(pname: GLenum, param: GLint | GLboolean): void;
	polygonOffset(factor: GLfloat, units: GLfloat): void;
	renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
	sampleCoverage(value: GLclampf, invert: GLboolean): void;
	scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	shaderSource(shader: WebGLShader, source: string): void;
	stencilFunc(func: GLenum, ref: GLint, mask: GLuint): void;
	stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void;
	stencilMask(mask: GLuint): void;
	stencilMaskSeparate(face: GLenum, mask: GLuint): void;
	stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void;
	stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void;
	texParameterf(target: GLenum, pname: GLenum, param: GLfloat): void;
	texParameteri(target: GLenum, pname: GLenum, param: GLint): void;
	uniform1f(location: WebGLUniformLocation, x: GLfloat): void;
	uniform1i(location: WebGLUniformLocation, x: GLint): void;
	uniform2f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat): void;
	uniform2i(location: WebGLUniformLocation, x: GLint, y: GLint): void;
	uniform3f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat): void;
	uniform3i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint): void;
	uniform4f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;
	uniform4i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint, w: GLint): void;
	useProgram(program: WebGLProgram): void;
	validateProgram(program: WebGLProgram): void;
	vertexAttrib1f(index: GLuint, x: GLfloat): void;
	vertexAttrib1fv(index: GLuint, values: Float32List): void;
	vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat): void;
	vertexAttrib2fv(index: GLuint, values: Float32List): void;
	vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void;
	vertexAttrib3fv(index: GLuint, values: Float32List): void;
	vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;
	vertexAttrib4fv(index: GLuint, values: Float32List): void;
	vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void;
	viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	get ACTIVE_ATTRIBUTES(): GLenum;
	get ACTIVE_TEXTURE(): GLenum;
	get ACTIVE_UNIFORMS(): GLenum;
	get ALIASED_LINE_WIDTH_RANGE(): GLenum;
	get ALIASED_POINT_SIZE_RANGE(): GLenum;
	get ALPHA(): GLenum;
	get ALPHA_BITS(): GLenum;
	get ALWAYS(): GLenum;
	get ARRAY_BUFFER(): GLenum;
	get ARRAY_BUFFER_BINDING(): GLenum;
	get ATTACHED_SHADERS(): GLenum;
	get BACK(): GLenum;
	get BLEND(): GLenum;
	get BLEND_COLOR(): GLenum;
	get BLEND_DST_ALPHA(): GLenum;
	get BLEND_DST_RGB(): GLenum;
	get BLEND_EQUATION(): GLenum;
	get BLEND_EQUATION_ALPHA(): GLenum;
	get BLEND_EQUATION_RGB(): GLenum;
	get BLEND_SRC_ALPHA(): GLenum;
	get BLEND_SRC_RGB(): GLenum;
	get BLUE_BITS(): GLenum;
	get BOOL(): GLenum;
	get BOOL_VEC2(): GLenum;
	get BOOL_VEC3(): GLenum;
	get BOOL_VEC4(): GLenum;
	get BROWSER_DEFAULT_WEBGL(): GLenum;
	get BUFFER_SIZE(): GLenum;
	get BUFFER_USAGE(): GLenum;
	get BYTE(): GLenum;
	get CCW(): GLenum;
	get CLAMP_TO_EDGE(): GLenum;
	get COLOR_ATTACHMENT0(): GLenum;
	get COLOR_BUFFER_BIT(): GLenum;
	get COLOR_CLEAR_VALUE(): GLenum;
	get COLOR_WRITEMASK(): GLenum;
	get COMPILE_STATUS(): GLenum;
	get COMPRESSED_TEXTURE_FORMATS(): GLenum;
	get CONSTANT_ALPHA(): GLenum;
	get CONSTANT_COLOR(): GLenum;
	get CONTEXT_LOST_WEBGL(): GLenum;
	get CULL_FACE(): GLenum;
	get CULL_FACE_MODE(): GLenum;
	get CURRENT_PROGRAM(): GLenum;
	get CURRENT_VERTEX_ATTRIB(): GLenum;
	get CW(): GLenum;
	get DECR(): GLenum;
	get DECR_WRAP(): GLenum;
	get DELETE_STATUS(): GLenum;
	get DEPTH_ATTACHMENT(): GLenum;
	get DEPTH_BITS(): GLenum;
	get DEPTH_BUFFER_BIT(): GLenum;
	get DEPTH_CLEAR_VALUE(): GLenum;
	get DEPTH_COMPONENT(): GLenum;
	get DEPTH_COMPONENT16(): GLenum;
	get DEPTH_FUNC(): GLenum;
	get DEPTH_RANGE(): GLenum;
	get DEPTH_STENCIL(): GLenum;
	get DEPTH_STENCIL_ATTACHMENT(): GLenum;
	get DEPTH_TEST(): GLenum;
	get DEPTH_WRITEMASK(): GLenum;
	get DITHER(): GLenum;
	get DONT_CARE(): GLenum;
	get DST_ALPHA(): GLenum;
	get DST_COLOR(): GLenum;
	get DYNAMIC_DRAW(): GLenum;
	get ELEMENT_ARRAY_BUFFER(): GLenum;
	get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum;
	get EQUAL(): GLenum;
	get FASTEST(): GLenum;
	get FLOAT(): GLenum;
	get FLOAT_MAT2(): GLenum;
	get FLOAT_MAT3(): GLenum;
	get FLOAT_MAT4(): GLenum;
	get FLOAT_VEC2(): GLenum;
	get FLOAT_VEC3(): GLenum;
	get FLOAT_VEC4(): GLenum;
	get FRAGMENT_SHADER(): GLenum;
	get FRAMEBUFFER(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum;
	get FRAMEBUFFER_BINDING(): GLenum;
	get FRAMEBUFFER_COMPLETE(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum;
	get FRAMEBUFFER_UNSUPPORTED(): GLenum;
	get FRONT(): GLenum;
	get FRONT_AND_BACK(): GLenum;
	get FRONT_FACE(): GLenum;
	get FUNC_ADD(): GLenum;
	get FUNC_REVERSE_SUBTRACT(): GLenum;
	get FUNC_SUBTRACT(): GLenum;
	get GENERATE_MIPMAP_HINT(): GLenum;
	get GEQUAL(): GLenum;
	get GREATER(): GLenum;
	get GREEN_BITS(): GLenum;
	get HIGH_FLOAT(): GLenum;
	get HIGH_INT(): GLenum;
	get IMPLEMENTATION_COLOR_READ_FORMAT(): GLenum;
	get IMPLEMENTATION_COLOR_READ_TYPE(): GLenum;
	get INCR(): GLenum;
	get INCR_WRAP(): GLenum;
	get INT(): GLenum;
	get INT_VEC2(): GLenum;
	get INT_VEC3(): GLenum;
	get INT_VEC4(): GLenum;
	get INVALID_ENUM(): GLenum;
	get INVALID_FRAMEBUFFER_OPERATION(): GLenum;
	get INVALID_OPERATION(): GLenum;
	get INVALID_VALUE(): GLenum;
	get INVERT(): GLenum;
	get KEEP(): GLenum;
	get LEQUAL(): GLenum;
	get LESS(): GLenum;
	get LINEAR(): GLenum;
	get LINEAR_MIPMAP_LINEAR(): GLenum;
	get LINEAR_MIPMAP_NEAREST(): GLenum;
	get LINES(): GLenum;
	get LINE_LOOP(): GLenum;
	get LINE_STRIP(): GLenum;
	get LINE_WIDTH(): GLenum;
	get LINK_STATUS(): GLenum;
	get LOW_FLOAT(): GLenum;
	get LOW_INT(): GLenum;
	get LUMINANCE(): GLenum;
	get LUMINANCE_ALPHA(): GLenum;
	get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum;
	get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum;
	get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum;
	get MAX_RENDERBUFFER_SIZE(): GLenum;
	get MAX_TEXTURE_IMAGE_UNITS(): GLenum;
	get MAX_TEXTURE_SIZE(): GLenum;
	get MAX_VARYING_VECTORS(): GLenum;
	get MAX_VERTEX_ATTRIBS(): GLenum;
	get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum;
	get MAX_VERTEX_UNIFORM_VECTORS(): GLenum;
	get MAX_VIEWPORT_DIMS(): GLenum;
	get MEDIUM_FLOAT(): GLenum;
	get MEDIUM_INT(): GLenum;
	get MIRRORED_REPEAT(): GLenum;
	get NEAREST(): GLenum;
	get NEAREST_MIPMAP_LINEAR(): GLenum;
	get NEAREST_MIPMAP_NEAREST(): GLenum;
	get NEVER(): GLenum;
	get NICEST(): GLenum;
	get NONE(): GLenum;
	get NOTEQUAL(): GLenum;
	get NO_ERROR(): GLenum;
	get ONE(): GLenum;
	get ONE_MINUS_CONSTANT_ALPHA(): GLenum;
	get ONE_MINUS_CONSTANT_COLOR(): GLenum;
	get ONE_MINUS_DST_ALPHA(): GLenum;
	get ONE_MINUS_DST_COLOR(): GLenum;
	get ONE_MINUS_SRC_ALPHA(): GLenum;
	get ONE_MINUS_SRC_COLOR(): GLenum;
	get OUT_OF_MEMORY(): GLenum;
	get PACK_ALIGNMENT(): GLenum;
	get POINTS(): GLenum;
	get POLYGON_OFFSET_FACTOR(): GLenum;
	get POLYGON_OFFSET_FILL(): GLenum;
	get POLYGON_OFFSET_UNITS(): GLenum;
	get RED_BITS(): GLenum;
	get RENDERBUFFER(): GLenum;
	get RENDERBUFFER_ALPHA_SIZE(): GLenum;
	get RENDERBUFFER_BINDING(): GLenum;
	get RENDERBUFFER_BLUE_SIZE(): GLenum;
	get RENDERBUFFER_DEPTH_SIZE(): GLenum;
	get RENDERBUFFER_GREEN_SIZE(): GLenum;
	get RENDERBUFFER_HEIGHT(): GLenum;
	get RENDERBUFFER_INTERNAL_FORMAT(): GLenum;
	get RENDERBUFFER_RED_SIZE(): GLenum;
	get RENDERBUFFER_STENCIL_SIZE(): GLenum;
	get RENDERBUFFER_WIDTH(): GLenum;
	get RENDERER(): GLenum;
	get REPEAT(): GLenum;
	get REPLACE(): GLenum;
	get RGB(): GLenum;
	get RGB565(): GLenum;
	get RGB5_A1(): GLenum;
	get RGBA(): GLenum;
	get RGBA4(): GLenum;
	get SAMPLER_2D(): GLenum;
	get SAMPLER_CUBE(): GLenum;
	get SAMPLES(): GLenum;
	get SAMPLE_ALPHA_TO_COVERAGE(): GLenum;
	get SAMPLE_BUFFERS(): GLenum;
	get SAMPLE_COVERAGE(): GLenum;
	get SAMPLE_COVERAGE_INVERT(): GLenum;
	get SAMPLE_COVERAGE_VALUE(): GLenum;
	get SCISSOR_BOX(): GLenum;
	get SCISSOR_TEST(): GLenum;
	get SHADER_TYPE(): GLenum;
	get SHADING_LANGUAGE_VERSION(): GLenum;
	get SHORT(): GLenum;
	get SRC_ALPHA(): GLenum;
	get SRC_ALPHA_SATURATE(): GLenum;
	get SRC_COLOR(): GLenum;
	get STATIC_DRAW(): GLenum;
	get STENCIL_ATTACHMENT(): GLenum;
	get STENCIL_BACK_FAIL(): GLenum;
	get STENCIL_BACK_FUNC(): GLenum;
	get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum;
	get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum;
	get STENCIL_BACK_REF(): GLenum;
	get STENCIL_BACK_VALUE_MASK(): GLenum;
	get STENCIL_BACK_WRITEMASK(): GLenum;
	get STENCIL_BITS(): GLenum;
	get STENCIL_BUFFER_BIT(): GLenum;
	get STENCIL_CLEAR_VALUE(): GLenum;
	get STENCIL_FAIL(): GLenum;
	get STENCIL_FUNC(): GLenum;
	get STENCIL_INDEX8(): GLenum;
	get STENCIL_PASS_DEPTH_FAIL(): GLenum;
	get STENCIL_PASS_DEPTH_PASS(): GLenum;
	get STENCIL_REF(): GLenum;
	get STENCIL_TEST(): GLenum;
	get STENCIL_VALUE_MASK(): GLenum;
	get STENCIL_WRITEMASK(): GLenum;
	get STREAM_DRAW(): GLenum;
	get SUBPIXEL_BITS(): GLenum;
	get TEXTURE(): GLenum;
	get TEXTURE0(): GLenum;
	get TEXTURE1(): GLenum;
	get TEXTURE10(): GLenum;
	get TEXTURE11(): GLenum;
	get TEXTURE12(): GLenum;
	get TEXTURE13(): GLenum;
	get TEXTURE14(): GLenum;
	get TEXTURE15(): GLenum;
	get TEXTURE16(): GLenum;
	get TEXTURE17(): GLenum;
	get TEXTURE18(): GLenum;
	get TEXTURE19(): GLenum;
	get TEXTURE2(): GLenum;
	get TEXTURE20(): GLenum;
	get TEXTURE21(): GLenum;
	get TEXTURE22(): GLenum;
	get TEXTURE23(): GLenum;
	get TEXTURE24(): GLenum;
	get TEXTURE25(): GLenum;
	get TEXTURE26(): GLenum;
	get TEXTURE27(): GLenum;
	get TEXTURE28(): GLenum;
	get TEXTURE29(): GLenum;
	get TEXTURE3(): GLenum;
	get TEXTURE30(): GLenum;
	get TEXTURE31(): GLenum;
	get TEXTURE4(): GLenum;
	get TEXTURE5(): GLenum;
	get TEXTURE6(): GLenum;
	get TEXTURE7(): GLenum;
	get TEXTURE8(): GLenum;
	get TEXTURE9(): GLenum;
	get TEXTURE_2D(): GLenum;
	get TEXTURE_BINDING_2D(): GLenum;
	get TEXTURE_BINDING_CUBE_MAP(): GLenum;
	get TEXTURE_CUBE_MAP(): GLenum;
	get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum;
	get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum;
	get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum;
	get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum;
	get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum;
	get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum;
	get TEXTURE_MAG_FILTER(): GLenum;
	get TEXTURE_MIN_FILTER(): GLenum;
	get TEXTURE_WRAP_S(): GLenum;
	get TEXTURE_WRAP_T(): GLenum;
	get TRIANGLES(): GLenum;
	get TRIANGLE_FAN(): GLenum;
	get TRIANGLE_STRIP(): GLenum;
	get UNPACK_ALIGNMENT(): GLenum;
	get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum;
	get UNPACK_FLIP_Y_WEBGL(): GLenum;
	get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum;
	get UNSIGNED_BYTE(): GLenum;
	get UNSIGNED_INT(): GLenum;
	get UNSIGNED_SHORT(): GLenum;
	get UNSIGNED_SHORT_4_4_4_4(): GLenum;
	get UNSIGNED_SHORT_5_5_5_1(): GLenum;
	get UNSIGNED_SHORT_5_6_5(): GLenum;
	get VALIDATE_STATUS(): GLenum;
	get VENDOR(): GLenum;
	get VERSION(): GLenum;
	get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum;
	get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum;
	get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum;
	get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum;
	get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum;
	get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum;
	get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum;
	get VERTEX_SHADER(): GLenum;
	get VIEWPORT(): GLenum;
	get ZERO(): GLenum;
}

export external public interface ~WebGLRenderingContextOverloads {
	bufferData(...args: any+): any+; // overloading not supported
	bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource): void;
	compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void;
	compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void;
	readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView): void;
	texImage2D(...args: any+): any+; // overloading not supported
	texSubImage2D(...args: any+): any+; // overloading not supported
	uniform1fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform1iv(location: WebGLUniformLocation, v: Int32List): void;
	uniform2fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform2iv(location: WebGLUniformLocation, v: Int32List): void;
	uniform3fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform3iv(location: WebGLUniformLocation, v: Int32List): void;
	uniform4fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform4iv(location: WebGLUniformLocation, v: Int32List): void;
	uniformMatrix2fv(location: WebGLUniformLocation, transpose: GLboolean, value: Float32List): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: GLboolean, value: Float32List): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: GLboolean, value: Float32List): void;
}

export external public class WebGLSampler {
	public constructor();
}

export external public class WebGLShader {
	public constructor();
}

export external public class WebGLShaderPrecisionFormat {
	public get precision(): GLint;
	public get rangeMax(): GLint;
	public get rangeMin(): GLint;
	public constructor();
}

export external public class WebGLSync {
	public constructor();
}

export external public class WebGLTexture {
	public constructor();
}

export external public class WebGLTransformFeedback {
	public constructor();
}

export external public class WebGLUniformLocation {
	public constructor();
}

export external public class WebGLVertexArrayObject {
	public constructor();
}

export external public interface ~WebGLVertexArrayObjectOES {}

export external public interface ~WebSocketEventMap {
	close: CloseEvent;
	error: Event;
	message: MessageEvent;
	open: Event;
}

export external public class WebSocket extends EventTarget {
	public binaryType: BinaryType;
	public get bufferedAmount(): number;
	public get extensions(): string;
	public onclose: ({@This(WebSocket) function(ev: CloseEvent): any});
	public onerror: ({@This(WebSocket) function(ev: Event): any});
	public onmessage: ({@This(WebSocket) function(ev: MessageEvent): any});
	public onopen: ({@This(WebSocket) function(ev: Event): any});
	public get protocol(): string;
	public get readyState(): number;
	public get url(): string;
	public close(code: number = , reason: string = ): void;
	public send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;
	public get CLOSED(): number;
	public get CLOSING(): number;
	public get CONNECTING(): number;
	public get OPEN(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(url: string | URL, protocols: string | Array<string> = );
	public static get CLOSED(): number;
	public static get CLOSING(): number;
	public static get CONNECTING(): number;
	public static get OPEN(): number;
}

export external public class WheelEvent extends MouseEvent {
	public get deltaMode(): number;
	public get deltaX(): number;
	public get deltaY(): number;
	public get deltaZ(): number;
	public get DOM_DELTA_LINE(): number;
	public get DOM_DELTA_PAGE(): number;
	public get DOM_DELTA_PIXEL(): number;
	public constructor(type: string, eventInitDict: WheelEventInit = );
	public static get DOM_DELTA_LINE(): number;
	public static get DOM_DELTA_PAGE(): number;
	public static get DOM_DELTA_PIXEL(): number;
}

export external public interface ~WindowEventMap extends GlobalEventHandlersEventMap, WindowEventHandlersEventMap {
	devicemotion: DeviceMotionEvent;
	deviceorientation: DeviceOrientationEvent;
	@Override
	gamepadconnected: GamepadEvent;
	@Override
	gamepaddisconnected: GamepadEvent;
	orientationchange: Event;
}

export external public class Window extends EventTarget implements AnimationFrameProvider, GlobalEventHandlers, WindowEventHandlers, WindowLocalStorage, WindowOrWorkerGlobalScope, WindowSessionStorage {
	public get clientInformation(): Navigator;
	public get closed(): boolean;
	public get customElements(): CustomElementRegistry;
	public get devicePixelRatio(): number;
	public get document(): Document;
	public get event(): Event;
	public get external(): External;
	public get frameElement(): Element;
	public get frames(): WindowProxy;
	public get history(): History;
	public get innerHeight(): number;
	public get innerWidth(): number;
	public get length(): number;
	public get location(): Location;
	public get locationbar(): BarProp;
	public get menubar(): BarProp;
	public name: string;
	public get navigator(): Navigator;
	public ondevicemotion: ({@This(Window) function(ev: DeviceMotionEvent): any});
	public ondeviceorientation: ({@This(Window) function(ev: DeviceOrientationEvent): any});
	public onorientationchange: ({@This(Window) function(ev: Event): any});
	public opener: any;
	public get orientation(): number;
	public get outerHeight(): number;
	public get outerWidth(): number;
	public get pageXOffset(): number;
	public get pageYOffset(): number;
	public get parent(): WindowProxy;
	public get personalbar(): BarProp;
	public get screen(): Screen;
	public get screenLeft(): number;
	public get screenTop(): number;
	public get screenX(): number;
	public get screenY(): number;
	public get scrollX(): number;
	public get scrollY(): number;
	public get scrollbars(): BarProp;
	public get self(): Window & any+;
	public get speechSynthesis(): SpeechSynthesis;
	public status: string;
	public get statusbar(): BarProp;
	public get toolbar(): BarProp;
	public get top(): WindowProxy;
	public get visualViewport(): VisualViewport;
	public get window(): Window & any+;
	public alert(message: any = ): void;
	public blur(): void;
	public cancelIdleCallback(handle: number): void;
	public captureEvents(): void;
	public close(): void;
	public confirm(message: string = ): boolean;
	public focus(): void;
	public getComputedStyle(elt: Element, pseudoElt: string = ): CSSStyleDeclaration;
	public getSelection(): Selection;
	public matchMedia(query: string): MediaQueryList;
	public moveBy(x: number, y: number): void;
	public moveTo(x: number, y: number): void;
	public open(url: string | URL = , target: string = , features: string = ): WindowProxy;
	public postMessage(...args: any+): any+; // overloading not supported
	public print(): void;
	public prompt(message: string = , _default: string = ): string;
	public releaseEvents(): void;
	public requestIdleCallback(callback: IdleRequestCallback, options: IdleRequestOptions = ): number;
	public resizeBy(x: number, y: number): void;
	public resizeTo(width: number, height: number): void;
	public scroll(...args: any+): any+; // overloading not supported
	public scrollBy(...args: any+): any+; // overloading not supported
	public scrollTo(...args: any+): any+; // overloading not supported
	public stop(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~WindowEventHandlersEventMap {
	afterprint: Event;
	beforeprint: Event;
	beforeunload: BeforeUnloadEvent;
	gamepadconnected: GamepadEvent;
	gamepaddisconnected: GamepadEvent;
	hashchange: HashChangeEvent;
	languagechange: Event;
	message: MessageEvent;
	messageerror: MessageEvent;
	offline: Event;
	online: Event;
	pagehide: PageTransitionEvent;
	pageshow: PageTransitionEvent;
	popstate: PopStateEvent;
	rejectionhandled: PromiseRejectionEvent;
	storage: StorageEvent;
	unhandledrejection: PromiseRejectionEvent;
	unload: Event;
}

export external public interface ~WindowEventHandlers {
	onafterprint: ({@This(WindowEventHandlers) function(ev: Event): any});
	onbeforeprint: ({@This(WindowEventHandlers) function(ev: Event): any});
	onbeforeunload: ({@This(WindowEventHandlers) function(ev: BeforeUnloadEvent): any});
	ongamepadconnected: ({@This(WindowEventHandlers) function(ev: GamepadEvent): any});
	ongamepaddisconnected: ({@This(WindowEventHandlers) function(ev: GamepadEvent): any});
	onhashchange: ({@This(WindowEventHandlers) function(ev: HashChangeEvent): any});
	onlanguagechange: ({@This(WindowEventHandlers) function(ev: Event): any});
	onmessage: ({@This(WindowEventHandlers) function(ev: MessageEvent): any});
	onmessageerror: ({@This(WindowEventHandlers) function(ev: MessageEvent): any});
	onoffline: ({@This(WindowEventHandlers) function(ev: Event): any});
	ononline: ({@This(WindowEventHandlers) function(ev: Event): any});
	onpagehide: ({@This(WindowEventHandlers) function(ev: PageTransitionEvent): any});
	onpageshow: ({@This(WindowEventHandlers) function(ev: PageTransitionEvent): any});
	onpopstate: ({@This(WindowEventHandlers) function(ev: PopStateEvent): any});
	onrejectionhandled: ({@This(WindowEventHandlers) function(ev: PromiseRejectionEvent): any});
	onstorage: ({@This(WindowEventHandlers) function(ev: StorageEvent): any});
	onunhandledrejection: ({@This(WindowEventHandlers) function(ev: PromiseRejectionEvent): any});
	onunload: ({@This(WindowEventHandlers) function(ev: Event): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~WindowLocalStorage {
	get localStorage(): Storage;
}

export external public interface ~WindowOrWorkerGlobalScope {
	get caches(): CacheStorage;
	get crossOriginIsolated(): boolean;
	get crypto(): Crypto;
	get indexedDB(): IDBFactory;
	get isSecureContext(): boolean;
	get origin(): string;
	get performance(): Performance;
	atob(data: string): string;
	btoa(data: string): string;
	clearInterval(handle: number = ): void;
	clearTimeout(handle: number = ): void;
	createImageBitmap(...args: any+): any+; // overloading not supported
	fetch(input: RequestInfo, init: RequestInit = ): Promise<Response>;
	queueMicrotask(callback: VoidFunction): void;
	setInterval(handler: TimerHandler, timeout: number = , ...arguments: any): number;
	setTimeout(handler: TimerHandler, timeout: number = , ...arguments: any): number;
}

export external public interface ~WindowSessionStorage {
	get sessionStorage(): Storage;
}

export external public interface ~WorkerEventMap extends AbstractWorkerEventMap {
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public class Worker extends EventTarget implements AbstractWorker {
	public onmessage: ({@This(Worker) function(ev: MessageEvent): any});
	public onmessageerror: ({@This(Worker) function(ev: MessageEvent): any});
	public postMessage(...args: any+): any+; // overloading not supported
	public terminate(): void;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor(scriptURL: string | URL, options: WorkerOptions = );
}

export external public class Worklet {
	public addModule(moduleURL: string | URL, options: WorkletOptions = ): Promise<void>;
	public constructor();
}

export external public class WritableStream<W> {
	public get locked(): boolean;
	public abort(reason: any = ): Promise<void>;
	public close(): Promise<void>;
	public getWriter(): WritableStreamDefaultWriter<W>;
	public constructor(underlyingSink: UnderlyingSink<W> = , strategy: QueuingStrategy<W> = );
}

export external public class WritableStreamDefaultController {
	public error(e: any = ): void;
	public constructor();
}

export external public class WritableStreamDefaultWriter<W> {
	public get closed(): Promise<undefined>;
	public get desiredSize(): number;
	public get ready(): Promise<undefined>;
	public abort(reason: any = ): Promise<void>;
	public close(): Promise<void>;
	public releaseLock(): void;
	public write(chunk: W = ): Promise<void>;
	public constructor(stream: WritableStream<W>);
}

export external public class XMLDocument extends Document {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public interface ~XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {
	readystatechange: Event;
}

export external public class XMLHttpRequest extends XMLHttpRequestEventTarget {
	public onreadystatechange: ({@This(XMLHttpRequest) function(ev: Event): any});
	public get readyState(): number;
	public get response(): any;
	public get responseText(): string;
	public responseType: XMLHttpRequestResponseType;
	public get responseURL(): string;
	public get responseXML(): Document;
	public get status(): number;
	public get statusText(): string;
	public timeout: number;
	public get upload(): XMLHttpRequestUpload;
	public withCredentials: boolean;
	public abort(): void;
	public getAllResponseHeaders(): string;
	public getResponseHeader(name: string): string;
	public open(...args: any+): any+; // overloading not supported
	public overrideMimeType(mime: string): void;
	public send(body: Document | XMLHttpRequestBodyInit = ): void;
	public setRequestHeader(name: string, value: string): void;
	public get DONE(): number;
	public get HEADERS_RECEIVED(): number;
	public get LOADING(): number;
	public get OPENED(): number;
	public get UNSENT(): number;
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
	public static get DONE(): number;
	public static get HEADERS_RECEIVED(): number;
	public static get LOADING(): number;
	public static get OPENED(): number;
	public static get UNSENT(): number;
}

export external public interface ~XMLHttpRequestEventTargetEventMap {
	abort: ProgressEvent<XMLHttpRequestEventTarget>;
	error: ProgressEvent<XMLHttpRequestEventTarget>;
	load: ProgressEvent<XMLHttpRequestEventTarget>;
	loadend: ProgressEvent<XMLHttpRequestEventTarget>;
	loadstart: ProgressEvent<XMLHttpRequestEventTarget>;
	progress: ProgressEvent<XMLHttpRequestEventTarget>;
	timeout: ProgressEvent<XMLHttpRequestEventTarget>;
}

export external public class XMLHttpRequestEventTarget extends EventTarget {
	public onabort: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	public onerror: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	public onload: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	public onloadend: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	public onloadstart: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	public onprogress: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	public ontimeout: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class XMLHttpRequestUpload extends XMLHttpRequestEventTarget {
	@Override
	public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
	public constructor();
}

export external public class XMLSerializer {
	public serializeToString(root: Node): string;
	public constructor();
}

export external public class XPathEvaluator extends XPathEvaluatorBase {
	public constructor();
}

export external public interface ~XPathEvaluatorBase {
	createExpression(expression: string, resolver: XPathNSResolver = ): XPathExpression;
	createNSResolver(nodeResolver: Node): XPathNSResolver;
	evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver = , type: number = , result: XPathResult = ): XPathResult;
}

export external public class XPathExpression {
	public evaluate(contextNode: Node, type: number = , result: XPathResult = ): XPathResult;
	public constructor();
}

export external public class XPathResult {
	public get booleanValue(): boolean;
	public get invalidIteratorState(): boolean;
	public get numberValue(): number;
	public get resultType(): number;
	public get singleNodeValue(): Node;
	public get snapshotLength(): number;
	public get stringValue(): string;
	public iterateNext(): Node;
	public snapshotItem(index: number): Node;
	public get ANY_TYPE(): number;
	public get ANY_UNORDERED_NODE_TYPE(): number;
	public get BOOLEAN_TYPE(): number;
	public get FIRST_ORDERED_NODE_TYPE(): number;
	public get NUMBER_TYPE(): number;
	public get ORDERED_NODE_ITERATOR_TYPE(): number;
	public get ORDERED_NODE_SNAPSHOT_TYPE(): number;
	public get STRING_TYPE(): number;
	public get UNORDERED_NODE_ITERATOR_TYPE(): number;
	public get UNORDERED_NODE_SNAPSHOT_TYPE(): number;
	public constructor();
	public static get ANY_TYPE(): number;
	public static get ANY_UNORDERED_NODE_TYPE(): number;
	public static get BOOLEAN_TYPE(): number;
	public static get FIRST_ORDERED_NODE_TYPE(): number;
	public static get NUMBER_TYPE(): number;
	public static get ORDERED_NODE_ITERATOR_TYPE(): number;
	public static get ORDERED_NODE_SNAPSHOT_TYPE(): number;
	public static get STRING_TYPE(): number;
	public static get UNORDERED_NODE_ITERATOR_TYPE(): number;
	public static get UNORDERED_NODE_SNAPSHOT_TYPE(): number;
}

export external public class XSLTProcessor {
	public clearParameters(): void;
	public getParameter(namespaceURI: string, localName: string): any;
	public importStylesheet(style: Node): void;
	public removeParameter(namespaceURI: string, localName: string): void;
	public reset(): void;
	public setParameter(namespaceURI: string, localName: string, value: any): void;
	public transformToDocument(source: Node): Document;
	public transformToFragment(source: Node, output: Document): DocumentFragment;
	public constructor();
}

export external public class Console {
	public static assert(condition: boolean = , ...data: any): void;
	public static clear(): void;
	public static count(label: string = ): void;
	public static countReset(label: string = ): void;
	public static debug(...data: any): void;
	public static dir(item: any = , options: any = ): void;
	public static dirxml(...data: any): void;
	public static error(...data: any): void;
	public static group(...data: any): void;
	public static groupCollapsed(...data: any): void;
	public static groupEnd(): void;
	public static info(...data: any): void;
	public static log(...data: any): void;
	public static table(tabularData: any = , properties: Array<string> = ): void;
	public static time(label: string = ): void;
	public static timeEnd(label: string = ): void;
	public static timeLog(label: string = , ...data: any): void;
	public static timeStamp(label: string = ): void;
	public static trace(...data: any): void;
	public static warn(...data: any): void;
}

export external public interface ~BlobCallback {
	(blob: Blob): void;
}

export external public interface ~CustomElementConstructor {
	@CovariantConstructor
	constructor(...params: any);
}

export external public interface ~DecodeErrorCallback {
	(error: DOMException): void;
}

export external public interface ~DecodeSuccessCallback {
	(decodedData: AudioBuffer): void;
}

export external public interface ~ErrorCallback {
	(err: DOMException): void;
}

export external public interface ~FileCallback {
	(file: File): void;
}

export external public interface ~FileSystemEntriesCallback {
	(entries: Array<FileSystemEntry>): void;
}

export external public interface ~FileSystemEntryCallback {
	(entry: FileSystemEntry): void;
}

export external public interface ~FrameRequestCallback {
	(time: DOMHighResTimeStamp): void;
}

export external public interface ~FunctionStringCallback {
	(data: string): void;
}

export external public interface ~IdleRequestCallback {
	(deadline: IdleDeadline): void;
}

export external public interface ~IntersectionObserverCallback {
	(entries: Array<IntersectionObserverEntry>, observer: IntersectionObserver): void;
}

export external public interface ~MediaSessionActionHandler {
	(details: MediaSessionActionDetails): void;
}

export external public interface ~MutationCallback {
	(mutations: Array<MutationRecord>, observer: MutationObserver): void;
}

export external public interface ~NotificationPermissionCallback {
	(permission: NotificationPermission): void;
}

export external public interface ~OnBeforeUnloadEventHandlerNonNull {
	(event: Event): string;
}

export external public interface ~OnErrorEventHandlerNonNull {
	(event: Event | string, source: string = , lineno: number = , colno: number = , error: Error = ): any;
}

export external public interface ~PerformanceObserverCallback {
	(entries: PerformanceObserverEntryList, observer: PerformanceObserver): void;
}

export external public interface ~PositionCallback {
	(position: GeolocationPosition): void;
}

export external public interface ~PositionErrorCallback {
	(positionError: GeolocationPositionError): void;
}

export external public interface ~QueuingStrategySize<T> {
	(chunk: T = ): number;
}

export external public interface ~RTCPeerConnectionErrorCallback {
	(error: DOMException): void;
}

export external public interface ~RTCSessionDescriptionCallback {
	(description: RTCSessionDescriptionInit): void;
}

export external public interface ~RemotePlaybackAvailabilityCallback {
	(available: boolean): void;
}

export external public interface ~ResizeObserverCallback {
	(entries: Array<ResizeObserverEntry>, observer: ResizeObserver): void;
}

export external public interface ~TransformerFlushCallback<O> {
	(controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;
}

export external public interface ~TransformerStartCallback<O> {
	(controller: TransformStreamDefaultController<O>): any;
}

export external public interface ~TransformerTransformCallback<I,O> {
	(chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;
}

export external public interface ~UnderlyingSinkAbortCallback {
	(reason: any = ): void | PromiseLike<void>;
}

export external public interface ~UnderlyingSinkCloseCallback {
	(): void | PromiseLike<void>;
}

export external public interface ~UnderlyingSinkStartCallback {
	(controller: WritableStreamDefaultController): any;
}

export external public interface ~UnderlyingSinkWriteCallback<W> {
	(chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>;
}

export external public interface ~UnderlyingSourceCancelCallback {
	(reason: any = ): void | PromiseLike<void>;
}

export external public interface ~UnderlyingSourcePullCallback<R> {
	(controller: ReadableStreamController<R>): void | PromiseLike<void>;
}

export external public interface ~UnderlyingSourceStartCallback<R> {
	(controller: ReadableStreamController<R>): any;
}

export external public interface ~VoidFunction {
	(): void;
}

export external public interface ~HTMLElementTagNameMap {
	a: HTMLAnchorElement;
	abbr: HTMLElement;
	address: HTMLElement;
	area: HTMLAreaElement;
	article: HTMLElement;
	aside: HTMLElement;
	audio: HTMLAudioElement;
	b: HTMLElement;
	base: HTMLBaseElement;
	bdi: HTMLElement;
	bdo: HTMLElement;
	blockquote: HTMLQuoteElement;
	body: HTMLBodyElement;
	br: HTMLBRElement;
	button: HTMLButtonElement;
	canvas: HTMLCanvasElement;
	caption: HTMLTableCaptionElement;
	cite: HTMLElement;
	code: HTMLElement;
	col: HTMLTableColElement;
	colgroup: HTMLTableColElement;
	data: HTMLDataElement;
	datalist: HTMLDataListElement;
	dd: HTMLElement;
	del: HTMLModElement;
	details: HTMLDetailsElement;
	dfn: HTMLElement;
	dialog: HTMLDialogElement;
	dir: HTMLDirectoryElement;
	div: HTMLDivElement;
	dl: HTMLDListElement;
	dt: HTMLElement;
	em: HTMLElement;
	embed: HTMLEmbedElement;
	fieldset: HTMLFieldSetElement;
	figcaption: HTMLElement;
	figure: HTMLElement;
	font: HTMLFontElement;
	footer: HTMLElement;
	form: HTMLFormElement;
	frame: HTMLFrameElement;
	frameset: HTMLFrameSetElement;
	h1: HTMLHeadingElement;
	h2: HTMLHeadingElement;
	h3: HTMLHeadingElement;
	h4: HTMLHeadingElement;
	h5: HTMLHeadingElement;
	h6: HTMLHeadingElement;
	head: HTMLHeadElement;
	header: HTMLElement;
	hgroup: HTMLElement;
	hr: HTMLHRElement;
	html: HTMLHtmlElement;
	i: HTMLElement;
	iframe: HTMLIFrameElement;
	img: HTMLImageElement;
	input: HTMLInputElement;
	ins: HTMLModElement;
	kbd: HTMLElement;
	label: HTMLLabelElement;
	legend: HTMLLegendElement;
	li: HTMLLIElement;
	link: HTMLLinkElement;
	main: HTMLElement;
	map: HTMLMapElement;
	mark: HTMLElement;
	marquee: HTMLMarqueeElement;
	menu: HTMLMenuElement;
	meta: HTMLMetaElement;
	meter: HTMLMeterElement;
	nav: HTMLElement;
	noscript: HTMLElement;
	object: HTMLObjectElement;
	ol: HTMLOListElement;
	optgroup: HTMLOptGroupElement;
	option: HTMLOptionElement;
	output: HTMLOutputElement;
	p: HTMLParagraphElement;
	param: HTMLParamElement;
	picture: HTMLPictureElement;
	pre: HTMLPreElement;
	progress: HTMLProgressElement;
	q: HTMLQuoteElement;
	rp: HTMLElement;
	rt: HTMLElement;
	ruby: HTMLElement;
	s: HTMLElement;
	samp: HTMLElement;
	script: HTMLScriptElement;
	section: HTMLElement;
	select: HTMLSelectElement;
	slot: HTMLSlotElement;
	small: HTMLElement;
	source: HTMLSourceElement;
	span: HTMLSpanElement;
	strong: HTMLElement;
	style: HTMLStyleElement;
	sub: HTMLElement;
	summary: HTMLElement;
	sup: HTMLElement;
	table: HTMLTableElement;
	tbody: HTMLTableSectionElement;
	td: HTMLTableCellElement;
	template: HTMLTemplateElement;
	textarea: HTMLTextAreaElement;
	tfoot: HTMLTableSectionElement;
	th: HTMLTableCellElement;
	thead: HTMLTableSectionElement;
	time: HTMLTimeElement;
	title: HTMLTitleElement;
	tr: HTMLTableRowElement;
	track: HTMLTrackElement;
	u: HTMLElement;
	ul: HTMLUListElement;
	var: HTMLElement;
	video: HTMLVideoElement;
	wbr: HTMLElement;
}

export external public interface ~HTMLElementDeprecatedTagNameMap {
	listing: HTMLPreElement;
	xmp: HTMLPreElement;
}

export external public interface ~SVGElementTagNameMap {
	a: SVGAElement;
	animate: SVGAnimateElement;
	animateMotion: SVGAnimateMotionElement;
	animateTransform: SVGAnimateTransformElement;
	circle: SVGCircleElement;
	clipPath: SVGClipPathElement;
	defs: SVGDefsElement;
	desc: SVGDescElement;
	ellipse: SVGEllipseElement;
	feBlend: SVGFEBlendElement;
	feColorMatrix: SVGFEColorMatrixElement;
	feComponentTransfer: SVGFEComponentTransferElement;
	feComposite: SVGFECompositeElement;
	feConvolveMatrix: SVGFEConvolveMatrixElement;
	feDiffuseLighting: SVGFEDiffuseLightingElement;
	feDisplacementMap: SVGFEDisplacementMapElement;
	feDistantLight: SVGFEDistantLightElement;
	feDropShadow: SVGFEDropShadowElement;
	feFlood: SVGFEFloodElement;
	feFuncA: SVGFEFuncAElement;
	feFuncB: SVGFEFuncBElement;
	feFuncG: SVGFEFuncGElement;
	feFuncR: SVGFEFuncRElement;
	feGaussianBlur: SVGFEGaussianBlurElement;
	feImage: SVGFEImageElement;
	feMerge: SVGFEMergeElement;
	feMergeNode: SVGFEMergeNodeElement;
	feMorphology: SVGFEMorphologyElement;
	feOffset: SVGFEOffsetElement;
	fePointLight: SVGFEPointLightElement;
	feSpecularLighting: SVGFESpecularLightingElement;
	feSpotLight: SVGFESpotLightElement;
	feTile: SVGFETileElement;
	feTurbulence: SVGFETurbulenceElement;
	filter: SVGFilterElement;
	foreignObject: SVGForeignObjectElement;
	g: SVGGElement;
	image: SVGImageElement;
	line: SVGLineElement;
	linearGradient: SVGLinearGradientElement;
	marker: SVGMarkerElement;
	mask: SVGMaskElement;
	metadata: SVGMetadataElement;
	mpath: SVGMPathElement;
	path: SVGPathElement;
	pattern: SVGPatternElement;
	polygon: SVGPolygonElement;
	polyline: SVGPolylineElement;
	radialGradient: SVGRadialGradientElement;
	rect: SVGRectElement;
	script: SVGScriptElement;
	set: SVGSetElement;
	stop: SVGStopElement;
	style: SVGStyleElement;
	svg: SVGSVGElement;
	switch: SVGSwitchElement;
	symbol: SVGSymbolElement;
	text: SVGTextElement;
	textPath: SVGTextPathElement;
	title: SVGTitleElement;
	tspan: SVGTSpanElement;
	use: SVGUseElement;
	view: SVGViewElement;
}

export external public type ElementTagNameMap = HTMLElementTagNameMap & Pick<SVGElementTagNameMap,Exclude<SVGElementTagNameMap,HTMLElementTagNameMap>>;

var Audio: ~Object with { constructor(src: string = ); };

var Image: ~Object with { constructor(width: number = , height: number = ); };

var Option: ~Object with { constructor(text: string = , value: string = , defaultSelected: boolean = , selected: boolean = ); };

var clientInformation: Navigator;

var closed: boolean;

var customElements: CustomElementRegistry;

var devicePixelRatio: number;

var document: Document;

var event: Event;

var external: External;

var frameElement: Element;

var frames: WindowProxy;

var history: History;

var innerHeight: number;

var innerWidth: number;

var length: number;

var location: Location;

var locationbar: BarProp;

var menubar: BarProp;

const name: void;

var navigator: Navigator;

var ondevicemotion: ({@This(Window) function(ev: DeviceMotionEvent): any});

var ondeviceorientation: ({@This(Window) function(ev: DeviceOrientationEvent): any});

var onorientationchange: ({@This(Window) function(ev: Event): any});

var opener: any;

var orientation: number;

var outerHeight: number;

var outerWidth: number;

var pageXOffset: number;

var pageYOffset: number;

var parent: WindowProxy;

var personalbar: BarProp;

var screen: Screen;

var screenLeft: number;

var screenTop: number;

var screenX: number;

var screenY: number;

var scrollX: number;

var scrollY: number;

var scrollbars: BarProp;

var self: Window & any+;

var speechSynthesis: SpeechSynthesis;

var status: string;

var statusbar: BarProp;

var toolbar: BarProp;

var top: WindowProxy;

var visualViewport: VisualViewport;

var window: Window & any+;

export external public function alert(message: any = ): void;

export external public function blur(): void;

export external public function cancelIdleCallback(handle: number): void;

export external public function captureEvents(): void;

export external public function close(): void;

export external public function confirm(message: string = ): boolean;

export external public function focus(): void;

export external public function getComputedStyle(elt: Element, pseudoElt: string = ): CSSStyleDeclaration;

export external public function getSelection(): Selection;

export external public function matchMedia(query: string): MediaQueryList;

export external public function moveBy(x: number, y: number): void;

export external public function moveTo(x: number, y: number): void;

export external public function open(url: string | URL = , target: string = , features: string = ): WindowProxy;

export external public function postMessage(...args: any+): any+; // overloading not supported

export external public function print(): void;

export external public function prompt(message: string = , _default: string = ): string;

export external public function releaseEvents(): void;

export external public function requestIdleCallback(callback: IdleRequestCallback, options: IdleRequestOptions = ): number;

export external public function resizeBy(x: number, y: number): void;

export external public function resizeTo(width: number, height: number): void;

export external public function scroll(...args: any+): any+; // overloading not supported

export external public function scrollBy(...args: any+): any+; // overloading not supported

export external public function scrollTo(...args: any+): any+; // overloading not supported

export external public function stop(): void;

export external public function toString(): string;

export external public function dispatchEvent(event: Event): boolean;

export external public function cancelAnimationFrame(handle: number): void;

export external public function requestAnimationFrame(callback: FrameRequestCallback): number;

var onabort: ({@This(Window) function(ev: UIEvent): any});

var onanimationcancel: ({@This(Window) function(ev: AnimationEvent): any});

var onanimationend: ({@This(Window) function(ev: AnimationEvent): any});

var onanimationiteration: ({@This(Window) function(ev: AnimationEvent): any});

var onanimationstart: ({@This(Window) function(ev: AnimationEvent): any});

var onauxclick: ({@This(Window) function(ev: MouseEvent): any});

var onblur: ({@This(Window) function(ev: FocusEvent): any});

var oncanplay: ({@This(Window) function(ev: Event): any});

var oncanplaythrough: ({@This(Window) function(ev: Event): any});

var onchange: ({@This(Window) function(ev: Event): any});

var onclick: ({@This(Window) function(ev: MouseEvent): any});

var onclose: ({@This(Window) function(ev: Event): any});

var oncontextmenu: ({@This(Window) function(ev: MouseEvent): any});

var oncuechange: ({@This(Window) function(ev: Event): any});

var ondblclick: ({@This(Window) function(ev: MouseEvent): any});

var ondrag: ({@This(Window) function(ev: DragEvent): any});

var ondragend: ({@This(Window) function(ev: DragEvent): any});

var ondragenter: ({@This(Window) function(ev: DragEvent): any});

var ondragleave: ({@This(Window) function(ev: DragEvent): any});

var ondragover: ({@This(Window) function(ev: DragEvent): any});

var ondragstart: ({@This(Window) function(ev: DragEvent): any});

var ondrop: ({@This(Window) function(ev: DragEvent): any});

var ondurationchange: ({@This(Window) function(ev: Event): any});

var onemptied: ({@This(Window) function(ev: Event): any});

var onended: ({@This(Window) function(ev: Event): any});

var onerror: OnErrorEventHandler;

var onfocus: ({@This(Window) function(ev: FocusEvent): any});

var onformdata: ({@This(Window) function(ev: FormDataEvent): any});

var ongotpointercapture: ({@This(Window) function(ev: PointerEvent): any});

var oninput: ({@This(Window) function(ev: Event): any});

var oninvalid: ({@This(Window) function(ev: Event): any});

var onkeydown: ({@This(Window) function(ev: KeyboardEvent): any});

var onkeypress: ({@This(Window) function(ev: KeyboardEvent): any});

var onkeyup: ({@This(Window) function(ev: KeyboardEvent): any});

var onload: ({@This(Window) function(ev: Event): any});

var onloadeddata: ({@This(Window) function(ev: Event): any});

var onloadedmetadata: ({@This(Window) function(ev: Event): any});

var onloadstart: ({@This(Window) function(ev: Event): any});

var onlostpointercapture: ({@This(Window) function(ev: PointerEvent): any});

var onmousedown: ({@This(Window) function(ev: MouseEvent): any});

var onmouseenter: ({@This(Window) function(ev: MouseEvent): any});

var onmouseleave: ({@This(Window) function(ev: MouseEvent): any});

var onmousemove: ({@This(Window) function(ev: MouseEvent): any});

var onmouseout: ({@This(Window) function(ev: MouseEvent): any});

var onmouseover: ({@This(Window) function(ev: MouseEvent): any});

var onmouseup: ({@This(Window) function(ev: MouseEvent): any});

var onpause: ({@This(Window) function(ev: Event): any});

var onplay: ({@This(Window) function(ev: Event): any});

var onplaying: ({@This(Window) function(ev: Event): any});

var onpointercancel: ({@This(Window) function(ev: PointerEvent): any});

var onpointerdown: ({@This(Window) function(ev: PointerEvent): any});

var onpointerenter: ({@This(Window) function(ev: PointerEvent): any});

var onpointerleave: ({@This(Window) function(ev: PointerEvent): any});

var onpointermove: ({@This(Window) function(ev: PointerEvent): any});

var onpointerout: ({@This(Window) function(ev: PointerEvent): any});

var onpointerover: ({@This(Window) function(ev: PointerEvent): any});

var onpointerup: ({@This(Window) function(ev: PointerEvent): any});

var onprogress: ({@This(Window) function(ev: ProgressEvent): any});

var onratechange: ({@This(Window) function(ev: Event): any});

var onreset: ({@This(Window) function(ev: Event): any});

var onresize: ({@This(Window) function(ev: UIEvent): any});

var onscroll: ({@This(Window) function(ev: Event): any});

var onseeked: ({@This(Window) function(ev: Event): any});

var onseeking: ({@This(Window) function(ev: Event): any});

var onselect: ({@This(Window) function(ev: Event): any});

var onselectionchange: ({@This(Window) function(ev: Event): any});

var onselectstart: ({@This(Window) function(ev: Event): any});

var onstalled: ({@This(Window) function(ev: Event): any});

var onsubmit: ({@This(Window) function(ev: SubmitEvent): any});

var onsuspend: ({@This(Window) function(ev: Event): any});

var ontimeupdate: ({@This(Window) function(ev: Event): any});

var ontoggle: ({@This(Window) function(ev: Event): any});

var ontouchcancel: ({@This(Window) function(ev: TouchEvent): any});

var ontouchend: ({@This(Window) function(ev: TouchEvent): any});

var ontouchmove: ({@This(Window) function(ev: TouchEvent): any});

var ontouchstart: ({@This(Window) function(ev: TouchEvent): any});

var ontransitioncancel: ({@This(Window) function(ev: TransitionEvent): any});

var ontransitionend: ({@This(Window) function(ev: TransitionEvent): any});

var ontransitionrun: ({@This(Window) function(ev: TransitionEvent): any});

var ontransitionstart: ({@This(Window) function(ev: TransitionEvent): any});

var onvolumechange: ({@This(Window) function(ev: Event): any});

var onwaiting: ({@This(Window) function(ev: Event): any});

var onwebkitanimationend: ({@This(Window) function(ev: Event): any});

var onwebkitanimationiteration: ({@This(Window) function(ev: Event): any});

var onwebkitanimationstart: ({@This(Window) function(ev: Event): any});

var onwebkittransitionend: ({@This(Window) function(ev: Event): any});

var onwheel: ({@This(Window) function(ev: WheelEvent): any});

var onafterprint: ({@This(Window) function(ev: Event): any});

var onbeforeprint: ({@This(Window) function(ev: Event): any});

var onbeforeunload: ({@This(Window) function(ev: BeforeUnloadEvent): any});

var ongamepadconnected: ({@This(Window) function(ev: GamepadEvent): any});

var ongamepaddisconnected: ({@This(Window) function(ev: GamepadEvent): any});

var onhashchange: ({@This(Window) function(ev: HashChangeEvent): any});

var onlanguagechange: ({@This(Window) function(ev: Event): any});

var onmessage: ({@This(Window) function(ev: MessageEvent): any});

var onmessageerror: ({@This(Window) function(ev: MessageEvent): any});

var onoffline: ({@This(Window) function(ev: Event): any});

var ononline: ({@This(Window) function(ev: Event): any});

var onpagehide: ({@This(Window) function(ev: PageTransitionEvent): any});

var onpageshow: ({@This(Window) function(ev: PageTransitionEvent): any});

var onpopstate: ({@This(Window) function(ev: PopStateEvent): any});

var onrejectionhandled: ({@This(Window) function(ev: PromiseRejectionEvent): any});

var onstorage: ({@This(Window) function(ev: StorageEvent): any});

var onunhandledrejection: ({@This(Window) function(ev: PromiseRejectionEvent): any});

var onunload: ({@This(Window) function(ev: Event): any});

var localStorage: Storage;

var caches: CacheStorage;

var crossOriginIsolated: boolean;

var crypto: Crypto;

var indexedDB: IDBFactory;

var isSecureContext: boolean;

var origin: string;

var performance: Performance;

export external public function atob(data: string): string;

export external public function btoa(data: string): string;

export external public function clearInterval(handle: number = ): void;

export external public function clearTimeout(handle: number = ): void;

export external public function createImageBitmap(...args: any+): any+; // overloading not supported

export external public function fetch(input: RequestInfo, init: RequestInit = ): Promise<Response>;

export external public function queueMicrotask(callback: VoidFunction): void;

export external public function setInterval(handler: TimerHandler, timeout: number = , ...arguments: any): number;

export external public function setTimeout(handler: TimerHandler, timeout: number = , ...arguments: any): number;

var sessionStorage: Storage;

export external public function addEventListener(...args: any+): any+; // overloading not supported

export external public function removeEventListener(...args: any+): any+; // overloading not supported

export external public type AlgorithmIdentifier = Algorithm | string;

export external public type BigInteger = Uint8Array;

export external public type BinaryData = ArrayBuffer | ArrayBufferView;

export external public type BlobPart = BufferSource | Blob | string;

export external public type BodyInit = ReadableStream | XMLHttpRequestBodyInit;

export external public type BufferSource = ArrayBufferView | ArrayBuffer;

export external public type COSEAlgorithmIdentifier = number;

export external public type CSSNumberish = number;

export external public type CanvasImageSource = HTMLOrSVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap;

export external public type ClipboardItemData = Promise<ClipboardItemDataType>;

export external public type ClipboardItemDataType = string | Blob;

export external public type ClipboardItems = Array<ClipboardItem>;

export external public type ConstrainBoolean = boolean | ConstrainBooleanParameters;

export external public type ConstrainDOMString = string | Array<string> | ConstrainDOMStringParameters;

export external public type ConstrainDouble = number | ConstrainDoubleRange;

export external public type ConstrainULong = number | ConstrainULongRange;

export external public type DOMHighResTimeStamp = number;

export external public type DOMTimeStamp = number;

export external public type EventListenerOrEventListenerObject = EventListener | EventListenerObject;

export external public type Float32List = Float32Array | Array<GLfloat>;

export external public type FormDataEntryValue = File | string;

export external public type GLbitfield = number;

export external public type GLboolean = boolean;

export external public type GLclampf = number;

export external public type GLenum = number;

export external public type GLfloat = number;

export external public type GLint = number;

export external public type GLint64 = number;

export external public type GLintptr = number;

export external public type GLsizei = number;

export external public type GLsizeiptr = number;

export external public type GLuint = number;

export external public type GLuint64 = number;

export external public type HTMLOrSVGImageElement = HTMLImageElement | SVGImageElement;

export external public type HTMLOrSVGScriptElement = HTMLScriptElement | SVGScriptElement;

export external public type HashAlgorithmIdentifier = AlgorithmIdentifier;

export external public type HeadersInit = Array<Array<string>> | Record<string,string> | Headers;

export external public type IDBValidKey = number | string | Date | BufferSource | Array<IDBValidKey>;

export external public type ImageBitmapSource = CanvasImageSource | Blob | ImageData;

export external public type InsertPosition = "beforebegin" | "afterbegin" | "beforeend" | "afterend";

export external public type Int32List = Int32Array | Array<GLint>;

export external public type LineAndPositionSetting = number | AutoKeyword;

export external public type MediaProvider = MediaStream | MediaSource | Blob;

export external public type MessageEventSource = WindowProxy | MessagePort | ServiceWorker;

export external public type MutationRecordType = "attributes" | "characterData" | "childList";

export external public type NamedCurve = string;

export external public type OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull;

export external public type OnErrorEventHandler = OnErrorEventHandlerNonNull;

export external public type PerformanceEntryList = Array<PerformanceEntry>;

export external public type ReadableStreamController<T> = ReadableStreamDefaultController<T>;

export external public type ReadableStreamDefaultReadResult<T> = ReadableStreamDefaultReadValueResult<T> | ReadableStreamDefaultReadDoneResult;

export external public type ReadableStreamReader<T> = ReadableStreamDefaultReader<T>;

export external public type RenderingContext = CanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext;

export external public type RequestInfo = Request | string;

export external public type TexImageSource = ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;

export external public type TimerHandler = string | Function;

export external public type Transferable = ArrayBuffer | MessagePort | ImageBitmap;

export external public type Uint32List = Uint32Array | Array<GLuint>;

export external public type UvmEntries = Array<UvmEntry>;

export external public type UvmEntry = Array<number>;

export external public type VibratePattern = number | Array<number>;

export external public type WindowProxy = Window;

export external public type XMLHttpRequestBodyInit = Blob | BufferSource | FormData | URLSearchParams | string;

export external public type AlignSetting = "center" | "end" | "left" | "right" | "start";

export external public type AnimationPlayState = "finished" | "idle" | "paused" | "running";

export external public type AnimationReplaceState = "active" | "persisted" | "removed";

export external public type AppendMode = "segments" | "sequence";

export external public type AttestationConveyancePreference = "direct" | "enterprise" | "indirect" | "none";

export external public type AudioContextLatencyCategory = "balanced" | "interactive" | "playback";

export external public type AudioContextState = "closed" | "running" | "suspended";

export external public type AuthenticatorAttachment = "cross-platform" | "platform";

export external public type AuthenticatorTransport = "ble" | "internal" | "nfc" | "usb";

export external public type AutoKeyword = "auto";

export external public type AutomationRate = "a-rate" | "k-rate";

export external public type BinaryType = "arraybuffer" | "blob";

export external public type BiquadFilterType = "allpass" | "bandpass" | "highpass" | "highshelf" | "lowpass" | "lowshelf" | "notch" | "peaking";

export external public type CanPlayTypeResult = "" | "maybe" | "probably";

export external public type CanvasDirection = "inherit" | "ltr" | "rtl";

export external public type CanvasFillRule = "evenodd" | "nonzero";

export external public type CanvasFontKerning = "auto" | "none" | "normal";

export external public type CanvasFontStretch = "condensed" | "expanded" | "extra-condensed" | "extra-expanded" | "normal" | "semi-condensed" | "semi-expanded" | "ultra-condensed" | "ultra-expanded";

export external public type CanvasFontVariantCaps = "all-petite-caps" | "all-small-caps" | "normal" | "petite-caps" | "small-caps" | "titling-caps" | "unicase";

export external public type CanvasLineCap = "butt" | "round" | "square";

export external public type CanvasLineJoin = "bevel" | "miter" | "round";

export external public type CanvasTextAlign = "center" | "end" | "left" | "right" | "start";

export external public type CanvasTextBaseline = "alphabetic" | "bottom" | "hanging" | "ideographic" | "middle" | "top";

export external public type CanvasTextRendering = "auto" | "geometricPrecision" | "optimizeLegibility" | "optimizeSpeed";

export external public type ChannelCountMode = "clamped-max" | "explicit" | "max";

export external public type ChannelInterpretation = "discrete" | "speakers";

export external public type ClientTypes = "all" | "sharedworker" | "window" | "worker";

export external public type ColorGamut = "p3" | "rec2020" | "srgb";

export external public type ColorSpaceConversion = "default" | "none";

export external public type CompositeOperation = "accumulate" | "add" | "replace";

export external public type CompositeOperationOrAuto = "accumulate" | "add" | "auto" | "replace";

export external public type ConnectionType = "bluetooth" | "cellular" | "ethernet" | "mixed" | "none" | "other" | "unknown" | "wifi";

export external public type CredentialMediationRequirement = "optional" | "required" | "silent";

export external public type DOMParserSupportedType = "application/xhtml+xml" | "application/xml" | "image/svg+xml" | "text/html" | "text/xml";

export external public type DirectionSetting = "" | "lr" | "rl";

export external public type DisplayCaptureSurfaceType = "application" | "browser" | "monitor" | "window";

export external public type DistanceModelType = "exponential" | "inverse" | "linear";

export external public type DocumentReadyState = "complete" | "interactive" | "loading";

export external public type EndOfStreamError = "decode" | "network";

export external public type EndingType = "native" | "transparent";

export external public type FillMode = "auto" | "backwards" | "both" | "forwards" | "none";

export external public type FontFaceLoadStatus = "error" | "loaded" | "loading" | "unloaded";

export external public type FontFaceSetLoadStatus = "loaded" | "loading";

export external public type FullscreenNavigationUI = "auto" | "hide" | "show";

export external public type GamepadHapticActuatorType = "vibration";

export external public type GamepadMappingType = "" | "standard" | "xr-standard";

export external public type HdrMetadataType = "smpteSt2086" | "smpteSt2094-10" | "smpteSt2094-40";

export external public type IDBCursorDirection = "next" | "nextunique" | "prev" | "prevunique";

export external public type IDBRequestReadyState = "done" | "pending";

export external public type IDBTransactionMode = "readonly" | "readwrite" | "versionchange";

export external public type ImageOrientation = "flipY" | "none";

export external public type ImageSmoothingQuality = "high" | "low" | "medium";

export external public type IterationCompositeOperation = "accumulate" | "replace";

export external public type KeyFormat = "jwk" | "pkcs8" | "raw" | "spki";

export external public type KeyType = "private" | "public" | "secret";

export external public type KeyUsage = "decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey";

export external public type LineAlignSetting = "center" | "end" | "start";

export external public type MediaDecodingType = "file" | "media-source" | "webrtc";

export external public type MediaDeviceKind = "audioinput" | "audiooutput" | "videoinput";

export external public type MediaEncodingType = "record" | "webrtc";

export external public type MediaKeyMessageType = "individualization-request" | "license-release" | "license-renewal" | "license-request";

export external public type MediaKeySessionClosedReason = "closed-by-application" | "hardware-context-reset" | "internal-error" | "release-acknowledged" | "resource-evicted";

export external public type MediaKeySessionType = "persistent-license" | "temporary";

export external public type MediaKeyStatus = "expired" | "internal-error" | "output-downscaled" | "output-restricted" | "released" | "status-pending" | "usable" | "usable-in-future";

export external public type MediaKeysRequirement = "not-allowed" | "optional" | "required";

export external public type MediaSessionAction = "hangup" | "nexttrack" | "pause" | "play" | "previoustrack" | "seekbackward" | "seekforward" | "seekto" | "skipad" | "stop" | "togglecamera" | "togglemicrophone";

export external public type MediaSessionPlaybackState = "none" | "paused" | "playing";

export external public type MediaStreamTrackState = "ended" | "live";

export external public type NavigationType = "back_forward" | "navigate" | "prerender" | "reload";

export external public type NotificationDirection = "auto" | "ltr" | "rtl";

export external public type NotificationPermission = "default" | "denied" | "granted";

export external public type OrientationLockType = "any" | "landscape" | "landscape-primary" | "landscape-secondary" | "natural" | "portrait" | "portrait-primary" | "portrait-secondary";

export external public type OrientationType = "landscape-primary" | "landscape-secondary" | "portrait-primary" | "portrait-secondary";

export external public type OscillatorType = "custom" | "sawtooth" | "sine" | "square" | "triangle";

export external public type OverSampleType = "2x" | "4x" | "none";

export external public type PanningModelType = "HRTF" | "equalpower";

export external public type PaymentComplete = "fail" | "success" | "unknown";

export external public type PermissionName = "geolocation" | "notifications" | "persistent-storage" | "push" | "screen-wake-lock";

export external public type PermissionState = "denied" | "granted" | "prompt";

export external public type PlaybackDirection = "alternate" | "alternate-reverse" | "normal" | "reverse";

export external public type PositionAlignSetting = "auto" | "center" | "line-left" | "line-right";

export external public type PredefinedColorSpace = "display-p3" | "srgb";

export external public type PremultiplyAlpha = "default" | "none" | "premultiply";

export external public type PresentationStyle = "attachment" | "inline" | "unspecified";

export external public type PublicKeyCredentialType = "public-key";

export external public type PushEncryptionKeyName = "auth" | "p256dh";

export external public type PushPermissionState = "denied" | "granted" | "prompt";

export external public type RTCBundlePolicy = "balanced" | "max-bundle" | "max-compat";

export external public type RTCDataChannelState = "closed" | "closing" | "connecting" | "open";

export external public type RTCDegradationPreference = "balanced" | "maintain-framerate" | "maintain-resolution";

export external public type RTCDtlsTransportState = "closed" | "connected" | "connecting" | "failed" | "new";

export external public type RTCIceCandidateType = "host" | "prflx" | "relay" | "srflx";

export external public type RTCIceComponent = "rtcp" | "rtp";

export external public type RTCIceConnectionState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new";

export external public type RTCIceCredentialType = "password";

export external public type RTCIceGathererState = "complete" | "gathering" | "new";

export external public type RTCIceGatheringState = "complete" | "gathering" | "new";

export external public type RTCIceProtocol = "tcp" | "udp";

export external public type RTCIceTcpCandidateType = "active" | "passive" | "so";

export external public type RTCIceTransportPolicy = "all" | "relay";

export external public type RTCIceTransportState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new";

export external public type RTCPeerConnectionState = "closed" | "connected" | "connecting" | "disconnected" | "failed" | "new";

export external public type RTCPriorityType = "high" | "low" | "medium" | "very-low";

export external public type RTCRtcpMuxPolicy = "require";

export external public type RTCRtpTransceiverDirection = "inactive" | "recvonly" | "sendonly" | "sendrecv" | "stopped";

export external public type RTCSdpType = "answer" | "offer" | "pranswer" | "rollback";

export external public type RTCSignalingState = "closed" | "have-local-offer" | "have-local-pranswer" | "have-remote-offer" | "have-remote-pranswer" | "stable";

export external public type RTCStatsIceCandidatePairState = "failed" | "frozen" | "in-progress" | "inprogress" | "succeeded" | "waiting";

export external public type RTCStatsType = "candidate-pair" | "certificate" | "codec" | "csrc" | "data-channel" | "inbound-rtp" | "local-candidate" | "media-source" | "outbound-rtp" | "peer-connection" | "remote-candidate" | "remote-inbound-rtp" | "remote-outbound-rtp" | "track" | "transport";

export external public type ReadyState = "closed" | "ended" | "open";

export external public type RecordingState = "inactive" | "paused" | "recording";

export external public type ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url";

export external public type RemotePlaybackState = "connected" | "connecting" | "disconnected";

export external public type RequestCache = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload";

export external public type RequestCredentials = "include" | "omit" | "same-origin";

export external public type RequestDestination = "" | "audio" | "audioworklet" | "document" | "embed" | "font" | "frame" | "iframe" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt";

export external public type RequestMode = "cors" | "navigate" | "no-cors" | "same-origin";

export external public type RequestRedirect = "error" | "follow" | "manual";

export external public type ResidentKeyRequirement = "discouraged" | "preferred" | "required";

export external public type ResizeObserverBoxOptions = "border-box" | "content-box" | "device-pixel-content-box";

export external public type ResizeQuality = "high" | "low" | "medium" | "pixelated";

export external public type ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect";

export external public type ScrollBehavior = "auto" | "smooth";

export external public type ScrollLogicalPosition = "center" | "end" | "nearest" | "start";

export external public type ScrollRestoration = "auto" | "manual";

export external public type ScrollSetting = "" | "up";

export external public type SecurityPolicyViolationEventDisposition = "enforce" | "report";

export external public type SelectionMode = "end" | "preserve" | "select" | "start";

export external public type ServiceWorkerState = "activated" | "activating" | "installed" | "installing" | "parsed" | "redundant";

export external public type ServiceWorkerUpdateViaCache = "all" | "imports" | "none";

export external public type ShadowRootMode = "closed" | "open";

export external public type SlotAssignmentMode = "manual" | "named";

export external public type SpeechSynthesisErrorCode = "audio-busy" | "audio-hardware" | "canceled" | "interrupted" | "invalid-argument" | "language-unavailable" | "network" | "not-allowed" | "synthesis-failed" | "synthesis-unavailable" | "text-too-long" | "voice-unavailable";

export external public type TextTrackKind = "captions" | "chapters" | "descriptions" | "metadata" | "subtitles";

export external public type TextTrackMode = "disabled" | "hidden" | "showing";

export external public type TouchType = "direct" | "stylus";

export external public type TransferFunction = "hlg" | "pq" | "srgb";

export external public type UserVerificationRequirement = "discouraged" | "preferred" | "required";

export external public type VideoFacingModeEnum = "environment" | "left" | "right" | "user";

export external public type VisibilityState = "hidden" | "visible";

export external public type WebGLPowerPreference = "default" | "high-performance" | "low-power";

export external public type WorkerType = "classic" | "module";

export external public type XMLHttpRequestResponseType = "" | "arraybuffer" | "blob" | "document" | "json" | "text";
