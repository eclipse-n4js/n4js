// generated from https://github.com/microsoft/TypeScript/blob/5d0d7ae85d1ff52d3ef4cb6cac653f33f7e76724/src/lib/dom.generated.d.ts
// (for license information of original file see https://github.com/microsoft/TypeScript/blob/main/LICENSE.txt)

@@Global @@ProvidedByRuntime

export external public interface ~AddEventListenerOptions extends EventListenerOptions {
	once?: boolean;
	passive?: boolean;
	signal?: AbortSignal;
}

export external public interface ~AesCbcParams extends Algorithm {
	iv: BufferSource;
}

export external public interface ~AesCtrParams extends Algorithm {
	counter: BufferSource;
	length: number;
}

export external public interface ~AesDerivedKeyParams extends Algorithm {
	length: number;
}

export external public interface ~AesGcmParams extends Algorithm {
	additionalData?: BufferSource;
	iv: BufferSource;
	tagLength?: number;
}

export external public interface ~AesKeyAlgorithm extends KeyAlgorithm {
	length: number;
}

export external public interface ~AesKeyGenParams extends Algorithm {
	length: number;
}

export external public interface ~Algorithm {
	name: string;
}

export external public interface ~AnalyserOptions extends AudioNodeOptions {
	fftSize?: number;
	maxDecibels?: number;
	minDecibels?: number;
	smoothingTimeConstant?: number;
}

export external public interface ~AnimationEventInit extends EventInit {
	animationName?: string;
	elapsedTime?: number;
	pseudoElement?: string;
}

export external public interface ~AnimationPlaybackEventInit extends EventInit {
	currentTime?: number;
	timelineTime?: number;
}

export external public interface ~AssignedNodesOptions {
	flatten?: boolean;
}

export external public interface ~AudioBufferOptions {
	length: number;
	numberOfChannels?: number;
	sampleRate: number;
}

export external public interface ~AudioBufferSourceOptions {
	buffer?: AudioBuffer;
	detune?: number;
	loop?: boolean;
	loopEnd?: number;
	loopStart?: number;
	playbackRate?: number;
}

export external public interface ~AudioConfiguration {
	bitrate?: number;
	channels?: string;
	contentType: string;
	samplerate?: number;
	spatialRendering?: boolean;
}

export external public interface ~AudioContextOptions {
	latencyHint?: AudioContextLatencyCategory | number;
	sampleRate?: number;
}

export external public interface ~AudioNodeOptions {
	channelCount?: number;
	channelCountMode?: ChannelCountMode;
	channelInterpretation?: ChannelInterpretation;
}

export external public interface ~AudioProcessingEventInit extends EventInit {
	inputBuffer: AudioBuffer;
	outputBuffer: AudioBuffer;
	playbackTime: number;
}

export external public interface ~AudioTimestamp {
	contextTime?: number;
	performanceTime?: DOMHighResTimeStamp;
}

export external public interface ~AudioWorkletNodeOptions extends AudioNodeOptions {
	numberOfInputs?: number;
	numberOfOutputs?: number;
	outputChannelCount?: Array<number>;
	parameterData?: Record<string,number>;
	processorOptions?: any;
}

export external public interface ~AuthenticationExtensionsClientInputs {
	appid?: string;
	appidExclude?: string;
	credProps?: boolean;
	uvm?: boolean;
}

export external public interface ~AuthenticationExtensionsClientOutputs {
	appid?: boolean;
	credProps?: CredentialPropertiesOutput;
	uvm?: UvmEntries;
}

export external public interface ~AuthenticatorSelectionCriteria {
	authenticatorAttachment?: AuthenticatorAttachment;
	requireResidentKey?: boolean;
	residentKey?: ResidentKeyRequirement;
	userVerification?: UserVerificationRequirement;
}

export external public interface ~BiquadFilterOptions extends AudioNodeOptions {
	Q?: number;
	detune?: number;
	frequency?: number;
	gain?: number;
	type?: BiquadFilterType;
}

export external public interface ~BlobEventInit {
	data: Blob;
	timecode?: DOMHighResTimeStamp;
}

export external public interface ~BlobPropertyBag {
	endings?: EndingType;
	type?: string;
}

export external public interface ~CSSStyleSheetInit {
	baseURL?: string;
	disabled?: boolean;
	media?: MediaList | string;
}

export external public interface ~CacheQueryOptions {
	ignoreMethod?: boolean;
	ignoreSearch?: boolean;
	ignoreVary?: boolean;
}

export external public interface ~CanvasRenderingContext2DSettings {
	alpha?: boolean;
	colorSpace?: PredefinedColorSpace;
	desynchronized?: boolean;
	willReadFrequently?: boolean;
}

export external public interface ~ChannelMergerOptions extends AudioNodeOptions {
	numberOfInputs?: number;
}

export external public interface ~ChannelSplitterOptions extends AudioNodeOptions {
	numberOfOutputs?: number;
}

export external public interface ~ClientQueryOptions {
	includeUncontrolled?: boolean;
	type?: ClientTypes;
}

export external public interface ~ClipboardEventInit extends EventInit {
	clipboardData?: DataTransfer;
}

export external public interface ~ClipboardItemOptions {
	presentationStyle?: PresentationStyle;
}

export external public interface ~CloseEventInit extends EventInit {
	code?: number;
	reason?: string;
	wasClean?: boolean;
}

export external public interface ~CompositionEventInit extends UIEventInit {
	data?: string;
}

export external public interface ~ComputedEffectTiming extends EffectTiming {
	activeDuration?: CSSNumberish;
	currentIteration?: number;
	endTime?: CSSNumberish;
	localTime?: CSSNumberish;
	progress?: CSSNumberish;
	startTime?: CSSNumberish;
}

export external public interface ~ComputedKeyframe {
	composite: CompositeOperationOrAuto;
	computedOffset: number;
	easing: string;
	offset: number;
}

export external public interface ~ConstantSourceOptions {
	offset?: number;
}

export external public interface ~ConstrainBooleanParameters {
	exact?: boolean;
	ideal?: boolean;
}

export external public interface ~ConstrainDOMStringParameters {
	exact?: string | Array<string>;
	ideal?: string | Array<string>;
}

export external public interface ~ConstrainDoubleRange extends DoubleRange {
	exact?: number;
	ideal?: number;
}

export external public interface ~ConstrainULongRange extends ULongRange {
	exact?: number;
	ideal?: number;
}

export external public interface ~ConvolverOptions extends AudioNodeOptions {
	buffer?: AudioBuffer;
	disableNormalization?: boolean;
}

export external public interface ~CredentialCreationOptions {
	publicKey?: PublicKeyCredentialCreationOptions;
	signal?: AbortSignal;
}

export external public interface ~CredentialPropertiesOutput {
	rk?: boolean;
}

export external public interface ~CredentialRequestOptions {
	mediation?: CredentialMediationRequirement;
	publicKey?: PublicKeyCredentialRequestOptions;
	signal?: AbortSignal;
}

export external public interface ~CryptoKeyPair {
	privateKey?: CryptoKey;
	publicKey?: CryptoKey;
}

export external public interface ~CustomEventInit<T=any> extends EventInit {
	detail?: T;
}

export external public interface ~DOMMatrix2DInit {
	a?: number;
	b?: number;
	c?: number;
	d?: number;
	e?: number;
	f?: number;
	m11?: number;
	m12?: number;
	m21?: number;
	m22?: number;
	m41?: number;
	m42?: number;
}

export external public interface ~DOMMatrixInit extends DOMMatrix2DInit {
	is2D?: boolean;
	m13?: number;
	m14?: number;
	m23?: number;
	m24?: number;
	m31?: number;
	m32?: number;
	m33?: number;
	m34?: number;
	m43?: number;
	m44?: number;
}

export external public interface ~DOMPointInit {
	w?: number;
	x?: number;
	y?: number;
	z?: number;
}

export external public interface ~DOMQuadInit {
	p1?: DOMPointInit;
	p2?: DOMPointInit;
	p3?: DOMPointInit;
	p4?: DOMPointInit;
}

export external public interface ~DOMRectInit {
	height?: number;
	width?: number;
	x?: number;
	y?: number;
}

export external public interface ~DelayOptions extends AudioNodeOptions {
	delayTime?: number;
	maxDelayTime?: number;
}

export external public interface ~DeviceMotionEventAccelerationInit {
	x?: number;
	y?: number;
	z?: number;
}

export external public interface ~DeviceMotionEventInit extends EventInit {
	acceleration?: DeviceMotionEventAccelerationInit;
	accelerationIncludingGravity?: DeviceMotionEventAccelerationInit;
	interval?: number;
	rotationRate?: DeviceMotionEventRotationRateInit;
}

export external public interface ~DeviceMotionEventRotationRateInit {
	alpha?: number;
	beta?: number;
	gamma?: number;
}

export external public interface ~DeviceOrientationEventInit extends EventInit {
	absolute?: boolean;
	alpha?: number;
	beta?: number;
	gamma?: number;
}

export external public interface ~DisplayMediaStreamConstraints {
	audio?: boolean | MediaTrackConstraints;
	video?: boolean | MediaTrackConstraints;
}

export external public interface ~DocumentTimelineOptions {
	originTime?: DOMHighResTimeStamp;
}

export external public interface ~DoubleRange {
	max?: number;
	min?: number;
}

export external public interface ~DragEventInit extends MouseEventInit {
	dataTransfer?: DataTransfer;
}

export external public interface ~DynamicsCompressorOptions extends AudioNodeOptions {
	attack?: number;
	knee?: number;
	ratio?: number;
	release?: number;
	threshold?: number;
}

export external public interface ~EcKeyAlgorithm extends KeyAlgorithm {
	namedCurve: NamedCurve;
}

export external public interface ~EcKeyGenParams extends Algorithm {
	namedCurve: NamedCurve;
}

export external public interface ~EcKeyImportParams extends Algorithm {
	namedCurve: NamedCurve;
}

export external public interface ~EcdhKeyDeriveParams extends Algorithm {
	public: CryptoKey;
}

export external public interface ~EcdsaParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
}

export external public interface ~EffectTiming {
	delay?: number;
	direction?: PlaybackDirection;
	duration?: number | string;
	easing?: string;
	endDelay?: number;
	fill?: FillMode;
	iterationStart?: number;
	iterations?: number;
	playbackRate?: number;
}

export external public interface ~ElementCreationOptions {
	is?: string;
}

export external public interface ~ElementDefinitionOptions {
	extends?: string;
}

export external public interface ~ErrorEventInit extends EventInit {
	colno?: number;
	error?: any;
	filename?: string;
	lineno?: number;
	message?: string;
}

export external public interface ~EventInit {
	bubbles?: boolean;
	cancelable?: boolean;
	composed?: boolean;
}

export external public interface ~EventListenerOptions {
	capture?: boolean;
}

export external public interface ~EventModifierInit extends UIEventInit {
	altKey?: boolean;
	ctrlKey?: boolean;
	metaKey?: boolean;
	modifierAltGraph?: boolean;
	modifierCapsLock?: boolean;
	modifierFn?: boolean;
	modifierFnLock?: boolean;
	modifierHyper?: boolean;
	modifierNumLock?: boolean;
	modifierScrollLock?: boolean;
	modifierSuper?: boolean;
	modifierSymbol?: boolean;
	modifierSymbolLock?: boolean;
	shiftKey?: boolean;
}

export external public interface ~EventSourceInit {
	withCredentials?: boolean;
}

export external public interface ~FilePropertyBag extends BlobPropertyBag {
	lastModified?: number;
}

export external public interface ~FileSystemFlags {
	create?: boolean;
	exclusive?: boolean;
}

export external public interface ~FocusEventInit extends UIEventInit {
	relatedTarget?: EventTarget;
}

export external public interface ~FocusOptions {
	preventScroll?: boolean;
}

export external public interface ~FontFaceDescriptors {
	display?: string;
	featureSettings?: string;
	stretch?: string;
	style?: string;
	unicodeRange?: string;
	variant?: string;
	weight?: string;
}

export external public interface ~FontFaceSetLoadEventInit extends EventInit {
	fontfaces?: Array<FontFace>;
}

export external public interface ~FormDataEventInit extends EventInit {
	formData: FormData;
}

export external public interface ~FullscreenOptions {
	navigationUI?: FullscreenNavigationUI;
}

export external public interface ~GainOptions extends AudioNodeOptions {
	gain?: number;
}

export external public interface ~GamepadEventInit extends EventInit {
	gamepad: Gamepad;
}

export external public interface ~GetAnimationsOptions {
	subtree?: boolean;
}

export external public interface ~GetNotificationOptions {
	tag?: string;
}

export external public interface ~GetRootNodeOptions {
	composed?: boolean;
}

export external public interface ~HashChangeEventInit extends EventInit {
	newURL?: string;
	oldURL?: string;
}

export external public interface ~HkdfParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
	info: BufferSource;
	salt: BufferSource;
}

export external public interface ~HmacImportParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
	length?: number;
}

export external public interface ~HmacKeyAlgorithm extends KeyAlgorithm {
	hash: KeyAlgorithm;
	length: number;
}

export external public interface ~HmacKeyGenParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
	length?: number;
}

export external public interface ~IDBDatabaseInfo {
	name?: string;
	version?: number;
}

export external public interface ~IDBIndexParameters {
	multiEntry?: boolean;
	unique?: boolean;
}

export external public interface ~IDBObjectStoreParameters {
	autoIncrement?: boolean;
	keyPath?: string | Array<string>;
}

export external public interface ~IDBVersionChangeEventInit extends EventInit {
	newVersion?: number;
	oldVersion?: number;
}

export external public interface ~IIRFilterOptions extends AudioNodeOptions {
	feedback: Array<number>;
	feedforward: Array<number>;
}

export external public interface ~IdleRequestOptions {
	timeout?: number;
}

export external public interface ~ImageBitmapOptions {
	colorSpaceConversion?: ColorSpaceConversion;
	imageOrientation?: ImageOrientation;
	premultiplyAlpha?: PremultiplyAlpha;
	resizeHeight?: number;
	resizeQuality?: ResizeQuality;
	resizeWidth?: number;
}

export external public interface ~ImageBitmapRenderingContextSettings {
	alpha?: boolean;
}

export external public interface ~ImageDataSettings {
	colorSpace?: PredefinedColorSpace;
}

export external public interface ~ImportMeta {
	url: string;
}

export external public interface ~InputEventInit extends UIEventInit {
	data?: string;
	dataTransfer?: DataTransfer;
	inputType?: string;
	isComposing?: boolean;
	targetRanges?: Array<StaticRange>;
}

export external public interface ~IntersectionObserverEntryInit {
	boundingClientRect: DOMRectInit;
	intersectionRatio: number;
	intersectionRect: DOMRectInit;
	isIntersecting: boolean;
	rootBounds: DOMRectInit;
	target: Element;
	time: DOMHighResTimeStamp;
}

export external public interface ~IntersectionObserverInit {
	root?: Element | Document;
	rootMargin?: string;
	threshold?: number | Array<number>;
}

export external public interface ~JsonWebKey {
	alg?: string;
	crv?: string;
	d?: string;
	dp?: string;
	dq?: string;
	e?: string;
	ext?: boolean;
	k?: string;
	key_ops?: Array<string>;
	kty?: string;
	n?: string;
	oth?: Array<RsaOtherPrimesInfo>;
	p?: string;
	q?: string;
	qi?: string;
	use?: string;
	x?: string;
	y?: string;
}

export external public interface ~KeyAlgorithm {
	name: string;
}

export external public interface ~KeyboardEventInit extends EventModifierInit {
	charCode?: number;
	code?: string;
	isComposing?: boolean;
	key?: string;
	keyCode?: number;
	location?: number;
	repeat?: boolean;
}

export external public interface ~Keyframe {
	composite?: CompositeOperationOrAuto;
	easing?: string;
	offset?: number;
}

export external public interface ~KeyframeAnimationOptions extends KeyframeEffectOptions {
	id?: string;
}

export external public interface ~KeyframeEffectOptions extends EffectTiming {
	composite?: CompositeOperation;
	iterationComposite?: IterationCompositeOperation;
	pseudoElement?: string;
}

export external public interface ~MediaCapabilitiesDecodingInfo extends MediaCapabilitiesInfo {
	configuration?: MediaDecodingConfiguration;
}

export external public interface ~MediaCapabilitiesEncodingInfo extends MediaCapabilitiesInfo {
	configuration?: MediaEncodingConfiguration;
}

export external public interface ~MediaCapabilitiesInfo {
	powerEfficient: boolean;
	smooth: boolean;
	supported: boolean;
}

export external public interface ~MediaConfiguration {
	audio?: AudioConfiguration;
	video?: VideoConfiguration;
}

export external public interface ~MediaDecodingConfiguration extends MediaConfiguration {
	type: MediaDecodingType;
}

export external public interface ~MediaElementAudioSourceOptions {
	mediaElement: HTMLMediaElement;
}

export external public interface ~MediaEncodingConfiguration extends MediaConfiguration {
	type: MediaEncodingType;
}

export external public interface ~MediaEncryptedEventInit extends EventInit {
	initData?: ArrayBuffer;
	initDataType?: string;
}

export external public interface ~MediaImage {
	sizes?: string;
	src: string;
	type?: string;
}

export external public interface ~MediaKeyMessageEventInit extends EventInit {
	message: ArrayBuffer;
	messageType: MediaKeyMessageType;
}

export external public interface ~MediaKeySystemConfiguration {
	audioCapabilities?: Array<MediaKeySystemMediaCapability>;
	distinctiveIdentifier?: MediaKeysRequirement;
	initDataTypes?: Array<string>;
	label?: string;
	persistentState?: MediaKeysRequirement;
	sessionTypes?: Array<string>;
	videoCapabilities?: Array<MediaKeySystemMediaCapability>;
}

export external public interface ~MediaKeySystemMediaCapability {
	contentType?: string;
	encryptionScheme?: string;
	robustness?: string;
}

export external public interface ~MediaMetadataInit {
	album?: string;
	artist?: string;
	artwork?: Array<MediaImage>;
	title?: string;
}

export external public interface ~MediaPositionState {
	duration?: number;
	playbackRate?: number;
	position?: number;
}

export external public interface ~MediaQueryListEventInit extends EventInit {
	matches?: boolean;
	media?: string;
}

export external public interface ~MediaRecorderErrorEventInit extends EventInit {
	error: DOMException;
}

export external public interface ~MediaRecorderOptions {
	audioBitsPerSecond?: number;
	bitsPerSecond?: number;
	mimeType?: string;
	videoBitsPerSecond?: number;
}

export external public interface ~MediaSessionActionDetails {
	action: MediaSessionAction;
	fastSeek?: boolean;
	seekOffset?: number;
	seekTime?: number;
}

export external public interface ~MediaStreamAudioSourceOptions {
	mediaStream: MediaStream;
}

export external public interface ~MediaStreamConstraints {
	audio?: boolean | MediaTrackConstraints;
	peerIdentity?: string;
	preferCurrentTab?: boolean;
	video?: boolean | MediaTrackConstraints;
}

export external public interface ~MediaStreamTrackEventInit extends EventInit {
	track: MediaStreamTrack;
}

export external public interface ~MediaTrackCapabilities {
	aspectRatio?: DoubleRange;
	autoGainControl?: Array<boolean>;
	channelCount?: ULongRange;
	cursor?: Array<string>;
	deviceId?: string;
	displaySurface?: string;
	echoCancellation?: Array<boolean>;
	facingMode?: Array<string>;
	frameRate?: DoubleRange;
	groupId?: string;
	height?: ULongRange;
	latency?: DoubleRange;
	logicalSurface?: boolean;
	noiseSuppression?: Array<boolean>;
	resizeMode?: Array<string>;
	sampleRate?: ULongRange;
	sampleSize?: ULongRange;
	width?: ULongRange;
}

export external public interface ~MediaTrackConstraintSet {
	aspectRatio?: ConstrainDouble;
	channelCount?: ConstrainULong;
	deviceId?: ConstrainDOMString;
	echoCancellation?: ConstrainBoolean;
	facingMode?: ConstrainDOMString;
	frameRate?: ConstrainDouble;
	groupId?: ConstrainDOMString;
	height?: ConstrainULong;
	latency?: ConstrainDouble;
	sampleRate?: ConstrainULong;
	sampleSize?: ConstrainULong;
	suppressLocalAudioPlayback?: ConstrainBoolean;
	width?: ConstrainULong;
}

export external public interface ~MediaTrackConstraints extends MediaTrackConstraintSet {
	advanced?: Array<MediaTrackConstraintSet>;
}

export external public interface ~MediaTrackSettings {
	aspectRatio?: number;
	deviceId?: string;
	echoCancellation?: boolean;
	facingMode?: string;
	frameRate?: number;
	groupId?: string;
	height?: number;
	restrictOwnAudio?: boolean;
	sampleRate?: number;
	sampleSize?: number;
	width?: number;
}

export external public interface ~MediaTrackSupportedConstraints {
	aspectRatio?: boolean;
	deviceId?: boolean;
	echoCancellation?: boolean;
	facingMode?: boolean;
	frameRate?: boolean;
	groupId?: boolean;
	height?: boolean;
	sampleRate?: boolean;
	sampleSize?: boolean;
	suppressLocalAudioPlayback?: boolean;
	width?: boolean;
}

export external public interface ~MessageEventInit<T=any> extends EventInit {
	data?: T;
	lastEventId?: string;
	origin?: string;
	ports?: Array<MessagePort>;
	source?: MessageEventSource;
}

export external public interface ~MouseEventInit extends EventModifierInit {
	button?: number;
	buttons?: number;
	clientX?: number;
	clientY?: number;
	movementX?: number;
	movementY?: number;
	relatedTarget?: EventTarget;
	screenX?: number;
	screenY?: number;
}

export external public interface ~MultiCacheQueryOptions extends CacheQueryOptions {
	cacheName?: string;
}

export external public interface ~MutationObserverInit {
	attributeFilter?: Array<string>;
	attributeOldValue?: boolean;
	attributes?: boolean;
	characterData?: boolean;
	characterDataOldValue?: boolean;
	childList?: boolean;
	subtree?: boolean;
}

export external public interface ~NotificationAction {
	action: string;
	icon?: string;
	title: string;
}

export external public interface ~NotificationOptions {
	actions?: Array<NotificationAction>;
	badge?: string;
	body?: string;
	data?: any;
	dir?: NotificationDirection;
	icon?: string;
	image?: string;
	lang?: string;
	renotify?: boolean;
	requireInteraction?: boolean;
	silent?: boolean;
	tag?: string;
	timestamp?: DOMTimeStamp;
	vibrate?: VibratePattern;
}

export external public interface ~OfflineAudioCompletionEventInit extends EventInit {
	renderedBuffer: AudioBuffer;
}

export external public interface ~OfflineAudioContextOptions {
	length: number;
	numberOfChannels?: number;
	sampleRate: number;
}

export external public interface ~OptionalEffectTiming {
	delay?: number;
	direction?: PlaybackDirection;
	duration?: number | string;
	easing?: string;
	endDelay?: number;
	fill?: FillMode;
	iterationStart?: number;
	iterations?: number;
	playbackRate?: number;
}

export external public interface ~OscillatorOptions extends AudioNodeOptions {
	detune?: number;
	frequency?: number;
	periodicWave?: PeriodicWave;
	type?: OscillatorType;
}

export external public interface ~PageTransitionEventInit extends EventInit {
	persisted?: boolean;
}

export external public interface ~PannerOptions extends AudioNodeOptions {
	coneInnerAngle?: number;
	coneOuterAngle?: number;
	coneOuterGain?: number;
	distanceModel?: DistanceModelType;
	maxDistance?: number;
	orientationX?: number;
	orientationY?: number;
	orientationZ?: number;
	panningModel?: PanningModelType;
	positionX?: number;
	positionY?: number;
	positionZ?: number;
	refDistance?: number;
	rolloffFactor?: number;
}

export external public interface ~PaymentCurrencyAmount {
	currency: string;
	value: string;
}

export external public interface ~PaymentDetailsBase {
	displayItems?: Array<PaymentItem>;
	modifiers?: Array<PaymentDetailsModifier>;
}

export external public interface ~PaymentDetailsInit extends PaymentDetailsBase {
	id?: string;
	total: PaymentItem;
}

export external public interface ~PaymentDetailsModifier {
	additionalDisplayItems?: Array<PaymentItem>;
	data?: any;
	supportedMethods: string;
	total?: PaymentItem;
}

export external public interface ~PaymentDetailsUpdate extends PaymentDetailsBase {
	paymentMethodErrors?: any;
	total?: PaymentItem;
}

export external public interface ~PaymentItem {
	amount: PaymentCurrencyAmount;
	label: string;
	pending?: boolean;
}

export external public interface ~PaymentMethodChangeEventInit extends PaymentRequestUpdateEventInit {
	methodDetails?: any;
	methodName?: string;
}

export external public interface ~PaymentMethodData {
	data?: any;
	supportedMethods: string;
}

export external public interface ~PaymentRequestUpdateEventInit extends EventInit {}

export external public interface ~PaymentValidationErrors {
	error?: string;
	paymentMethod?: any;
}

export external public interface ~Pbkdf2Params extends Algorithm {
	hash: HashAlgorithmIdentifier;
	iterations: number;
	salt: BufferSource;
}

export external public interface ~PerformanceMarkOptions {
	detail?: any;
	startTime?: DOMHighResTimeStamp;
}

export external public interface ~PerformanceMeasureOptions {
	detail?: any;
	duration?: DOMHighResTimeStamp;
	end?: string | DOMHighResTimeStamp;
	start?: string | DOMHighResTimeStamp;
}

export external public interface ~PerformanceObserverInit {
	buffered?: boolean;
	entryTypes?: Array<string>;
	type?: string;
}

export external public interface ~PeriodicWaveConstraints {
	disableNormalization?: boolean;
}

export external public interface ~PeriodicWaveOptions extends PeriodicWaveConstraints {
	imag?: Array<number> | Float32Array;
	real?: Array<number> | Float32Array;
}

export external public interface ~PermissionDescriptor {
	name: PermissionName;
}

export external public interface ~PointerEventInit extends MouseEventInit {
	coalescedEvents?: Array<PointerEvent>;
	height?: number;
	isPrimary?: boolean;
	pointerId?: number;
	pointerType?: string;
	predictedEvents?: Array<PointerEvent>;
	pressure?: number;
	tangentialPressure?: number;
	tiltX?: number;
	tiltY?: number;
	twist?: number;
	width?: number;
}

export external public interface ~PopStateEventInit extends EventInit {
	state?: any;
}

export external public interface ~PositionOptions {
	enableHighAccuracy?: boolean;
	maximumAge?: number;
	timeout?: number;
}

export external public interface ~ProgressEventInit extends EventInit {
	lengthComputable?: boolean;
	loaded?: number;
	total?: number;
}

export external public interface ~PromiseRejectionEventInit extends EventInit {
	promise: Promise<any>;
	reason?: any;
}

export external public interface ~PropertyIndexedKeyframes {
	composite?: CompositeOperationOrAuto | Array<CompositeOperationOrAuto>;
	easing?: string | Array<string>;
	offset?: number | Array<number>;
}

export external public interface ~PublicKeyCredentialCreationOptions {
	attestation?: AttestationConveyancePreference;
	authenticatorSelection?: AuthenticatorSelectionCriteria;
	challenge: BufferSource;
	excludeCredentials?: Array<PublicKeyCredentialDescriptor>;
	extensions?: AuthenticationExtensionsClientInputs;
	pubKeyCredParams: Array<PublicKeyCredentialParameters>;
	rp: PublicKeyCredentialRpEntity;
	timeout?: number;
	user: PublicKeyCredentialUserEntity;
}

export external public interface ~PublicKeyCredentialDescriptor {
	id: BufferSource;
	transports?: Array<AuthenticatorTransport>;
	type: PublicKeyCredentialType;
}

export external public interface ~PublicKeyCredentialEntity {
	name: string;
}

export external public interface ~PublicKeyCredentialParameters {
	alg: COSEAlgorithmIdentifier;
	type: PublicKeyCredentialType;
}

export external public interface ~PublicKeyCredentialRequestOptions {
	allowCredentials?: Array<PublicKeyCredentialDescriptor>;
	challenge: BufferSource;
	extensions?: AuthenticationExtensionsClientInputs;
	rpId?: string;
	timeout?: number;
	userVerification?: UserVerificationRequirement;
}

export external public interface ~PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {
	id?: string;
}

export external public interface ~PublicKeyCredentialUserEntity extends PublicKeyCredentialEntity {
	displayName: string;
	id: BufferSource;
}

export external public interface ~PushSubscriptionJSON {
	endpoint?: string;
	expirationTime?: DOMTimeStamp;
	keys?: Record<string,string>;
}

export external public interface ~PushSubscriptionOptionsInit {
	applicationServerKey?: BufferSource | string;
	userVisibleOnly?: boolean;
}

export external public interface ~QueuingStrategy<T=any> {
	highWaterMark?: number;
	size?: QueuingStrategySize<T>;
}

export external public interface ~QueuingStrategyInit {
	highWaterMark: number;
}

export external public interface ~RTCAnswerOptions extends RTCOfferAnswerOptions {}

export external public interface ~RTCCertificateExpiration {
	expires?: DOMTimeStamp;
}

export external public interface ~RTCConfiguration {
	bundlePolicy?: RTCBundlePolicy;
	certificates?: Array<RTCCertificate>;
	iceCandidatePoolSize?: number;
	iceServers?: Array<RTCIceServer>;
	iceTransportPolicy?: RTCIceTransportPolicy;
	rtcpMuxPolicy?: RTCRtcpMuxPolicy;
}

export external public interface ~RTCDTMFToneChangeEventInit extends EventInit {
	tone?: string;
}

export external public interface ~RTCDataChannelEventInit extends EventInit {
	channel: RTCDataChannel;
}

export external public interface ~RTCDataChannelInit {
	id?: number;
	maxPacketLifeTime?: number;
	maxRetransmits?: number;
	negotiated?: boolean;
	ordered?: boolean;
	protocol?: string;
}

export external public interface ~RTCDtlsFingerprint {
	algorithm?: string;
	value?: string;
}

export external public interface ~RTCIceCandidateInit {
	candidate?: string;
	sdpMLineIndex?: number;
	sdpMid?: string;
	usernameFragment?: string;
}

export external public interface ~RTCIceCandidatePairStats extends RTCStats {
	availableIncomingBitrate?: number;
	availableOutgoingBitrate?: number;
	bytesReceived?: number;
	bytesSent?: number;
	currentRoundTripTime?: number;
	localCandidateId: string;
	nominated?: boolean;
	remoteCandidateId: string;
	requestsReceived?: number;
	requestsSent?: number;
	responsesReceived?: number;
	responsesSent?: number;
	state: RTCStatsIceCandidatePairState;
	totalRoundTripTime?: number;
	transportId: string;
}

export external public interface ~RTCIceServer {
	credential?: string;
	credentialType?: RTCIceCredentialType;
	urls: string | Array<string>;
	username?: string;
}

export external public interface ~RTCInboundRtpStreamStats extends RTCReceivedRtpStreamStats {
	firCount?: number;
	framesDecoded?: number;
	nackCount?: number;
	pliCount?: number;
	qpSum?: number;
	remoteId?: string;
}

export external public interface ~RTCLocalSessionDescriptionInit {
	sdp?: string;
	type?: RTCSdpType;
}

export external public interface ~RTCOfferAnswerOptions {}

export external public interface ~RTCOfferOptions extends RTCOfferAnswerOptions {
	iceRestart?: boolean;
	offerToReceiveAudio?: boolean;
	offerToReceiveVideo?: boolean;
}

export external public interface ~RTCOutboundRtpStreamStats extends RTCSentRtpStreamStats {
	firCount?: number;
	framesEncoded?: number;
	nackCount?: number;
	pliCount?: number;
	qpSum?: number;
	remoteId?: string;
}

export external public interface ~RTCPeerConnectionIceErrorEventInit extends EventInit {
	address?: string;
	errorCode: number;
	errorText?: string;
	port?: number;
	url?: string;
}

export external public interface ~RTCPeerConnectionIceEventInit extends EventInit {
	candidate?: RTCIceCandidate;
	url?: string;
}

export external public interface ~RTCReceivedRtpStreamStats extends RTCRtpStreamStats {
	jitter?: number;
	packetsDiscarded?: number;
	packetsLost?: number;
	packetsReceived?: number;
}

export external public interface ~RTCRtcpParameters {
	cname?: string;
	reducedSize?: boolean;
}

export external public interface ~RTCRtpCapabilities {
	codecs: Array<RTCRtpCodecCapability>;
	headerExtensions: Array<RTCRtpHeaderExtensionCapability>;
}

export external public interface ~RTCRtpCodecCapability {
	channels?: number;
	clockRate: number;
	mimeType: string;
	sdpFmtpLine?: string;
}

export external public interface ~RTCRtpCodecParameters {
	channels?: number;
	clockRate: number;
	mimeType: string;
	payloadType: number;
	sdpFmtpLine?: string;
}

export external public interface ~RTCRtpCodingParameters {
	rid?: string;
}

export external public interface ~RTCRtpContributingSource {
	audioLevel?: number;
	rtpTimestamp: number;
	source: number;
	timestamp: DOMHighResTimeStamp;
}

export external public interface ~RTCRtpEncodingParameters extends RTCRtpCodingParameters {
	active?: boolean;
	maxBitrate?: number;
	priority?: RTCPriorityType;
	scaleResolutionDownBy?: number;
}

export external public interface ~RTCRtpHeaderExtensionCapability {
	uri?: string;
}

export external public interface ~RTCRtpHeaderExtensionParameters {
	encrypted?: boolean;
	id: number;
	uri: string;
}

export external public interface ~RTCRtpParameters {
	codecs: Array<RTCRtpCodecParameters>;
	headerExtensions: Array<RTCRtpHeaderExtensionParameters>;
	rtcp: RTCRtcpParameters;
}

export external public interface ~RTCRtpReceiveParameters extends RTCRtpParameters {}

export external public interface ~RTCRtpSendParameters extends RTCRtpParameters {
	degradationPreference?: RTCDegradationPreference;
	encodings: Array<RTCRtpEncodingParameters>;
	transactionId: string;
}

export external public interface ~RTCRtpStreamStats extends RTCStats {
	codecId?: string;
	kind: string;
	ssrc: number;
	transportId?: string;
}

export external public interface ~RTCRtpSynchronizationSource extends RTCRtpContributingSource {}

export external public interface ~RTCRtpTransceiverInit {
	direction?: RTCRtpTransceiverDirection;
	sendEncodings?: Array<RTCRtpEncodingParameters>;
	streams?: Array<MediaStream>;
}

export external public interface ~RTCSentRtpStreamStats extends RTCRtpStreamStats {
	bytesSent?: number;
	packetsSent?: number;
}

export external public interface ~RTCSessionDescriptionInit {
	sdp?: string;
	type: RTCSdpType;
}

export external public interface ~RTCStats {
	id: string;
	timestamp: DOMHighResTimeStamp;
	type: RTCStatsType;
}

export external public interface ~RTCTrackEventInit extends EventInit {
	receiver: RTCRtpReceiver;
	streams?: Array<MediaStream>;
	track: MediaStreamTrack;
	transceiver: RTCRtpTransceiver;
}

export external public interface ~RTCTransportStats extends RTCStats {
	bytesReceived?: number;
	bytesSent?: number;
	dtlsCipher?: string;
	dtlsState: RTCDtlsTransportState;
	localCertificateId?: string;
	remoteCertificateId?: string;
	rtcpTransportStatsId?: string;
	selectedCandidatePairId?: string;
	srtpCipher?: string;
	tlsVersion?: string;
}

export external public interface ~ReadableStreamDefaultReadDoneResult {
	done: true;
	value?: undefined;
}

export external public interface ~ReadableStreamDefaultReadValueResult<T> {
	done: false;
	value: T;
}

export external public interface ~ReadableWritablePair<R=any,W=any> {
	readable: ReadableStream<R>;
	writable: WritableStream<W>;
}

export external public interface ~RegistrationOptions {
	scope?: string;
	type?: WorkerType;
	updateViaCache?: ServiceWorkerUpdateViaCache;
}

export external public interface ~RequestInit {
	body?: BodyInit;
	cache?: RequestCache;
	credentials?: RequestCredentials;
	headers?: HeadersInit;
	integrity?: string;
	keepalive?: boolean;
	method?: string;
	mode?: RequestMode;
	redirect?: RequestRedirect;
	referrer?: string;
	referrerPolicy?: ReferrerPolicy;
	signal?: AbortSignal;
	window?: any;
}

export external public interface ~ResizeObserverOptions {
	box?: ResizeObserverBoxOptions;
}

export external public interface ~ResponseInit {
	headers?: HeadersInit;
	status?: number;
	statusText?: string;
}

export external public interface ~RsaHashedImportParams extends Algorithm {
	hash: HashAlgorithmIdentifier;
}

export external public interface ~RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {
	hash: KeyAlgorithm;
}

export external public interface ~RsaHashedKeyGenParams extends RsaKeyGenParams {
	hash: HashAlgorithmIdentifier;
}

export external public interface ~RsaKeyAlgorithm extends KeyAlgorithm {
	modulusLength: number;
	publicExponent: BigInteger;
}

export external public interface ~RsaKeyGenParams extends Algorithm {
	modulusLength: number;
	publicExponent: BigInteger;
}

export external public interface ~RsaOaepParams extends Algorithm {
	label?: BufferSource;
}

export external public interface ~RsaOtherPrimesInfo {
	d?: string;
	r?: string;
	t?: string;
}

export external public interface ~RsaPssParams extends Algorithm {
	saltLength: number;
}

export external public interface ~SVGBoundingBoxOptions {
	clipped?: boolean;
	fill?: boolean;
	markers?: boolean;
	stroke?: boolean;
}

export external public interface ~ScrollIntoViewOptions extends ScrollOptions {
	block?: ScrollLogicalPosition;
	inline?: ScrollLogicalPosition;
}

export external public interface ~ScrollOptions {
	behavior?: ScrollBehavior;
}

export external public interface ~ScrollToOptions extends ScrollOptions {
	left?: number;
	top?: number;
}

export external public interface ~SecurityPolicyViolationEventInit extends EventInit {
	blockedURI?: string;
	columnNumber?: number;
	disposition: SecurityPolicyViolationEventDisposition;
	documentURI: string;
	effectiveDirective: string;
	lineNumber?: number;
	originalPolicy: string;
	referrer?: string;
	sample?: string;
	sourceFile?: string;
	statusCode: number;
	violatedDirective: string;
}

export external public interface ~ShadowRootInit {
	delegatesFocus?: boolean;
	mode: ShadowRootMode;
	slotAssignment?: SlotAssignmentMode;
}

export external public interface ~ShareData {
	files?: Array<File>;
	text?: string;
	title?: string;
	url?: string;
}

export external public interface ~SpeechSynthesisErrorEventInit extends SpeechSynthesisEventInit {
	error: SpeechSynthesisErrorCode;
}

export external public interface ~SpeechSynthesisEventInit extends EventInit {
	charIndex?: number;
	charLength?: number;
	elapsedTime?: number;
	name?: string;
	utterance: SpeechSynthesisUtterance;
}

export external public interface ~StaticRangeInit {
	endContainer: Node;
	endOffset: number;
	startContainer: Node;
	startOffset: number;
}

export external public interface ~StereoPannerOptions extends AudioNodeOptions {
	pan?: number;
}

export external public interface ~StorageEstimate {
	quota?: number;
	usage?: number;
}

export external public interface ~StorageEventInit extends EventInit {
	key?: string;
	newValue?: string;
	oldValue?: string;
	storageArea?: Storage;
	url?: string;
}

export external public interface ~StreamPipeOptions {
	preventAbort?: boolean;
	preventCancel?: boolean;
	preventClose?: boolean;
	signal?: AbortSignal;
}

export external public interface ~StructuredSerializeOptions {
	transfer?: Array<any>;
}

export external public interface ~SubmitEventInit extends EventInit {
	submitter?: HTMLElement;
}

export external public interface ~TextDecodeOptions {
	stream?: boolean;
}

export external public interface ~TextDecoderOptions {
	fatal?: boolean;
	ignoreBOM?: boolean;
}

export external public interface ~TextEncoderEncodeIntoResult {
	read?: number;
	written?: number;
}

export external public interface ~TouchEventInit extends EventModifierInit {
	changedTouches?: Array<Touch>;
	targetTouches?: Array<Touch>;
	touches?: Array<Touch>;
}

export external public interface ~TouchInit {
	altitudeAngle?: number;
	azimuthAngle?: number;
	clientX?: number;
	clientY?: number;
	force?: number;
	identifier: number;
	pageX?: number;
	pageY?: number;
	radiusX?: number;
	radiusY?: number;
	rotationAngle?: number;
	screenX?: number;
	screenY?: number;
	target: EventTarget;
	touchType?: TouchType;
}

export external public interface ~TrackEventInit extends EventInit {
	track?: TextTrack;
}

export external public interface ~Transformer<I=any,O=any> {
	flush?: TransformerFlushCallback<O>;
	readableType?: undefined;
	start?: TransformerStartCallback<O>;
	transform?: TransformerTransformCallback<I,O>;
	writableType?: undefined;
}

export external public interface ~TransitionEventInit extends EventInit {
	elapsedTime?: number;
	propertyName?: string;
	pseudoElement?: string;
}

export external public interface ~UIEventInit extends EventInit {
	detail?: number;
	view?: Window;
	which?: number;
}

export external public interface ~ULongRange {
	max?: number;
	min?: number;
}

export external public interface ~UnderlyingSink<W=any> {
	abort?: UnderlyingSinkAbortCallback;
	close?: UnderlyingSinkCloseCallback;
	start?: UnderlyingSinkStartCallback;
	type?: undefined;
	write?: UnderlyingSinkWriteCallback<W>;
}

export external public interface ~UnderlyingSource<R=any> {
	cancel?: UnderlyingSourceCancelCallback;
	pull?: UnderlyingSourcePullCallback<R>;
	start?: UnderlyingSourceStartCallback<R>;
	type?: undefined;
}

export external public interface ~VideoConfiguration {
	bitrate: number;
	colorGamut?: ColorGamut;
	contentType: string;
	framerate: number;
	hdrMetadataType?: HdrMetadataType;
	height: number;
	scalabilityMode?: string;
	transferFunction?: TransferFunction;
	width: number;
}

export external public interface ~WaveShaperOptions extends AudioNodeOptions {
	curve?: Array<number> | Float32Array;
	oversample?: OverSampleType;
}

export external public interface ~WebGLContextAttributes {
	alpha?: boolean;
	antialias?: boolean;
	depth?: boolean;
	desynchronized?: boolean;
	failIfMajorPerformanceCaveat?: boolean;
	powerPreference?: WebGLPowerPreference;
	premultipliedAlpha?: boolean;
	preserveDrawingBuffer?: boolean;
	stencil?: boolean;
}

export external public interface ~WebGLContextEventInit extends EventInit {
	statusMessage?: string;
}

export external public interface ~WheelEventInit extends MouseEventInit {
	deltaMode?: number;
	deltaX?: number;
	deltaY?: number;
	deltaZ?: number;
}

export external public interface ~WindowPostMessageOptions extends StructuredSerializeOptions {
	targetOrigin?: string;
}

export external public interface ~WorkerOptions {
	credentials?: RequestCredentials;
	name?: string;
	type?: WorkerType;
}

export external public interface ~WorkletOptions {
	credentials?: RequestCredentials;
}

export external public type NodeFilter = ((node: Node)=>number) | ~Object with { acceptNode(node: Node): number; };

var NodeFilter: ~Object with { get FILTER_ACCEPT(): number; get FILTER_REJECT(): number; get FILTER_SKIP(): number; get SHOW_ALL(): number; get SHOW_ATTRIBUTE(): number; get SHOW_CDATA_SECTION(): number; get SHOW_COMMENT(): number; get SHOW_DOCUMENT(): number; get SHOW_DOCUMENT_FRAGMENT(): number; get SHOW_DOCUMENT_TYPE(): number; get SHOW_ELEMENT(): number; get SHOW_ENTITY(): number; get SHOW_ENTITY_REFERENCE(): number; get SHOW_NOTATION(): number; get SHOW_PROCESSING_INSTRUCTION(): number; get SHOW_TEXT(): number; };

export external public type XPathNSResolver = ((prefix: string)=>string) | ~Object with { lookupNamespaceURI(prefix: string): string; };

export external public interface ~ANGLE_instanced_arrays {
	drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei): void;
	drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, primcount: GLsizei): void;
	vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint): void;
	get VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE(): GLenum;
}

export external public interface ~ARIAMixin {
	ariaAtomic: string;
	ariaAutoComplete: string;
	ariaBusy: string;
	ariaChecked: string;
	ariaColCount: string;
	ariaColIndex: string;
	ariaColSpan: string;
	ariaCurrent: string;
	ariaDisabled: string;
	ariaExpanded: string;
	ariaHasPopup: string;
	ariaHidden: string;
	ariaKeyShortcuts: string;
	ariaLabel: string;
	ariaLevel: string;
	ariaLive: string;
	ariaModal: string;
	ariaMultiLine: string;
	ariaMultiSelectable: string;
	ariaOrientation: string;
	ariaPlaceholder: string;
	ariaPosInSet: string;
	ariaPressed: string;
	ariaReadOnly: string;
	ariaRequired: string;
	ariaRoleDescription: string;
	ariaRowCount: string;
	ariaRowIndex: string;
	ariaRowSpan: string;
	ariaSelected: string;
	ariaSetSize: string;
	ariaSort: string;
	ariaValueMax: string;
	ariaValueMin: string;
	ariaValueNow: string;
	ariaValueText: string;
}

export external public interface ~AbortController {
	get signal(): AbortSignal;
	abort(): void;
}

var AbortController: ~Object with { constructor(); };

export external public interface ~AbortSignalEventMap {
	abort: Event;
}

export external public interface ~AbortSignal extends EventTarget {
	get aborted(): boolean;
	onabort: ({@This(AbortSignal) function(ev: Event): any});
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var AbortSignal: ~Object with { constructor(); };

export external public interface ~AbstractRange {
	get collapsed(): boolean;
	get endContainer(): Node;
	get endOffset(): number;
	get startContainer(): Node;
	get startOffset(): number;
}

var AbstractRange: ~Object with { constructor(); };

export external public interface ~AbstractWorkerEventMap {
	error: ErrorEvent;
}

export external public interface ~AbstractWorker {
	onerror: ({@This(AbstractWorker) function(ev: ErrorEvent): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~AnalyserNode extends AudioNode {
	fftSize: number;
	get frequencyBinCount(): number;
	maxDecibels: number;
	minDecibels: number;
	smoothingTimeConstant: number;
	getByteFrequencyData(array: Uint8Array): void;
	getByteTimeDomainData(array: Uint8Array): void;
	getFloatFrequencyData(array: Float32Array): void;
	getFloatTimeDomainData(array: Float32Array): void;
}

var AnalyserNode: ~Object with { constructor(context: BaseAudioContext, options: AnalyserOptions = ); };

export external public interface ~Animatable {
	animate(keyframes: Array<Keyframe> | PropertyIndexedKeyframes, options: number | KeyframeAnimationOptions = ): Animation;
	getAnimations(options: GetAnimationsOptions = ): Array<Animation>;
}

export external public interface ~AnimationEventMap {
	cancel: AnimationPlaybackEvent;
	finish: AnimationPlaybackEvent;
	remove: Event;
}

export external public interface ~Animation extends EventTarget {
	currentTime: number;
	effect: AnimationEffect;
	get finished(): Promise<Animation>;
	id: string;
	oncancel: ({@This(Animation) function(ev: AnimationPlaybackEvent): any});
	onfinish: ({@This(Animation) function(ev: AnimationPlaybackEvent): any});
	onremove: ({@This(Animation) function(ev: Event): any});
	get pending(): boolean;
	get playState(): AnimationPlayState;
	playbackRate: number;
	get ready(): Promise<Animation>;
	get replaceState(): AnimationReplaceState;
	startTime: number;
	timeline: AnimationTimeline;
	cancel(): void;
	commitStyles(): void;
	finish(): void;
	pause(): void;
	persist(): void;
	play(): void;
	reverse(): void;
	updatePlaybackRate(playbackRate: number): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var Animation: ~Object with { constructor(effect: AnimationEffect = , timeline: AnimationTimeline = ); };

export external public interface ~AnimationEffect {
	getComputedTiming(): ComputedEffectTiming;
	getTiming(): EffectTiming;
	updateTiming(timing: OptionalEffectTiming = ): void;
}

var AnimationEffect: ~Object with { constructor(); };

export external public interface ~AnimationEvent extends Event {
	get animationName(): string;
	get elapsedTime(): number;
	get pseudoElement(): string;
}

var AnimationEvent: ~Object with { constructor(type: string, animationEventInitDict: AnimationEventInit = ); };

export external public interface ~AnimationFrameProvider {
	cancelAnimationFrame(handle: number): void;
	requestAnimationFrame(callback: FrameRequestCallback): number;
}

export external public interface ~AnimationPlaybackEvent extends Event {
	get currentTime(): number;
	get timelineTime(): number;
}

var AnimationPlaybackEvent: ~Object with { constructor(type: string, eventInitDict: AnimationPlaybackEventInit = ); };

export external public interface ~AnimationTimeline {
	get currentTime(): number;
}

var AnimationTimeline: ~Object with { constructor(); };

export external public interface ~Attr extends Node {
	get localName(): string;
	get name(): string;
	get namespaceURI(): string;
	@Override
	get ownerDocument(): Document;
	get ownerElement(): Element;
	get prefix(): string;
	get specified(): boolean;
	value: string;
}

var Attr: ~Object with { constructor(); };

export external public interface ~AudioBuffer {
	get duration(): number;
	get length(): number;
	get numberOfChannels(): number;
	get sampleRate(): number;
	copyFromChannel(destination: Float32Array, channelNumber: number, bufferOffset: number = ): void;
	copyToChannel(source: Float32Array, channelNumber: number, bufferOffset: number = ): void;
	getChannelData(channel: number): Float32Array;
}

var AudioBuffer: ~Object with { constructor(options: AudioBufferOptions); };

export external public interface ~AudioBufferSourceNode extends AudioScheduledSourceNode {
	buffer: AudioBuffer;
	get detune(): AudioParam;
	loop: boolean;
	loopEnd: number;
	loopStart: number;
	get playbackRate(): AudioParam;
	@Override
	start(when: number = , offset: number = , duration: number = ): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var AudioBufferSourceNode: ~Object with { constructor(context: BaseAudioContext, options: AudioBufferSourceOptions = ); };

export external public interface ~AudioContext extends BaseAudioContext {
	get baseLatency(): number;
	close(): Promise<undefined>;
	createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode;
	createMediaStreamDestination(): MediaStreamAudioDestinationNode;
	createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode;
	getOutputTimestamp(): AudioTimestamp;
	resume(): Promise<undefined>;
	suspend(): Promise<undefined>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var AudioContext: ~Object with { constructor(contextOptions: AudioContextOptions = ); };

export external public interface ~AudioDestinationNode extends AudioNode {
	get maxChannelCount(): number;
}

var AudioDestinationNode: ~Object with { constructor(); };

export external public interface ~AudioListener {
	get forwardX(): AudioParam;
	get forwardY(): AudioParam;
	get forwardZ(): AudioParam;
	get positionX(): AudioParam;
	get positionY(): AudioParam;
	get positionZ(): AudioParam;
	get upX(): AudioParam;
	get upY(): AudioParam;
	get upZ(): AudioParam;
	setOrientation(x: number, y: number, z: number, xUp: number, yUp: number, zUp: number): void;
	setPosition(x: number, y: number, z: number): void;
}

var AudioListener: ~Object with { constructor(); };

export external public interface ~AudioNode extends EventTarget {
	channelCount: number;
	channelCountMode: ChannelCountMode;
	channelInterpretation: ChannelInterpretation;
	get context(): BaseAudioContext;
	get numberOfInputs(): number;
	get numberOfOutputs(): number;
	connect(...args: any+): any+; // overloading not supported
	disconnect(...args: any+): any+; // overloading not supported
}

var AudioNode: ~Object with { constructor(); };

export external public interface ~AudioParam {
	automationRate: AutomationRate;
	get defaultValue(): number;
	get maxValue(): number;
	get minValue(): number;
	value: number;
	cancelAndHoldAtTime(cancelTime: number): AudioParam;
	cancelScheduledValues(cancelTime: number): AudioParam;
	exponentialRampToValueAtTime(value: number, endTime: number): AudioParam;
	linearRampToValueAtTime(value: number, endTime: number): AudioParam;
	setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam;
	setValueAtTime(value: number, startTime: number): AudioParam;
	setValueCurveAtTime(values: Array<number> | Float32Array, startTime: number, duration: number): AudioParam;
}

var AudioParam: ~Object with { constructor(); };

export external public interface ~AudioParamMap {
	forEach(callbackfn: (value: AudioParam, key: string, parent: AudioParamMap)=>void, thisArg: any = ): void;
}

var AudioParamMap: ~Object with { constructor(); };

export external public interface ~AudioProcessingEvent extends Event {
	get inputBuffer(): AudioBuffer;
	get outputBuffer(): AudioBuffer;
	get playbackTime(): number;
}

var AudioProcessingEvent: ~Object with { constructor(type: string, eventInitDict: AudioProcessingEventInit); };

export external public interface ~AudioScheduledSourceNodeEventMap {
	ended: Event;
}

export external public interface ~AudioScheduledSourceNode extends AudioNode {
	onended: ({@This(AudioScheduledSourceNode) function(ev: Event): any});
	start(when: number = ): void;
	stop(when: number = ): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var AudioScheduledSourceNode: ~Object with { constructor(); };

export external public interface ~AudioWorklet extends Worklet {}

var AudioWorklet: ~Object with { constructor(); };

export external public interface ~AudioWorkletNodeEventMap {
	processorerror: Event;
}

export external public interface ~AudioWorkletNode extends AudioNode {
	onprocessorerror: ({@This(AudioWorkletNode) function(ev: Event): any});
	get parameters(): AudioParamMap;
	get port(): MessagePort;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var AudioWorkletNode: ~Object with { constructor(context: BaseAudioContext, name: string, options: AudioWorkletNodeOptions = ); };

export external public interface ~AuthenticatorAssertionResponse extends AuthenticatorResponse {
	get authenticatorData(): ArrayBuffer;
	get signature(): ArrayBuffer;
	get userHandle(): ArrayBuffer;
}

var AuthenticatorAssertionResponse: ~Object with { constructor(); };

export external public interface ~AuthenticatorAttestationResponse extends AuthenticatorResponse {
	get attestationObject(): ArrayBuffer;
}

var AuthenticatorAttestationResponse: ~Object with { constructor(); };

export external public interface ~AuthenticatorResponse {
	get clientDataJSON(): ArrayBuffer;
}

var AuthenticatorResponse: ~Object with { constructor(); };

export external public interface ~BarProp {
	get visible(): boolean;
}

var BarProp: ~Object with { constructor(); };

export external public interface ~BaseAudioContextEventMap {
	statechange: Event;
}

export external public interface ~BaseAudioContext extends EventTarget {
	get audioWorklet(): AudioWorklet;
	get currentTime(): number;
	get destination(): AudioDestinationNode;
	get listener(): AudioListener;
	onstatechange: ({@This(BaseAudioContext) function(ev: Event): any});
	get sampleRate(): number;
	get state(): AudioContextState;
	createAnalyser(): AnalyserNode;
	createBiquadFilter(): BiquadFilterNode;
	createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;
	createBufferSource(): AudioBufferSourceNode;
	createChannelMerger(numberOfInputs: number = ): ChannelMergerNode;
	createChannelSplitter(numberOfOutputs: number = ): ChannelSplitterNode;
	createConstantSource(): ConstantSourceNode;
	createConvolver(): ConvolverNode;
	createDelay(maxDelayTime: number = ): DelayNode;
	createDynamicsCompressor(): DynamicsCompressorNode;
	createGain(): GainNode;
	createIIRFilter(feedforward: Array<number>, feedback: Array<number>): IIRFilterNode;
	createOscillator(): OscillatorNode;
	createPanner(): PannerNode;
	createPeriodicWave(real: Array<number> | Float32Array, imag: Array<number> | Float32Array, constraints: PeriodicWaveConstraints = ): PeriodicWave;
	createScriptProcessor(bufferSize: number = , numberOfInputChannels: number = , numberOfOutputChannels: number = ): ScriptProcessorNode;
	createStereoPanner(): StereoPannerNode;
	createWaveShaper(): WaveShaperNode;
	decodeAudioData(audioData: ArrayBuffer, successCallback: DecodeSuccessCallback = , errorCallback: DecodeErrorCallback = ): Promise<AudioBuffer>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var BaseAudioContext: ~Object with { constructor(); };

export external public interface ~BeforeUnloadEvent extends Event {
	returnValue: any;
}

var BeforeUnloadEvent: ~Object with { constructor(); };

export external public interface ~BiquadFilterNode extends AudioNode {
	get Q(): AudioParam;
	get detune(): AudioParam;
	get frequency(): AudioParam;
	get gain(): AudioParam;
	type: BiquadFilterType;
	getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
}

var BiquadFilterNode: ~Object with { constructor(context: BaseAudioContext, options: BiquadFilterOptions = ); };

export external public interface ~Blob {
	get size(): number;
	get type(): string;
	arrayBuffer(): Promise<ArrayBuffer>;
	slice(start: number = , end: number = , contentType: string = ): Blob;
	stream(): ReadableStream;
	text(): Promise<string>;
}

var Blob: ~Object with { constructor(blobParts: Array<BlobPart> = , options: BlobPropertyBag = ); };

export external public interface ~BlobEvent extends Event {
	get data(): Blob;
	get timecode(): DOMHighResTimeStamp;
}

var BlobEvent: ~Object with { constructor(type: string, eventInitDict: BlobEventInit); };

export external public interface ~Body {
	get body(): ReadableStream<Uint8Array>;
	get bodyUsed(): boolean;
	arrayBuffer(): Promise<ArrayBuffer>;
	blob(): Promise<Blob>;
	formData(): Promise<FormData>;
	json(): Promise<any>;
	text(): Promise<string>;
}

export external public interface ~BroadcastChannelEventMap {
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public interface ~BroadcastChannel extends EventTarget {
	get name(): string;
	onmessage: ({@This(BroadcastChannel) function(ev: MessageEvent): any});
	onmessageerror: ({@This(BroadcastChannel) function(ev: MessageEvent): any});
	close(): void;
	postMessage(message: any): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var BroadcastChannel: ~Object with { constructor(name: string); };

export external public interface ~ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView> {
	get highWaterMark(): number;
	get size(): QueuingStrategySize<ArrayBufferView>;
}

var ByteLengthQueuingStrategy: ~Object with { constructor(init: QueuingStrategyInit); };

export external public interface ~CDATASection extends Text {}

var CDATASection: ~Object with { constructor(); };

export external public interface ~CSSAnimation extends Animation {
	get animationName(): string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var CSSAnimation: ~Object with { constructor(); };

export external public interface ~CSSConditionRule extends CSSGroupingRule {
	conditionText: string;
}

var CSSConditionRule: ~Object with { constructor(); };

export external public interface ~CSSCounterStyleRule extends CSSRule {
	additiveSymbols: string;
	fallback: string;
	name: string;
	negative: string;
	pad: string;
	prefix: string;
	range: string;
	speakAs: string;
	suffix: string;
	symbols: string;
	system: string;
}

var CSSCounterStyleRule: ~Object with { constructor(); };

export external public interface ~CSSFontFaceRule extends CSSRule {
	get style(): CSSStyleDeclaration;
}

var CSSFontFaceRule: ~Object with { constructor(); };

export external public interface ~CSSGroupingRule extends CSSRule {
	get cssRules(): CSSRuleList;
	deleteRule(index: number): void;
	insertRule(rule: string, index: number = ): number;
}

var CSSGroupingRule: ~Object with { constructor(); };

export external public interface ~CSSImportRule extends CSSRule {
	get href(): string;
	get media(): MediaList;
	get styleSheet(): CSSStyleSheet;
}

var CSSImportRule: ~Object with { constructor(); };

export external public interface ~CSSKeyframeRule extends CSSRule {
	keyText: string;
	get style(): CSSStyleDeclaration;
}

var CSSKeyframeRule: ~Object with { constructor(); };

export external public interface ~CSSKeyframesRule extends CSSRule {
	get cssRules(): CSSRuleList;
	name: string;
	appendRule(rule: string): void;
	deleteRule(select: string): void;
	findRule(select: string): CSSKeyframeRule;
}

var CSSKeyframesRule: ~Object with { constructor(); };

export external public interface ~CSSMediaRule extends CSSConditionRule {
	get media(): MediaList;
}

var CSSMediaRule: ~Object with { constructor(); };

export external public interface ~CSSNamespaceRule extends CSSRule {
	get namespaceURI(): string;
	get prefix(): string;
}

var CSSNamespaceRule: ~Object with { constructor(); };

export external public interface ~CSSPageRule extends CSSGroupingRule {
	selectorText: string;
	get style(): CSSStyleDeclaration;
}

var CSSPageRule: ~Object with { constructor(); };

export external public interface ~CSSRule {
	cssText: string;
	get parentRule(): CSSRule;
	get parentStyleSheet(): CSSStyleSheet;
	get type(): number;
	get CHARSET_RULE(): number;
	get FONT_FACE_RULE(): number;
	get IMPORT_RULE(): number;
	get KEYFRAMES_RULE(): number;
	get KEYFRAME_RULE(): number;
	get MEDIA_RULE(): number;
	get NAMESPACE_RULE(): number;
	get PAGE_RULE(): number;
	get STYLE_RULE(): number;
	get SUPPORTS_RULE(): number;
}

var CSSRule: ~Object with { constructor(); get CHARSET_RULE(): number; get FONT_FACE_RULE(): number; get IMPORT_RULE(): number; get KEYFRAMES_RULE(): number; get KEYFRAME_RULE(): number; get MEDIA_RULE(): number; get NAMESPACE_RULE(): number; get PAGE_RULE(): number; get STYLE_RULE(): number; get SUPPORTS_RULE(): number; };

export external public interface ~CSSRuleList {
	get length(): number;
	item(index: number): CSSRule;
}

var CSSRuleList: ~Object with { constructor(); };

export external public interface ~CSSStyleDeclaration {
	alignContent: string;
	alignItems: string;
	alignSelf: string;
	alignmentBaseline: string;
	all: string;
	animation: string;
	animationDelay: string;
	animationDirection: string;
	animationDuration: string;
	animationFillMode: string;
	animationIterationCount: string;
	animationName: string;
	animationPlayState: string;
	animationTimingFunction: string;
	appearance: string;
	aspectRatio: string;
	backfaceVisibility: string;
	background: string;
	backgroundAttachment: string;
	backgroundBlendMode: string;
	backgroundClip: string;
	backgroundColor: string;
	backgroundImage: string;
	backgroundOrigin: string;
	backgroundPosition: string;
	backgroundPositionX: string;
	backgroundPositionY: string;
	backgroundRepeat: string;
	backgroundSize: string;
	baselineShift: string;
	blockSize: string;
	border: string;
	borderBlock: string;
	borderBlockColor: string;
	borderBlockEnd: string;
	borderBlockEndColor: string;
	borderBlockEndStyle: string;
	borderBlockEndWidth: string;
	borderBlockStart: string;
	borderBlockStartColor: string;
	borderBlockStartStyle: string;
	borderBlockStartWidth: string;
	borderBlockStyle: string;
	borderBlockWidth: string;
	borderBottom: string;
	borderBottomColor: string;
	borderBottomLeftRadius: string;
	borderBottomRightRadius: string;
	borderBottomStyle: string;
	borderBottomWidth: string;
	borderCollapse: string;
	borderColor: string;
	borderEndEndRadius: string;
	borderEndStartRadius: string;
	borderImage: string;
	borderImageOutset: string;
	borderImageRepeat: string;
	borderImageSlice: string;
	borderImageSource: string;
	borderImageWidth: string;
	borderInline: string;
	borderInlineColor: string;
	borderInlineEnd: string;
	borderInlineEndColor: string;
	borderInlineEndStyle: string;
	borderInlineEndWidth: string;
	borderInlineStart: string;
	borderInlineStartColor: string;
	borderInlineStartStyle: string;
	borderInlineStartWidth: string;
	borderInlineStyle: string;
	borderInlineWidth: string;
	borderLeft: string;
	borderLeftColor: string;
	borderLeftStyle: string;
	borderLeftWidth: string;
	borderRadius: string;
	borderRight: string;
	borderRightColor: string;
	borderRightStyle: string;
	borderRightWidth: string;
	borderSpacing: string;
	borderStartEndRadius: string;
	borderStartStartRadius: string;
	borderStyle: string;
	borderTop: string;
	borderTopColor: string;
	borderTopLeftRadius: string;
	borderTopRightRadius: string;
	borderTopStyle: string;
	borderTopWidth: string;
	borderWidth: string;
	bottom: string;
	boxShadow: string;
	boxSizing: string;
	breakAfter: string;
	breakBefore: string;
	breakInside: string;
	captionSide: string;
	caretColor: string;
	clear: string;
	clip: string;
	clipPath: string;
	clipRule: string;
	color: string;
	colorInterpolation: string;
	colorInterpolationFilters: string;
	colorScheme: string;
	columnCount: string;
	columnFill: string;
	columnGap: string;
	columnRule: string;
	columnRuleColor: string;
	columnRuleStyle: string;
	columnRuleWidth: string;
	columnSpan: string;
	columnWidth: string;
	columns: string;
	contain: string;
	content: string;
	counterIncrement: string;
	counterReset: string;
	counterSet: string;
	cssFloat: string;
	cssText: string;
	cursor: string;
	direction: string;
	display: string;
	dominantBaseline: string;
	emptyCells: string;
	fill: string;
	fillOpacity: string;
	fillRule: string;
	filter: string;
	flex: string;
	flexBasis: string;
	flexDirection: string;
	flexFlow: string;
	flexGrow: string;
	flexShrink: string;
	flexWrap: string;
	float: string;
	floodColor: string;
	floodOpacity: string;
	font: string;
	fontFamily: string;
	fontFeatureSettings: string;
	fontKerning: string;
	fontOpticalSizing: string;
	fontSize: string;
	fontSizeAdjust: string;
	fontStretch: string;
	fontStyle: string;
	fontSynthesis: string;
	fontVariant: string;
	fontVariantAlternates: string;
	fontVariantCaps: string;
	fontVariantEastAsian: string;
	fontVariantLigatures: string;
	fontVariantNumeric: string;
	fontVariantPosition: string;
	fontVariationSettings: string;
	fontWeight: string;
	gap: string;
	grid: string;
	gridArea: string;
	gridAutoColumns: string;
	gridAutoFlow: string;
	gridAutoRows: string;
	gridColumn: string;
	gridColumnEnd: string;
	gridColumnGap: string;
	gridColumnStart: string;
	gridGap: string;
	gridRow: string;
	gridRowEnd: string;
	gridRowGap: string;
	gridRowStart: string;
	gridTemplate: string;
	gridTemplateAreas: string;
	gridTemplateColumns: string;
	gridTemplateRows: string;
	height: string;
	hyphens: string;
	imageOrientation: string;
	imageRendering: string;
	inlineSize: string;
	inset: string;
	insetBlock: string;
	insetBlockEnd: string;
	insetBlockStart: string;
	insetInline: string;
	insetInlineEnd: string;
	insetInlineStart: string;
	isolation: string;
	justifyContent: string;
	justifyItems: string;
	justifySelf: string;
	left: string;
	get length(): number;
	letterSpacing: string;
	lightingColor: string;
	lineBreak: string;
	lineHeight: string;
	listStyle: string;
	listStyleImage: string;
	listStylePosition: string;
	listStyleType: string;
	margin: string;
	marginBlock: string;
	marginBlockEnd: string;
	marginBlockStart: string;
	marginBottom: string;
	marginInline: string;
	marginInlineEnd: string;
	marginInlineStart: string;
	marginLeft: string;
	marginRight: string;
	marginTop: string;
	marker: string;
	markerEnd: string;
	markerMid: string;
	markerStart: string;
	mask: string;
	maskType: string;
	maxBlockSize: string;
	maxHeight: string;
	maxInlineSize: string;
	maxWidth: string;
	minBlockSize: string;
	minHeight: string;
	minInlineSize: string;
	minWidth: string;
	mixBlendMode: string;
	objectFit: string;
	objectPosition: string;
	offset: string;
	offsetAnchor: string;
	offsetDistance: string;
	offsetPath: string;
	offsetRotate: string;
	opacity: string;
	order: string;
	orphans: string;
	outline: string;
	outlineColor: string;
	outlineOffset: string;
	outlineStyle: string;
	outlineWidth: string;
	overflow: string;
	overflowAnchor: string;
	overflowWrap: string;
	overflowX: string;
	overflowY: string;
	overscrollBehavior: string;
	overscrollBehaviorBlock: string;
	overscrollBehaviorInline: string;
	overscrollBehaviorX: string;
	overscrollBehaviorY: string;
	padding: string;
	paddingBlock: string;
	paddingBlockEnd: string;
	paddingBlockStart: string;
	paddingBottom: string;
	paddingInline: string;
	paddingInlineEnd: string;
	paddingInlineStart: string;
	paddingLeft: string;
	paddingRight: string;
	paddingTop: string;
	pageBreakAfter: string;
	pageBreakBefore: string;
	pageBreakInside: string;
	paintOrder: string;
	get parentRule(): CSSRule;
	perspective: string;
	perspectiveOrigin: string;
	placeContent: string;
	placeItems: string;
	placeSelf: string;
	pointerEvents: string;
	position: string;
	quotes: string;
	resize: string;
	right: string;
	rotate: string;
	rowGap: string;
	rubyPosition: string;
	scale: string;
	scrollBehavior: string;
	scrollMargin: string;
	scrollMarginBlock: string;
	scrollMarginBlockEnd: string;
	scrollMarginBlockStart: string;
	scrollMarginBottom: string;
	scrollMarginInline: string;
	scrollMarginInlineEnd: string;
	scrollMarginInlineStart: string;
	scrollMarginLeft: string;
	scrollMarginRight: string;
	scrollMarginTop: string;
	scrollPadding: string;
	scrollPaddingBlock: string;
	scrollPaddingBlockEnd: string;
	scrollPaddingBlockStart: string;
	scrollPaddingBottom: string;
	scrollPaddingInline: string;
	scrollPaddingInlineEnd: string;
	scrollPaddingInlineStart: string;
	scrollPaddingLeft: string;
	scrollPaddingRight: string;
	scrollPaddingTop: string;
	scrollSnapAlign: string;
	scrollSnapStop: string;
	scrollSnapType: string;
	shapeImageThreshold: string;
	shapeMargin: string;
	shapeOutside: string;
	shapeRendering: string;
	stopColor: string;
	stopOpacity: string;
	stroke: string;
	strokeDasharray: string;
	strokeDashoffset: string;
	strokeLinecap: string;
	strokeLinejoin: string;
	strokeMiterlimit: string;
	strokeOpacity: string;
	strokeWidth: string;
	tabSize: string;
	tableLayout: string;
	textAlign: string;
	textAlignLast: string;
	textAnchor: string;
	textCombineUpright: string;
	textDecoration: string;
	textDecorationColor: string;
	textDecorationLine: string;
	textDecorationSkipInk: string;
	textDecorationStyle: string;
	textDecorationThickness: string;
	textEmphasis: string;
	textEmphasisColor: string;
	textEmphasisPosition: string;
	textEmphasisStyle: string;
	textIndent: string;
	textOrientation: string;
	textOverflow: string;
	textRendering: string;
	textShadow: string;
	textTransform: string;
	textUnderlineOffset: string;
	textUnderlinePosition: string;
	top: string;
	touchAction: string;
	transform: string;
	transformBox: string;
	transformOrigin: string;
	transformStyle: string;
	transition: string;
	transitionDelay: string;
	transitionDuration: string;
	transitionProperty: string;
	transitionTimingFunction: string;
	translate: string;
	unicodeBidi: string;
	userSelect: string;
	verticalAlign: string;
	visibility: string;
	webkitAlignContent: string;
	webkitAlignItems: string;
	webkitAlignSelf: string;
	webkitAnimation: string;
	webkitAnimationDelay: string;
	webkitAnimationDirection: string;
	webkitAnimationDuration: string;
	webkitAnimationFillMode: string;
	webkitAnimationIterationCount: string;
	webkitAnimationName: string;
	webkitAnimationPlayState: string;
	webkitAnimationTimingFunction: string;
	webkitAppearance: string;
	webkitBackfaceVisibility: string;
	webkitBackgroundClip: string;
	webkitBackgroundOrigin: string;
	webkitBackgroundSize: string;
	webkitBorderBottomLeftRadius: string;
	webkitBorderBottomRightRadius: string;
	webkitBorderRadius: string;
	webkitBorderTopLeftRadius: string;
	webkitBorderTopRightRadius: string;
	webkitBoxAlign: string;
	webkitBoxFlex: string;
	webkitBoxOrdinalGroup: string;
	webkitBoxOrient: string;
	webkitBoxPack: string;
	webkitBoxShadow: string;
	webkitBoxSizing: string;
	webkitFilter: string;
	webkitFlex: string;
	webkitFlexBasis: string;
	webkitFlexDirection: string;
	webkitFlexFlow: string;
	webkitFlexGrow: string;
	webkitFlexShrink: string;
	webkitFlexWrap: string;
	webkitJustifyContent: string;
	webkitLineClamp: string;
	webkitMask: string;
	webkitMaskBoxImage: string;
	webkitMaskBoxImageOutset: string;
	webkitMaskBoxImageRepeat: string;
	webkitMaskBoxImageSlice: string;
	webkitMaskBoxImageSource: string;
	webkitMaskBoxImageWidth: string;
	webkitMaskClip: string;
	webkitMaskComposite: string;
	webkitMaskImage: string;
	webkitMaskOrigin: string;
	webkitMaskPosition: string;
	webkitMaskRepeat: string;
	webkitMaskSize: string;
	webkitOrder: string;
	webkitPerspective: string;
	webkitPerspectiveOrigin: string;
	webkitTextFillColor: string;
	webkitTextStroke: string;
	webkitTextStrokeColor: string;
	webkitTextStrokeWidth: string;
	webkitTransform: string;
	webkitTransformOrigin: string;
	webkitTransformStyle: string;
	webkitTransition: string;
	webkitTransitionDelay: string;
	webkitTransitionDuration: string;
	webkitTransitionProperty: string;
	webkitTransitionTimingFunction: string;
	webkitUserSelect: string;
	whiteSpace: string;
	widows: string;
	width: string;
	willChange: string;
	wordBreak: string;
	wordSpacing: string;
	wordWrap: string;
	writingMode: string;
	zIndex: string;
	getPropertyPriority(property: string): string;
	getPropertyValue(property: string): string;
	item(index: number): string;
	removeProperty(property: string): string;
	setProperty(property: string, value: string, priority: string = ): void;
}

var CSSStyleDeclaration: ~Object with { constructor(); };

export external public interface ~CSSStyleRule extends CSSRule {
	selectorText: string;
	get style(): CSSStyleDeclaration;
}

var CSSStyleRule: ~Object with { constructor(); };

export external public interface ~CSSStyleSheet extends StyleSheet {
	get cssRules(): CSSRuleList;
	get ownerRule(): CSSRule;
	get rules(): CSSRuleList;
	addRule(selector: string = , style: string = , index: number = ): number;
	deleteRule(index: number): void;
	insertRule(rule: string, index: number = ): number;
	removeRule(index: number = ): void;
}

var CSSStyleSheet: ~Object with { constructor(options: CSSStyleSheetInit = ); };

export external public interface ~CSSSupportsRule extends CSSConditionRule {}

var CSSSupportsRule: ~Object with { constructor(); };

export external public interface ~CSSTransition extends Animation {
	get transitionProperty(): string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var CSSTransition: ~Object with { constructor(); };

export external public interface ~Cache {
	add(request: RequestInfo): Promise<undefined>;
	addAll(requests: Array<RequestInfo>): Promise<undefined>;
	delete(request: RequestInfo, options: CacheQueryOptions = ): Promise<boolean>;
	keys(request: RequestInfo = , options: CacheQueryOptions = ): Promise<ReadonlyArray<Request>>;
	match(request: RequestInfo, options: CacheQueryOptions = ): Promise<Response>;
	matchAll(request: RequestInfo = , options: CacheQueryOptions = ): Promise<ReadonlyArray<Response>>;
	put(request: RequestInfo, response: Response): Promise<undefined>;
}

var Cache: ~Object with { constructor(); };

export external public interface ~CacheStorage {
	delete(cacheName: string): Promise<boolean>;
	has(cacheName: string): Promise<boolean>;
	keys(): Promise<Array<string>>;
	match(request: RequestInfo, options: MultiCacheQueryOptions = ): Promise<Response>;
	open(cacheName: string): Promise<Cache>;
}

var CacheStorage: ~Object with { constructor(); };

export external public interface ~CanvasCompositing {
	globalAlpha: number;
	globalCompositeOperation: string;
}

export external public interface ~CanvasDrawImage {
	drawImage(...args: any+): any+; // overloading not supported
}

export external public interface ~CanvasDrawPath {
	beginPath(): void;
	clip(...args: any+): any+; // overloading not supported
	fill(...args: any+): any+; // overloading not supported
	isPointInPath(...args: any+): any+; // overloading not supported
	isPointInStroke(...args: any+): any+; // overloading not supported
	stroke(...args: any+): any+; // overloading not supported
}

export external public interface ~CanvasFillStrokeStyles {
	fillStyle: string | CanvasGradient | CanvasPattern;
	strokeStyle: string | CanvasGradient | CanvasPattern;
	createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
	createPattern(image: CanvasImageSource, repetition: string): CanvasPattern;
	createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
}

export external public interface ~CanvasFilters {
	filter: string;
}

export external public interface ~CanvasGradient {
	addColorStop(offset: number, color: string): void;
}

var CanvasGradient: ~Object with { constructor(); };

export external public interface ~CanvasImageData {
	createImageData(...args: any+): any+; // overloading not supported
	getImageData(sx: number, sy: number, sw: number, sh: number, settings: ImageDataSettings = ): ImageData;
	putImageData(...args: any+): any+; // overloading not supported
}

export external public interface ~CanvasImageSmoothing {
	imageSmoothingEnabled: boolean;
	imageSmoothingQuality: ImageSmoothingQuality;
}

export external public interface ~CanvasPath {
	arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean = ): void;
	arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
	bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
	closePath(): void;
	ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, counterclockwise: boolean = ): void;
	lineTo(x: number, y: number): void;
	moveTo(x: number, y: number): void;
	quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
	rect(x: number, y: number, w: number, h: number): void;
}

export external public interface ~CanvasPathDrawingStyles {
	lineCap: CanvasLineCap;
	lineDashOffset: number;
	lineJoin: CanvasLineJoin;
	lineWidth: number;
	miterLimit: number;
	getLineDash(): Array<number>;
	setLineDash(segments: Array<number>): void;
}

export external public interface ~CanvasPattern {
	setTransform(transform: DOMMatrix2DInit = ): void;
}

var CanvasPattern: ~Object with { constructor(); };

export external public interface ~CanvasRect {
	clearRect(x: number, y: number, w: number, h: number): void;
	fillRect(x: number, y: number, w: number, h: number): void;
	strokeRect(x: number, y: number, w: number, h: number): void;
}

export external public interface ~CanvasRenderingContext2D extends CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPath, CanvasPathDrawingStyles, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform, CanvasUserInterface {
	get canvas(): HTMLCanvasElement;
	getContextAttributes(): CanvasRenderingContext2DSettings;
}

var CanvasRenderingContext2D: ~Object with { constructor(); };

export external public interface ~CanvasShadowStyles {
	shadowBlur: number;
	shadowColor: string;
	shadowOffsetX: number;
	shadowOffsetY: number;
}

export external public interface ~CanvasState {
	restore(): void;
	save(): void;
}

export external public interface ~CanvasText {
	fillText(text: string, x: number, y: number, maxWidth: number = ): void;
	measureText(text: string): TextMetrics;
	strokeText(text: string, x: number, y: number, maxWidth: number = ): void;
}

export external public interface ~CanvasTextDrawingStyles {
	direction: CanvasDirection;
	font: string;
	textAlign: CanvasTextAlign;
	textBaseline: CanvasTextBaseline;
}

export external public interface ~CanvasTransform {
	getTransform(): DOMMatrix;
	resetTransform(): void;
	rotate(angle: number): void;
	scale(x: number, y: number): void;
	setTransform(...args: any+): any+; // overloading not supported
	transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
	translate(x: number, y: number): void;
}

export external public interface ~CanvasUserInterface {
	drawFocusIfNeeded(...args: any+): any+; // overloading not supported
}

export external public interface ~ChannelMergerNode extends AudioNode {}

var ChannelMergerNode: ~Object with { constructor(context: BaseAudioContext, options: ChannelMergerOptions = ); };

export external public interface ~ChannelSplitterNode extends AudioNode {}

var ChannelSplitterNode: ~Object with { constructor(context: BaseAudioContext, options: ChannelSplitterOptions = ); };

export external public interface ~CharacterData extends Node, ChildNode, NonDocumentTypeChildNode {
	data: string;
	get length(): number;
	@Override
	get ownerDocument(): Document;
	appendData(data: string): void;
	deleteData(offset: number, count: number): void;
	insertData(offset: number, data: string): void;
	replaceData(offset: number, count: number, data: string): void;
	substringData(offset: number, count: number): string;
}

var CharacterData: ~Object with { constructor(); };

export external public interface ~ChildNode extends Node {
	after(...nodes: Node | string): void;
	before(...nodes: Node | string): void;
	remove(): void;
	replaceWith(...nodes: Node | string): void;
}

export external public interface ~ClientRect extends DOMRect {}

export external public interface ~Clipboard extends EventTarget {
	read(): Promise<ClipboardItems>;
	readText(): Promise<string>;
	write(data: ClipboardItems): Promise<undefined>;
	writeText(data: string): Promise<undefined>;
}

var Clipboard: ~Object with { constructor(); };

export external public interface ~ClipboardEvent extends Event {
	get clipboardData(): DataTransfer;
}

var ClipboardEvent: ~Object with { constructor(type: string, eventInitDict: ClipboardEventInit = ); };

export external public interface ~ClipboardItem {
	get types(): ReadonlyArray<string>;
	getType(type: string): Promise<Blob>;
}

var ClipboardItem: ~Object with { constructor(items: Record<string,ClipboardItemDataType | PromiseLike<ClipboardItemDataType>>, options: ClipboardItemOptions = ); };

export external public interface ~CloseEvent extends Event {
	get code(): number;
	get reason(): string;
	get wasClean(): boolean;
}

var CloseEvent: ~Object with { constructor(type: string, eventInitDict: CloseEventInit = ); };

export external public interface ~Comment extends CharacterData {}

var Comment: ~Object with { constructor(data: string = ); };

export external public interface ~CompositionEvent extends UIEvent {
	get data(): string;
	initCompositionEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , viewArg: WindowProxy = , dataArg: string = ): void;
}

var CompositionEvent: ~Object with { constructor(type: string, eventInitDict: CompositionEventInit = ); };

export external public interface ~ConstantSourceNode extends AudioScheduledSourceNode {
	get offset(): AudioParam;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var ConstantSourceNode: ~Object with { constructor(context: BaseAudioContext, options: ConstantSourceOptions = ); };

export external public interface ~ConvolverNode extends AudioNode {
	buffer: AudioBuffer;
	normalize: boolean;
}

var ConvolverNode: ~Object with { constructor(context: BaseAudioContext, options: ConvolverOptions = ); };

export external public interface ~CountQueuingStrategy extends QueuingStrategy {
	get highWaterMark(): number;
	get size(): QueuingStrategySize;
}

var CountQueuingStrategy: ~Object with { constructor(init: QueuingStrategyInit); };

export external public interface ~Credential {
	get id(): string;
	get type(): string;
}

var Credential: ~Object with { constructor(); };

export external public interface ~CredentialsContainer {
	create(options: CredentialCreationOptions = ): Promise<Credential>;
	get(options: CredentialRequestOptions = ): Promise<Credential>;
	preventSilentAccess(): Promise<undefined>;
	store(credential: Credential): Promise<Credential>;
}

var CredentialsContainer: ~Object with { constructor(); };

export external public interface ~Crypto {
	get subtle(): SubtleCrypto;
	<T> getRandomValues(array: T): T;
}

var Crypto: ~Object with { constructor(); };

export external public interface ~CryptoKey {
	get algorithm(): KeyAlgorithm;
	get extractable(): boolean;
	get type(): KeyType;
	get usages(): Array<KeyUsage>;
}

var CryptoKey: ~Object with { constructor(); };

export external public interface ~CustomElementRegistry {
	define(name: string, constructor: CustomElementConstructor, options: ElementDefinitionOptions = ): void;
	get(name: string): CustomElementConstructor;
	upgrade(root: Node): void;
	whenDefined(name: string): Promise<CustomElementConstructor>;
}

var CustomElementRegistry: ~Object with { constructor(); };

export external public interface ~CustomEvent<T=any> extends Event {
	get detail(): T;
	initCustomEvent(type: string, bubbles: boolean = , cancelable: boolean = , detail: T = ): void;
}

var CustomEvent: ~Object with { constructor(type: string, eventInitDict: CustomEventInit<T> = ); };

export external public interface ~DOMException extends Error {
	get code(): number;
	get message(): string;
	get name(): string;
	get ABORT_ERR(): number;
	get DATA_CLONE_ERR(): number;
	get DOMSTRING_SIZE_ERR(): number;
	get HIERARCHY_REQUEST_ERR(): number;
	get INDEX_SIZE_ERR(): number;
	get INUSE_ATTRIBUTE_ERR(): number;
	get INVALID_ACCESS_ERR(): number;
	get INVALID_CHARACTER_ERR(): number;
	get INVALID_MODIFICATION_ERR(): number;
	get INVALID_NODE_TYPE_ERR(): number;
	get INVALID_STATE_ERR(): number;
	get NAMESPACE_ERR(): number;
	get NETWORK_ERR(): number;
	get NOT_FOUND_ERR(): number;
	get NOT_SUPPORTED_ERR(): number;
	get NO_DATA_ALLOWED_ERR(): number;
	get NO_MODIFICATION_ALLOWED_ERR(): number;
	get QUOTA_EXCEEDED_ERR(): number;
	get SECURITY_ERR(): number;
	get SYNTAX_ERR(): number;
	get TIMEOUT_ERR(): number;
	get TYPE_MISMATCH_ERR(): number;
	get URL_MISMATCH_ERR(): number;
	get VALIDATION_ERR(): number;
	get WRONG_DOCUMENT_ERR(): number;
}

var DOMException: ~Object with { constructor(message: string = , name: string = ); get ABORT_ERR(): number; get DATA_CLONE_ERR(): number; get DOMSTRING_SIZE_ERR(): number; get HIERARCHY_REQUEST_ERR(): number; get INDEX_SIZE_ERR(): number; get INUSE_ATTRIBUTE_ERR(): number; get INVALID_ACCESS_ERR(): number; get INVALID_CHARACTER_ERR(): number; get INVALID_MODIFICATION_ERR(): number; get INVALID_NODE_TYPE_ERR(): number; get INVALID_STATE_ERR(): number; get NAMESPACE_ERR(): number; get NETWORK_ERR(): number; get NOT_FOUND_ERR(): number; get NOT_SUPPORTED_ERR(): number; get NO_DATA_ALLOWED_ERR(): number; get NO_MODIFICATION_ALLOWED_ERR(): number; get QUOTA_EXCEEDED_ERR(): number; get SECURITY_ERR(): number; get SYNTAX_ERR(): number; get TIMEOUT_ERR(): number; get TYPE_MISMATCH_ERR(): number; get URL_MISMATCH_ERR(): number; get VALIDATION_ERR(): number; get WRONG_DOCUMENT_ERR(): number; };

export external public interface ~DOMImplementation {
	createDocument(namespace: string, qualifiedName: string, doctype: DocumentType = ): XMLDocument;
	createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;
	createHTMLDocument(title: string = ): Document;
	hasFeature(...args: any): true;
}

var DOMImplementation: ~Object with { constructor(); };

export external public interface ~DOMMatrix extends DOMMatrixReadOnly {
	@Override
	a: number;
	@Override
	b: number;
	@Override
	c: number;
	@Override
	d: number;
	@Override
	e: number;
	@Override
	f: number;
	@Override
	m11: number;
	@Override
	m12: number;
	@Override
	m13: number;
	@Override
	m14: number;
	@Override
	m21: number;
	@Override
	m22: number;
	@Override
	m23: number;
	@Override
	m24: number;
	@Override
	m31: number;
	@Override
	m32: number;
	@Override
	m33: number;
	@Override
	m34: number;
	@Override
	m41: number;
	@Override
	m42: number;
	@Override
	m43: number;
	@Override
	m44: number;
	invertSelf(): DOMMatrix;
	multiplySelf(other: DOMMatrixInit = ): DOMMatrix;
	preMultiplySelf(other: DOMMatrixInit = ): DOMMatrix;
	rotateAxisAngleSelf(x: number = , y: number = , z: number = , angle: number = ): DOMMatrix;
	rotateFromVectorSelf(x: number = , y: number = ): DOMMatrix;
	rotateSelf(rotX: number = , rotY: number = , rotZ: number = ): DOMMatrix;
	scale3dSelf(scale: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	scaleSelf(scaleX: number = , scaleY: number = , scaleZ: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	setMatrixValue(transformList: string): DOMMatrix;
	skewXSelf(sx: number = ): DOMMatrix;
	skewYSelf(sy: number = ): DOMMatrix;
	translateSelf(tx: number = , ty: number = , tz: number = ): DOMMatrix;
}

var DOMMatrix: ~Object with { constructor(init: string | Array<number> = ); fromFloat32Array(array32: Float32Array): DOMMatrix; fromFloat64Array(array64: Float64Array): DOMMatrix; fromMatrix(other: DOMMatrixInit = ): DOMMatrix; };

export external public type SVGMatrix = DOMMatrix;

var SVGMatrix: any+;

export external public type WebKitCSSMatrix = DOMMatrix;

var WebKitCSSMatrix: any+;

export external public interface ~DOMMatrixReadOnly {
	get a(): number;
	get b(): number;
	get c(): number;
	get d(): number;
	get e(): number;
	get f(): number;
	get is2D(): boolean;
	get isIdentity(): boolean;
	get m11(): number;
	get m12(): number;
	get m13(): number;
	get m14(): number;
	get m21(): number;
	get m22(): number;
	get m23(): number;
	get m24(): number;
	get m31(): number;
	get m32(): number;
	get m33(): number;
	get m34(): number;
	get m41(): number;
	get m42(): number;
	get m43(): number;
	get m44(): number;
	flipX(): DOMMatrix;
	flipY(): DOMMatrix;
	inverse(): DOMMatrix;
	multiply(other: DOMMatrixInit = ): DOMMatrix;
	rotate(rotX: number = , rotY: number = , rotZ: number = ): DOMMatrix;
	rotateAxisAngle(x: number = , y: number = , z: number = , angle: number = ): DOMMatrix;
	rotateFromVector(x: number = , y: number = ): DOMMatrix;
	scale(scaleX: number = , scaleY: number = , scaleZ: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	scale3d(scale: number = , originX: number = , originY: number = , originZ: number = ): DOMMatrix;
	scaleNonUniform(scaleX: number = , scaleY: number = ): DOMMatrix;
	skewX(sx: number = ): DOMMatrix;
	skewY(sy: number = ): DOMMatrix;
	toFloat32Array(): Float32Array;
	toFloat64Array(): Float64Array;
	toJSON(): any;
	transformPoint(point: DOMPointInit = ): DOMPoint;
	translate(tx: number = , ty: number = , tz: number = ): DOMMatrix;
	toString(): string;
}

var DOMMatrixReadOnly: ~Object with { constructor(init: string | Array<number> = ); fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly; fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly; fromMatrix(other: DOMMatrixInit = ): DOMMatrixReadOnly; toString(): string; };

export external public interface ~DOMParser {
	parseFromString(string: string, type: DOMParserSupportedType): Document;
}

var DOMParser: ~Object with { constructor(); };

export external public interface ~DOMPoint extends DOMPointReadOnly {
	@Override
	w: number;
	@Override
	x: number;
	@Override
	y: number;
	@Override
	z: number;
}

var DOMPoint: ~Object with { constructor(x: number = , y: number = , z: number = , w: number = ); fromPoint(other: DOMPointInit = ): DOMPoint; };

export external public type SVGPoint = DOMPoint;

var SVGPoint: any+;

export external public interface ~DOMPointReadOnly {
	get w(): number;
	get x(): number;
	get y(): number;
	get z(): number;
	matrixTransform(matrix: DOMMatrixInit = ): DOMPoint;
	toJSON(): any;
}

var DOMPointReadOnly: ~Object with { constructor(x: number = , y: number = , z: number = , w: number = ); fromPoint(other: DOMPointInit = ): DOMPointReadOnly; };

export external public interface ~DOMQuad {
	get p1(): DOMPoint;
	get p2(): DOMPoint;
	get p3(): DOMPoint;
	get p4(): DOMPoint;
	getBounds(): DOMRect;
	toJSON(): any;
}

var DOMQuad: ~Object with { constructor(p1: DOMPointInit = , p2: DOMPointInit = , p3: DOMPointInit = , p4: DOMPointInit = ); fromQuad(other: DOMQuadInit = ): DOMQuad; fromRect(other: DOMRectInit = ): DOMQuad; };

export external public interface ~DOMRect extends DOMRectReadOnly {
	@Override
	height: number;
	@Override
	width: number;
	@Override
	x: number;
	@Override
	y: number;
}

var DOMRect: ~Object with { constructor(x: number = , y: number = , width: number = , height: number = ); fromRect(other: DOMRectInit = ): DOMRect; };

export external public type SVGRect = DOMRect;

var SVGRect: any+;

export external public interface ~DOMRectList {
	get length(): number;
	item(index: number): DOMRect;
}

var DOMRectList: ~Object with { constructor(); };

export external public interface ~DOMRectReadOnly {
	get bottom(): number;
	get height(): number;
	get left(): number;
	get right(): number;
	get top(): number;
	get width(): number;
	get x(): number;
	get y(): number;
	toJSON(): any;
}

var DOMRectReadOnly: ~Object with { constructor(x: number = , y: number = , width: number = , height: number = ); fromRect(other: DOMRectInit = ): DOMRectReadOnly; };

export external public interface ~DOMStringList {
	get length(): number;
	contains(string: string): boolean;
	item(index: number): string;
}

var DOMStringList: ~Object with { constructor(); };

export external public interface ~DOMStringMap {}

var DOMStringMap: ~Object with { constructor(); };

export external public interface ~DOMTokenList {
	get length(): number;
	value: string;
	toString(): string;
	add(...tokens: string): void;
	contains(token: string): boolean;
	item(index: number): string;
	remove(...tokens: string): void;
	replace(token: string, newToken: string): boolean;
	supports(token: string): boolean;
	toggle(token: string, force: boolean = ): boolean;
	forEach(callbackfn: (value: string, key: number, parent: DOMTokenList)=>void, thisArg: any = ): void;
}

var DOMTokenList: ~Object with { constructor(); };

export external public interface ~DataTransfer {
	dropEffect: "none" | "copy" | "link" | "move";
	effectAllowed: "none" | "copy" | "copyLink" | "copyMove" | "link" | "linkMove" | "move" | "all" | "uninitialized";
	get files(): FileList;
	get items(): DataTransferItemList;
	get types(): ReadonlyArray<string>;
	clearData(format: string = ): void;
	getData(format: string): string;
	setData(format: string, data: string): void;
	setDragImage(image: Element, x: number, y: number): void;
}

var DataTransfer: ~Object with { constructor(); };

export external public interface ~DataTransferItem {
	get kind(): string;
	get type(): string;
	getAsFile(): File;
	getAsString(callback: FunctionStringCallback): void;
	webkitGetAsEntry(): FileSystemEntry;
}

var DataTransferItem: ~Object with { constructor(); };

export external public interface ~DataTransferItemList {
	get length(): number;
	add(...args: any+): any+; // overloading not supported
	clear(): void;
	remove(index: number): void;
}

var DataTransferItemList: ~Object with { constructor(); };

export external public interface ~DelayNode extends AudioNode {
	get delayTime(): AudioParam;
}

var DelayNode: ~Object with { constructor(context: BaseAudioContext, options: DelayOptions = ); };

export external public interface ~DeviceMotionEvent extends Event {
	get acceleration(): DeviceMotionEventAcceleration;
	get accelerationIncludingGravity(): DeviceMotionEventAcceleration;
	get interval(): number;
	get rotationRate(): DeviceMotionEventRotationRate;
}

var DeviceMotionEvent: ~Object with { constructor(type: string, eventInitDict: DeviceMotionEventInit = ); };

export external public interface ~DeviceMotionEventAcceleration {
	get x(): number;
	get y(): number;
	get z(): number;
}

export external public interface ~DeviceMotionEventRotationRate {
	get alpha(): number;
	get beta(): number;
	get gamma(): number;
}

export external public interface ~DeviceOrientationEvent extends Event {
	get absolute(): boolean;
	get alpha(): number;
	get beta(): number;
	get gamma(): number;
}

var DeviceOrientationEvent: ~Object with { constructor(type: string, eventInitDict: DeviceOrientationEventInit = ); };

export external public interface ~DocumentEventMap extends DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {
	fullscreenchange: Event;
	fullscreenerror: Event;
	pointerlockchange: Event;
	pointerlockerror: Event;
	readystatechange: Event;
	visibilitychange: Event;
}

export external public interface ~Document extends Node, DocumentAndElementEventHandlers, DocumentOrShadowRoot, FontFaceSource, GlobalEventHandlers, NonElementParentNode, ParentNode, XPathEvaluatorBase {
	get URL(): string;
	alinkColor: string;
	get all(): HTMLAllCollection;
	get anchors(): HTMLCollectionOf<HTMLAnchorElement>;
	get applets(): HTMLCollection;
	bgColor: string;
	body: HTMLElement;
	get characterSet(): string;
	get charset(): string;
	get compatMode(): string;
	get contentType(): string;
	cookie: string;
	get currentScript(): HTMLOrSVGScriptElement;
	get defaultView(): (WindowProxy & any+);
	designMode: string;
	dir: string;
	get doctype(): DocumentType;
	get documentElement(): HTMLElement;
	get documentURI(): string;
	domain: string;
	get embeds(): HTMLCollectionOf<HTMLEmbedElement>;
	fgColor: string;
	get forms(): HTMLCollectionOf<HTMLFormElement>;
	get fullscreen(): boolean;
	get fullscreenEnabled(): boolean;
	get head(): HTMLHeadElement;
	get hidden(): boolean;
	get images(): HTMLCollectionOf<HTMLImageElement>;
	get implementation(): DOMImplementation;
	get inputEncoding(): string;
	get lastModified(): string;
	linkColor: string;
	get links(): HTMLCollectionOf<HTMLAnchorElement | HTMLAreaElement>;
	get location(): Location;
	onfullscreenchange: ({@This(Document) function(ev: Event): any});
	onfullscreenerror: ({@This(Document) function(ev: Event): any});
	onpointerlockchange: ({@This(Document) function(ev: Event): any});
	onpointerlockerror: ({@This(Document) function(ev: Event): any});
	onreadystatechange: ({@This(Document) function(ev: Event): any});
	onvisibilitychange: ({@This(Document) function(ev: Event): any});
	@Override
	get ownerDocument(): any+;
	get pictureInPictureEnabled(): boolean;
	get plugins(): HTMLCollectionOf<HTMLEmbedElement>;
	get readyState(): DocumentReadyState;
	get referrer(): string;
	get rootElement(): SVGSVGElement;
	get scripts(): HTMLCollectionOf<HTMLScriptElement>;
	get scrollingElement(): Element;
	get timeline(): DocumentTimeline;
	title: string;
	get visibilityState(): VisibilityState;
	vlinkColor: string;
	<T> adoptNode(node: T): T;
	captureEvents(): void;
	caretRangeFromPoint(x: number, y: number): Range;
	clear(): void;
	close(): void;
	createAttribute(localName: string): Attr;
	createAttributeNS(namespace: string, qualifiedName: string): Attr;
	createCDATASection(data: string): CDATASection;
	createComment(data: string): Comment;
	createDocumentFragment(): DocumentFragment;
	createElement(...args: any+): any+; // overloading not supported
	createElementNS(...args: any+): any+; // overloading not supported
	createEvent(...args: any+): any+; // overloading not supported
	createNodeIterator(root: Node, whatToShow: number = , filter: NodeFilter = ): NodeIterator;
	createProcessingInstruction(target: string, data: string): ProcessingInstruction;
	createRange(): Range;
	createTextNode(data: string): Text;
	createTreeWalker(root: Node, whatToShow: number = , filter: NodeFilter = ): TreeWalker;
	elementFromPoint(x: number, y: number): Element;
	elementsFromPoint(x: number, y: number): Array<Element>;
	execCommand(commandId: string, showUI: boolean = , value: string = ): boolean;
	exitFullscreen(): Promise<undefined>;
	exitPictureInPicture(): Promise<undefined>;
	exitPointerLock(): void;
	@Override
	getElementById(elementId: string): HTMLElement;
	getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
	getElementsByName(elementName: string): NodeListOf<HTMLElement>;
	getElementsByTagName(...args: any+): any+; // overloading not supported
	getElementsByTagNameNS(...args: any+): any+; // overloading not supported
	getSelection(): Selection;
	hasFocus(): boolean;
	hasStorageAccess(): Promise<boolean>;
	<T> importNode(node: T, deep: boolean = ): T;
	open(...args: any+): any+; // overloading not supported
	queryCommandEnabled(commandId: string): boolean;
	queryCommandIndeterm(commandId: string): boolean;
	queryCommandState(commandId: string): boolean;
	queryCommandSupported(commandId: string): boolean;
	queryCommandValue(commandId: string): string;
	releaseEvents(): void;
	requestStorageAccess(): Promise<undefined>;
	write(...text: string): void;
	writeln(...text: string): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var Document: ~Object with { constructor(); };

export external public interface ~DocumentAndElementEventHandlersEventMap {
	copy: ClipboardEvent;
	cut: ClipboardEvent;
	paste: ClipboardEvent;
}

export external public interface ~DocumentAndElementEventHandlers {
	oncopy: ({@This(DocumentAndElementEventHandlers) function(ev: ClipboardEvent): any});
	oncut: ({@This(DocumentAndElementEventHandlers) function(ev: ClipboardEvent): any});
	onpaste: ({@This(DocumentAndElementEventHandlers) function(ev: ClipboardEvent): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~DocumentFragment extends Node, NonElementParentNode, ParentNode {
	@Override
	get ownerDocument(): Document;
	@Override
	getElementById(elementId: string): HTMLElement;
}

var DocumentFragment: ~Object with { constructor(); };

export external public interface ~DocumentOrShadowRoot {
	get activeElement(): Element;
	get fullscreenElement(): Element;
	get pictureInPictureElement(): Element;
	get pointerLockElement(): Element;
	get styleSheets(): StyleSheetList;
	getAnimations(): Array<Animation>;
}

export external public interface ~DocumentTimeline extends AnimationTimeline {}

var DocumentTimeline: ~Object with { constructor(options: DocumentTimelineOptions = ); };

export external public interface ~DocumentType extends Node, ChildNode {
	get name(): string;
	@Override
	get ownerDocument(): Document;
	get publicId(): string;
	get systemId(): string;
}

var DocumentType: ~Object with { constructor(); };

export external public interface ~DragEvent extends MouseEvent {
	get dataTransfer(): DataTransfer;
}

var DragEvent: ~Object with { constructor(type: string, eventInitDict: DragEventInit = ); };

export external public interface ~DynamicsCompressorNode extends AudioNode {
	get attack(): AudioParam;
	get knee(): AudioParam;
	get ratio(): AudioParam;
	get reduction(): number;
	get release(): AudioParam;
	get threshold(): AudioParam;
}

var DynamicsCompressorNode: ~Object with { constructor(context: BaseAudioContext, options: DynamicsCompressorOptions = ); };

export external public interface ~EXT_blend_minmax {
	get MAX_EXT(): GLenum;
	get MIN_EXT(): GLenum;
}

export external public interface ~EXT_color_buffer_float {}

export external public interface ~EXT_color_buffer_half_float {
	get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT(): GLenum;
	get RGB16F_EXT(): GLenum;
	get RGBA16F_EXT(): GLenum;
	get UNSIGNED_NORMALIZED_EXT(): GLenum;
}

export external public interface ~EXT_float_blend {}

export external public interface ~EXT_frag_depth {}

export external public interface ~EXT_sRGB {
	get FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT(): GLenum;
	get SRGB8_ALPHA8_EXT(): GLenum;
	get SRGB_ALPHA_EXT(): GLenum;
	get SRGB_EXT(): GLenum;
}

export external public interface ~EXT_shader_texture_lod {}

export external public interface ~EXT_texture_compression_rgtc {
	get COMPRESSED_RED_GREEN_RGTC2_EXT(): GLenum;
	get COMPRESSED_RED_RGTC1_EXT(): GLenum;
	get COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT(): GLenum;
	get COMPRESSED_SIGNED_RED_RGTC1_EXT(): GLenum;
}

export external public interface ~EXT_texture_filter_anisotropic {
	get MAX_TEXTURE_MAX_ANISOTROPY_EXT(): GLenum;
	get TEXTURE_MAX_ANISOTROPY_EXT(): GLenum;
}

export external public interface ~ElementEventMap {
	fullscreenchange: Event;
	fullscreenerror: Event;
}

export external public interface ~Element extends Node, ARIAMixin, Animatable, ChildNode, InnerHTML, NonDocumentTypeChildNode, ParentNode, Slottable {
	get attributes(): NamedNodeMap;
	get classList(): DOMTokenList;
	className: string;
	get clientHeight(): number;
	get clientLeft(): number;
	get clientTop(): number;
	get clientWidth(): number;
	id: string;
	get localName(): string;
	get namespaceURI(): string;
	onfullscreenchange: ({@This(Element) function(ev: Event): any});
	onfullscreenerror: ({@This(Element) function(ev: Event): any});
	outerHTML: string;
	@Override
	get ownerDocument(): Document;
	get part(): DOMTokenList;
	get prefix(): string;
	get scrollHeight(): number;
	scrollLeft: number;
	scrollTop: number;
	get scrollWidth(): number;
	get shadowRoot(): ShadowRoot;
	slot: string;
	get tagName(): string;
	attachShadow(init: ShadowRootInit): ShadowRoot;
	closest(...args: any+): any+; // overloading not supported
	getAttribute(qualifiedName: string): string;
	getAttributeNS(namespace: string, localName: string): string;
	getAttributeNames(): Array<string>;
	getAttributeNode(qualifiedName: string): Attr;
	getAttributeNodeNS(namespace: string, localName: string): Attr;
	getBoundingClientRect(): DOMRect;
	getClientRects(): DOMRectList;
	getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
	getElementsByTagName(...args: any+): any+; // overloading not supported
	getElementsByTagNameNS(...args: any+): any+; // overloading not supported
	hasAttribute(qualifiedName: string): boolean;
	hasAttributeNS(namespace: string, localName: string): boolean;
	hasAttributes(): boolean;
	hasPointerCapture(pointerId: number): boolean;
	insertAdjacentElement(where: InsertPosition, element: Element): Element;
	insertAdjacentHTML(position: InsertPosition, text: string): void;
	insertAdjacentText(where: InsertPosition, data: string): void;
	matches(selectors: string): boolean;
	releasePointerCapture(pointerId: number): void;
	removeAttribute(qualifiedName: string): void;
	removeAttributeNS(namespace: string, localName: string): void;
	removeAttributeNode(attr: Attr): Attr;
	requestFullscreen(options: FullscreenOptions = ): Promise<undefined>;
	requestPointerLock(): void;
	scroll(...args: any+): any+; // overloading not supported
	scrollBy(...args: any+): any+; // overloading not supported
	scrollIntoView(arg: boolean | ScrollIntoViewOptions = ): void;
	scrollTo(...args: any+): any+; // overloading not supported
	setAttribute(qualifiedName: string, value: string): void;
	setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
	setAttributeNode(attr: Attr): Attr;
	setAttributeNodeNS(attr: Attr): Attr;
	setPointerCapture(pointerId: number): void;
	toggleAttribute(qualifiedName: string, force: boolean = ): boolean;
	webkitMatchesSelector(selectors: string): boolean;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var Element: ~Object with { constructor(); };

export external public interface ~ElementCSSInlineStyle {
	get style(): CSSStyleDeclaration;
}

export external public interface ~ElementContentEditable {
	contentEditable: string;
	enterKeyHint: string;
	inputMode: string;
	get isContentEditable(): boolean;
}

export external public interface ~ErrorEvent extends Event {
	get colno(): number;
	get error(): any;
	get filename(): string;
	get lineno(): number;
	get message(): string;
}

var ErrorEvent: ~Object with { constructor(type: string, eventInitDict: ErrorEventInit = ); };

export external public interface ~Event {
	get bubbles(): boolean;
	cancelBubble: boolean;
	get cancelable(): boolean;
	get composed(): boolean;
	get currentTarget(): EventTarget;
	get defaultPrevented(): boolean;
	get eventPhase(): number;
	get isTrusted(): boolean;
	returnValue: boolean;
	get srcElement(): EventTarget;
	get target(): EventTarget;
	get timeStamp(): DOMHighResTimeStamp;
	get type(): string;
	composedPath(): Array<EventTarget>;
	initEvent(type: string, bubbles: boolean = , cancelable: boolean = ): void;
	preventDefault(): void;
	stopImmediatePropagation(): void;
	stopPropagation(): void;
	get AT_TARGET(): number;
	get BUBBLING_PHASE(): number;
	get CAPTURING_PHASE(): number;
	get NONE(): number;
}

var Event: ~Object with { constructor(type: string, eventInitDict: EventInit = ); get AT_TARGET(): number; get BUBBLING_PHASE(): number; get CAPTURING_PHASE(): number; get NONE(): number; };

export external public interface ~EventListener {
	(evt: Event): void;
}

export external public interface ~EventListenerObject {
	handleEvent(object: Event): void;
}

export external public interface ~EventSourceEventMap {
	error: Event;
	message: MessageEvent;
	open: Event;
}

export external public interface ~EventSource extends EventTarget {
	onerror: ({@This(EventSource) function(ev: Event): any});
	onmessage: ({@This(EventSource) function(ev: MessageEvent): any});
	onopen: ({@This(EventSource) function(ev: Event): any});
	get readyState(): number;
	get url(): string;
	get withCredentials(): boolean;
	close(): void;
	get CLOSED(): number;
	get CONNECTING(): number;
	get OPEN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var EventSource: ~Object with { constructor(url: string | URL, eventSourceInitDict: EventSourceInit = ); get CLOSED(): number; get CONNECTING(): number; get OPEN(): number; };

export external public interface ~EventTarget {
	addEventListener(type: string, callback: EventListenerOrEventListenerObject, options: AddEventListenerOptions | boolean = ): void;
	dispatchEvent(event: Event): boolean;
	removeEventListener(type: string, callback: EventListenerOrEventListenerObject, options: EventListenerOptions | boolean = ): void;
}

var EventTarget: ~Object with { constructor(); };

export external public interface ~External {
	AddSearchProvider(): void;
	IsSearchProviderInstalled(): void;
}

var External: ~Object with { constructor(); };

export external public interface ~File extends Blob {
	get lastModified(): number;
	get name(): string;
	get webkitRelativePath(): string;
}

var File: ~Object with { constructor(fileBits: Array<BlobPart>, fileName: string, options: FilePropertyBag = ); };

export external public interface ~FileList {
	get length(): number;
	item(index: number): File;
}

var FileList: ~Object with { constructor(); };

export external public interface ~FileReaderEventMap {
	abort: ProgressEvent<FileReader>;
	error: ProgressEvent<FileReader>;
	load: ProgressEvent<FileReader>;
	loadend: ProgressEvent<FileReader>;
	loadstart: ProgressEvent<FileReader>;
	progress: ProgressEvent<FileReader>;
}

export external public interface ~FileReader extends EventTarget {
	get error(): DOMException;
	onabort: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	onerror: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	onload: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	onloadend: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	onloadstart: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	onprogress: ({@This(FileReader) function(ev: ProgressEvent<FileReader>): any});
	get readyState(): number;
	get result(): string | ArrayBuffer;
	abort(): void;
	readAsArrayBuffer(blob: Blob): void;
	readAsBinaryString(blob: Blob): void;
	readAsDataURL(blob: Blob): void;
	readAsText(blob: Blob, encoding: string = ): void;
	get DONE(): number;
	get EMPTY(): number;
	get LOADING(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var FileReader: ~Object with { constructor(); get DONE(): number; get EMPTY(): number; get LOADING(): number; };

export external public interface ~FileSystem {
	get name(): string;
	get root(): FileSystemDirectoryEntry;
}

var FileSystem: ~Object with { constructor(); };

export external public interface ~FileSystemDirectoryEntry extends FileSystemEntry {
	createReader(): FileSystemDirectoryReader;
	getDirectory(path: string = , options: FileSystemFlags = , successCallback: FileSystemEntryCallback = , errorCallback: ErrorCallback = ): void;
	getFile(path: string = , options: FileSystemFlags = , successCallback: FileSystemEntryCallback = , errorCallback: ErrorCallback = ): void;
}

var FileSystemDirectoryEntry: ~Object with { constructor(); };

export external public interface ~FileSystemDirectoryReader {
	readEntries(successCallback: FileSystemEntriesCallback, errorCallback: ErrorCallback = ): void;
}

var FileSystemDirectoryReader: ~Object with { constructor(); };

export external public interface ~FileSystemEntry {
	get filesystem(): FileSystem;
	get fullPath(): string;
	get isDirectory(): boolean;
	get isFile(): boolean;
	get name(): string;
	getParent(successCallback: FileSystemEntryCallback = , errorCallback: ErrorCallback = ): void;
}

var FileSystemEntry: ~Object with { constructor(); };

export external public interface ~FileSystemFileEntry extends FileSystemEntry {
	file(successCallback: FileCallback, errorCallback: ErrorCallback = ): void;
}

var FileSystemFileEntry: ~Object with { constructor(); };

export external public interface ~FocusEvent extends UIEvent {
	get relatedTarget(): EventTarget;
}

var FocusEvent: ~Object with { constructor(type: string, eventInitDict: FocusEventInit = ); };

export external public interface ~FontFace {
	ascentOverride: string;
	descentOverride: string;
	display: string;
	family: string;
	featureSettings: string;
	lineGapOverride: string;
	get loaded(): Promise<FontFace>;
	get status(): FontFaceLoadStatus;
	stretch: string;
	style: string;
	unicodeRange: string;
	variant: string;
	variationSettings: string;
	weight: string;
	load(): Promise<FontFace>;
}

var FontFace: ~Object with { constructor(family: string, source: string | BinaryData, descriptors: FontFaceDescriptors = ); };

export external public interface ~FontFaceSetEventMap {
	loading: Event;
	loadingdone: Event;
	loadingerror: Event;
}

export external public interface ~FontFaceSet extends EventTarget {
	onloading: ({@This(FontFaceSet) function(ev: Event): any});
	onloadingdone: ({@This(FontFaceSet) function(ev: Event): any});
	onloadingerror: ({@This(FontFaceSet) function(ev: Event): any});
	get ready(): Promise<FontFaceSet>;
	get status(): FontFaceSetLoadStatus;
	check(font: string, text: string = ): boolean;
	load(font: string, text: string = ): Promise<Array<FontFace>>;
	forEach(callbackfn: (value: FontFace, key: FontFace, parent: FontFaceSet)=>void, thisArg: any = ): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var FontFaceSet: ~Object with { constructor(initialFaces: Array<FontFace>); };

export external public interface ~FontFaceSetLoadEvent extends Event {
	get fontfaces(): ReadonlyArray<FontFace>;
}

var FontFaceSetLoadEvent: ~Object with { constructor(type: string, eventInitDict: FontFaceSetLoadEventInit = ); };

export external public interface ~FontFaceSource {
	get fonts(): FontFaceSet;
}

export external public interface ~FormData {
	append(name: string, value: string | Blob, fileName: string = ): void;
	delete(name: string): void;
	get(name: string): FormDataEntryValue;
	getAll(name: string): Array<FormDataEntryValue>;
	has(name: string): boolean;
	set(name: string, value: string | Blob, fileName: string = ): void;
	forEach(callbackfn: (value: FormDataEntryValue, key: string, parent: FormData)=>void, thisArg: any = ): void;
}

var FormData: ~Object with { constructor(form: HTMLFormElement = ); };

export external public interface ~FormDataEvent extends Event {
	get formData(): FormData;
}

var FormDataEvent: ~Object with { constructor(type: string, eventInitDict: FormDataEventInit); };

export external public interface ~GainNode extends AudioNode {
	get gain(): AudioParam;
}

var GainNode: ~Object with { constructor(context: BaseAudioContext, options: GainOptions = ); };

export external public interface ~Gamepad {
	get axes(): ReadonlyArray<number>;
	get buttons(): ReadonlyArray<GamepadButton>;
	get connected(): boolean;
	get hapticActuators(): ReadonlyArray<GamepadHapticActuator>;
	get id(): string;
	get index(): number;
	get mapping(): GamepadMappingType;
	get timestamp(): DOMHighResTimeStamp;
}

var Gamepad: ~Object with { constructor(); };

export external public interface ~GamepadButton {
	get pressed(): boolean;
	get touched(): boolean;
	get value(): number;
}

var GamepadButton: ~Object with { constructor(); };

export external public interface ~GamepadEvent extends Event {
	get gamepad(): Gamepad;
}

var GamepadEvent: ~Object with { constructor(type: string, eventInitDict: GamepadEventInit); };

export external public interface ~GamepadHapticActuator {
	get type(): GamepadHapticActuatorType;
}

var GamepadHapticActuator: ~Object with { constructor(); };

export external public interface ~GenericTransformStream {
	get readable(): ReadableStream;
	get writable(): WritableStream;
}

export external public interface ~Geolocation {
	clearWatch(watchId: number): void;
	getCurrentPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback = , options: PositionOptions = ): void;
	watchPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback = , options: PositionOptions = ): number;
}

var Geolocation: ~Object with { constructor(); };

export external public interface ~GeolocationCoordinates {
	get accuracy(): number;
	get altitude(): number;
	get altitudeAccuracy(): number;
	get heading(): number;
	get latitude(): number;
	get longitude(): number;
	get speed(): number;
}

var GeolocationCoordinates: ~Object with { constructor(); };

export external public interface ~GeolocationPosition {
	get coords(): GeolocationCoordinates;
	get timestamp(): DOMTimeStamp;
}

var GeolocationPosition: ~Object with { constructor(); };

export external public interface ~GeolocationPositionError {
	get code(): number;
	get message(): string;
	get PERMISSION_DENIED(): number;
	get POSITION_UNAVAILABLE(): number;
	get TIMEOUT(): number;
}

var GeolocationPositionError: ~Object with { constructor(); get PERMISSION_DENIED(): number; get POSITION_UNAVAILABLE(): number; get TIMEOUT(): number; };

export external public interface ~GlobalEventHandlersEventMap {
	abort: UIEvent;
	animationcancel: AnimationEvent;
	animationend: AnimationEvent;
	animationiteration: AnimationEvent;
	animationstart: AnimationEvent;
	auxclick: MouseEvent;
	beforeinput: InputEvent;
	blur: FocusEvent;
	canplay: Event;
	canplaythrough: Event;
	change: Event;
	click: MouseEvent;
	close: Event;
	compositionend: CompositionEvent;
	compositionstart: CompositionEvent;
	compositionupdate: CompositionEvent;
	contextmenu: MouseEvent;
	cuechange: Event;
	dblclick: MouseEvent;
	drag: DragEvent;
	dragend: DragEvent;
	dragenter: DragEvent;
	dragleave: DragEvent;
	dragover: DragEvent;
	dragstart: DragEvent;
	drop: DragEvent;
	durationchange: Event;
	emptied: Event;
	ended: Event;
	error: ErrorEvent;
	focus: FocusEvent;
	focusin: FocusEvent;
	focusout: FocusEvent;
	formdata: FormDataEvent;
	gotpointercapture: PointerEvent;
	input: Event;
	invalid: Event;
	keydown: KeyboardEvent;
	keypress: KeyboardEvent;
	keyup: KeyboardEvent;
	load: Event;
	loadeddata: Event;
	loadedmetadata: Event;
	loadstart: Event;
	lostpointercapture: PointerEvent;
	mousedown: MouseEvent;
	mouseenter: MouseEvent;
	mouseleave: MouseEvent;
	mousemove: MouseEvent;
	mouseout: MouseEvent;
	mouseover: MouseEvent;
	mouseup: MouseEvent;
	pause: Event;
	play: Event;
	playing: Event;
	pointercancel: PointerEvent;
	pointerdown: PointerEvent;
	pointerenter: PointerEvent;
	pointerleave: PointerEvent;
	pointermove: PointerEvent;
	pointerout: PointerEvent;
	pointerover: PointerEvent;
	pointerup: PointerEvent;
	progress: ProgressEvent;
	ratechange: Event;
	reset: Event;
	resize: UIEvent;
	scroll: Event;
	securitypolicyviolation: SecurityPolicyViolationEvent;
	seeked: Event;
	seeking: Event;
	select: Event;
	selectionchange: Event;
	selectstart: Event;
	stalled: Event;
	submit: SubmitEvent;
	suspend: Event;
	timeupdate: Event;
	toggle: Event;
	touchcancel: TouchEvent;
	touchend: TouchEvent;
	touchmove: TouchEvent;
	touchstart: TouchEvent;
	transitioncancel: TransitionEvent;
	transitionend: TransitionEvent;
	transitionrun: TransitionEvent;
	transitionstart: TransitionEvent;
	volumechange: Event;
	waiting: Event;
	webkitanimationend: Event;
	webkitanimationiteration: Event;
	webkitanimationstart: Event;
	webkittransitionend: Event;
	wheel: WheelEvent;
}

export external public interface ~GlobalEventHandlers {
	onabort: ({@This(GlobalEventHandlers) function(ev: UIEvent): any});
	onanimationcancel: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onanimationend: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onanimationiteration: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onanimationstart: ({@This(GlobalEventHandlers) function(ev: AnimationEvent): any});
	onauxclick: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onblur: ({@This(GlobalEventHandlers) function(ev: FocusEvent): any});
	oncanplay: ({@This(GlobalEventHandlers) function(ev: Event): any});
	oncanplaythrough: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onchange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onclick: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onclose: ({@This(GlobalEventHandlers) function(ev: Event): any});
	oncontextmenu: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	oncuechange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ondblclick: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	ondrag: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragend: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragenter: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragleave: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragover: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondragstart: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondrop: ({@This(GlobalEventHandlers) function(ev: DragEvent): any});
	ondurationchange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onemptied: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onended: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onerror: OnErrorEventHandler;
	onfocus: ({@This(GlobalEventHandlers) function(ev: FocusEvent): any});
	onformdata: ({@This(GlobalEventHandlers) function(ev: FormDataEvent): any});
	ongotpointercapture: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	oninput: ({@This(GlobalEventHandlers) function(ev: Event): any});
	oninvalid: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onkeydown: ({@This(GlobalEventHandlers) function(ev: KeyboardEvent): any});
	onkeypress: ({@This(GlobalEventHandlers) function(ev: KeyboardEvent): any});
	onkeyup: ({@This(GlobalEventHandlers) function(ev: KeyboardEvent): any});
	onload: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onloadeddata: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onloadedmetadata: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onloadstart: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onlostpointercapture: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onmousedown: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseenter: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseleave: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmousemove: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseout: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseover: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onmouseup: ({@This(GlobalEventHandlers) function(ev: MouseEvent): any});
	onpause: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onplay: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onplaying: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onpointercancel: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerdown: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerenter: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerleave: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointermove: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerout: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerover: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onpointerup: ({@This(GlobalEventHandlers) function(ev: PointerEvent): any});
	onprogress: ({@This(GlobalEventHandlers) function(ev: ProgressEvent): any});
	onratechange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onreset: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onresize: ({@This(GlobalEventHandlers) function(ev: UIEvent): any});
	onscroll: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onseeked: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onseeking: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onselect: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onselectionchange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onselectstart: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onstalled: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onsubmit: ({@This(GlobalEventHandlers) function(ev: SubmitEvent): any});
	onsuspend: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ontimeupdate: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ontoggle: ({@This(GlobalEventHandlers) function(ev: Event): any});
	ontouchcancel?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontouchend?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontouchmove?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontouchstart?: ({@This(GlobalEventHandlers) function(ev: TouchEvent): any});
	ontransitioncancel: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	ontransitionend: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	ontransitionrun: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	ontransitionstart: ({@This(GlobalEventHandlers) function(ev: TransitionEvent): any});
	onvolumechange: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwaiting: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkitanimationend: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkitanimationiteration: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkitanimationstart: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwebkittransitionend: ({@This(GlobalEventHandlers) function(ev: Event): any});
	onwheel: ({@This(GlobalEventHandlers) function(ev: WheelEvent): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~HTMLAllCollection {
	get length(): number;
	item(nameOrIndex: string = ): HTMLCollection | Element;
	namedItem(name: string): HTMLCollection | Element;
}

var HTMLAllCollection: ~Object with { constructor(); };

export external public interface ~HTMLAnchorElement extends HTMLElement, HTMLHyperlinkElementUtils {
	charset: string;
	coords: string;
	download: string;
	hreflang: string;
	name: string;
	ping: string;
	referrerPolicy: string;
	rel: string;
	get relList(): DOMTokenList;
	rev: string;
	shape: string;
	target: string;
	text: string;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLAnchorElement: ~Object with { constructor(); };

export external public interface ~HTMLAreaElement extends HTMLElement, HTMLHyperlinkElementUtils {
	alt: string;
	coords: string;
	download: string;
	noHref: boolean;
	ping: string;
	referrerPolicy: string;
	rel: string;
	get relList(): DOMTokenList;
	shape: string;
	target: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLAreaElement: ~Object with { constructor(); };

export external public interface ~HTMLAudioElement extends HTMLMediaElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLAudioElement: ~Object with { constructor(); };

export external public interface ~HTMLBRElement extends HTMLElement {
	clear: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLBRElement: ~Object with { constructor(); };

export external public interface ~HTMLBaseElement extends HTMLElement {
	href: string;
	target: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLBaseElement: ~Object with { constructor(); };

export external public interface ~HTMLBodyElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {
	orientationchange: Event;
}

export external public interface ~HTMLBodyElement extends HTMLElement, WindowEventHandlers {
	aLink: string;
	background: string;
	bgColor: string;
	link: string;
	onorientationchange: ({@This(HTMLBodyElement) function(ev: Event): any});
	text: string;
	vLink: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLBodyElement: ~Object with { constructor(); };

export external public interface ~HTMLButtonElement extends HTMLElement {
	disabled: boolean;
	get form(): HTMLFormElement;
	formAction: string;
	formEnctype: string;
	formMethod: string;
	formNoValidate: boolean;
	formTarget: string;
	get labels(): NodeListOf<HTMLLabelElement>;
	name: string;
	type: string;
	get validationMessage(): string;
	get validity(): ValidityState;
	value: string;
	get willValidate(): boolean;
	checkValidity(): boolean;
	reportValidity(): boolean;
	setCustomValidity(error: string): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLButtonElement: ~Object with { constructor(); };

export external public interface ~HTMLCanvasElement extends HTMLElement {
	height: number;
	width: number;
	captureStream(frameRequestRate: number = ): MediaStream;
	getContext(...args: any+): any+; // overloading not supported
	toBlob(callback: BlobCallback, type: string = , quality: any = ): void;
	toDataURL(type: string = , quality: any = ): string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLCanvasElement: ~Object with { constructor(); };

export external public interface ~HTMLCollectionBase {
	get length(): number;
	item(index: number): Element;
}

export external public interface ~HTMLCollection extends HTMLCollectionBase {
	namedItem(name: string): Element;
}

var HTMLCollection: ~Object with { constructor(); };

export external public interface ~HTMLCollectionOf<T> extends HTMLCollectionBase {
	item(index: number): T;
	namedItem(name: string): T;
}

export external public interface ~HTMLDListElement extends HTMLElement {
	compact: boolean;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLDListElement: ~Object with { constructor(); };

export external public interface ~HTMLDataElement extends HTMLElement {
	value: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLDataElement: ~Object with { constructor(); };

export external public interface ~HTMLDataListElement extends HTMLElement {
	get options(): HTMLCollectionOf<HTMLOptionElement>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLDataListElement: ~Object with { constructor(); };

export external public interface ~HTMLDetailsElement extends HTMLElement {
	open: boolean;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLDetailsElement: ~Object with { constructor(); };

export external public interface ~HTMLDialogElement extends HTMLElement {
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~HTMLDirectoryElement extends HTMLElement {
	compact: boolean;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLDirectoryElement: ~Object with { constructor(); };

export external public interface ~HTMLDivElement extends HTMLElement {
	align: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLDivElement: ~Object with { constructor(); };

export external public interface ~HTMLDocument extends Document {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLDocument: ~Object with { constructor(); };

export external public interface ~HTMLElementEventMap extends ElementEventMap, DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {}

export external public interface ~HTMLElement extends Element, DocumentAndElementEventHandlers, ElementCSSInlineStyle, ElementContentEditable, GlobalEventHandlers, HTMLOrSVGElement {
	accessKey: string;
	get accessKeyLabel(): string;
	autocapitalize: string;
	dir: string;
	draggable: boolean;
	hidden: boolean;
	innerText: string;
	lang: string;
	get offsetHeight(): number;
	get offsetLeft(): number;
	get offsetParent(): Element;
	get offsetTop(): number;
	get offsetWidth(): number;
	outerText: string;
	spellcheck: boolean;
	title: string;
	translate: boolean;
	click(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLElement: ~Object with { constructor(); };

export external public interface ~HTMLEmbedElement extends HTMLElement {
	align: string;
	height: string;
	name: string;
	src: string;
	type: string;
	width: string;
	getSVGDocument(): Document;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLEmbedElement: ~Object with { constructor(); };

export external public interface ~HTMLFieldSetElement extends HTMLElement {
	disabled: boolean;
	get elements(): HTMLCollection;
	get form(): HTMLFormElement;
	name: string;
	get type(): string;
	get validationMessage(): string;
	get validity(): ValidityState;
	get willValidate(): boolean;
	checkValidity(): boolean;
	reportValidity(): boolean;
	setCustomValidity(error: string): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLFieldSetElement: ~Object with { constructor(); };

export external public interface ~HTMLFontElement extends HTMLElement {
	color: string;
	face: string;
	size: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLFontElement: ~Object with { constructor(); };

export external public interface ~HTMLFormControlsCollection extends HTMLCollectionBase {
	namedItem(name: string): RadioNodeList | Element;
}

var HTMLFormControlsCollection: ~Object with { constructor(); };

export external public interface ~HTMLFormElement extends HTMLElement {
	acceptCharset: string;
	action: string;
	autocomplete: string;
	get elements(): HTMLFormControlsCollection;
	encoding: string;
	enctype: string;
	get length(): number;
	method: string;
	name: string;
	noValidate: boolean;
	target: string;
	checkValidity(): boolean;
	reportValidity(): boolean;
	requestSubmit(submitter: HTMLElement = ): void;
	reset(): void;
	submit(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLFormElement: ~Object with { constructor(); };

export external public interface ~HTMLFrameElement extends HTMLElement {
	get contentDocument(): Document;
	get contentWindow(): WindowProxy;
	frameBorder: string;
	longDesc: string;
	marginHeight: string;
	marginWidth: string;
	name: string;
	noResize: boolean;
	scrolling: string;
	src: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLFrameElement: ~Object with { constructor(); };

export external public interface ~HTMLFrameSetElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {}

export external public interface ~HTMLFrameSetElement extends HTMLElement, WindowEventHandlers {
	cols: string;
	rows: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLFrameSetElement: ~Object with { constructor(); };

export external public interface ~HTMLHRElement extends HTMLElement {
	align: string;
	color: string;
	noShade: boolean;
	size: string;
	width: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLHRElement: ~Object with { constructor(); };

export external public interface ~HTMLHeadElement extends HTMLElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLHeadElement: ~Object with { constructor(); };

export external public interface ~HTMLHeadingElement extends HTMLElement {
	align: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLHeadingElement: ~Object with { constructor(); };

export external public interface ~HTMLHtmlElement extends HTMLElement {
	version: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLHtmlElement: ~Object with { constructor(); };

export external public interface ~HTMLHyperlinkElementUtils {
	hash: string;
	host: string;
	hostname: string;
	href: string;
	toString(): string;
	get origin(): string;
	password: string;
	pathname: string;
	port: string;
	protocol: string;
	search: string;
	username: string;
}

export external public interface ~HTMLIFrameElement extends HTMLElement {
	align: string;
	allow: string;
	allowFullscreen: boolean;
	get contentDocument(): Document;
	get contentWindow(): WindowProxy;
	frameBorder: string;
	height: string;
	longDesc: string;
	marginHeight: string;
	marginWidth: string;
	name: string;
	referrerPolicy: ReferrerPolicy;
	get sandbox(): DOMTokenList;
	scrolling: string;
	src: string;
	srcdoc: string;
	width: string;
	getSVGDocument(): Document;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLIFrameElement: ~Object with { constructor(); };

export external public interface ~HTMLImageElement extends HTMLElement {
	align: string;
	alt: string;
	border: string;
	get complete(): boolean;
	crossOrigin: string;
	get currentSrc(): string;
	decoding: "async" | "sync" | "auto";
	height: number;
	hspace: number;
	isMap: boolean;
	loading: string;
	longDesc: string;
	lowsrc: string;
	name: string;
	get naturalHeight(): number;
	get naturalWidth(): number;
	referrerPolicy: string;
	sizes: string;
	src: string;
	srcset: string;
	useMap: string;
	vspace: number;
	width: number;
	get x(): number;
	get y(): number;
	decode(): Promise<undefined>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLImageElement: ~Object with { constructor(); };

export external public interface ~HTMLInputElement extends HTMLElement {
	accept: string;
	align: string;
	alt: string;
	autocomplete: string;
	capture: string;
	checked: boolean;
	defaultChecked: boolean;
	defaultValue: string;
	dirName: string;
	disabled: boolean;
	files: FileList;
	get form(): HTMLFormElement;
	formAction: string;
	formEnctype: string;
	formMethod: string;
	formNoValidate: boolean;
	formTarget: string;
	height: number;
	indeterminate: boolean;
	get labels(): NodeListOf<HTMLLabelElement>;
	get list(): HTMLElement;
	max: string;
	maxLength: number;
	min: string;
	minLength: number;
	multiple: boolean;
	name: string;
	pattern: string;
	placeholder: string;
	readOnly: boolean;
	required: boolean;
	selectionDirection: "forward" | "backward" | "none";
	selectionEnd: number;
	selectionStart: number;
	size: number;
	src: string;
	step: string;
	type: string;
	useMap: string;
	get validationMessage(): string;
	get validity(): ValidityState;
	value: string;
	valueAsDate: Date;
	valueAsNumber: number;
	get webkitEntries(): ReadonlyArray<FileSystemEntry>;
	webkitdirectory: boolean;
	width: number;
	get willValidate(): boolean;
	checkValidity(): boolean;
	reportValidity(): boolean;
	select(): void;
	setCustomValidity(error: string): void;
	setRangeText(...args: any+): any+; // overloading not supported
	setSelectionRange(start: number, end: number, direction: "forward" | "backward" | "none" = ): void;
	stepDown(n: number = ): void;
	stepUp(n: number = ): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLInputElement: ~Object with { constructor(); };

export external public interface ~HTMLLIElement extends HTMLElement {
	type: string;
	value: number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLLIElement: ~Object with { constructor(); };

export external public interface ~HTMLLabelElement extends HTMLElement {
	get control(): HTMLElement;
	get form(): HTMLFormElement;
	htmlFor: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLLabelElement: ~Object with { constructor(); };

export external public interface ~HTMLLegendElement extends HTMLElement {
	align: string;
	get form(): HTMLFormElement;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLLegendElement: ~Object with { constructor(); };

export external public interface ~HTMLLinkElement extends HTMLElement, LinkStyle {
	as: string;
	charset: string;
	crossOrigin: string;
	disabled: boolean;
	href: string;
	hreflang: string;
	imageSizes: string;
	imageSrcset: string;
	integrity: string;
	media: string;
	referrerPolicy: string;
	rel: string;
	get relList(): DOMTokenList;
	rev: string;
	get sizes(): DOMTokenList;
	target: string;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLLinkElement: ~Object with { constructor(); };

export external public interface ~HTMLMapElement extends HTMLElement {
	get areas(): HTMLCollection;
	name: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLMapElement: ~Object with { constructor(); };

export external public interface ~HTMLMarqueeElement extends HTMLElement {
	behavior: string;
	bgColor: string;
	direction: string;
	height: string;
	hspace: number;
	loop: number;
	scrollAmount: number;
	scrollDelay: number;
	trueSpeed: boolean;
	vspace: number;
	width: string;
	start(): void;
	stop(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLMarqueeElement: ~Object with { constructor(); };

export external public interface ~HTMLMediaElementEventMap extends HTMLElementEventMap {
	encrypted: MediaEncryptedEvent;
	waitingforkey: Event;
}

export external public interface ~HTMLMediaElement extends HTMLElement {
	autoplay: boolean;
	get buffered(): TimeRanges;
	controls: boolean;
	crossOrigin: string;
	get currentSrc(): string;
	currentTime: number;
	defaultMuted: boolean;
	defaultPlaybackRate: number;
	disableRemotePlayback: boolean;
	get duration(): number;
	get ended(): boolean;
	get error(): MediaError;
	loop: boolean;
	get mediaKeys(): MediaKeys;
	muted: boolean;
	get networkState(): number;
	onencrypted: ({@This(HTMLMediaElement) function(ev: MediaEncryptedEvent): any});
	onwaitingforkey: ({@This(HTMLMediaElement) function(ev: Event): any});
	get paused(): boolean;
	playbackRate: number;
	get played(): TimeRanges;
	preload: "none" | "metadata" | "auto" | "";
	get readyState(): number;
	get remote(): RemotePlayback;
	get seekable(): TimeRanges;
	get seeking(): boolean;
	src: string;
	srcObject: MediaProvider;
	get textTracks(): TextTrackList;
	volume: number;
	addTextTrack(kind: TextTrackKind, label: string = , language: string = ): TextTrack;
	canPlayType(type: string): CanPlayTypeResult;
	fastSeek(time: number): void;
	load(): void;
	pause(): void;
	play(): Promise<undefined>;
	setMediaKeys(mediaKeys: MediaKeys): Promise<undefined>;
	get HAVE_CURRENT_DATA(): number;
	get HAVE_ENOUGH_DATA(): number;
	get HAVE_FUTURE_DATA(): number;
	get HAVE_METADATA(): number;
	get HAVE_NOTHING(): number;
	get NETWORK_EMPTY(): number;
	get NETWORK_IDLE(): number;
	get NETWORK_LOADING(): number;
	get NETWORK_NO_SOURCE(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLMediaElement: ~Object with { constructor(); get HAVE_CURRENT_DATA(): number; get HAVE_ENOUGH_DATA(): number; get HAVE_FUTURE_DATA(): number; get HAVE_METADATA(): number; get HAVE_NOTHING(): number; get NETWORK_EMPTY(): number; get NETWORK_IDLE(): number; get NETWORK_LOADING(): number; get NETWORK_NO_SOURCE(): number; };

export external public interface ~HTMLMenuElement extends HTMLElement {
	compact: boolean;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLMenuElement: ~Object with { constructor(); };

export external public interface ~HTMLMetaElement extends HTMLElement {
	content: string;
	httpEquiv: string;
	name: string;
	scheme: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLMetaElement: ~Object with { constructor(); };

export external public interface ~HTMLMeterElement extends HTMLElement {
	high: number;
	get labels(): NodeListOf<HTMLLabelElement>;
	low: number;
	max: number;
	min: number;
	optimum: number;
	value: number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLMeterElement: ~Object with { constructor(); };

export external public interface ~HTMLModElement extends HTMLElement {
	cite: string;
	dateTime: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLModElement: ~Object with { constructor(); };

export external public interface ~HTMLOListElement extends HTMLElement {
	compact: boolean;
	reversed: boolean;
	start: number;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLOListElement: ~Object with { constructor(); };

export external public interface ~HTMLObjectElement extends HTMLElement {
	align: string;
	archive: string;
	border: string;
	code: string;
	codeBase: string;
	codeType: string;
	get contentDocument(): Document;
	get contentWindow(): WindowProxy;
	data: string;
	declare: boolean;
	get form(): HTMLFormElement;
	height: string;
	hspace: number;
	name: string;
	standby: string;
	type: string;
	useMap: string;
	get validationMessage(): string;
	get validity(): ValidityState;
	vspace: number;
	width: string;
	get willValidate(): boolean;
	checkValidity(): boolean;
	getSVGDocument(): Document;
	reportValidity(): boolean;
	setCustomValidity(error: string): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLObjectElement: ~Object with { constructor(); };

export external public interface ~HTMLOptGroupElement extends HTMLElement {
	disabled: boolean;
	label: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLOptGroupElement: ~Object with { constructor(); };

export external public interface ~HTMLOptionElement extends HTMLElement {
	defaultSelected: boolean;
	disabled: boolean;
	get form(): HTMLFormElement;
	get index(): number;
	label: string;
	selected: boolean;
	text: string;
	value: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLOptionElement: ~Object with { constructor(); };

export external public interface ~HTMLOptionsCollection extends HTMLCollectionOf<HTMLOptionElement> {
	@Override
	length: number;
	selectedIndex: number;
	add(element: HTMLOptionElement | HTMLOptGroupElement, before: HTMLElement | number = ): void;
	remove(index: number): void;
}

var HTMLOptionsCollection: ~Object with { constructor(); };

export external public interface ~HTMLOrSVGElement {
	autofocus: boolean;
	get dataset(): DOMStringMap;
	nonce?: string;
	tabIndex: number;
	blur(): void;
	focus(options: FocusOptions = ): void;
}

export external public interface ~HTMLOutputElement extends HTMLElement {
	defaultValue: string;
	get form(): HTMLFormElement;
	get htmlFor(): DOMTokenList;
	get labels(): NodeListOf<HTMLLabelElement>;
	name: string;
	get type(): string;
	get validationMessage(): string;
	get validity(): ValidityState;
	value: string;
	get willValidate(): boolean;
	checkValidity(): boolean;
	reportValidity(): boolean;
	setCustomValidity(error: string): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLOutputElement: ~Object with { constructor(); };

export external public interface ~HTMLParagraphElement extends HTMLElement {
	align: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLParagraphElement: ~Object with { constructor(); };

export external public interface ~HTMLParamElement extends HTMLElement {
	name: string;
	type: string;
	value: string;
	valueType: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLParamElement: ~Object with { constructor(); };

export external public interface ~HTMLPictureElement extends HTMLElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLPictureElement: ~Object with { constructor(); };

export external public interface ~HTMLPreElement extends HTMLElement {
	width: number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLPreElement: ~Object with { constructor(); };

export external public interface ~HTMLProgressElement extends HTMLElement {
	get labels(): NodeListOf<HTMLLabelElement>;
	max: number;
	get position(): number;
	value: number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLProgressElement: ~Object with { constructor(); };

export external public interface ~HTMLQuoteElement extends HTMLElement {
	cite: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLQuoteElement: ~Object with { constructor(); };

export external public interface ~HTMLScriptElement extends HTMLElement {
	async: boolean;
	charset: string;
	crossOrigin: string;
	defer: boolean;
	event: string;
	htmlFor: string;
	integrity: string;
	noModule: boolean;
	referrerPolicy: string;
	src: string;
	text: string;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLScriptElement: ~Object with { constructor(); };

export external public interface ~HTMLSelectElement extends HTMLElement {
	autocomplete: string;
	disabled: boolean;
	get form(): HTMLFormElement;
	get labels(): NodeListOf<HTMLLabelElement>;
	length: number;
	multiple: boolean;
	name: string;
	get options(): HTMLOptionsCollection;
	required: boolean;
	selectedIndex: number;
	get selectedOptions(): HTMLCollectionOf<HTMLOptionElement>;
	size: number;
	get type(): string;
	get validationMessage(): string;
	get validity(): ValidityState;
	value: string;
	get willValidate(): boolean;
	add(element: HTMLOptionElement | HTMLOptGroupElement, before: HTMLElement | number = ): void;
	checkValidity(): boolean;
	item(index: number): HTMLOptionElement;
	namedItem(name: string): HTMLOptionElement;
	@Override
	remove(...args: any+): any+; // overloading not supported
	reportValidity(): boolean;
	setCustomValidity(error: string): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLSelectElement: ~Object with { constructor(); };

export external public interface ~HTMLSlotElement extends HTMLElement {
	name: string;
	assignedElements(options: AssignedNodesOptions = ): Array<Element>;
	assignedNodes(options: AssignedNodesOptions = ): Array<Node>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLSlotElement: ~Object with { constructor(); };

export external public interface ~HTMLSourceElement extends HTMLElement {
	media: string;
	sizes: string;
	src: string;
	srcset: string;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLSourceElement: ~Object with { constructor(); };

export external public interface ~HTMLSpanElement extends HTMLElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLSpanElement: ~Object with { constructor(); };

export external public interface ~HTMLStyleElement extends HTMLElement, LinkStyle {
	media: string;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLStyleElement: ~Object with { constructor(); };

export external public interface ~HTMLTableCaptionElement extends HTMLElement {
	align: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTableCaptionElement: ~Object with { constructor(); };

export external public interface ~HTMLTableCellElement extends HTMLElement {
	abbr: string;
	align: string;
	axis: string;
	bgColor: string;
	get cellIndex(): number;
	ch: string;
	chOff: string;
	colSpan: number;
	headers: string;
	height: string;
	noWrap: boolean;
	rowSpan: number;
	scope: string;
	vAlign: string;
	width: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTableCellElement: ~Object with { constructor(); };

export external public interface ~HTMLTableColElement extends HTMLElement {
	align: string;
	ch: string;
	chOff: string;
	span: number;
	vAlign: string;
	width: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTableColElement: ~Object with { constructor(); };

export external public interface ~HTMLTableDataCellElement extends HTMLTableCellElement {
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~HTMLTableElement extends HTMLElement {
	align: string;
	bgColor: string;
	border: string;
	caption: HTMLTableCaptionElement;
	cellPadding: string;
	cellSpacing: string;
	frame: string;
	get rows(): HTMLCollectionOf<HTMLTableRowElement>;
	rules: string;
	summary: string;
	get tBodies(): HTMLCollectionOf<HTMLTableSectionElement>;
	tFoot: HTMLTableSectionElement;
	tHead: HTMLTableSectionElement;
	width: string;
	createCaption(): HTMLTableCaptionElement;
	createTBody(): HTMLTableSectionElement;
	createTFoot(): HTMLTableSectionElement;
	createTHead(): HTMLTableSectionElement;
	deleteCaption(): void;
	deleteRow(index: number): void;
	deleteTFoot(): void;
	deleteTHead(): void;
	insertRow(index: number = ): HTMLTableRowElement;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTableElement: ~Object with { constructor(); };

export external public interface ~HTMLTableHeaderCellElement extends HTMLTableCellElement {
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~HTMLTableRowElement extends HTMLElement {
	align: string;
	bgColor: string;
	get cells(): HTMLCollectionOf<HTMLTableCellElement>;
	ch: string;
	chOff: string;
	get rowIndex(): number;
	get sectionRowIndex(): number;
	vAlign: string;
	deleteCell(index: number): void;
	insertCell(index: number = ): HTMLTableCellElement;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTableRowElement: ~Object with { constructor(); };

export external public interface ~HTMLTableSectionElement extends HTMLElement {
	align: string;
	ch: string;
	chOff: string;
	get rows(): HTMLCollectionOf<HTMLTableRowElement>;
	vAlign: string;
	deleteRow(index: number): void;
	insertRow(index: number = ): HTMLTableRowElement;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTableSectionElement: ~Object with { constructor(); };

export external public interface ~HTMLTemplateElement extends HTMLElement {
	get content(): DocumentFragment;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTemplateElement: ~Object with { constructor(); };

export external public interface ~HTMLTextAreaElement extends HTMLElement {
	autocomplete: string;
	cols: number;
	defaultValue: string;
	dirName: string;
	disabled: boolean;
	get form(): HTMLFormElement;
	get labels(): NodeListOf<HTMLLabelElement>;
	maxLength: number;
	minLength: number;
	name: string;
	placeholder: string;
	readOnly: boolean;
	required: boolean;
	rows: number;
	selectionDirection: "forward" | "backward" | "none";
	selectionEnd: number;
	selectionStart: number;
	get textLength(): number;
	get type(): string;
	get validationMessage(): string;
	get validity(): ValidityState;
	value: string;
	get willValidate(): boolean;
	wrap: string;
	checkValidity(): boolean;
	reportValidity(): boolean;
	select(): void;
	setCustomValidity(error: string): void;
	setRangeText(...args: any+): any+; // overloading not supported
	setSelectionRange(start: number, end: number, direction: "forward" | "backward" | "none" = ): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTextAreaElement: ~Object with { constructor(); };

export external public interface ~HTMLTimeElement extends HTMLElement {
	dateTime: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTimeElement: ~Object with { constructor(); };

export external public interface ~HTMLTitleElement extends HTMLElement {
	text: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTitleElement: ~Object with { constructor(); };

export external public interface ~HTMLTrackElement extends HTMLElement {
	default: boolean;
	kind: string;
	label: string;
	get readyState(): number;
	src: string;
	srclang: string;
	get track(): TextTrack;
	get ERROR(): number;
	get LOADED(): number;
	get LOADING(): number;
	get NONE(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLTrackElement: ~Object with { constructor(); get ERROR(): number; get LOADED(): number; get LOADING(): number; get NONE(): number; };

export external public interface ~HTMLUListElement extends HTMLElement {
	compact: boolean;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLUListElement: ~Object with { constructor(); };

export external public interface ~HTMLUnknownElement extends HTMLElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLUnknownElement: ~Object with { constructor(); };

export external public interface ~HTMLVideoElementEventMap extends HTMLMediaElementEventMap {
	enterpictureinpicture: Event;
	leavepictureinpicture: Event;
}

export external public interface ~HTMLVideoElement extends HTMLMediaElement {
	disablePictureInPicture: boolean;
	height: number;
	onenterpictureinpicture: ({@This(HTMLVideoElement) function(ev: Event): any});
	onleavepictureinpicture: ({@This(HTMLVideoElement) function(ev: Event): any});
	playsInline: boolean;
	poster: string;
	get videoHeight(): number;
	get videoWidth(): number;
	width: number;
	getVideoPlaybackQuality(): VideoPlaybackQuality;
	requestPictureInPicture(): Promise<PictureInPictureWindow>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var HTMLVideoElement: ~Object with { constructor(); };

export external public interface ~HashChangeEvent extends Event {
	get newURL(): string;
	get oldURL(): string;
}

var HashChangeEvent: ~Object with { constructor(type: string, eventInitDict: HashChangeEventInit = ); };

export external public interface ~Headers {
	append(name: string, value: string): void;
	delete(name: string): void;
	get(name: string): string;
	has(name: string): boolean;
	set(name: string, value: string): void;
	forEach(callbackfn: (value: string, key: string, parent: Headers)=>void, thisArg: any = ): void;
}

var Headers: ~Object with { constructor(init: HeadersInit = ); };

export external public interface ~History {
	get length(): number;
	scrollRestoration: ScrollRestoration;
	get state(): any;
	back(): void;
	forward(): void;
	go(delta: number = ): void;
	pushState(data: any, unused: string, url: string | URL = ): void;
	replaceState(data: any, unused: string, url: string | URL = ): void;
}

var History: ~Object with { constructor(); };

export external public interface ~IDBCursor {
	get direction(): IDBCursorDirection;
	get key(): IDBValidKey;
	get primaryKey(): IDBValidKey;
	get request(): IDBRequest;
	get source(): IDBObjectStore | IDBIndex;
	advance(count: number): void;
	continue(key: IDBValidKey = ): void;
	continuePrimaryKey(key: IDBValidKey, primaryKey: IDBValidKey): void;
	delete(): IDBRequest<undefined>;
	update(value: any): IDBRequest<IDBValidKey>;
}

var IDBCursor: ~Object with { constructor(); };

export external public interface ~IDBCursorWithValue extends IDBCursor {
	get value(): any;
}

var IDBCursorWithValue: ~Object with { constructor(); };

export external public interface ~IDBDatabaseEventMap {
	abort: Event;
	close: Event;
	error: Event;
	versionchange: IDBVersionChangeEvent;
}

export external public interface ~IDBDatabase extends EventTarget {
	get name(): string;
	get objectStoreNames(): DOMStringList;
	onabort: ({@This(IDBDatabase) function(ev: Event): any});
	onclose: ({@This(IDBDatabase) function(ev: Event): any});
	onerror: ({@This(IDBDatabase) function(ev: Event): any});
	onversionchange: ({@This(IDBDatabase) function(ev: IDBVersionChangeEvent): any});
	get version(): number;
	close(): void;
	createObjectStore(name: string, options: IDBObjectStoreParameters = ): IDBObjectStore;
	deleteObjectStore(name: string): void;
	transaction(storeNames: string | Array<string>, mode: IDBTransactionMode = ): IDBTransaction;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var IDBDatabase: ~Object with { constructor(); };

export external public interface ~IDBFactory {
	cmp(first: any, second: any): number;
	databases(): Promise<Array<IDBDatabaseInfo>>;
	deleteDatabase(name: string): IDBOpenDBRequest;
	open(name: string, version: number = ): IDBOpenDBRequest;
}

var IDBFactory: ~Object with { constructor(); };

export external public interface ~IDBIndex {
	get keyPath(): string | Array<string>;
	get multiEntry(): boolean;
	name: string;
	get objectStore(): IDBObjectStore;
	get unique(): boolean;
	count(query: IDBValidKey | IDBKeyRange = ): IDBRequest<number>;
	get(query: IDBValidKey | IDBKeyRange): IDBRequest<any>;
	getAll(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<any>>;
	getAllKeys(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<IDBValidKey>>;
	getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;
	openCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursorWithValue>;
	openKeyCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursor>;
}

var IDBIndex: ~Object with { constructor(); };

export external public interface ~IDBKeyRange {
	get lower(): any;
	get lowerOpen(): boolean;
	get upper(): any;
	get upperOpen(): boolean;
	includes(key: any): boolean;
}

var IDBKeyRange: ~Object with { constructor(); bound(lower: any, upper: any, lowerOpen: boolean = , upperOpen: boolean = ): IDBKeyRange; lowerBound(lower: any, open: boolean = ): IDBKeyRange; only(value: any): IDBKeyRange; upperBound(upper: any, open: boolean = ): IDBKeyRange; };

export external public interface ~IDBObjectStore {
	get autoIncrement(): boolean;
	get indexNames(): DOMStringList;
	get keyPath(): string | Array<string>;
	name: string;
	get transaction(): IDBTransaction;
	add(value: any, key: IDBValidKey = ): IDBRequest<IDBValidKey>;
	clear(): IDBRequest<undefined>;
	count(query: IDBValidKey | IDBKeyRange = ): IDBRequest<number>;
	createIndex(name: string, keyPath: string | Array<string>, options: IDBIndexParameters = ): IDBIndex;
	delete(query: IDBValidKey | IDBKeyRange): IDBRequest<undefined>;
	deleteIndex(name: string): void;
	get(query: IDBValidKey | IDBKeyRange): IDBRequest<any>;
	getAll(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<any>>;
	getAllKeys(query: IDBValidKey | IDBKeyRange = , count: number = ): IDBRequest<Array<IDBValidKey>>;
	getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;
	index(name: string): IDBIndex;
	openCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursorWithValue>;
	openKeyCursor(query: IDBValidKey | IDBKeyRange = , direction: IDBCursorDirection = ): IDBRequest<IDBCursor>;
	put(value: any, key: IDBValidKey = ): IDBRequest<IDBValidKey>;
}

var IDBObjectStore: ~Object with { constructor(); };

export external public interface ~IDBOpenDBRequestEventMap extends IDBRequestEventMap {
	blocked: Event;
	upgradeneeded: IDBVersionChangeEvent;
}

export external public interface ~IDBOpenDBRequest extends IDBRequest<IDBDatabase> {
	onblocked: ({@This(IDBOpenDBRequest) function(ev: Event): any});
	onupgradeneeded: ({@This(IDBOpenDBRequest) function(ev: IDBVersionChangeEvent): any});
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var IDBOpenDBRequest: ~Object with { constructor(); };

export external public interface ~IDBRequestEventMap {
	error: Event;
	success: Event;
}

export external public interface ~IDBRequest<T=any> extends EventTarget {
	get error(): DOMException;
	onerror: ({@This(IDBRequest<T>) function(ev: Event): any});
	onsuccess: ({@This(IDBRequest<T>) function(ev: Event): any});
	get readyState(): IDBRequestReadyState;
	get result(): T;
	get source(): IDBObjectStore | IDBIndex | IDBCursor;
	get transaction(): IDBTransaction;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var IDBRequest: ~Object with { constructor(); };

export external public interface ~IDBTransactionEventMap {
	abort: Event;
	complete: Event;
	error: Event;
}

export external public interface ~IDBTransaction extends EventTarget {
	get db(): IDBDatabase;
	get error(): DOMException;
	get mode(): IDBTransactionMode;
	get objectStoreNames(): DOMStringList;
	onabort: ({@This(IDBTransaction) function(ev: Event): any});
	oncomplete: ({@This(IDBTransaction) function(ev: Event): any});
	onerror: ({@This(IDBTransaction) function(ev: Event): any});
	abort(): void;
	commit(): void;
	objectStore(name: string): IDBObjectStore;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var IDBTransaction: ~Object with { constructor(); };

export external public interface ~IDBVersionChangeEvent extends Event {
	get newVersion(): number;
	get oldVersion(): number;
}

var IDBVersionChangeEvent: ~Object with { constructor(type: string, eventInitDict: IDBVersionChangeEventInit = ); };

export external public interface ~IIRFilterNode extends AudioNode {
	getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
}

var IIRFilterNode: ~Object with { constructor(context: BaseAudioContext, options: IIRFilterOptions); };

export external public interface ~IdleDeadline {
	get didTimeout(): boolean;
	timeRemaining(): DOMHighResTimeStamp;
}

var IdleDeadline: ~Object with { constructor(); };

export external public interface ~ImageBitmap {
	get height(): number;
	get width(): number;
	close(): void;
}

var ImageBitmap: ~Object with { constructor(); };

export external public interface ~ImageBitmapRenderingContext {
	get canvas(): HTMLCanvasElement;
	transferFromImageBitmap(bitmap: ImageBitmap): void;
}

var ImageBitmapRenderingContext: ~Object with { constructor(); };

export external public interface ~ImageData {
	get data(): Uint8ClampedArray;
	get height(): number;
	get width(): number;
}

var ImageData: ~Object with { constructor(...args: any+); /* <-- overloading not supported */ };

export external public interface ~InnerHTML {
	innerHTML: string;
}

export external public interface ~InputEvent extends UIEvent {
	get data(): string;
	get dataTransfer(): DataTransfer;
	get inputType(): string;
	get isComposing(): boolean;
	getTargetRanges(): Array<StaticRange>;
}

var InputEvent: ~Object with { constructor(type: string, eventInitDict: InputEventInit = ); };

export external public interface ~IntersectionObserver {
	get root(): Element | Document;
	get rootMargin(): string;
	get thresholds(): ReadonlyArray<number>;
	disconnect(): void;
	observe(target: Element): void;
	takeRecords(): Array<IntersectionObserverEntry>;
	unobserve(target: Element): void;
}

var IntersectionObserver: ~Object with { constructor(callback: IntersectionObserverCallback, options: IntersectionObserverInit = ); };

export external public interface ~IntersectionObserverEntry {
	get boundingClientRect(): DOMRectReadOnly;
	get intersectionRatio(): number;
	get intersectionRect(): DOMRectReadOnly;
	get isIntersecting(): boolean;
	get rootBounds(): DOMRectReadOnly;
	get target(): Element;
	get time(): DOMHighResTimeStamp;
}

var IntersectionObserverEntry: ~Object with { constructor(intersectionObserverEntryInit: IntersectionObserverEntryInit); };

export external public interface ~KHR_parallel_shader_compile {
	get COMPLETION_STATUS_KHR(): GLenum;
}

export external public interface ~KeyboardEvent extends UIEvent {
	get altKey(): boolean;
	get charCode(): number;
	get code(): string;
	get ctrlKey(): boolean;
	get isComposing(): boolean;
	get key(): string;
	get keyCode(): number;
	get location(): number;
	get metaKey(): boolean;
	get repeat(): boolean;
	get shiftKey(): boolean;
	getModifierState(keyArg: string): boolean;
	initKeyboardEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , viewArg: Window = , keyArg: string = , locationArg: number = , ctrlKey: boolean = , altKey: boolean = , shiftKey: boolean = , metaKey: boolean = ): void;
	get DOM_KEY_LOCATION_LEFT(): number;
	get DOM_KEY_LOCATION_NUMPAD(): number;
	get DOM_KEY_LOCATION_RIGHT(): number;
	get DOM_KEY_LOCATION_STANDARD(): number;
}

var KeyboardEvent: ~Object with { constructor(type: string, eventInitDict: KeyboardEventInit = ); get DOM_KEY_LOCATION_LEFT(): number; get DOM_KEY_LOCATION_NUMPAD(): number; get DOM_KEY_LOCATION_RIGHT(): number; get DOM_KEY_LOCATION_STANDARD(): number; };

export external public interface ~KeyframeEffect extends AnimationEffect {
	composite: CompositeOperation;
	iterationComposite: IterationCompositeOperation;
	pseudoElement: string;
	target: Element;
	getKeyframes(): Array<ComputedKeyframe>;
	setKeyframes(keyframes: Array<Keyframe> | PropertyIndexedKeyframes): void;
}

var KeyframeEffect: ~Object with { constructor(...args: any+); /* <-- overloading not supported */ };

export external public interface ~LinkStyle {
	get sheet(): CSSStyleSheet;
}

export external public interface ~Location {
	get ancestorOrigins(): DOMStringList;
	hash: string;
	host: string;
	hostname: string;
	href: string;
	toString(): string;
	get origin(): string;
	pathname: string;
	port: string;
	protocol: string;
	search: string;
	assign(url: string | URL): void;
	reload(): void;
	replace(url: string | URL): void;
}

var Location: ~Object with { constructor(); };

export external public interface ~MathMLElementEventMap extends ElementEventMap, DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {}

export external public interface ~MathMLElement extends Element, DocumentAndElementEventHandlers, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrSVGElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MathMLElement: ~Object with { constructor(); };

export external public interface ~MediaCapabilities {
	decodingInfo(configuration: MediaDecodingConfiguration): Promise<MediaCapabilitiesDecodingInfo>;
	encodingInfo(configuration: MediaEncodingConfiguration): Promise<MediaCapabilitiesEncodingInfo>;
}

var MediaCapabilities: ~Object with { constructor(); };

export external public interface ~MediaDeviceInfo {
	get deviceId(): string;
	get groupId(): string;
	get kind(): MediaDeviceKind;
	get label(): string;
	toJSON(): any;
}

var MediaDeviceInfo: ~Object with { constructor(); };

export external public interface ~MediaDevicesEventMap {
	devicechange: Event;
}

export external public interface ~MediaDevices extends EventTarget {
	ondevicechange: ({@This(MediaDevices) function(ev: Event): any});
	enumerateDevices(): Promise<Array<MediaDeviceInfo>>;
	getDisplayMedia(constraints: DisplayMediaStreamConstraints = ): Promise<MediaStream>;
	getSupportedConstraints(): MediaTrackSupportedConstraints;
	getUserMedia(constraints: MediaStreamConstraints = ): Promise<MediaStream>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MediaDevices: ~Object with { constructor(); };

export external public interface ~MediaElementAudioSourceNode extends AudioNode {
	get mediaElement(): HTMLMediaElement;
}

var MediaElementAudioSourceNode: ~Object with { constructor(context: AudioContext, options: MediaElementAudioSourceOptions); };

export external public interface ~MediaEncryptedEvent extends Event {
	get initData(): ArrayBuffer;
	get initDataType(): string;
}

var MediaEncryptedEvent: ~Object with { constructor(type: string, eventInitDict: MediaEncryptedEventInit = ); };

export external public interface ~MediaError {
	get code(): number;
	get message(): string;
	get MEDIA_ERR_ABORTED(): number;
	get MEDIA_ERR_DECODE(): number;
	get MEDIA_ERR_NETWORK(): number;
	get MEDIA_ERR_SRC_NOT_SUPPORTED(): number;
}

var MediaError: ~Object with { constructor(); get MEDIA_ERR_ABORTED(): number; get MEDIA_ERR_DECODE(): number; get MEDIA_ERR_NETWORK(): number; get MEDIA_ERR_SRC_NOT_SUPPORTED(): number; };

export external public interface ~MediaKeyMessageEvent extends Event {
	get message(): ArrayBuffer;
	get messageType(): MediaKeyMessageType;
}

var MediaKeyMessageEvent: ~Object with { constructor(type: string, eventInitDict: MediaKeyMessageEventInit); };

export external public interface ~MediaKeySessionEventMap {
	keystatuseschange: Event;
	message: MediaKeyMessageEvent;
}

export external public interface ~MediaKeySession extends EventTarget {
	get closed(): Promise<MediaKeySessionClosedReason>;
	get expiration(): number;
	get keyStatuses(): MediaKeyStatusMap;
	onkeystatuseschange: ({@This(MediaKeySession) function(ev: Event): any});
	onmessage: ({@This(MediaKeySession) function(ev: MediaKeyMessageEvent): any});
	get sessionId(): string;
	close(): Promise<undefined>;
	generateRequest(initDataType: string, initData: BufferSource): Promise<undefined>;
	load(sessionId: string): Promise<boolean>;
	remove(): Promise<undefined>;
	update(response: BufferSource): Promise<undefined>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MediaKeySession: ~Object with { constructor(); };

export external public interface ~MediaKeyStatusMap {
	get size(): number;
	get(keyId: BufferSource): MediaKeyStatus;
	has(keyId: BufferSource): boolean;
	forEach(callbackfn: (value: MediaKeyStatus, key: BufferSource, parent: MediaKeyStatusMap)=>void, thisArg: any = ): void;
}

var MediaKeyStatusMap: ~Object with { constructor(); };

export external public interface ~MediaKeySystemAccess {
	get keySystem(): string;
	createMediaKeys(): Promise<MediaKeys>;
	getConfiguration(): MediaKeySystemConfiguration;
}

var MediaKeySystemAccess: ~Object with { constructor(); };

export external public interface ~MediaKeys {
	createSession(sessionType: MediaKeySessionType = ): MediaKeySession;
	setServerCertificate(serverCertificate: BufferSource): Promise<boolean>;
}

var MediaKeys: ~Object with { constructor(); };

export external public interface ~MediaList {
	get length(): number;
	mediaText: string;
	toString(): string;
	appendMedium(medium: string): void;
	deleteMedium(medium: string): void;
	item(index: number): string;
}

var MediaList: ~Object with { constructor(); };

export external public interface ~MediaMetadata {
	album: string;
	artist: string;
	artwork: ReadonlyArray<MediaImage>;
	title: string;
}

var MediaMetadata: ~Object with { constructor(init: MediaMetadataInit = ); };

export external public interface ~MediaQueryListEventMap {
	change: MediaQueryListEvent;
}

export external public interface ~MediaQueryList extends EventTarget {
	get matches(): boolean;
	get media(): string;
	onchange: ({@This(MediaQueryList) function(ev: MediaQueryListEvent): any});
	addListener(callback: ({@This(MediaQueryList) function(ev: MediaQueryListEvent): any})): void;
	removeListener(callback: ({@This(MediaQueryList) function(ev: MediaQueryListEvent): any})): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MediaQueryList: ~Object with { constructor(); };

export external public interface ~MediaQueryListEvent extends Event {
	get matches(): boolean;
	get media(): string;
}

var MediaQueryListEvent: ~Object with { constructor(type: string, eventInitDict: MediaQueryListEventInit = ); };

export external public interface ~MediaRecorderEventMap {
	dataavailable: BlobEvent;
	error: Event;
	pause: Event;
	resume: Event;
	start: Event;
	stop: Event;
}

export external public interface ~MediaRecorder extends EventTarget {
	get audioBitsPerSecond(): number;
	get mimeType(): string;
	ondataavailable: ({@This(MediaRecorder) function(ev: BlobEvent): any});
	onerror: ({@This(MediaRecorder) function(ev: Event): any});
	onpause: ({@This(MediaRecorder) function(ev: Event): any});
	onresume: ({@This(MediaRecorder) function(ev: Event): any});
	onstart: ({@This(MediaRecorder) function(ev: Event): any});
	onstop: ({@This(MediaRecorder) function(ev: Event): any});
	get state(): RecordingState;
	get stream(): MediaStream;
	get videoBitsPerSecond(): number;
	pause(): void;
	requestData(): void;
	resume(): void;
	start(timeslice: number = ): void;
	stop(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MediaRecorder: ~Object with { constructor(stream: MediaStream, options: MediaRecorderOptions = ); isTypeSupported(type: string): boolean; };

export external public interface ~MediaRecorderErrorEvent extends Event {
	get error(): DOMException;
}

var MediaRecorderErrorEvent: ~Object with { constructor(type: string, eventInitDict: MediaRecorderErrorEventInit); };

export external public interface ~MediaSession {
	metadata: MediaMetadata;
	playbackState: MediaSessionPlaybackState;
	setActionHandler(action: MediaSessionAction, handler: MediaSessionActionHandler): void;
	setPositionState(state: MediaPositionState = ): void;
}

var MediaSession: ~Object with { constructor(); };

export external public interface ~MediaSourceEventMap {
	sourceclose: Event;
	sourceended: Event;
	sourceopen: Event;
}

export external public interface ~MediaSource extends EventTarget {
	get activeSourceBuffers(): SourceBufferList;
	duration: number;
	onsourceclose: ({@This(MediaSource) function(ev: Event): any});
	onsourceended: ({@This(MediaSource) function(ev: Event): any});
	onsourceopen: ({@This(MediaSource) function(ev: Event): any});
	get readyState(): ReadyState;
	get sourceBuffers(): SourceBufferList;
	addSourceBuffer(type: string): SourceBuffer;
	clearLiveSeekableRange(): void;
	endOfStream(error: EndOfStreamError = ): void;
	removeSourceBuffer(sourceBuffer: SourceBuffer): void;
	setLiveSeekableRange(start: number, end: number): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MediaSource: ~Object with { constructor(); isTypeSupported(type: string): boolean; };

export external public interface ~MediaStreamEventMap {
	addtrack: MediaStreamTrackEvent;
	removetrack: MediaStreamTrackEvent;
}

export external public interface ~MediaStream extends EventTarget {
	get active(): boolean;
	get id(): string;
	onaddtrack: ({@This(MediaStream) function(ev: MediaStreamTrackEvent): any});
	onremovetrack: ({@This(MediaStream) function(ev: MediaStreamTrackEvent): any});
	addTrack(track: MediaStreamTrack): void;
	clone(): MediaStream;
	getAudioTracks(): Array<MediaStreamTrack>;
	getTrackById(trackId: string): MediaStreamTrack;
	getTracks(): Array<MediaStreamTrack>;
	getVideoTracks(): Array<MediaStreamTrack>;
	removeTrack(track: MediaStreamTrack): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MediaStream: ~Object with { constructor(...args: any+); /* <-- overloading not supported */ };

export external public interface ~MediaStreamAudioDestinationNode extends AudioNode {
	get stream(): MediaStream;
}

var MediaStreamAudioDestinationNode: ~Object with { constructor(context: AudioContext, options: AudioNodeOptions = ); };

export external public interface ~MediaStreamAudioSourceNode extends AudioNode {
	get mediaStream(): MediaStream;
}

var MediaStreamAudioSourceNode: ~Object with { constructor(context: AudioContext, options: MediaStreamAudioSourceOptions); };

export external public interface ~MediaStreamTrackEventMap {
	ended: Event;
	mute: Event;
	unmute: Event;
}

export external public interface ~MediaStreamTrack extends EventTarget {
	contentHint: string;
	enabled: boolean;
	get id(): string;
	get kind(): string;
	get label(): string;
	get muted(): boolean;
	onended: ({@This(MediaStreamTrack) function(ev: Event): any});
	onmute: ({@This(MediaStreamTrack) function(ev: Event): any});
	onunmute: ({@This(MediaStreamTrack) function(ev: Event): any});
	get readyState(): MediaStreamTrackState;
	applyConstraints(constraints: MediaTrackConstraints = ): Promise<undefined>;
	clone(): MediaStreamTrack;
	getCapabilities(): MediaTrackCapabilities;
	getConstraints(): MediaTrackConstraints;
	getSettings(): MediaTrackSettings;
	stop(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MediaStreamTrack: ~Object with { constructor(); };

export external public interface ~MediaStreamTrackEvent extends Event {
	get track(): MediaStreamTrack;
}

var MediaStreamTrackEvent: ~Object with { constructor(type: string, eventInitDict: MediaStreamTrackEventInit); };

export external public interface ~MessageChannel {
	get port1(): MessagePort;
	get port2(): MessagePort;
}

var MessageChannel: ~Object with { constructor(); };

export external public interface ~MessageEvent<T=any> extends Event {
	get data(): T;
	get lastEventId(): string;
	get origin(): string;
	get ports(): ReadonlyArray<MessagePort>;
	get source(): MessageEventSource;
	initMessageEvent(type: string, bubbles: boolean = , cancelable: boolean = , data: any = , origin: string = , lastEventId: string = , source: MessageEventSource = , ports: Array<MessagePort> = ): void;
}

var MessageEvent: ~Object with { constructor(type: string, eventInitDict: MessageEventInit<T> = ); };

export external public interface ~MessagePortEventMap {
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public interface ~MessagePort extends EventTarget {
	onmessage: ({@This(MessagePort) function(ev: MessageEvent): any});
	onmessageerror: ({@This(MessagePort) function(ev: MessageEvent): any});
	close(): void;
	postMessage(...args: any+): any+; // overloading not supported
	start(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var MessagePort: ~Object with { constructor(); };

export external public interface ~MimeType {
	get description(): string;
	get enabledPlugin(): Plugin;
	get suffixes(): string;
	get type(): string;
}

var MimeType: ~Object with { constructor(); };

export external public interface ~MimeTypeArray {
	get length(): number;
	item(index: number): MimeType;
	namedItem(name: string): MimeType;
}

var MimeTypeArray: ~Object with { constructor(); };

export external public interface ~MouseEvent extends UIEvent {
	get altKey(): boolean;
	get button(): number;
	get buttons(): number;
	get clientX(): number;
	get clientY(): number;
	get ctrlKey(): boolean;
	get metaKey(): boolean;
	get movementX(): number;
	get movementY(): number;
	get offsetX(): number;
	get offsetY(): number;
	get pageX(): number;
	get pageY(): number;
	get relatedTarget(): EventTarget;
	get screenX(): number;
	get screenY(): number;
	get shiftKey(): boolean;
	get x(): number;
	get y(): number;
	getModifierState(keyArg: string): boolean;
	initMouseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget): void;
}

var MouseEvent: ~Object with { constructor(type: string, eventInitDict: MouseEventInit = ); };

export external public interface ~MutationEvent extends Event {
	get attrChange(): number;
	get attrName(): string;
	get newValue(): string;
	get prevValue(): string;
	get relatedNode(): Node;
	initMutationEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , relatedNodeArg: Node = , prevValueArg: string = , newValueArg: string = , attrNameArg: string = , attrChangeArg: number = ): void;
	get ADDITION(): number;
	get MODIFICATION(): number;
	get REMOVAL(): number;
}

var MutationEvent: ~Object with { constructor(); get ADDITION(): number; get MODIFICATION(): number; get REMOVAL(): number; };

export external public interface ~MutationObserver {
	disconnect(): void;
	observe(target: Node, options: MutationObserverInit = ): void;
	takeRecords(): Array<MutationRecord>;
}

var MutationObserver: ~Object with { constructor(callback: MutationCallback); };

export external public interface ~MutationRecord {
	get addedNodes(): NodeList;
	get attributeName(): string;
	get attributeNamespace(): string;
	get nextSibling(): Node;
	get oldValue(): string;
	get previousSibling(): Node;
	get removedNodes(): NodeList;
	get target(): Node;
	get type(): MutationRecordType;
}

var MutationRecord: ~Object with { constructor(); };

export external public interface ~NamedNodeMap {
	get length(): number;
	getNamedItem(qualifiedName: string): Attr;
	getNamedItemNS(namespace: string, localName: string): Attr;
	item(index: number): Attr;
	removeNamedItem(qualifiedName: string): Attr;
	removeNamedItemNS(namespace: string, localName: string): Attr;
	setNamedItem(attr: Attr): Attr;
	setNamedItemNS(attr: Attr): Attr;
}

var NamedNodeMap: ~Object with { constructor(); };

export external public interface ~Navigator extends NavigatorAutomationInformation, NavigatorConcurrentHardware, NavigatorContentUtils, NavigatorCookies, NavigatorID, NavigatorLanguage, NavigatorNetworkInformation, NavigatorOnLine, NavigatorPlugins, NavigatorStorage {
	get clipboard(): Clipboard;
	get credentials(): CredentialsContainer;
	get doNotTrack(): string;
	get geolocation(): Geolocation;
	get maxTouchPoints(): number;
	get mediaCapabilities(): MediaCapabilities;
	get mediaDevices(): MediaDevices;
	get mediaSession(): MediaSession;
	get permissions(): Permissions;
	get pointerEnabled(): boolean;
	get serviceWorker(): ServiceWorkerContainer;
	getGamepads(): Array<Gamepad>;
	requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: Array<MediaKeySystemConfiguration>): Promise<MediaKeySystemAccess>;
	sendBeacon(url: string | URL, data: BodyInit = ): boolean;
	share(data: ShareData = ): Promise<undefined>;
	vibrate(pattern: VibratePattern): boolean;
}

var Navigator: ~Object with { constructor(); };

export external public interface ~NavigatorAutomationInformation {
	get webdriver(): boolean;
}

export external public interface ~NavigatorConcurrentHardware {
	get hardwareConcurrency(): number;
}

export external public interface ~NavigatorContentUtils {
	registerProtocolHandler(scheme: string, url: string | URL): void;
}

export external public interface ~NavigatorCookies {
	get cookieEnabled(): boolean;
}

export external public interface ~NavigatorID {
	get appCodeName(): string;
	get appName(): string;
	get appVersion(): string;
	get platform(): string;
	get product(): string;
	get productSub(): string;
	get userAgent(): string;
	get vendor(): string;
	get vendorSub(): string;
}

export external public interface ~NavigatorLanguage {
	get language(): string;
	get languages(): ReadonlyArray<string>;
}

export external public interface ~NavigatorNetworkInformation {
	get connection(): NetworkInformation;
}

export external public interface ~NavigatorOnLine {
	get onLine(): boolean;
}

export external public interface ~NavigatorPlugins {
	get mimeTypes(): MimeTypeArray;
	get plugins(): PluginArray;
	javaEnabled(): boolean;
}

export external public interface ~NavigatorStorage {
	get storage(): StorageManager;
}

export external public interface ~NetworkInformation extends EventTarget {
	get type(): ConnectionType;
}

var NetworkInformation: ~Object with { constructor(); };

export external public interface ~Node extends EventTarget {
	get baseURI(): string;
	get childNodes(): NodeListOf<ChildNode>;
	get firstChild(): ChildNode;
	get isConnected(): boolean;
	get lastChild(): ChildNode;
	get nextSibling(): ChildNode;
	get nodeName(): string;
	get nodeType(): number;
	nodeValue: string;
	get ownerDocument(): Document;
	get parentElement(): HTMLElement;
	get parentNode(): ParentNode;
	get previousSibling(): ChildNode;
	textContent: string;
	<T> appendChild(node: T): T;
	cloneNode(deep: boolean = ): Node;
	compareDocumentPosition(other: Node): number;
	contains(other: Node): boolean;
	getRootNode(options: GetRootNodeOptions = ): Node;
	hasChildNodes(): boolean;
	<T> insertBefore(node: T, child: Node): T;
	isDefaultNamespace(namespace: string): boolean;
	isEqualNode(otherNode: Node): boolean;
	isSameNode(otherNode: Node): boolean;
	lookupNamespaceURI(prefix: string): string;
	lookupPrefix(namespace: string): string;
	normalize(): void;
	<T> removeChild(child: T): T;
	<T> replaceChild(node: Node, child: T): T;
	get ATTRIBUTE_NODE(): number;
	get CDATA_SECTION_NODE(): number;
	get COMMENT_NODE(): number;
	get DOCUMENT_FRAGMENT_NODE(): number;
	get DOCUMENT_NODE(): number;
	get DOCUMENT_POSITION_CONTAINED_BY(): number;
	get DOCUMENT_POSITION_CONTAINS(): number;
	get DOCUMENT_POSITION_DISCONNECTED(): number;
	get DOCUMENT_POSITION_FOLLOWING(): number;
	get DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC(): number;
	get DOCUMENT_POSITION_PRECEDING(): number;
	get DOCUMENT_TYPE_NODE(): number;
	get ELEMENT_NODE(): number;
	get ENTITY_NODE(): number;
	get ENTITY_REFERENCE_NODE(): number;
	get NOTATION_NODE(): number;
	get PROCESSING_INSTRUCTION_NODE(): number;
	get TEXT_NODE(): number;
}

var Node: ~Object with { constructor(); get ATTRIBUTE_NODE(): number; get CDATA_SECTION_NODE(): number; get COMMENT_NODE(): number; get DOCUMENT_FRAGMENT_NODE(): number; get DOCUMENT_NODE(): number; get DOCUMENT_POSITION_CONTAINED_BY(): number; get DOCUMENT_POSITION_CONTAINS(): number; get DOCUMENT_POSITION_DISCONNECTED(): number; get DOCUMENT_POSITION_FOLLOWING(): number; get DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC(): number; get DOCUMENT_POSITION_PRECEDING(): number; get DOCUMENT_TYPE_NODE(): number; get ELEMENT_NODE(): number; get ENTITY_NODE(): number; get ENTITY_REFERENCE_NODE(): number; get NOTATION_NODE(): number; get PROCESSING_INSTRUCTION_NODE(): number; get TEXT_NODE(): number; };

export external public interface ~NodeIterator {
	get filter(): NodeFilter;
	get pointerBeforeReferenceNode(): boolean;
	get referenceNode(): Node;
	get root(): Node;
	get whatToShow(): number;
	detach(): void;
	nextNode(): Node;
	previousNode(): Node;
}

var NodeIterator: ~Object with { constructor(); };

export external public interface ~NodeList {
	get length(): number;
	item(index: number): Node;
	forEach(callbackfn: (value: Node, key: number, parent: NodeList)=>void, thisArg: any = ): void;
}

var NodeList: ~Object with { constructor(); };

export external public interface ~NodeListOf<TNode> extends NodeList {
	item(index: number): TNode;
	forEach(callbackfn: (value: TNode, key: number, parent: NodeListOf<TNode>)=>void, thisArg: any = ): void;
}

export external public interface ~NonDocumentTypeChildNode {
	get nextElementSibling(): Element;
	get previousElementSibling(): Element;
}

export external public interface ~NonElementParentNode {
	getElementById(elementId: string): Element;
}

export external public interface ~NotificationEventMap {
	click: Event;
	close: Event;
	error: Event;
	show: Event;
}

export external public interface ~Notification extends EventTarget {
	get body(): string;
	get data(): any;
	get dir(): NotificationDirection;
	get icon(): string;
	get lang(): string;
	onclick: ({@This(Notification) function(ev: Event): any});
	onclose: ({@This(Notification) function(ev: Event): any});
	onerror: ({@This(Notification) function(ev: Event): any});
	onshow: ({@This(Notification) function(ev: Event): any});
	get tag(): string;
	get title(): string;
	close(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var Notification: ~Object with { constructor(title: string, options: NotificationOptions = ); get permission(): NotificationPermission; requestPermission(deprecatedCallback: NotificationPermissionCallback = ): Promise<NotificationPermission>; };

export external public interface ~OES_element_index_uint {}

export external public interface ~OES_fbo_render_mipmap {}

export external public interface ~OES_standard_derivatives {
	get FRAGMENT_SHADER_DERIVATIVE_HINT_OES(): GLenum;
}

export external public interface ~OES_texture_float {}

export external public interface ~OES_texture_float_linear {}

export external public interface ~OES_texture_half_float {
	get HALF_FLOAT_OES(): GLenum;
}

export external public interface ~OES_texture_half_float_linear {}

export external public interface ~OES_vertex_array_object {
	bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
	createVertexArrayOES(): WebGLVertexArrayObjectOES;
	deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
	isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): GLboolean;
	get VERTEX_ARRAY_BINDING_OES(): GLenum;
}

export external public interface ~OVR_multiview2 {
	framebufferTextureMultiviewOVR(target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint, baseViewIndex: GLint, numViews: GLsizei): void;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR(): GLenum;
	get MAX_VIEWS_OVR(): GLenum;
}

export external public interface ~OfflineAudioCompletionEvent extends Event {
	get renderedBuffer(): AudioBuffer;
}

var OfflineAudioCompletionEvent: ~Object with { constructor(type: string, eventInitDict: OfflineAudioCompletionEventInit); };

export external public interface ~OfflineAudioContextEventMap extends BaseAudioContextEventMap {
	complete: OfflineAudioCompletionEvent;
}

export external public interface ~OfflineAudioContext extends BaseAudioContext {
	get length(): number;
	oncomplete: ({@This(OfflineAudioContext) function(ev: OfflineAudioCompletionEvent): any});
	resume(): Promise<undefined>;
	startRendering(): Promise<AudioBuffer>;
	suspend(suspendTime: number): Promise<undefined>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var OfflineAudioContext: ~Object with { constructor(...args: any+); /* <-- overloading not supported */ };

export external public interface ~OscillatorNode extends AudioScheduledSourceNode {
	get detune(): AudioParam;
	get frequency(): AudioParam;
	type: OscillatorType;
	setPeriodicWave(periodicWave: PeriodicWave): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var OscillatorNode: ~Object with { constructor(context: BaseAudioContext, options: OscillatorOptions = ); };

export external public interface ~OverconstrainedError extends Error {
	get constraint(): string;
}

var OverconstrainedError: ~Object with { constructor(constraint: string, message: string = ); };

export external public interface ~PageTransitionEvent extends Event {
	get persisted(): boolean;
}

var PageTransitionEvent: ~Object with { constructor(type: string, eventInitDict: PageTransitionEventInit = ); };

export external public interface ~PannerNode extends AudioNode {
	coneInnerAngle: number;
	coneOuterAngle: number;
	coneOuterGain: number;
	distanceModel: DistanceModelType;
	maxDistance: number;
	get orientationX(): AudioParam;
	get orientationY(): AudioParam;
	get orientationZ(): AudioParam;
	panningModel: PanningModelType;
	get positionX(): AudioParam;
	get positionY(): AudioParam;
	get positionZ(): AudioParam;
	refDistance: number;
	rolloffFactor: number;
	setOrientation(x: number, y: number, z: number): void;
	setPosition(x: number, y: number, z: number): void;
}

var PannerNode: ~Object with { constructor(context: BaseAudioContext, options: PannerOptions = ); };

export external public interface ~ParentNode extends Node {
	get childElementCount(): number;
	get children(): HTMLCollection;
	get firstElementChild(): Element;
	get lastElementChild(): Element;
	append(...nodes: Node | string): void;
	prepend(...nodes: Node | string): void;
	querySelector(...args: any+): any+; // overloading not supported
	querySelectorAll(...args: any+): any+; // overloading not supported
	replaceChildren(...nodes: Node | string): void;
}

export external public interface ~Path2D extends CanvasPath {
	addPath(path: Path2D, transform: DOMMatrix2DInit = ): void;
}

var Path2D: ~Object with { constructor(path: Path2D | string = ); };

export external public interface ~PaymentAddress {
	get addressLine(): ReadonlyArray<string>;
	get city(): string;
	get country(): string;
	get dependentLocality(): string;
	get organization(): string;
	get phone(): string;
	get postalCode(): string;
	get recipient(): string;
	get region(): string;
	get sortingCode(): string;
	toJSON(): any;
}

var PaymentAddress: ~Object with { constructor(); };

export external public interface ~PaymentMethodChangeEvent extends PaymentRequestUpdateEvent {
	get methodDetails(): any;
	get methodName(): string;
}

var PaymentMethodChangeEvent: ~Object with { constructor(type: string, eventInitDict: PaymentMethodChangeEventInit = ); };

export external public interface ~PaymentRequestEventMap {
	paymentmethodchange: Event;
}

export external public interface ~PaymentRequest extends EventTarget {
	get id(): string;
	onpaymentmethodchange: ({@This(PaymentRequest) function(ev: Event): any});
	abort(): Promise<undefined>;
	canMakePayment(): Promise<boolean>;
	show(detailsPromise: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate> = ): Promise<PaymentResponse>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var PaymentRequest: ~Object with { constructor(methodData: Array<PaymentMethodData>, details: PaymentDetailsInit); };

export external public interface ~PaymentRequestUpdateEvent extends Event {
	updateWith(detailsPromise: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate>): void;
}

var PaymentRequestUpdateEvent: ~Object with { constructor(type: string, eventInitDict: PaymentRequestUpdateEventInit = ); };

export external public interface ~PaymentResponse extends EventTarget {
	get details(): any;
	get methodName(): string;
	get requestId(): string;
	complete(result: PaymentComplete = ): Promise<undefined>;
	retry(errorFields: PaymentValidationErrors = ): Promise<undefined>;
	toJSON(): any;
}

var PaymentResponse: ~Object with { constructor(); };

export external public interface ~PerformanceEventMap {
	resourcetimingbufferfull: Event;
}

export external public interface ~Performance extends EventTarget {
	get navigation(): PerformanceNavigation;
	onresourcetimingbufferfull: ({@This(Performance) function(ev: Event): any});
	get timeOrigin(): DOMHighResTimeStamp;
	get timing(): PerformanceTiming;
	clearMarks(markName: string = ): void;
	clearMeasures(measureName: string = ): void;
	clearResourceTimings(): void;
	getEntries(): PerformanceEntryList;
	getEntriesByName(name: string, type: string = ): PerformanceEntryList;
	getEntriesByType(type: string): PerformanceEntryList;
	mark(markName: string, markOptions: PerformanceMarkOptions = ): PerformanceMark;
	measure(measureName: string, startOrMeasureOptions: string | PerformanceMeasureOptions = , endMark: string = ): PerformanceMeasure;
	now(): DOMHighResTimeStamp;
	setResourceTimingBufferSize(maxSize: number): void;
	toJSON(): any;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var Performance: ~Object with { constructor(); };

export external public interface ~PerformanceEntry {
	get duration(): DOMHighResTimeStamp;
	get entryType(): string;
	get name(): string;
	get startTime(): DOMHighResTimeStamp;
	toJSON(): any;
}

var PerformanceEntry: ~Object with { constructor(); };

export external public interface ~PerformanceEventTiming extends PerformanceEntry {
	get cancelable(): boolean;
	get processingEnd(): DOMHighResTimeStamp;
	get processingStart(): DOMHighResTimeStamp;
	get target(): Node;
}

var PerformanceEventTiming: ~Object with { constructor(); };

export external public interface ~PerformanceMark extends PerformanceEntry {
	get detail(): any;
}

var PerformanceMark: ~Object with { constructor(markName: string, markOptions: PerformanceMarkOptions = ); };

export external public interface ~PerformanceMeasure extends PerformanceEntry {
	get detail(): any;
}

var PerformanceMeasure: ~Object with { constructor(); };

export external public interface ~PerformanceNavigation {
	get redirectCount(): number;
	get type(): number;
	toJSON(): any;
	get TYPE_BACK_FORWARD(): number;
	get TYPE_NAVIGATE(): number;
	get TYPE_RELOAD(): number;
	get TYPE_RESERVED(): number;
}

var PerformanceNavigation: ~Object with { constructor(); get TYPE_BACK_FORWARD(): number; get TYPE_NAVIGATE(): number; get TYPE_RELOAD(): number; get TYPE_RESERVED(): number; };

export external public interface ~PerformanceNavigationTiming extends PerformanceResourceTiming {
	get domComplete(): DOMHighResTimeStamp;
	get domContentLoadedEventEnd(): DOMHighResTimeStamp;
	get domContentLoadedEventStart(): DOMHighResTimeStamp;
	get domInteractive(): DOMHighResTimeStamp;
	get loadEventEnd(): DOMHighResTimeStamp;
	get loadEventStart(): DOMHighResTimeStamp;
	get redirectCount(): number;
	get type(): NavigationType;
	get unloadEventEnd(): DOMHighResTimeStamp;
	get unloadEventStart(): DOMHighResTimeStamp;
	@Override
	toJSON(): any;
}

var PerformanceNavigationTiming: ~Object with { constructor(); };

export external public interface ~PerformanceObserver {
	disconnect(): void;
	observe(options: PerformanceObserverInit = ): void;
	takeRecords(): PerformanceEntryList;
}

var PerformanceObserver: ~Object with { constructor(callback: PerformanceObserverCallback); get supportedEntryTypes(): ReadonlyArray<string>; };

export external public interface ~PerformanceObserverEntryList {
	getEntries(): PerformanceEntryList;
	getEntriesByName(name: string, type: string = ): PerformanceEntryList;
	getEntriesByType(type: string): PerformanceEntryList;
}

var PerformanceObserverEntryList: ~Object with { constructor(); };

export external public interface ~PerformancePaintTiming extends PerformanceEntry {}

var PerformancePaintTiming: ~Object with { constructor(); };

export external public interface ~PerformanceResourceTiming extends PerformanceEntry {
	get connectEnd(): DOMHighResTimeStamp;
	get connectStart(): DOMHighResTimeStamp;
	get decodedBodySize(): number;
	get domainLookupEnd(): DOMHighResTimeStamp;
	get domainLookupStart(): DOMHighResTimeStamp;
	get encodedBodySize(): number;
	get fetchStart(): DOMHighResTimeStamp;
	get initiatorType(): string;
	get nextHopProtocol(): string;
	get redirectEnd(): DOMHighResTimeStamp;
	get redirectStart(): DOMHighResTimeStamp;
	get requestStart(): DOMHighResTimeStamp;
	get responseEnd(): DOMHighResTimeStamp;
	get responseStart(): DOMHighResTimeStamp;
	get secureConnectionStart(): DOMHighResTimeStamp;
	get serverTiming(): ReadonlyArray<PerformanceServerTiming>;
	get transferSize(): number;
	get workerStart(): DOMHighResTimeStamp;
	@Override
	toJSON(): any;
}

var PerformanceResourceTiming: ~Object with { constructor(); };

export external public interface ~PerformanceServerTiming {
	get description(): string;
	get duration(): DOMHighResTimeStamp;
	get name(): string;
	toJSON(): any;
}

var PerformanceServerTiming: ~Object with { constructor(); };

export external public interface ~PerformanceTiming {
	get connectEnd(): number;
	get connectStart(): number;
	get domComplete(): number;
	get domContentLoadedEventEnd(): number;
	get domContentLoadedEventStart(): number;
	get domInteractive(): number;
	get domLoading(): number;
	get domainLookupEnd(): number;
	get domainLookupStart(): number;
	get fetchStart(): number;
	get loadEventEnd(): number;
	get loadEventStart(): number;
	get navigationStart(): number;
	get redirectEnd(): number;
	get redirectStart(): number;
	get requestStart(): number;
	get responseEnd(): number;
	get responseStart(): number;
	get secureConnectionStart(): number;
	get unloadEventEnd(): number;
	get unloadEventStart(): number;
	toJSON(): any;
}

var PerformanceTiming: ~Object with { constructor(); };

export external public interface ~PeriodicWave {}

var PeriodicWave: ~Object with { constructor(context: BaseAudioContext, options: PeriodicWaveOptions = ); };

export external public interface ~PermissionStatusEventMap {
	change: Event;
}

export external public interface ~PermissionStatus extends EventTarget {
	onchange: ({@This(PermissionStatus) function(ev: Event): any});
	get state(): PermissionState;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var PermissionStatus: ~Object with { constructor(); };

export external public interface ~Permissions {
	query(permissionDesc: PermissionDescriptor): Promise<PermissionStatus>;
}

var Permissions: ~Object with { constructor(); };

export external public interface ~PictureInPictureWindowEventMap {
	resize: Event;
}

export external public interface ~PictureInPictureWindow extends EventTarget {
	get height(): number;
	onresize: ({@This(PictureInPictureWindow) function(ev: Event): any});
	get width(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var PictureInPictureWindow: ~Object with { constructor(); };

export external public interface ~Plugin {
	get description(): string;
	get filename(): string;
	get length(): number;
	get name(): string;
	item(index: number): MimeType;
	namedItem(name: string): MimeType;
}

var Plugin: ~Object with { constructor(); };

export external public interface ~PluginArray {
	get length(): number;
	item(index: number): Plugin;
	namedItem(name: string): Plugin;
	refresh(): void;
}

var PluginArray: ~Object with { constructor(); };

export external public interface ~PointerEvent extends MouseEvent {
	get height(): number;
	get isPrimary(): boolean;
	get pointerId(): number;
	get pointerType(): string;
	get pressure(): number;
	get tangentialPressure(): number;
	get tiltX(): number;
	get tiltY(): number;
	get twist(): number;
	get width(): number;
	getCoalescedEvents(): Array<PointerEvent>;
	getPredictedEvents(): Array<PointerEvent>;
}

var PointerEvent: ~Object with { constructor(type: string, eventInitDict: PointerEventInit = ); };

export external public interface ~PopStateEvent extends Event {
	get state(): any;
}

var PopStateEvent: ~Object with { constructor(type: string, eventInitDict: PopStateEventInit = ); };

export external public interface ~ProcessingInstruction extends CharacterData, LinkStyle {
	@Override
	get ownerDocument(): Document;
	get target(): string;
}

var ProcessingInstruction: ~Object with { constructor(); };

export external public interface ~ProgressEvent<T=EventTarget> extends Event {
	get lengthComputable(): boolean;
	get loaded(): number;
	get target(): T;
	get total(): number;
}

var ProgressEvent: ~Object with { constructor(type: string, eventInitDict: ProgressEventInit = ); };

export external public interface ~PromiseRejectionEvent extends Event {
	get promise(): Promise<any>;
	get reason(): any;
}

var PromiseRejectionEvent: ~Object with { constructor(type: string, eventInitDict: PromiseRejectionEventInit); };

export external public interface ~PublicKeyCredential extends Credential {
	get rawId(): ArrayBuffer;
	get response(): AuthenticatorResponse;
	getClientExtensionResults(): AuthenticationExtensionsClientOutputs;
}

var PublicKeyCredential: ~Object with { constructor(); isUserVerifyingPlatformAuthenticatorAvailable(): Promise<boolean>; };

export external public interface ~PushManager {
	getSubscription(): Promise<PushSubscription>;
	permissionState(options: PushSubscriptionOptionsInit = ): Promise<PushPermissionState>;
	subscribe(options: PushSubscriptionOptionsInit = ): Promise<PushSubscription>;
}

var PushManager: ~Object with { constructor(); get supportedContentEncodings(): ReadonlyArray<string>; };

export external public interface ~PushSubscription {
	get endpoint(): string;
	get options(): PushSubscriptionOptions;
	getKey(name: PushEncryptionKeyName): ArrayBuffer;
	toJSON(): PushSubscriptionJSON;
	unsubscribe(): Promise<boolean>;
}

var PushSubscription: ~Object with { constructor(); };

export external public interface ~PushSubscriptionOptions {
	get applicationServerKey(): ArrayBuffer;
}

var PushSubscriptionOptions: ~Object with { constructor(); };

export external public interface ~RTCCertificate {
	get expires(): DOMTimeStamp;
	getFingerprints(): Array<RTCDtlsFingerprint>;
}

var RTCCertificate: ~Object with { constructor(); };

export external public interface ~RTCDTMFSenderEventMap {
	tonechange: RTCDTMFToneChangeEvent;
}

export external public interface ~RTCDTMFSender extends EventTarget {
	get canInsertDTMF(): boolean;
	ontonechange: ({@This(RTCDTMFSender) function(ev: RTCDTMFToneChangeEvent): any});
	get toneBuffer(): string;
	insertDTMF(tones: string, duration: number = , interToneGap: number = ): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var RTCDTMFSender: ~Object with { constructor(); };

export external public interface ~RTCDTMFToneChangeEvent extends Event {
	get tone(): string;
}

var RTCDTMFToneChangeEvent: ~Object with { constructor(type: string, eventInitDict: RTCDTMFToneChangeEventInit = ); };

export external public interface ~RTCDataChannelEventMap {
	bufferedamountlow: Event;
	close: Event;
	error: Event;
	message: MessageEvent;
	open: Event;
}

export external public interface ~RTCDataChannel extends EventTarget {
	binaryType: BinaryType;
	get bufferedAmount(): number;
	bufferedAmountLowThreshold: number;
	get id(): number;
	get label(): string;
	get maxPacketLifeTime(): number;
	get maxRetransmits(): number;
	get negotiated(): boolean;
	onbufferedamountlow: ({@This(RTCDataChannel) function(ev: Event): any});
	onclose: ({@This(RTCDataChannel) function(ev: Event): any});
	onerror: ({@This(RTCDataChannel) function(ev: Event): any});
	onmessage: ({@This(RTCDataChannel) function(ev: MessageEvent): any});
	onopen: ({@This(RTCDataChannel) function(ev: Event): any});
	get ordered(): boolean;
	get protocol(): string;
	get readyState(): RTCDataChannelState;
	close(): void;
	send(...args: any+): any+; // overloading not supported
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var RTCDataChannel: ~Object with { constructor(); };

export external public interface ~RTCDataChannelEvent extends Event {
	get channel(): RTCDataChannel;
}

var RTCDataChannelEvent: ~Object with { constructor(type: string, eventInitDict: RTCDataChannelEventInit); };

export external public interface ~RTCDtlsTransportEventMap {
	statechange: Event;
}

export external public interface ~RTCDtlsTransport extends EventTarget {
	onstatechange: ({@This(RTCDtlsTransport) function(ev: Event): any});
	get state(): RTCDtlsTransportState;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var RTCDtlsTransport: ~Object with { constructor(); };

export external public interface ~RTCIceCandidate {
	get address(): string;
	get candidate(): string;
	get component(): RTCIceComponent;
	get foundation(): string;
	get port(): number;
	get priority(): number;
	get protocol(): RTCIceProtocol;
	get relatedAddress(): string;
	get relatedPort(): number;
	get sdpMLineIndex(): number;
	get sdpMid(): string;
	get tcpType(): RTCIceTcpCandidateType;
	get type(): RTCIceCandidateType;
	get usernameFragment(): string;
	toJSON(): RTCIceCandidateInit;
}

var RTCIceCandidate: ~Object with { constructor(candidateInitDict: RTCIceCandidateInit = ); };

export external public interface ~RTCIceTransport extends EventTarget {
	get gatheringState(): RTCIceGathererState;
	get state(): RTCIceTransportState;
}

var RTCIceTransport: ~Object with { constructor(); };

export external public interface ~RTCPeerConnectionEventMap {
	connectionstatechange: Event;
	datachannel: RTCDataChannelEvent;
	icecandidate: RTCPeerConnectionIceEvent;
	icecandidateerror: Event;
	iceconnectionstatechange: Event;
	icegatheringstatechange: Event;
	negotiationneeded: Event;
	signalingstatechange: Event;
	track: RTCTrackEvent;
}

export external public interface ~RTCPeerConnection extends EventTarget {
	get canTrickleIceCandidates(): boolean;
	get connectionState(): RTCPeerConnectionState;
	get currentLocalDescription(): RTCSessionDescription;
	get currentRemoteDescription(): RTCSessionDescription;
	get iceConnectionState(): RTCIceConnectionState;
	get iceGatheringState(): RTCIceGatheringState;
	get localDescription(): RTCSessionDescription;
	onconnectionstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	ondatachannel: ({@This(RTCPeerConnection) function(ev: RTCDataChannelEvent): any});
	onicecandidate: ({@This(RTCPeerConnection) function(ev: RTCPeerConnectionIceEvent): any});
	onicecandidateerror: ({@This(RTCPeerConnection) function(ev: Event): any});
	oniceconnectionstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	onicegatheringstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	onnegotiationneeded: ({@This(RTCPeerConnection) function(ev: Event): any});
	onsignalingstatechange: ({@This(RTCPeerConnection) function(ev: Event): any});
	ontrack: ({@This(RTCPeerConnection) function(ev: RTCTrackEvent): any});
	get pendingLocalDescription(): RTCSessionDescription;
	get pendingRemoteDescription(): RTCSessionDescription;
	get remoteDescription(): RTCSessionDescription;
	get signalingState(): RTCSignalingState;
	addIceCandidate(...args: any+): any+; // overloading not supported
	addTrack(track: MediaStreamTrack, ...streams: MediaStream): RTCRtpSender;
	addTransceiver(trackOrKind: MediaStreamTrack | string, init: RTCRtpTransceiverInit = ): RTCRtpTransceiver;
	close(): void;
	createAnswer(...args: any+): any+; // overloading not supported
	createDataChannel(label: string, dataChannelDict: RTCDataChannelInit = ): RTCDataChannel;
	createOffer(...args: any+): any+; // overloading not supported
	getConfiguration(): RTCConfiguration;
	getReceivers(): Array<RTCRtpReceiver>;
	getSenders(): Array<RTCRtpSender>;
	getStats(selector: MediaStreamTrack = ): Promise<RTCStatsReport>;
	getTransceivers(): Array<RTCRtpTransceiver>;
	removeTrack(sender: RTCRtpSender): void;
	restartIce(): void;
	setConfiguration(configuration: RTCConfiguration = ): void;
	setLocalDescription(...args: any+): any+; // overloading not supported
	setRemoteDescription(...args: any+): any+; // overloading not supported
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var RTCPeerConnection: ~Object with { constructor(configuration: RTCConfiguration = ); generateCertificate(keygenAlgorithm: AlgorithmIdentifier): Promise<RTCCertificate>; };

export external public interface ~RTCPeerConnectionIceErrorEvent extends Event {
	get address(): string;
	get errorCode(): number;
	get errorText(): string;
	get port(): number;
	get url(): string;
}

var RTCPeerConnectionIceErrorEvent: ~Object with { constructor(type: string, eventInitDict: RTCPeerConnectionIceErrorEventInit); };

export external public interface ~RTCPeerConnectionIceEvent extends Event {
	get candidate(): RTCIceCandidate;
}

var RTCPeerConnectionIceEvent: ~Object with { constructor(type: string, eventInitDict: RTCPeerConnectionIceEventInit = ); };

export external public interface ~RTCRtpReceiver {
	get track(): MediaStreamTrack;
	get transport(): RTCDtlsTransport;
	getContributingSources(): Array<RTCRtpContributingSource>;
	getParameters(): RTCRtpReceiveParameters;
	getStats(): Promise<RTCStatsReport>;
	getSynchronizationSources(): Array<RTCRtpSynchronizationSource>;
}

var RTCRtpReceiver: ~Object with { constructor(); getCapabilities(kind: string): RTCRtpCapabilities; };

export external public interface ~RTCRtpSender {
	get dtmf(): RTCDTMFSender;
	get track(): MediaStreamTrack;
	get transport(): RTCDtlsTransport;
	getParameters(): RTCRtpSendParameters;
	getStats(): Promise<RTCStatsReport>;
	replaceTrack(withTrack: MediaStreamTrack): Promise<undefined>;
	setParameters(parameters: RTCRtpSendParameters): Promise<undefined>;
	setStreams(...streams: MediaStream): void;
}

var RTCRtpSender: ~Object with { constructor(); getCapabilities(kind: string): RTCRtpCapabilities; };

export external public interface ~RTCRtpTransceiver {
	get currentDirection(): RTCRtpTransceiverDirection;
	direction: RTCRtpTransceiverDirection;
	get mid(): string;
	get receiver(): RTCRtpReceiver;
	get sender(): RTCRtpSender;
	stop(): void;
}

var RTCRtpTransceiver: ~Object with { constructor(); };

export external public interface ~RTCSessionDescription {
	get sdp(): string;
	get type(): RTCSdpType;
	toJSON(): any;
}

var RTCSessionDescription: ~Object with { constructor(descriptionInitDict: RTCSessionDescriptionInit); };

export external public interface ~RTCStatsReport {
	forEach(callbackfn: (value: any, key: string, parent: RTCStatsReport)=>void, thisArg: any = ): void;
}

var RTCStatsReport: ~Object with { constructor(); };

export external public interface ~RTCTrackEvent extends Event {
	get receiver(): RTCRtpReceiver;
	get streams(): ReadonlyArray<MediaStream>;
	get track(): MediaStreamTrack;
	get transceiver(): RTCRtpTransceiver;
}

var RTCTrackEvent: ~Object with { constructor(type: string, eventInitDict: RTCTrackEventInit); };

export external public interface ~RadioNodeList extends NodeList {
	value: string;
}

var RadioNodeList: ~Object with { constructor(); };

export external public interface ~Range extends AbstractRange {
	get commonAncestorContainer(): Node;
	cloneContents(): DocumentFragment;
	cloneRange(): Range;
	collapse(toStart: boolean = ): void;
	compareBoundaryPoints(how: number, sourceRange: Range): number;
	comparePoint(node: Node, offset: number): number;
	createContextualFragment(fragment: string): DocumentFragment;
	deleteContents(): void;
	detach(): void;
	extractContents(): DocumentFragment;
	getBoundingClientRect(): DOMRect;
	getClientRects(): DOMRectList;
	insertNode(node: Node): void;
	intersectsNode(node: Node): boolean;
	isPointInRange(node: Node, offset: number): boolean;
	selectNode(node: Node): void;
	selectNodeContents(node: Node): void;
	setEnd(node: Node, offset: number): void;
	setEndAfter(node: Node): void;
	setEndBefore(node: Node): void;
	setStart(node: Node, offset: number): void;
	setStartAfter(node: Node): void;
	setStartBefore(node: Node): void;
	surroundContents(newParent: Node): void;
	toString(): string;
	get END_TO_END(): number;
	get END_TO_START(): number;
	get START_TO_END(): number;
	get START_TO_START(): number;
}

var Range: ~Object with { constructor(); get END_TO_END(): number; get END_TO_START(): number; get START_TO_END(): number; get START_TO_START(): number; toString(): string; };

export external public interface ~ReadableStream<R=any> {
	get locked(): boolean;
	cancel(reason: any = ): Promise<undefined>;
	getReader(): ReadableStreamDefaultReader<R>;
	<T> pipeThrough(transform: ReadableWritablePair<T,R>, options: StreamPipeOptions = ): ReadableStream<T>;
	pipeTo(destination: WritableStream<R>, options: StreamPipeOptions = ): Promise<undefined>;
	tee(): [ReadableStream<R>,ReadableStream<R>];
	forEach(callbackfn: (value: any, key: number, parent: ReadableStream<R>)=>void, thisArg: any = ): void;
}

var ReadableStream: ~Object with { constructor(underlyingSource: UnderlyingSource<R> = , strategy: QueuingStrategy<R> = ); };

export external public interface ~ReadableStreamDefaultController<R=any> {
	get desiredSize(): number;
	close(): void;
	enqueue(chunk: R = ): void;
	error(e: any = ): void;
}

var ReadableStreamDefaultController: ~Object with { constructor(); };

export external public interface ~ReadableStreamDefaultReader<R=any> extends ReadableStreamGenericReader {
	read(): Promise<ReadableStreamDefaultReadResult<R>>;
	releaseLock(): void;
}

var ReadableStreamDefaultReader: ~Object with { constructor(stream: ReadableStream<R>); };

export external public interface ~ReadableStreamGenericReader {
	get closed(): Promise<undefined>;
	cancel(reason: any = ): Promise<undefined>;
}

export external public interface ~RemotePlaybackEventMap {
	connect: Event;
	connecting: Event;
	disconnect: Event;
}

export external public interface ~RemotePlayback extends EventTarget {
	onconnect: ({@This(RemotePlayback) function(ev: Event): any});
	onconnecting: ({@This(RemotePlayback) function(ev: Event): any});
	ondisconnect: ({@This(RemotePlayback) function(ev: Event): any});
	get state(): RemotePlaybackState;
	cancelWatchAvailability(id: number = ): Promise<undefined>;
	prompt(): Promise<undefined>;
	watchAvailability(callback: RemotePlaybackAvailabilityCallback): Promise<number>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var RemotePlayback: ~Object with { constructor(); };

export external public interface ~Request extends Body {
	get cache(): RequestCache;
	get credentials(): RequestCredentials;
	get destination(): RequestDestination;
	get headers(): Headers;
	get integrity(): string;
	get keepalive(): boolean;
	get method(): string;
	get mode(): RequestMode;
	get redirect(): RequestRedirect;
	get referrer(): string;
	get referrerPolicy(): ReferrerPolicy;
	get signal(): AbortSignal;
	get url(): string;
	clone(): Request;
}

var Request: ~Object with { constructor(input: RequestInfo, init: RequestInit = ); };

export external public interface ~ResizeObserver {
	disconnect(): void;
	observe(target: Element, options: ResizeObserverOptions = ): void;
	unobserve(target: Element): void;
}

var ResizeObserver: ~Object with { constructor(callback: ResizeObserverCallback); };

export external public interface ~ResizeObserverEntry {
	get borderBoxSize(): ReadonlyArray<ResizeObserverSize>;
	get contentBoxSize(): ReadonlyArray<ResizeObserverSize>;
	get contentRect(): DOMRectReadOnly;
	get target(): Element;
}

var ResizeObserverEntry: ~Object with { constructor(); };

export external public interface ~ResizeObserverSize {
	get blockSize(): number;
	get inlineSize(): number;
}

var ResizeObserverSize: ~Object with { constructor(); };

export external public interface ~Response extends Body {
	get headers(): Headers;
	get ok(): boolean;
	get redirected(): boolean;
	get status(): number;
	get statusText(): string;
	get type(): ResponseType;
	get url(): string;
	clone(): Response;
}

var Response: ~Object with { constructor(body: BodyInit = , init: ResponseInit = ); error(): Response; redirect(url: string | URL, status: number = ): Response; };

export external public interface ~SVGAElement extends SVGGraphicsElement, SVGURIReference {
	rel: string;
	get relList(): DOMTokenList;
	get target(): SVGAnimatedString;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGAElement: ~Object with { constructor(); };

export external public interface ~SVGAngle {
	get unitType(): number;
	value: number;
	valueAsString: string;
	valueInSpecifiedUnits: number;
	convertToSpecifiedUnits(unitType: number): void;
	newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
	get SVG_ANGLETYPE_DEG(): number;
	get SVG_ANGLETYPE_GRAD(): number;
	get SVG_ANGLETYPE_RAD(): number;
	get SVG_ANGLETYPE_UNKNOWN(): number;
	get SVG_ANGLETYPE_UNSPECIFIED(): number;
}

var SVGAngle: ~Object with { constructor(); get SVG_ANGLETYPE_DEG(): number; get SVG_ANGLETYPE_GRAD(): number; get SVG_ANGLETYPE_RAD(): number; get SVG_ANGLETYPE_UNKNOWN(): number; get SVG_ANGLETYPE_UNSPECIFIED(): number; };

export external public interface ~SVGAnimateElement extends SVGAnimationElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGAnimateElement: ~Object with { constructor(); };

export external public interface ~SVGAnimateMotionElement extends SVGAnimationElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGAnimateMotionElement: ~Object with { constructor(); };

export external public interface ~SVGAnimateTransformElement extends SVGAnimationElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGAnimateTransformElement: ~Object with { constructor(); };

export external public interface ~SVGAnimatedAngle {
	get animVal(): SVGAngle;
	get baseVal(): SVGAngle;
}

var SVGAnimatedAngle: ~Object with { constructor(); };

export external public interface ~SVGAnimatedBoolean {
	get animVal(): boolean;
	baseVal: boolean;
}

var SVGAnimatedBoolean: ~Object with { constructor(); };

export external public interface ~SVGAnimatedEnumeration {
	get animVal(): number;
	baseVal: number;
}

var SVGAnimatedEnumeration: ~Object with { constructor(); };

export external public interface ~SVGAnimatedInteger {
	get animVal(): number;
	baseVal: number;
}

var SVGAnimatedInteger: ~Object with { constructor(); };

export external public interface ~SVGAnimatedLength {
	get animVal(): SVGLength;
	get baseVal(): SVGLength;
}

var SVGAnimatedLength: ~Object with { constructor(); };

export external public interface ~SVGAnimatedLengthList {
	get animVal(): SVGLengthList;
	get baseVal(): SVGLengthList;
}

var SVGAnimatedLengthList: ~Object with { constructor(); };

export external public interface ~SVGAnimatedNumber {
	get animVal(): number;
	baseVal: number;
}

var SVGAnimatedNumber: ~Object with { constructor(); };

export external public interface ~SVGAnimatedNumberList {
	get animVal(): SVGNumberList;
	get baseVal(): SVGNumberList;
}

var SVGAnimatedNumberList: ~Object with { constructor(); };

export external public interface ~SVGAnimatedPoints {
	get animatedPoints(): SVGPointList;
	get points(): SVGPointList;
}

export external public interface ~SVGAnimatedPreserveAspectRatio {
	get animVal(): SVGPreserveAspectRatio;
	get baseVal(): SVGPreserveAspectRatio;
}

var SVGAnimatedPreserveAspectRatio: ~Object with { constructor(); };

export external public interface ~SVGAnimatedRect {
	get animVal(): DOMRectReadOnly;
	get baseVal(): DOMRect;
}

var SVGAnimatedRect: ~Object with { constructor(); };

export external public interface ~SVGAnimatedString {
	get animVal(): string;
	baseVal: string;
}

var SVGAnimatedString: ~Object with { constructor(); };

export external public interface ~SVGAnimatedTransformList {
	get animVal(): SVGTransformList;
	get baseVal(): SVGTransformList;
}

var SVGAnimatedTransformList: ~Object with { constructor(); };

export external public interface ~SVGAnimationElement extends SVGElement, SVGTests {
	get targetElement(): SVGElement;
	beginElement(): void;
	beginElementAt(offset: number): void;
	endElement(): void;
	endElementAt(offset: number): void;
	getCurrentTime(): number;
	getSimpleDuration(): number;
	getStartTime(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGAnimationElement: ~Object with { constructor(); };

export external public interface ~SVGCircleElement extends SVGGeometryElement {
	get cx(): SVGAnimatedLength;
	get cy(): SVGAnimatedLength;
	get r(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGCircleElement: ~Object with { constructor(); };

export external public interface ~SVGClipPathElement extends SVGElement {
	get clipPathUnits(): SVGAnimatedEnumeration;
	get transform(): SVGAnimatedTransformList;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGClipPathElement: ~Object with { constructor(); };

export external public interface ~SVGComponentTransferFunctionElement extends SVGElement {
	get amplitude(): SVGAnimatedNumber;
	get exponent(): SVGAnimatedNumber;
	get intercept(): SVGAnimatedNumber;
	get offset(): SVGAnimatedNumber;
	get slope(): SVGAnimatedNumber;
	get tableValues(): SVGAnimatedNumberList;
	get type(): SVGAnimatedEnumeration;
	get SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE(): number;
	get SVG_FECOMPONENTTRANSFER_TYPE_GAMMA(): number;
	get SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY(): number;
	get SVG_FECOMPONENTTRANSFER_TYPE_LINEAR(): number;
	get SVG_FECOMPONENTTRANSFER_TYPE_TABLE(): number;
	get SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGComponentTransferFunctionElement: ~Object with { constructor(); get SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE(): number; get SVG_FECOMPONENTTRANSFER_TYPE_GAMMA(): number; get SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY(): number; get SVG_FECOMPONENTTRANSFER_TYPE_LINEAR(): number; get SVG_FECOMPONENTTRANSFER_TYPE_TABLE(): number; get SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN(): number; };

export external public interface ~SVGDefsElement extends SVGGraphicsElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGDefsElement: ~Object with { constructor(); };

export external public interface ~SVGDescElement extends SVGElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGDescElement: ~Object with { constructor(); };

export external public interface ~SVGElementEventMap extends ElementEventMap, DocumentAndElementEventHandlersEventMap, GlobalEventHandlersEventMap {}

export external public interface ~SVGElement extends Element, DocumentAndElementEventHandlers, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrSVGElement {
	get className(): any;
	get ownerSVGElement(): SVGSVGElement;
	get viewportElement(): SVGElement;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGElement: ~Object with { constructor(); };

export external public interface ~SVGEllipseElement extends SVGGeometryElement {
	get cx(): SVGAnimatedLength;
	get cy(): SVGAnimatedLength;
	get rx(): SVGAnimatedLength;
	get ry(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGEllipseElement: ~Object with { constructor(); };

export external public interface ~SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	get in2(): SVGAnimatedString;
	get mode(): SVGAnimatedEnumeration;
	get SVG_FEBLEND_MODE_COLOR(): number;
	get SVG_FEBLEND_MODE_COLOR_BURN(): number;
	get SVG_FEBLEND_MODE_COLOR_DODGE(): number;
	get SVG_FEBLEND_MODE_DARKEN(): number;
	get SVG_FEBLEND_MODE_DIFFERENCE(): number;
	get SVG_FEBLEND_MODE_EXCLUSION(): number;
	get SVG_FEBLEND_MODE_HARD_LIGHT(): number;
	get SVG_FEBLEND_MODE_HUE(): number;
	get SVG_FEBLEND_MODE_LIGHTEN(): number;
	get SVG_FEBLEND_MODE_LUMINOSITY(): number;
	get SVG_FEBLEND_MODE_MULTIPLY(): number;
	get SVG_FEBLEND_MODE_NORMAL(): number;
	get SVG_FEBLEND_MODE_OVERLAY(): number;
	get SVG_FEBLEND_MODE_SATURATION(): number;
	get SVG_FEBLEND_MODE_SCREEN(): number;
	get SVG_FEBLEND_MODE_SOFT_LIGHT(): number;
	get SVG_FEBLEND_MODE_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEBlendElement: ~Object with { constructor(); get SVG_FEBLEND_MODE_COLOR(): number; get SVG_FEBLEND_MODE_COLOR_BURN(): number; get SVG_FEBLEND_MODE_COLOR_DODGE(): number; get SVG_FEBLEND_MODE_DARKEN(): number; get SVG_FEBLEND_MODE_DIFFERENCE(): number; get SVG_FEBLEND_MODE_EXCLUSION(): number; get SVG_FEBLEND_MODE_HARD_LIGHT(): number; get SVG_FEBLEND_MODE_HUE(): number; get SVG_FEBLEND_MODE_LIGHTEN(): number; get SVG_FEBLEND_MODE_LUMINOSITY(): number; get SVG_FEBLEND_MODE_MULTIPLY(): number; get SVG_FEBLEND_MODE_NORMAL(): number; get SVG_FEBLEND_MODE_OVERLAY(): number; get SVG_FEBLEND_MODE_SATURATION(): number; get SVG_FEBLEND_MODE_SCREEN(): number; get SVG_FEBLEND_MODE_SOFT_LIGHT(): number; get SVG_FEBLEND_MODE_UNKNOWN(): number; };

export external public interface ~SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	get type(): SVGAnimatedEnumeration;
	get values(): SVGAnimatedNumberList;
	get SVG_FECOLORMATRIX_TYPE_HUEROTATE(): number;
	get SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA(): number;
	get SVG_FECOLORMATRIX_TYPE_MATRIX(): number;
	get SVG_FECOLORMATRIX_TYPE_SATURATE(): number;
	get SVG_FECOLORMATRIX_TYPE_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEColorMatrixElement: ~Object with { constructor(); get SVG_FECOLORMATRIX_TYPE_HUEROTATE(): number; get SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA(): number; get SVG_FECOLORMATRIX_TYPE_MATRIX(): number; get SVG_FECOLORMATRIX_TYPE_SATURATE(): number; get SVG_FECOLORMATRIX_TYPE_UNKNOWN(): number; };

export external public interface ~SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEComponentTransferElement: ~Object with { constructor(); };

export external public interface ~SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	get in2(): SVGAnimatedString;
	get k1(): SVGAnimatedNumber;
	get k2(): SVGAnimatedNumber;
	get k3(): SVGAnimatedNumber;
	get k4(): SVGAnimatedNumber;
	get operator(): SVGAnimatedEnumeration;
	get SVG_FECOMPOSITE_OPERATOR_ARITHMETIC(): number;
	get SVG_FECOMPOSITE_OPERATOR_ATOP(): number;
	get SVG_FECOMPOSITE_OPERATOR_IN(): number;
	get SVG_FECOMPOSITE_OPERATOR_OUT(): number;
	get SVG_FECOMPOSITE_OPERATOR_OVER(): number;
	get SVG_FECOMPOSITE_OPERATOR_UNKNOWN(): number;
	get SVG_FECOMPOSITE_OPERATOR_XOR(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFECompositeElement: ~Object with { constructor(); get SVG_FECOMPOSITE_OPERATOR_ARITHMETIC(): number; get SVG_FECOMPOSITE_OPERATOR_ATOP(): number; get SVG_FECOMPOSITE_OPERATOR_IN(): number; get SVG_FECOMPOSITE_OPERATOR_OUT(): number; get SVG_FECOMPOSITE_OPERATOR_OVER(): number; get SVG_FECOMPOSITE_OPERATOR_UNKNOWN(): number; get SVG_FECOMPOSITE_OPERATOR_XOR(): number; };

export external public interface ~SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get bias(): SVGAnimatedNumber;
	get divisor(): SVGAnimatedNumber;
	get edgeMode(): SVGAnimatedEnumeration;
	get in1(): SVGAnimatedString;
	get kernelMatrix(): SVGAnimatedNumberList;
	get kernelUnitLengthX(): SVGAnimatedNumber;
	get kernelUnitLengthY(): SVGAnimatedNumber;
	get orderX(): SVGAnimatedInteger;
	get orderY(): SVGAnimatedInteger;
	get preserveAlpha(): SVGAnimatedBoolean;
	get targetX(): SVGAnimatedInteger;
	get targetY(): SVGAnimatedInteger;
	get SVG_EDGEMODE_DUPLICATE(): number;
	get SVG_EDGEMODE_NONE(): number;
	get SVG_EDGEMODE_UNKNOWN(): number;
	get SVG_EDGEMODE_WRAP(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEConvolveMatrixElement: ~Object with { constructor(); get SVG_EDGEMODE_DUPLICATE(): number; get SVG_EDGEMODE_NONE(): number; get SVG_EDGEMODE_UNKNOWN(): number; get SVG_EDGEMODE_WRAP(): number; };

export external public interface ~SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get diffuseConstant(): SVGAnimatedNumber;
	get in1(): SVGAnimatedString;
	get kernelUnitLengthX(): SVGAnimatedNumber;
	get kernelUnitLengthY(): SVGAnimatedNumber;
	get surfaceScale(): SVGAnimatedNumber;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEDiffuseLightingElement: ~Object with { constructor(); };

export external public interface ~SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	get in2(): SVGAnimatedString;
	get scale(): SVGAnimatedNumber;
	get xChannelSelector(): SVGAnimatedEnumeration;
	get yChannelSelector(): SVGAnimatedEnumeration;
	get SVG_CHANNEL_A(): number;
	get SVG_CHANNEL_B(): number;
	get SVG_CHANNEL_G(): number;
	get SVG_CHANNEL_R(): number;
	get SVG_CHANNEL_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEDisplacementMapElement: ~Object with { constructor(); get SVG_CHANNEL_A(): number; get SVG_CHANNEL_B(): number; get SVG_CHANNEL_G(): number; get SVG_CHANNEL_R(): number; get SVG_CHANNEL_UNKNOWN(): number; };

export external public interface ~SVGFEDistantLightElement extends SVGElement {
	get azimuth(): SVGAnimatedNumber;
	get elevation(): SVGAnimatedNumber;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEDistantLightElement: ~Object with { constructor(); };

export external public interface ~SVGFEDropShadowElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get dx(): SVGAnimatedNumber;
	get dy(): SVGAnimatedNumber;
	get in1(): SVGAnimatedString;
	get stdDeviationX(): SVGAnimatedNumber;
	get stdDeviationY(): SVGAnimatedNumber;
	setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEDropShadowElement: ~Object with { constructor(); };

export external public interface ~SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEFloodElement: ~Object with { constructor(); };

export external public interface ~SVGFEFuncAElement extends SVGComponentTransferFunctionElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEFuncAElement: ~Object with { constructor(); };

export external public interface ~SVGFEFuncBElement extends SVGComponentTransferFunctionElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEFuncBElement: ~Object with { constructor(); };

export external public interface ~SVGFEFuncGElement extends SVGComponentTransferFunctionElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEFuncGElement: ~Object with { constructor(); };

export external public interface ~SVGFEFuncRElement extends SVGComponentTransferFunctionElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEFuncRElement: ~Object with { constructor(); };

export external public interface ~SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	get stdDeviationX(): SVGAnimatedNumber;
	get stdDeviationY(): SVGAnimatedNumber;
	setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEGaussianBlurElement: ~Object with { constructor(); };

export external public interface ~SVGFEImageElement extends SVGElement, SVGFilterPrimitiveStandardAttributes, SVGURIReference {
	get preserveAspectRatio(): SVGAnimatedPreserveAspectRatio;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEImageElement: ~Object with { constructor(); };

export external public interface ~SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEMergeElement: ~Object with { constructor(); };

export external public interface ~SVGFEMergeNodeElement extends SVGElement {
	get in1(): SVGAnimatedString;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEMergeNodeElement: ~Object with { constructor(); };

export external public interface ~SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	get operator(): SVGAnimatedEnumeration;
	get radiusX(): SVGAnimatedNumber;
	get radiusY(): SVGAnimatedNumber;
	get SVG_MORPHOLOGY_OPERATOR_DILATE(): number;
	get SVG_MORPHOLOGY_OPERATOR_ERODE(): number;
	get SVG_MORPHOLOGY_OPERATOR_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEMorphologyElement: ~Object with { constructor(); get SVG_MORPHOLOGY_OPERATOR_DILATE(): number; get SVG_MORPHOLOGY_OPERATOR_ERODE(): number; get SVG_MORPHOLOGY_OPERATOR_UNKNOWN(): number; };

export external public interface ~SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get dx(): SVGAnimatedNumber;
	get dy(): SVGAnimatedNumber;
	get in1(): SVGAnimatedString;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEOffsetElement: ~Object with { constructor(); };

export external public interface ~SVGFEPointLightElement extends SVGElement {
	get x(): SVGAnimatedNumber;
	get y(): SVGAnimatedNumber;
	get z(): SVGAnimatedNumber;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFEPointLightElement: ~Object with { constructor(); };

export external public interface ~SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	get kernelUnitLengthX(): SVGAnimatedNumber;
	get kernelUnitLengthY(): SVGAnimatedNumber;
	get specularConstant(): SVGAnimatedNumber;
	get specularExponent(): SVGAnimatedNumber;
	get surfaceScale(): SVGAnimatedNumber;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFESpecularLightingElement: ~Object with { constructor(); };

export external public interface ~SVGFESpotLightElement extends SVGElement {
	get limitingConeAngle(): SVGAnimatedNumber;
	get pointsAtX(): SVGAnimatedNumber;
	get pointsAtY(): SVGAnimatedNumber;
	get pointsAtZ(): SVGAnimatedNumber;
	get specularExponent(): SVGAnimatedNumber;
	get x(): SVGAnimatedNumber;
	get y(): SVGAnimatedNumber;
	get z(): SVGAnimatedNumber;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFESpotLightElement: ~Object with { constructor(); };

export external public interface ~SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get in1(): SVGAnimatedString;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFETileElement: ~Object with { constructor(); };

export external public interface ~SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
	get baseFrequencyX(): SVGAnimatedNumber;
	get baseFrequencyY(): SVGAnimatedNumber;
	get numOctaves(): SVGAnimatedInteger;
	get seed(): SVGAnimatedNumber;
	get stitchTiles(): SVGAnimatedEnumeration;
	get type(): SVGAnimatedEnumeration;
	get SVG_STITCHTYPE_NOSTITCH(): number;
	get SVG_STITCHTYPE_STITCH(): number;
	get SVG_STITCHTYPE_UNKNOWN(): number;
	get SVG_TURBULENCE_TYPE_FRACTALNOISE(): number;
	get SVG_TURBULENCE_TYPE_TURBULENCE(): number;
	get SVG_TURBULENCE_TYPE_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFETurbulenceElement: ~Object with { constructor(); get SVG_STITCHTYPE_NOSTITCH(): number; get SVG_STITCHTYPE_STITCH(): number; get SVG_STITCHTYPE_UNKNOWN(): number; get SVG_TURBULENCE_TYPE_FRACTALNOISE(): number; get SVG_TURBULENCE_TYPE_TURBULENCE(): number; get SVG_TURBULENCE_TYPE_UNKNOWN(): number; };

export external public interface ~SVGFilterElement extends SVGElement, SVGURIReference {
	get filterUnits(): SVGAnimatedEnumeration;
	get height(): SVGAnimatedLength;
	get primitiveUnits(): SVGAnimatedEnumeration;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGFilterElement: ~Object with { constructor(); };

export external public interface ~SVGFilterPrimitiveStandardAttributes {
	get height(): SVGAnimatedLength;
	get result(): SVGAnimatedString;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
}

export external public interface ~SVGFitToViewBox {
	get preserveAspectRatio(): SVGAnimatedPreserveAspectRatio;
	get viewBox(): SVGAnimatedRect;
}

export external public interface ~SVGForeignObjectElement extends SVGGraphicsElement {
	get height(): SVGAnimatedLength;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGForeignObjectElement: ~Object with { constructor(); };

export external public interface ~SVGGElement extends SVGGraphicsElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGGElement: ~Object with { constructor(); };

export external public interface ~SVGGeometryElement extends SVGGraphicsElement {
	get pathLength(): SVGAnimatedNumber;
	getPointAtLength(distance: number): DOMPoint;
	getTotalLength(): number;
	isPointInFill(point: DOMPointInit = ): boolean;
	isPointInStroke(point: DOMPointInit = ): boolean;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGGeometryElement: ~Object with { constructor(); };

export external public interface ~SVGGradientElement extends SVGElement, SVGURIReference {
	get gradientTransform(): SVGAnimatedTransformList;
	get gradientUnits(): SVGAnimatedEnumeration;
	get spreadMethod(): SVGAnimatedEnumeration;
	get SVG_SPREADMETHOD_PAD(): number;
	get SVG_SPREADMETHOD_REFLECT(): number;
	get SVG_SPREADMETHOD_REPEAT(): number;
	get SVG_SPREADMETHOD_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGGradientElement: ~Object with { constructor(); get SVG_SPREADMETHOD_PAD(): number; get SVG_SPREADMETHOD_REFLECT(): number; get SVG_SPREADMETHOD_REPEAT(): number; get SVG_SPREADMETHOD_UNKNOWN(): number; };

export external public interface ~SVGGraphicsElement extends SVGElement, SVGTests {
	get transform(): SVGAnimatedTransformList;
	getBBox(options: SVGBoundingBoxOptions = ): DOMRect;
	getCTM(): DOMMatrix;
	getScreenCTM(): DOMMatrix;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGGraphicsElement: ~Object with { constructor(); };

export external public interface ~SVGImageElement extends SVGGraphicsElement, SVGURIReference {
	get height(): SVGAnimatedLength;
	get preserveAspectRatio(): SVGAnimatedPreserveAspectRatio;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGImageElement: ~Object with { constructor(); };

export external public interface ~SVGLength {
	get unitType(): number;
	value: number;
	valueAsString: string;
	valueInSpecifiedUnits: number;
	convertToSpecifiedUnits(unitType: number): void;
	newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
	get SVG_LENGTHTYPE_CM(): number;
	get SVG_LENGTHTYPE_EMS(): number;
	get SVG_LENGTHTYPE_EXS(): number;
	get SVG_LENGTHTYPE_IN(): number;
	get SVG_LENGTHTYPE_MM(): number;
	get SVG_LENGTHTYPE_NUMBER(): number;
	get SVG_LENGTHTYPE_PC(): number;
	get SVG_LENGTHTYPE_PERCENTAGE(): number;
	get SVG_LENGTHTYPE_PT(): number;
	get SVG_LENGTHTYPE_PX(): number;
	get SVG_LENGTHTYPE_UNKNOWN(): number;
}

var SVGLength: ~Object with { constructor(); get SVG_LENGTHTYPE_CM(): number; get SVG_LENGTHTYPE_EMS(): number; get SVG_LENGTHTYPE_EXS(): number; get SVG_LENGTHTYPE_IN(): number; get SVG_LENGTHTYPE_MM(): number; get SVG_LENGTHTYPE_NUMBER(): number; get SVG_LENGTHTYPE_PC(): number; get SVG_LENGTHTYPE_PERCENTAGE(): number; get SVG_LENGTHTYPE_PT(): number; get SVG_LENGTHTYPE_PX(): number; get SVG_LENGTHTYPE_UNKNOWN(): number; };

export external public interface ~SVGLengthList {
	get length(): number;
	get numberOfItems(): number;
	appendItem(newItem: SVGLength): SVGLength;
	clear(): void;
	getItem(index: number): SVGLength;
	initialize(newItem: SVGLength): SVGLength;
	insertItemBefore(newItem: SVGLength, index: number): SVGLength;
	removeItem(index: number): SVGLength;
	replaceItem(newItem: SVGLength, index: number): SVGLength;
}

var SVGLengthList: ~Object with { constructor(); };

export external public interface ~SVGLineElement extends SVGGeometryElement {
	get x1(): SVGAnimatedLength;
	get x2(): SVGAnimatedLength;
	get y1(): SVGAnimatedLength;
	get y2(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGLineElement: ~Object with { constructor(); };

export external public interface ~SVGLinearGradientElement extends SVGGradientElement {
	get x1(): SVGAnimatedLength;
	get x2(): SVGAnimatedLength;
	get y1(): SVGAnimatedLength;
	get y2(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGLinearGradientElement: ~Object with { constructor(); };

export external public interface ~SVGMPathElement extends SVGElement, SVGURIReference {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGMPathElement: ~Object with { constructor(); };

export external public interface ~SVGMarkerElement extends SVGElement, SVGFitToViewBox {
	get markerHeight(): SVGAnimatedLength;
	get markerUnits(): SVGAnimatedEnumeration;
	get markerWidth(): SVGAnimatedLength;
	get orientAngle(): SVGAnimatedAngle;
	get orientType(): SVGAnimatedEnumeration;
	get refX(): SVGAnimatedLength;
	get refY(): SVGAnimatedLength;
	setOrientToAngle(angle: SVGAngle): void;
	setOrientToAuto(): void;
	get SVG_MARKERUNITS_STROKEWIDTH(): number;
	get SVG_MARKERUNITS_UNKNOWN(): number;
	get SVG_MARKERUNITS_USERSPACEONUSE(): number;
	get SVG_MARKER_ORIENT_ANGLE(): number;
	get SVG_MARKER_ORIENT_AUTO(): number;
	get SVG_MARKER_ORIENT_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGMarkerElement: ~Object with { constructor(); get SVG_MARKERUNITS_STROKEWIDTH(): number; get SVG_MARKERUNITS_UNKNOWN(): number; get SVG_MARKERUNITS_USERSPACEONUSE(): number; get SVG_MARKER_ORIENT_ANGLE(): number; get SVG_MARKER_ORIENT_AUTO(): number; get SVG_MARKER_ORIENT_UNKNOWN(): number; };

export external public interface ~SVGMaskElement extends SVGElement {
	get height(): SVGAnimatedLength;
	get maskContentUnits(): SVGAnimatedEnumeration;
	get maskUnits(): SVGAnimatedEnumeration;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGMaskElement: ~Object with { constructor(); };

export external public interface ~SVGMetadataElement extends SVGElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGMetadataElement: ~Object with { constructor(); };

export external public interface ~SVGNumber {
	value: number;
}

var SVGNumber: ~Object with { constructor(); };

export external public interface ~SVGNumberList {
	get length(): number;
	get numberOfItems(): number;
	appendItem(newItem: SVGNumber): SVGNumber;
	clear(): void;
	getItem(index: number): SVGNumber;
	initialize(newItem: SVGNumber): SVGNumber;
	insertItemBefore(newItem: SVGNumber, index: number): SVGNumber;
	removeItem(index: number): SVGNumber;
	replaceItem(newItem: SVGNumber, index: number): SVGNumber;
}

var SVGNumberList: ~Object with { constructor(); };

export external public interface ~SVGPathElement extends SVGGeometryElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGPathElement: ~Object with { constructor(); };

export external public interface ~SVGPatternElement extends SVGElement, SVGFitToViewBox, SVGURIReference {
	get height(): SVGAnimatedLength;
	get patternContentUnits(): SVGAnimatedEnumeration;
	get patternTransform(): SVGAnimatedTransformList;
	get patternUnits(): SVGAnimatedEnumeration;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGPatternElement: ~Object with { constructor(); };

export external public interface ~SVGPointList {
	get length(): number;
	get numberOfItems(): number;
	appendItem(newItem: DOMPoint): DOMPoint;
	clear(): void;
	getItem(index: number): DOMPoint;
	initialize(newItem: DOMPoint): DOMPoint;
	insertItemBefore(newItem: DOMPoint, index: number): DOMPoint;
	removeItem(index: number): DOMPoint;
	replaceItem(newItem: DOMPoint, index: number): DOMPoint;
}

var SVGPointList: ~Object with { constructor(); };

export external public interface ~SVGPolygonElement extends SVGGeometryElement, SVGAnimatedPoints {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGPolygonElement: ~Object with { constructor(); };

export external public interface ~SVGPolylineElement extends SVGGeometryElement, SVGAnimatedPoints {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGPolylineElement: ~Object with { constructor(); };

export external public interface ~SVGPreserveAspectRatio {
	align: number;
	meetOrSlice: number;
	get SVG_MEETORSLICE_MEET(): number;
	get SVG_MEETORSLICE_SLICE(): number;
	get SVG_MEETORSLICE_UNKNOWN(): number;
	get SVG_PRESERVEASPECTRATIO_NONE(): number;
	get SVG_PRESERVEASPECTRATIO_UNKNOWN(): number;
	get SVG_PRESERVEASPECTRATIO_XMAXYMAX(): number;
	get SVG_PRESERVEASPECTRATIO_XMAXYMID(): number;
	get SVG_PRESERVEASPECTRATIO_XMAXYMIN(): number;
	get SVG_PRESERVEASPECTRATIO_XMIDYMAX(): number;
	get SVG_PRESERVEASPECTRATIO_XMIDYMID(): number;
	get SVG_PRESERVEASPECTRATIO_XMIDYMIN(): number;
	get SVG_PRESERVEASPECTRATIO_XMINYMAX(): number;
	get SVG_PRESERVEASPECTRATIO_XMINYMID(): number;
	get SVG_PRESERVEASPECTRATIO_XMINYMIN(): number;
}

var SVGPreserveAspectRatio: ~Object with { constructor(); get SVG_MEETORSLICE_MEET(): number; get SVG_MEETORSLICE_SLICE(): number; get SVG_MEETORSLICE_UNKNOWN(): number; get SVG_PRESERVEASPECTRATIO_NONE(): number; get SVG_PRESERVEASPECTRATIO_UNKNOWN(): number; get SVG_PRESERVEASPECTRATIO_XMAXYMAX(): number; get SVG_PRESERVEASPECTRATIO_XMAXYMID(): number; get SVG_PRESERVEASPECTRATIO_XMAXYMIN(): number; get SVG_PRESERVEASPECTRATIO_XMIDYMAX(): number; get SVG_PRESERVEASPECTRATIO_XMIDYMID(): number; get SVG_PRESERVEASPECTRATIO_XMIDYMIN(): number; get SVG_PRESERVEASPECTRATIO_XMINYMAX(): number; get SVG_PRESERVEASPECTRATIO_XMINYMID(): number; get SVG_PRESERVEASPECTRATIO_XMINYMIN(): number; };

export external public interface ~SVGRadialGradientElement extends SVGGradientElement {
	get cx(): SVGAnimatedLength;
	get cy(): SVGAnimatedLength;
	get fr(): SVGAnimatedLength;
	get fx(): SVGAnimatedLength;
	get fy(): SVGAnimatedLength;
	get r(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGRadialGradientElement: ~Object with { constructor(); };

export external public interface ~SVGRectElement extends SVGGeometryElement {
	get height(): SVGAnimatedLength;
	get rx(): SVGAnimatedLength;
	get ry(): SVGAnimatedLength;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGRectElement: ~Object with { constructor(); };

export external public interface ~SVGSVGElementEventMap extends SVGElementEventMap, WindowEventHandlersEventMap {}

export external public interface ~SVGSVGElement extends SVGGraphicsElement, SVGFitToViewBox, WindowEventHandlers {
	currentScale: number;
	get currentTranslate(): DOMPointReadOnly;
	get height(): SVGAnimatedLength;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	animationsPaused(): boolean;
	checkEnclosure(element: SVGElement, rect: DOMRectReadOnly): boolean;
	checkIntersection(element: SVGElement, rect: DOMRectReadOnly): boolean;
	createSVGAngle(): SVGAngle;
	createSVGLength(): SVGLength;
	createSVGMatrix(): DOMMatrix;
	createSVGNumber(): SVGNumber;
	createSVGPoint(): DOMPoint;
	createSVGRect(): DOMRect;
	createSVGTransform(): SVGTransform;
	createSVGTransformFromMatrix(matrix: DOMMatrix2DInit = ): SVGTransform;
	deselectAll(): void;
	forceRedraw(): void;
	getCurrentTime(): number;
	getElementById(elementId: string): Element;
	getEnclosureList(rect: DOMRectReadOnly, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;
	getIntersectionList(rect: DOMRectReadOnly, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;
	pauseAnimations(): void;
	setCurrentTime(seconds: number): void;
	suspendRedraw(maxWaitMilliseconds: number): number;
	unpauseAnimations(): void;
	unsuspendRedraw(suspendHandleID: number): void;
	unsuspendRedrawAll(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGSVGElement: ~Object with { constructor(); };

export external public interface ~SVGScriptElement extends SVGElement, SVGURIReference {
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGScriptElement: ~Object with { constructor(); };

export external public interface ~SVGSetElement extends SVGAnimationElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGSetElement: ~Object with { constructor(); };

export external public interface ~SVGStopElement extends SVGElement {
	get offset(): SVGAnimatedNumber;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGStopElement: ~Object with { constructor(); };

export external public interface ~SVGStringList {
	get length(): number;
	get numberOfItems(): number;
	appendItem(newItem: string): string;
	clear(): void;
	getItem(index: number): string;
	initialize(newItem: string): string;
	insertItemBefore(newItem: string, index: number): string;
	removeItem(index: number): string;
	replaceItem(newItem: string, index: number): string;
}

var SVGStringList: ~Object with { constructor(); };

export external public interface ~SVGStyleElement extends SVGElement, LinkStyle {
	disabled: boolean;
	media: string;
	title: string;
	type: string;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGStyleElement: ~Object with { constructor(); };

export external public interface ~SVGSwitchElement extends SVGGraphicsElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGSwitchElement: ~Object with { constructor(); };

export external public interface ~SVGSymbolElement extends SVGElement, SVGFitToViewBox {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGSymbolElement: ~Object with { constructor(); };

export external public interface ~SVGTSpanElement extends SVGTextPositioningElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGTSpanElement: ~Object with { constructor(); };

export external public interface ~SVGTests {
	get requiredExtensions(): SVGStringList;
	get systemLanguage(): SVGStringList;
}

export external public interface ~SVGTextContentElement extends SVGGraphicsElement {
	get lengthAdjust(): SVGAnimatedEnumeration;
	get textLength(): SVGAnimatedLength;
	getCharNumAtPosition(point: DOMPointInit = ): number;
	getComputedTextLength(): number;
	getEndPositionOfChar(charnum: number): DOMPoint;
	getExtentOfChar(charnum: number): DOMRect;
	getNumberOfChars(): number;
	getRotationOfChar(charnum: number): number;
	getStartPositionOfChar(charnum: number): DOMPoint;
	getSubStringLength(charnum: number, nchars: number): number;
	selectSubString(charnum: number, nchars: number): void;
	get LENGTHADJUST_SPACING(): number;
	get LENGTHADJUST_SPACINGANDGLYPHS(): number;
	get LENGTHADJUST_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGTextContentElement: ~Object with { constructor(); get LENGTHADJUST_SPACING(): number; get LENGTHADJUST_SPACINGANDGLYPHS(): number; get LENGTHADJUST_UNKNOWN(): number; };

export external public interface ~SVGTextElement extends SVGTextPositioningElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGTextElement: ~Object with { constructor(); };

export external public interface ~SVGTextPathElement extends SVGTextContentElement, SVGURIReference {
	get method(): SVGAnimatedEnumeration;
	get spacing(): SVGAnimatedEnumeration;
	get startOffset(): SVGAnimatedLength;
	get TEXTPATH_METHODTYPE_ALIGN(): number;
	get TEXTPATH_METHODTYPE_STRETCH(): number;
	get TEXTPATH_METHODTYPE_UNKNOWN(): number;
	get TEXTPATH_SPACINGTYPE_AUTO(): number;
	get TEXTPATH_SPACINGTYPE_EXACT(): number;
	get TEXTPATH_SPACINGTYPE_UNKNOWN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGTextPathElement: ~Object with { constructor(); get TEXTPATH_METHODTYPE_ALIGN(): number; get TEXTPATH_METHODTYPE_STRETCH(): number; get TEXTPATH_METHODTYPE_UNKNOWN(): number; get TEXTPATH_SPACINGTYPE_AUTO(): number; get TEXTPATH_SPACINGTYPE_EXACT(): number; get TEXTPATH_SPACINGTYPE_UNKNOWN(): number; };

export external public interface ~SVGTextPositioningElement extends SVGTextContentElement {
	get dx(): SVGAnimatedLengthList;
	get dy(): SVGAnimatedLengthList;
	get rotate(): SVGAnimatedNumberList;
	get x(): SVGAnimatedLengthList;
	get y(): SVGAnimatedLengthList;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGTextPositioningElement: ~Object with { constructor(); };

export external public interface ~SVGTitleElement extends SVGElement {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGTitleElement: ~Object with { constructor(); };

export external public interface ~SVGTransform {
	get angle(): number;
	get matrix(): DOMMatrix;
	get type(): number;
	setMatrix(matrix: DOMMatrix2DInit = ): void;
	setRotate(angle: number, cx: number, cy: number): void;
	setScale(sx: number, sy: number): void;
	setSkewX(angle: number): void;
	setSkewY(angle: number): void;
	setTranslate(tx: number, ty: number): void;
	get SVG_TRANSFORM_MATRIX(): number;
	get SVG_TRANSFORM_ROTATE(): number;
	get SVG_TRANSFORM_SCALE(): number;
	get SVG_TRANSFORM_SKEWX(): number;
	get SVG_TRANSFORM_SKEWY(): number;
	get SVG_TRANSFORM_TRANSLATE(): number;
	get SVG_TRANSFORM_UNKNOWN(): number;
}

var SVGTransform: ~Object with { constructor(); get SVG_TRANSFORM_MATRIX(): number; get SVG_TRANSFORM_ROTATE(): number; get SVG_TRANSFORM_SCALE(): number; get SVG_TRANSFORM_SKEWX(): number; get SVG_TRANSFORM_SKEWY(): number; get SVG_TRANSFORM_TRANSLATE(): number; get SVG_TRANSFORM_UNKNOWN(): number; };

export external public interface ~SVGTransformList {
	get length(): number;
	get numberOfItems(): number;
	appendItem(newItem: SVGTransform): SVGTransform;
	clear(): void;
	consolidate(): SVGTransform;
	createSVGTransformFromMatrix(matrix: DOMMatrix2DInit = ): SVGTransform;
	getItem(index: number): SVGTransform;
	initialize(newItem: SVGTransform): SVGTransform;
	insertItemBefore(newItem: SVGTransform, index: number): SVGTransform;
	removeItem(index: number): SVGTransform;
	replaceItem(newItem: SVGTransform, index: number): SVGTransform;
}

var SVGTransformList: ~Object with { constructor(); };

export external public interface ~SVGURIReference {
	get href(): SVGAnimatedString;
}

export external public interface ~SVGUnitTypes {
	get SVG_UNIT_TYPE_OBJECTBOUNDINGBOX(): number;
	get SVG_UNIT_TYPE_UNKNOWN(): number;
	get SVG_UNIT_TYPE_USERSPACEONUSE(): number;
}

var SVGUnitTypes: ~Object with { constructor(); get SVG_UNIT_TYPE_OBJECTBOUNDINGBOX(): number; get SVG_UNIT_TYPE_UNKNOWN(): number; get SVG_UNIT_TYPE_USERSPACEONUSE(): number; };

export external public interface ~SVGUseElement extends SVGGraphicsElement, SVGURIReference {
	get height(): SVGAnimatedLength;
	get width(): SVGAnimatedLength;
	get x(): SVGAnimatedLength;
	get y(): SVGAnimatedLength;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGUseElement: ~Object with { constructor(); };

export external public interface ~SVGViewElement extends SVGElement, SVGFitToViewBox {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SVGViewElement: ~Object with { constructor(); };

export external public interface ~Screen {
	get availHeight(): number;
	get availWidth(): number;
	get colorDepth(): number;
	get height(): number;
	get orientation(): ScreenOrientation;
	get pixelDepth(): number;
	get width(): number;
}

var Screen: ~Object with { constructor(); };

export external public interface ~ScreenOrientationEventMap {
	change: Event;
}

export external public interface ~ScreenOrientation extends EventTarget {
	get angle(): number;
	onchange: ({@This(ScreenOrientation) function(ev: Event): any});
	get type(): OrientationType;
	lock(orientation: OrientationLockType): Promise<undefined>;
	unlock(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var ScreenOrientation: ~Object with { constructor(); };

export external public interface ~ScriptProcessorNodeEventMap {
	audioprocess: AudioProcessingEvent;
}

export external public interface ~ScriptProcessorNode extends AudioNode {
	get bufferSize(): number;
	onaudioprocess: ({@This(ScriptProcessorNode) function(ev: AudioProcessingEvent): any});
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var ScriptProcessorNode: ~Object with { constructor(); };

export external public interface ~SecurityPolicyViolationEvent extends Event {
	get blockedURI(): string;
	get columnNumber(): number;
	get disposition(): SecurityPolicyViolationEventDisposition;
	get documentURI(): string;
	get effectiveDirective(): string;
	get lineNumber(): number;
	get originalPolicy(): string;
	get referrer(): string;
	get sample(): string;
	get sourceFile(): string;
	get statusCode(): number;
	get violatedDirective(): string;
}

var SecurityPolicyViolationEvent: ~Object with { constructor(type: string, eventInitDict: SecurityPolicyViolationEventInit = ); };

export external public interface ~Selection {
	get anchorNode(): Node;
	get anchorOffset(): number;
	get focusNode(): Node;
	get focusOffset(): number;
	get isCollapsed(): boolean;
	get rangeCount(): number;
	get type(): string;
	addRange(range: Range): void;
	collapse(node: Node, offset: number = ): void;
	collapseToEnd(): void;
	collapseToStart(): void;
	containsNode(node: Node, allowPartialContainment: boolean = ): boolean;
	deleteFromDocument(): void;
	empty(): void;
	extend(node: Node, offset: number = ): void;
	getRangeAt(index: number): Range;
	removeAllRanges(): void;
	removeRange(range: Range): void;
	selectAllChildren(node: Node): void;
	setBaseAndExtent(anchorNode: Node, anchorOffset: number, focusNode: Node, focusOffset: number): void;
	setPosition(node: Node, offset: number = ): void;
	toString(): string;
}

var Selection: ~Object with { constructor(); toString(): string; };

export external public interface ~ServiceWorkerEventMap extends AbstractWorkerEventMap {
	statechange: Event;
}

export external public interface ~ServiceWorker extends EventTarget, AbstractWorker {
	onstatechange: ({@This(ServiceWorker) function(ev: Event): any});
	get scriptURL(): string;
	get state(): ServiceWorkerState;
	postMessage(...args: any+): any+; // overloading not supported
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var ServiceWorker: ~Object with { constructor(); };

export external public interface ~ServiceWorkerContainerEventMap {
	controllerchange: Event;
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public interface ~ServiceWorkerContainer extends EventTarget {
	get controller(): ServiceWorker;
	oncontrollerchange: ({@This(ServiceWorkerContainer) function(ev: Event): any});
	onmessage: ({@This(ServiceWorkerContainer) function(ev: MessageEvent): any});
	onmessageerror: ({@This(ServiceWorkerContainer) function(ev: MessageEvent): any});
	get ready(): Promise<ServiceWorkerRegistration>;
	getRegistration(clientURL: string | URL = ): Promise<ServiceWorkerRegistration>;
	getRegistrations(): Promise<ReadonlyArray<ServiceWorkerRegistration>>;
	register(scriptURL: string | URL, options: RegistrationOptions = ): Promise<ServiceWorkerRegistration>;
	startMessages(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var ServiceWorkerContainer: ~Object with { constructor(); };

export external public interface ~ServiceWorkerRegistrationEventMap {
	updatefound: Event;
}

export external public interface ~ServiceWorkerRegistration extends EventTarget {
	get active(): ServiceWorker;
	get installing(): ServiceWorker;
	onupdatefound: ({@This(ServiceWorkerRegistration) function(ev: Event): any});
	get pushManager(): PushManager;
	get scope(): string;
	get updateViaCache(): ServiceWorkerUpdateViaCache;
	get waiting(): ServiceWorker;
	getNotifications(filter: GetNotificationOptions = ): Promise<Array<Notification>>;
	showNotification(title: string, options: NotificationOptions = ): Promise<undefined>;
	unregister(): Promise<boolean>;
	update(): Promise<undefined>;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var ServiceWorkerRegistration: ~Object with { constructor(); };

export external public interface ~ShadowRoot extends DocumentFragment, DocumentOrShadowRoot, InnerHTML {
	get delegatesFocus(): boolean;
	get host(): Element;
	get mode(): ShadowRootMode;
}

var ShadowRoot: ~Object with { constructor(); };

export external public interface ~SharedWorker extends EventTarget, AbstractWorker {
	get port(): MessagePort;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SharedWorker: ~Object with { constructor(scriptURL: string | URL, options: string | WorkerOptions = ); };

export external public interface ~Slottable {
	get assignedSlot(): HTMLSlotElement;
}

export external public interface ~SourceBufferEventMap {
	abort: Event;
	error: Event;
	update: Event;
	updateend: Event;
	updatestart: Event;
}

export external public interface ~SourceBuffer extends EventTarget {
	appendWindowEnd: number;
	appendWindowStart: number;
	get buffered(): TimeRanges;
	mode: AppendMode;
	onabort: ({@This(SourceBuffer) function(ev: Event): any});
	onerror: ({@This(SourceBuffer) function(ev: Event): any});
	onupdate: ({@This(SourceBuffer) function(ev: Event): any});
	onupdateend: ({@This(SourceBuffer) function(ev: Event): any});
	onupdatestart: ({@This(SourceBuffer) function(ev: Event): any});
	timestampOffset: number;
	get updating(): boolean;
	abort(): void;
	appendBuffer(data: BufferSource): void;
	changeType(type: string): void;
	remove(start: number, end: number): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SourceBuffer: ~Object with { constructor(); };

export external public interface ~SourceBufferListEventMap {
	addsourcebuffer: Event;
	removesourcebuffer: Event;
}

export external public interface ~SourceBufferList extends EventTarget {
	get length(): number;
	onaddsourcebuffer: ({@This(SourceBufferList) function(ev: Event): any});
	onremovesourcebuffer: ({@This(SourceBufferList) function(ev: Event): any});
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SourceBufferList: ~Object with { constructor(); };

export external public interface ~SpeechRecognitionAlternative {
	get confidence(): number;
	get transcript(): string;
}

var SpeechRecognitionAlternative: ~Object with { constructor(); };

export external public interface ~SpeechRecognitionResult {
	get isFinal(): boolean;
	get length(): number;
	item(index: number): SpeechRecognitionAlternative;
}

var SpeechRecognitionResult: ~Object with { constructor(); };

export external public interface ~SpeechRecognitionResultList {
	get length(): number;
	item(index: number): SpeechRecognitionResult;
}

var SpeechRecognitionResultList: ~Object with { constructor(); };

export external public interface ~SpeechSynthesisEventMap {
	voiceschanged: Event;
}

export external public interface ~SpeechSynthesis extends EventTarget {
	onvoiceschanged: ({@This(SpeechSynthesis) function(ev: Event): any});
	get paused(): boolean;
	get pending(): boolean;
	get speaking(): boolean;
	cancel(): void;
	getVoices(): Array<SpeechSynthesisVoice>;
	pause(): void;
	resume(): void;
	speak(utterance: SpeechSynthesisUtterance): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SpeechSynthesis: ~Object with { constructor(); };

export external public interface ~SpeechSynthesisErrorEvent extends SpeechSynthesisEvent {
	get error(): SpeechSynthesisErrorCode;
}

var SpeechSynthesisErrorEvent: ~Object with { constructor(type: string, eventInitDict: SpeechSynthesisErrorEventInit); };

export external public interface ~SpeechSynthesisEvent extends Event {
	get charIndex(): number;
	get charLength(): number;
	get elapsedTime(): number;
	get name(): string;
	get utterance(): SpeechSynthesisUtterance;
}

var SpeechSynthesisEvent: ~Object with { constructor(type: string, eventInitDict: SpeechSynthesisEventInit); };

export external public interface ~SpeechSynthesisUtteranceEventMap {
	boundary: SpeechSynthesisEvent;
	end: SpeechSynthesisEvent;
	error: SpeechSynthesisErrorEvent;
	mark: SpeechSynthesisEvent;
	pause: SpeechSynthesisEvent;
	resume: SpeechSynthesisEvent;
	start: SpeechSynthesisEvent;
}

export external public interface ~SpeechSynthesisUtterance extends EventTarget {
	lang: string;
	onboundary: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	onend: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	onerror: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisErrorEvent): any});
	onmark: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	onpause: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	onresume: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	onstart: ({@This(SpeechSynthesisUtterance) function(ev: SpeechSynthesisEvent): any});
	pitch: number;
	rate: number;
	text: string;
	voice: SpeechSynthesisVoice;
	volume: number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var SpeechSynthesisUtterance: ~Object with { constructor(text: string = ); };

export external public interface ~SpeechSynthesisVoice {
	get default(): boolean;
	get lang(): string;
	get localService(): boolean;
	get name(): string;
	get voiceURI(): string;
}

var SpeechSynthesisVoice: ~Object with { constructor(); };

export external public interface ~StaticRange extends AbstractRange {}

var StaticRange: ~Object with { constructor(init: StaticRangeInit); };

export external public interface ~StereoPannerNode extends AudioNode {
	get pan(): AudioParam;
}

var StereoPannerNode: ~Object with { constructor(context: BaseAudioContext, options: StereoPannerOptions = ); };

export external public interface ~Storage {
	get length(): number;
	clear(): void;
	getItem(key: string): string;
	key(index: number): string;
	removeItem(key: string): void;
	setItem(key: string, value: string): void;
}

var Storage: ~Object with { constructor(); };

export external public interface ~StorageEvent extends Event {
	get key(): string;
	get newValue(): string;
	get oldValue(): string;
	get storageArea(): Storage;
	get url(): string;
	initStorageEvent(type: string, bubbles: boolean = , cancelable: boolean = , key: string = , oldValue: string = , newValue: string = , url: string | URL = , storageArea: Storage = ): void;
}

var StorageEvent: ~Object with { constructor(type: string, eventInitDict: StorageEventInit = ); };

export external public interface ~StorageManager {
	estimate(): Promise<StorageEstimate>;
	persist(): Promise<boolean>;
	persisted(): Promise<boolean>;
}

var StorageManager: ~Object with { constructor(); };

export external public interface ~StyleMedia {
	type: string;
	matchMedium(mediaquery: string): boolean;
}

export external public interface ~StyleSheet {
	disabled: boolean;
	get href(): string;
	get media(): MediaList;
	get ownerNode(): Element | ProcessingInstruction;
	get parentStyleSheet(): CSSStyleSheet;
	get title(): string;
	get type(): string;
}

var StyleSheet: ~Object with { constructor(); };

export external public interface ~StyleSheetList {
	get length(): number;
	item(index: number): CSSStyleSheet;
}

var StyleSheetList: ~Object with { constructor(); };

export external public interface ~SubmitEvent extends Event {
	get submitter(): HTMLElement;
}

var SubmitEvent: ~Object with { constructor(type: string, eventInitDict: SubmitEventInit = ); };

export external public interface ~SubtleCrypto {
	decrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<any>;
	deriveBits(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, length: number): Promise<ArrayBuffer>;
	deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: boolean, keyUsages: Array<KeyUsage>): Promise<CryptoKey>;
	digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>;
	encrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<any>;
	exportKey(...args: any+): any+; // overloading not supported
	generateKey(...args: any+): any+; // overloading not supported
	importKey(...args: any+): any+; // overloading not supported
	sign(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>;
	unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: boolean, keyUsages: Array<KeyUsage>): Promise<CryptoKey>;
	verify(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, signature: BufferSource, data: BufferSource): Promise<boolean>;
	wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<ArrayBuffer>;
}

var SubtleCrypto: ~Object with { constructor(); };

export external public interface ~Text extends CharacterData, Slottable {
	@Override
	get assignedSlot(): HTMLSlotElement;
	get wholeText(): string;
	splitText(offset: number): Text;
}

var Text: ~Object with { constructor(data: string = ); };

export external public interface ~TextDecoder extends TextDecoderCommon {
	decode(input: BufferSource = , options: TextDecodeOptions = ): string;
}

var TextDecoder: ~Object with { constructor(label: string = , options: TextDecoderOptions = ); };

export external public interface ~TextDecoderCommon {
	get encoding(): string;
	get fatal(): boolean;
	get ignoreBOM(): boolean;
}

export external public interface ~TextDecoderStream extends GenericTransformStream, TextDecoderCommon {
	@Override
	get readable(): ReadableStream<string>;
	@Override
	get writable(): WritableStream<BufferSource>;
}

var TextDecoderStream: ~Object with { constructor(label: string = , options: TextDecoderOptions = ); };

export external public interface ~TextEncoder extends TextEncoderCommon {
	encode(input: string = ): Uint8Array;
	encodeInto(source: string, destination: Uint8Array): TextEncoderEncodeIntoResult;
}

var TextEncoder: ~Object with { constructor(); };

export external public interface ~TextEncoderCommon {
	get encoding(): string;
}

export external public interface ~TextEncoderStream extends GenericTransformStream, TextEncoderCommon {
	@Override
	get readable(): ReadableStream<Uint8Array>;
	@Override
	get writable(): WritableStream<string>;
}

var TextEncoderStream: ~Object with { constructor(); };

export external public interface ~TextMetrics {
	get actualBoundingBoxAscent(): number;
	get actualBoundingBoxDescent(): number;
	get actualBoundingBoxLeft(): number;
	get actualBoundingBoxRight(): number;
	get fontBoundingBoxAscent(): number;
	get fontBoundingBoxDescent(): number;
	get width(): number;
}

var TextMetrics: ~Object with { constructor(); };

export external public interface ~TextTrackEventMap {
	cuechange: Event;
}

export external public interface ~TextTrack extends EventTarget {
	get activeCues(): TextTrackCueList;
	get cues(): TextTrackCueList;
	get id(): string;
	get inBandMetadataTrackDispatchType(): string;
	get kind(): TextTrackKind;
	get label(): string;
	get language(): string;
	mode: TextTrackMode;
	oncuechange: ({@This(TextTrack) function(ev: Event): any});
	addCue(cue: TextTrackCue): void;
	removeCue(cue: TextTrackCue): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var TextTrack: ~Object with { constructor(); };

export external public interface ~TextTrackCueEventMap {
	enter: Event;
	exit: Event;
}

export external public interface ~TextTrackCue extends EventTarget {
	endTime: number;
	id: string;
	onenter: ({@This(TextTrackCue) function(ev: Event): any});
	onexit: ({@This(TextTrackCue) function(ev: Event): any});
	pauseOnExit: boolean;
	startTime: number;
	get track(): TextTrack;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var TextTrackCue: ~Object with { constructor(); };

export external public interface ~TextTrackCueList {
	get length(): number;
	getCueById(id: string): TextTrackCue;
}

var TextTrackCueList: ~Object with { constructor(); };

export external public interface ~TextTrackListEventMap {
	addtrack: TrackEvent;
	change: Event;
	removetrack: TrackEvent;
}

export external public interface ~TextTrackList extends EventTarget {
	get length(): number;
	onaddtrack: ({@This(TextTrackList) function(ev: TrackEvent): any});
	onchange: ({@This(TextTrackList) function(ev: Event): any});
	onremovetrack: ({@This(TextTrackList) function(ev: TrackEvent): any});
	getTrackById(id: string): TextTrack;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var TextTrackList: ~Object with { constructor(); };

export external public interface ~TimeRanges {
	get length(): number;
	end(index: number): number;
	start(index: number): number;
}

var TimeRanges: ~Object with { constructor(); };

export external public interface ~Touch {
	get clientX(): number;
	get clientY(): number;
	get force(): number;
	get identifier(): number;
	get pageX(): number;
	get pageY(): number;
	get radiusX(): number;
	get radiusY(): number;
	get rotationAngle(): number;
	get screenX(): number;
	get screenY(): number;
	get target(): EventTarget;
}

var Touch: ~Object with { constructor(touchInitDict: TouchInit); };

export external public interface ~TouchEvent extends UIEvent {
	get altKey(): boolean;
	get changedTouches(): TouchList;
	get ctrlKey(): boolean;
	get metaKey(): boolean;
	get shiftKey(): boolean;
	get targetTouches(): TouchList;
	get touches(): TouchList;
}

var TouchEvent: ~Object with { constructor(type: string, eventInitDict: TouchEventInit = ); };

export external public interface ~TouchList {
	get length(): number;
	item(index: number): Touch;
}

var TouchList: ~Object with { constructor(); };

export external public interface ~TrackEvent extends Event {
	get track(): TextTrack;
}

var TrackEvent: ~Object with { constructor(type: string, eventInitDict: TrackEventInit = ); };

export external public interface ~TransformStream<I=any,O=any> {
	get readable(): ReadableStream<O>;
	get writable(): WritableStream<I>;
}

var TransformStream: ~Object with { constructor(transformer: Transformer<I,O> = , writableStrategy: QueuingStrategy<I> = , readableStrategy: QueuingStrategy<O> = ); };

export external public interface ~TransformStreamDefaultController<O=any> {
	get desiredSize(): number;
	enqueue(chunk: O = ): void;
	error(reason: any = ): void;
	terminate(): void;
}

var TransformStreamDefaultController: ~Object with { constructor(); };

export external public interface ~TransitionEvent extends Event {
	get elapsedTime(): number;
	get propertyName(): string;
	get pseudoElement(): string;
}

var TransitionEvent: ~Object with { constructor(type: string, transitionEventInitDict: TransitionEventInit = ); };

export external public interface ~TreeWalker {
	currentNode: Node;
	get filter(): NodeFilter;
	get root(): Node;
	get whatToShow(): number;
	firstChild(): Node;
	lastChild(): Node;
	nextNode(): Node;
	nextSibling(): Node;
	parentNode(): Node;
	previousNode(): Node;
	previousSibling(): Node;
}

var TreeWalker: ~Object with { constructor(); };

export external public interface ~UIEvent extends Event {
	get detail(): number;
	get view(): Window;
	get which(): number;
	initUIEvent(typeArg: string, bubblesArg: boolean = , cancelableArg: boolean = , viewArg: Window = , detailArg: number = ): void;
}

var UIEvent: ~Object with { constructor(type: string, eventInitDict: UIEventInit = ); };

export external public interface ~URL {
	hash: string;
	host: string;
	hostname: string;
	href: string;
	toString(): string;
	get origin(): string;
	password: string;
	pathname: string;
	port: string;
	protocol: string;
	search: string;
	get searchParams(): URLSearchParams;
	username: string;
	toJSON(): string;
}

var URL: ~Object with { constructor(url: string | URL, base: string | URL = ); createObjectURL(obj: Blob | MediaSource): string; revokeObjectURL(url: string): void; };

export external public type webkitURL = URL;

var webkitURL: any+;

export external public interface ~URLSearchParams {
	append(name: string, value: string): void;
	delete(name: string): void;
	get(name: string): string;
	getAll(name: string): Array<string>;
	has(name: string): boolean;
	set(name: string, value: string): void;
	sort(): void;
	toString(): string;
	forEach(callbackfn: (value: string, key: string, parent: URLSearchParams)=>void, thisArg: any = ): void;
}

var URLSearchParams: ~Object with { constructor(init: Array<Array<string>> | Record<string,string> | string | URLSearchParams = ); toString(): string; };

export external public interface ~VTTCue extends TextTrackCue {
	align: AlignSetting;
	line: LineAndPositionSetting;
	lineAlign: LineAlignSetting;
	position: LineAndPositionSetting;
	positionAlign: PositionAlignSetting;
	region: VTTRegion;
	size: number;
	snapToLines: boolean;
	text: string;
	vertical: DirectionSetting;
	getCueAsHTML(): DocumentFragment;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var VTTCue: ~Object with { constructor(startTime: number, endTime: number, text: string); };

export external public interface ~VTTRegion {
	id: string;
	lines: number;
	regionAnchorX: number;
	regionAnchorY: number;
	scroll: ScrollSetting;
	viewportAnchorX: number;
	viewportAnchorY: number;
	width: number;
}

var VTTRegion: ~Object with { constructor(); };

export external public interface ~ValidityState {
	get badInput(): boolean;
	get customError(): boolean;
	get patternMismatch(): boolean;
	get rangeOverflow(): boolean;
	get rangeUnderflow(): boolean;
	get stepMismatch(): boolean;
	get tooLong(): boolean;
	get tooShort(): boolean;
	get typeMismatch(): boolean;
	get valid(): boolean;
	get valueMissing(): boolean;
}

var ValidityState: ~Object with { constructor(); };

export external public interface ~VideoPlaybackQuality {
	get corruptedVideoFrames(): number;
	get creationTime(): DOMHighResTimeStamp;
	get droppedVideoFrames(): number;
	get totalVideoFrames(): number;
}

var VideoPlaybackQuality: ~Object with { constructor(); };

export external public interface ~VisualViewportEventMap {
	resize: Event;
	scroll: Event;
}

export external public interface ~VisualViewport extends EventTarget {
	get height(): number;
	get offsetLeft(): number;
	get offsetTop(): number;
	onresize: ({@This(VisualViewport) function(ev: Event): any});
	onscroll: ({@This(VisualViewport) function(ev: Event): any});
	get pageLeft(): number;
	get pageTop(): number;
	get scale(): number;
	get width(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var VisualViewport: ~Object with { constructor(); };

export external public interface ~WEBGL_color_buffer_float {
	get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT(): GLenum;
	get RGBA32F_EXT(): GLenum;
	get UNSIGNED_NORMALIZED_EXT(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_astc {
	getSupportedProfiles(): Array<string>;
	get COMPRESSED_RGBA_ASTC_10x10_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_10x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_10x6_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_10x8_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_12x10_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_12x12_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_4x4_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_5x4_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_5x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_6x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_6x6_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_8x5_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_8x6_KHR(): GLenum;
	get COMPRESSED_RGBA_ASTC_8x8_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_etc {
	get COMPRESSED_R11_EAC(): GLenum;
	get COMPRESSED_RG11_EAC(): GLenum;
	get COMPRESSED_RGB8_ETC2(): GLenum;
	get COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2(): GLenum;
	get COMPRESSED_RGBA8_ETC2_EAC(): GLenum;
	get COMPRESSED_SIGNED_R11_EAC(): GLenum;
	get COMPRESSED_SIGNED_RG11_EAC(): GLenum;
	get COMPRESSED_SRGB8_ALPHA8_ETC2_EAC(): GLenum;
	get COMPRESSED_SRGB8_ETC2(): GLenum;
	get COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_etc1 {
	get COMPRESSED_RGB_ETC1_WEBGL(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_pvrtc {
	get COMPRESSED_RGBA_PVRTC_2BPPV1_IMG(): GLenum;
	get COMPRESSED_RGBA_PVRTC_4BPPV1_IMG(): GLenum;
	get COMPRESSED_RGB_PVRTC_2BPPV1_IMG(): GLenum;
	get COMPRESSED_RGB_PVRTC_4BPPV1_IMG(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_s3tc {
	get COMPRESSED_RGBA_S3TC_DXT1_EXT(): GLenum;
	get COMPRESSED_RGBA_S3TC_DXT3_EXT(): GLenum;
	get COMPRESSED_RGBA_S3TC_DXT5_EXT(): GLenum;
	get COMPRESSED_RGB_S3TC_DXT1_EXT(): GLenum;
}

export external public interface ~WEBGL_compressed_texture_s3tc_srgb {
	get COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT(): GLenum;
	get COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT(): GLenum;
	get COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT(): GLenum;
	get COMPRESSED_SRGB_S3TC_DXT1_EXT(): GLenum;
}

export external public interface ~WEBGL_debug_renderer_info {
	get UNMASKED_RENDERER_WEBGL(): GLenum;
	get UNMASKED_VENDOR_WEBGL(): GLenum;
}

export external public interface ~WEBGL_debug_shaders {
	getTranslatedShaderSource(shader: WebGLShader): string;
}

export external public interface ~WEBGL_depth_texture {
	get UNSIGNED_INT_24_8_WEBGL(): GLenum;
}

export external public interface ~WEBGL_draw_buffers {
	drawBuffersWEBGL(buffers: Array<GLenum>): void;
	get COLOR_ATTACHMENT0_WEBGL(): GLenum;
	get COLOR_ATTACHMENT10_WEBGL(): GLenum;
	get COLOR_ATTACHMENT11_WEBGL(): GLenum;
	get COLOR_ATTACHMENT12_WEBGL(): GLenum;
	get COLOR_ATTACHMENT13_WEBGL(): GLenum;
	get COLOR_ATTACHMENT14_WEBGL(): GLenum;
	get COLOR_ATTACHMENT15_WEBGL(): GLenum;
	get COLOR_ATTACHMENT1_WEBGL(): GLenum;
	get COLOR_ATTACHMENT2_WEBGL(): GLenum;
	get COLOR_ATTACHMENT3_WEBGL(): GLenum;
	get COLOR_ATTACHMENT4_WEBGL(): GLenum;
	get COLOR_ATTACHMENT5_WEBGL(): GLenum;
	get COLOR_ATTACHMENT6_WEBGL(): GLenum;
	get COLOR_ATTACHMENT7_WEBGL(): GLenum;
	get COLOR_ATTACHMENT8_WEBGL(): GLenum;
	get COLOR_ATTACHMENT9_WEBGL(): GLenum;
	get DRAW_BUFFER0_WEBGL(): GLenum;
	get DRAW_BUFFER10_WEBGL(): GLenum;
	get DRAW_BUFFER11_WEBGL(): GLenum;
	get DRAW_BUFFER12_WEBGL(): GLenum;
	get DRAW_BUFFER13_WEBGL(): GLenum;
	get DRAW_BUFFER14_WEBGL(): GLenum;
	get DRAW_BUFFER15_WEBGL(): GLenum;
	get DRAW_BUFFER1_WEBGL(): GLenum;
	get DRAW_BUFFER2_WEBGL(): GLenum;
	get DRAW_BUFFER3_WEBGL(): GLenum;
	get DRAW_BUFFER4_WEBGL(): GLenum;
	get DRAW_BUFFER5_WEBGL(): GLenum;
	get DRAW_BUFFER6_WEBGL(): GLenum;
	get DRAW_BUFFER7_WEBGL(): GLenum;
	get DRAW_BUFFER8_WEBGL(): GLenum;
	get DRAW_BUFFER9_WEBGL(): GLenum;
	get MAX_COLOR_ATTACHMENTS_WEBGL(): GLenum;
	get MAX_DRAW_BUFFERS_WEBGL(): GLenum;
}

export external public interface ~WEBGL_lose_context {
	loseContext(): void;
	restoreContext(): void;
}

export external public interface ~WaveShaperNode extends AudioNode {
	curve: Float32Array;
	oversample: OverSampleType;
}

var WaveShaperNode: ~Object with { constructor(context: BaseAudioContext, options: WaveShaperOptions = ); };

export external public interface ~WebGL2RenderingContext extends WebGL2RenderingContextBase, WebGL2RenderingContextOverloads, WebGLRenderingContextBase {}

var WebGL2RenderingContext: ~Object with { constructor(); get ACTIVE_UNIFORM_BLOCKS(): GLenum; get ALREADY_SIGNALED(): GLenum; get ANY_SAMPLES_PASSED(): GLenum; get ANY_SAMPLES_PASSED_CONSERVATIVE(): GLenum; get COLOR(): GLenum; get COLOR_ATTACHMENT1(): GLenum; get COLOR_ATTACHMENT10(): GLenum; get COLOR_ATTACHMENT11(): GLenum; get COLOR_ATTACHMENT12(): GLenum; get COLOR_ATTACHMENT13(): GLenum; get COLOR_ATTACHMENT14(): GLenum; get COLOR_ATTACHMENT15(): GLenum; get COLOR_ATTACHMENT2(): GLenum; get COLOR_ATTACHMENT3(): GLenum; get COLOR_ATTACHMENT4(): GLenum; get COLOR_ATTACHMENT5(): GLenum; get COLOR_ATTACHMENT6(): GLenum; get COLOR_ATTACHMENT7(): GLenum; get COLOR_ATTACHMENT8(): GLenum; get COLOR_ATTACHMENT9(): GLenum; get COMPARE_REF_TO_TEXTURE(): GLenum; get CONDITION_SATISFIED(): GLenum; get COPY_READ_BUFFER(): GLenum; get COPY_READ_BUFFER_BINDING(): GLenum; get COPY_WRITE_BUFFER(): GLenum; get COPY_WRITE_BUFFER_BINDING(): GLenum; get CURRENT_QUERY(): GLenum; get DEPTH(): GLenum; get DEPTH24_STENCIL8(): GLenum; get DEPTH32F_STENCIL8(): GLenum; get DEPTH_COMPONENT24(): GLenum; get DEPTH_COMPONENT32F(): GLenum; get DRAW_BUFFER0(): GLenum; get DRAW_BUFFER1(): GLenum; get DRAW_BUFFER10(): GLenum; get DRAW_BUFFER11(): GLenum; get DRAW_BUFFER12(): GLenum; get DRAW_BUFFER13(): GLenum; get DRAW_BUFFER14(): GLenum; get DRAW_BUFFER15(): GLenum; get DRAW_BUFFER2(): GLenum; get DRAW_BUFFER3(): GLenum; get DRAW_BUFFER4(): GLenum; get DRAW_BUFFER5(): GLenum; get DRAW_BUFFER6(): GLenum; get DRAW_BUFFER7(): GLenum; get DRAW_BUFFER8(): GLenum; get DRAW_BUFFER9(): GLenum; get DRAW_FRAMEBUFFER(): GLenum; get DRAW_FRAMEBUFFER_BINDING(): GLenum; get DYNAMIC_COPY(): GLenum; get DYNAMIC_READ(): GLenum; get FLOAT_32_UNSIGNED_INT_24_8_REV(): GLenum; get FLOAT_MAT2x3(): GLenum; get FLOAT_MAT2x4(): GLenum; get FLOAT_MAT3x2(): GLenum; get FLOAT_MAT3x4(): GLenum; get FLOAT_MAT4x2(): GLenum; get FLOAT_MAT4x3(): GLenum; get FRAGMENT_SHADER_DERIVATIVE_HINT(): GLenum; get FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE(): GLenum; get FRAMEBUFFER_ATTACHMENT_BLUE_SIZE(): GLenum; get FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING(): GLenum; get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE(): GLenum; get FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE(): GLenum; get FRAMEBUFFER_ATTACHMENT_GREEN_SIZE(): GLenum; get FRAMEBUFFER_ATTACHMENT_RED_SIZE(): GLenum; get FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE(): GLenum; get FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER(): GLenum; get FRAMEBUFFER_DEFAULT(): GLenum; get FRAMEBUFFER_INCOMPLETE_MULTISAMPLE(): GLenum; get HALF_FLOAT(): GLenum; get INTERLEAVED_ATTRIBS(): GLenum; get INT_2_10_10_10_REV(): GLenum; get INT_SAMPLER_2D(): GLenum; get INT_SAMPLER_2D_ARRAY(): GLenum; get INT_SAMPLER_3D(): GLenum; get INT_SAMPLER_CUBE(): GLenum; get INVALID_INDEX(): GLenum; get MAX(): GLenum; get MAX_3D_TEXTURE_SIZE(): GLenum; get MAX_ARRAY_TEXTURE_LAYERS(): GLenum; get MAX_CLIENT_WAIT_TIMEOUT_WEBGL(): GLenum; get MAX_COLOR_ATTACHMENTS(): GLenum; get MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS(): GLenum; get MAX_COMBINED_UNIFORM_BLOCKS(): GLenum; get MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS(): GLenum; get MAX_DRAW_BUFFERS(): GLenum; get MAX_ELEMENTS_INDICES(): GLenum; get MAX_ELEMENTS_VERTICES(): GLenum; get MAX_ELEMENT_INDEX(): GLenum; get MAX_FRAGMENT_INPUT_COMPONENTS(): GLenum; get MAX_FRAGMENT_UNIFORM_BLOCKS(): GLenum; get MAX_FRAGMENT_UNIFORM_COMPONENTS(): GLenum; get MAX_PROGRAM_TEXEL_OFFSET(): GLenum; get MAX_SAMPLES(): GLenum; get MAX_SERVER_WAIT_TIMEOUT(): GLenum; get MAX_TEXTURE_LOD_BIAS(): GLenum; get MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS(): GLenum; get MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS(): GLenum; get MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS(): GLenum; get MAX_UNIFORM_BLOCK_SIZE(): GLenum; get MAX_UNIFORM_BUFFER_BINDINGS(): GLenum; get MAX_VARYING_COMPONENTS(): GLenum; get MAX_VERTEX_OUTPUT_COMPONENTS(): GLenum; get MAX_VERTEX_UNIFORM_BLOCKS(): GLenum; get MAX_VERTEX_UNIFORM_COMPONENTS(): GLenum; get MIN(): GLenum; get MIN_PROGRAM_TEXEL_OFFSET(): GLenum; get OBJECT_TYPE(): GLenum; get PACK_ROW_LENGTH(): GLenum; get PACK_SKIP_PIXELS(): GLenum; get PACK_SKIP_ROWS(): GLenum; get PIXEL_PACK_BUFFER(): GLenum; get PIXEL_PACK_BUFFER_BINDING(): GLenum; get PIXEL_UNPACK_BUFFER(): GLenum; get PIXEL_UNPACK_BUFFER_BINDING(): GLenum; get QUERY_RESULT(): GLenum; get QUERY_RESULT_AVAILABLE(): GLenum; get R11F_G11F_B10F(): GLenum; get R16F(): GLenum; get R16I(): GLenum; get R16UI(): GLenum; get R32F(): GLenum; get R32I(): GLenum; get R32UI(): GLenum; get R8(): GLenum; get R8I(): GLenum; get R8UI(): GLenum; get R8_SNORM(): GLenum; get RASTERIZER_DISCARD(): GLenum; get READ_BUFFER(): GLenum; get READ_FRAMEBUFFER(): GLenum; get READ_FRAMEBUFFER_BINDING(): GLenum; get RED(): GLenum; get RED_INTEGER(): GLenum; get RENDERBUFFER_SAMPLES(): GLenum; get RG(): GLenum; get RG16F(): GLenum; get RG16I(): GLenum; get RG16UI(): GLenum; get RG32F(): GLenum; get RG32I(): GLenum; get RG32UI(): GLenum; get RG8(): GLenum; get RG8I(): GLenum; get RG8UI(): GLenum; get RG8_SNORM(): GLenum; get RGB10_A2(): GLenum; get RGB10_A2UI(): GLenum; get RGB16F(): GLenum; get RGB16I(): GLenum; get RGB16UI(): GLenum; get RGB32F(): GLenum; get RGB32I(): GLenum; get RGB32UI(): GLenum; get RGB8(): GLenum; get RGB8I(): GLenum; get RGB8UI(): GLenum; get RGB8_SNORM(): GLenum; get RGB9_E5(): GLenum; get RGBA16F(): GLenum; get RGBA16I(): GLenum; get RGBA16UI(): GLenum; get RGBA32F(): GLenum; get RGBA32I(): GLenum; get RGBA32UI(): GLenum; get RGBA8(): GLenum; get RGBA8I(): GLenum; get RGBA8UI(): GLenum; get RGBA8_SNORM(): GLenum; get RGBA_INTEGER(): GLenum; get RGB_INTEGER(): GLenum; get RG_INTEGER(): GLenum; get SAMPLER_2D_ARRAY(): GLenum; get SAMPLER_2D_ARRAY_SHADOW(): GLenum; get SAMPLER_2D_SHADOW(): GLenum; get SAMPLER_3D(): GLenum; get SAMPLER_BINDING(): GLenum; get SAMPLER_CUBE_SHADOW(): GLenum; get SEPARATE_ATTRIBS(): GLenum; get SIGNALED(): GLenum; get SIGNED_NORMALIZED(): GLenum; get SRGB(): GLenum; get SRGB8(): GLenum; get SRGB8_ALPHA8(): GLenum; get STATIC_COPY(): GLenum; get STATIC_READ(): GLenum; get STENCIL(): GLenum; get STREAM_COPY(): GLenum; get STREAM_READ(): GLenum; get SYNC_CONDITION(): GLenum; get SYNC_FENCE(): GLenum; get SYNC_FLAGS(): GLenum; get SYNC_FLUSH_COMMANDS_BIT(): GLenum; get SYNC_GPU_COMMANDS_COMPLETE(): GLenum; get SYNC_STATUS(): GLenum; get TEXTURE_2D_ARRAY(): GLenum; get TEXTURE_3D(): GLenum; get TEXTURE_BASE_LEVEL(): GLenum; get TEXTURE_BINDING_2D_ARRAY(): GLenum; get TEXTURE_BINDING_3D(): GLenum; get TEXTURE_COMPARE_FUNC(): GLenum; get TEXTURE_COMPARE_MODE(): GLenum; get TEXTURE_IMMUTABLE_FORMAT(): GLenum; get TEXTURE_IMMUTABLE_LEVELS(): GLenum; get TEXTURE_MAX_LEVEL(): GLenum; get TEXTURE_MAX_LOD(): GLenum; get TEXTURE_MIN_LOD(): GLenum; get TEXTURE_WRAP_R(): GLenum; get TIMEOUT_EXPIRED(): GLenum; get TIMEOUT_IGNORED(): GLint64; get TRANSFORM_FEEDBACK(): GLenum; get TRANSFORM_FEEDBACK_ACTIVE(): GLenum; get TRANSFORM_FEEDBACK_BINDING(): GLenum; get TRANSFORM_FEEDBACK_BUFFER(): GLenum; get TRANSFORM_FEEDBACK_BUFFER_BINDING(): GLenum; get TRANSFORM_FEEDBACK_BUFFER_MODE(): GLenum; get TRANSFORM_FEEDBACK_BUFFER_SIZE(): GLenum; get TRANSFORM_FEEDBACK_BUFFER_START(): GLenum; get TRANSFORM_FEEDBACK_PAUSED(): GLenum; get TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN(): GLenum; get TRANSFORM_FEEDBACK_VARYINGS(): GLenum; get UNIFORM_ARRAY_STRIDE(): GLenum; get UNIFORM_BLOCK_ACTIVE_UNIFORMS(): GLenum; get UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES(): GLenum; get UNIFORM_BLOCK_BINDING(): GLenum; get UNIFORM_BLOCK_DATA_SIZE(): GLenum; get UNIFORM_BLOCK_INDEX(): GLenum; get UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER(): GLenum; get UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER(): GLenum; get UNIFORM_BUFFER(): GLenum; get UNIFORM_BUFFER_BINDING(): GLenum; get UNIFORM_BUFFER_OFFSET_ALIGNMENT(): GLenum; get UNIFORM_BUFFER_SIZE(): GLenum; get UNIFORM_BUFFER_START(): GLenum; get UNIFORM_IS_ROW_MAJOR(): GLenum; get UNIFORM_MATRIX_STRIDE(): GLenum; get UNIFORM_OFFSET(): GLenum; get UNIFORM_SIZE(): GLenum; get UNIFORM_TYPE(): GLenum; get UNPACK_IMAGE_HEIGHT(): GLenum; get UNPACK_ROW_LENGTH(): GLenum; get UNPACK_SKIP_IMAGES(): GLenum; get UNPACK_SKIP_PIXELS(): GLenum; get UNPACK_SKIP_ROWS(): GLenum; get UNSIGNALED(): GLenum; get UNSIGNED_INT_10F_11F_11F_REV(): GLenum; get UNSIGNED_INT_24_8(): GLenum; get UNSIGNED_INT_2_10_10_10_REV(): GLenum; get UNSIGNED_INT_5_9_9_9_REV(): GLenum; get UNSIGNED_INT_SAMPLER_2D(): GLenum; get UNSIGNED_INT_SAMPLER_2D_ARRAY(): GLenum; get UNSIGNED_INT_SAMPLER_3D(): GLenum; get UNSIGNED_INT_SAMPLER_CUBE(): GLenum; get UNSIGNED_INT_VEC2(): GLenum; get UNSIGNED_INT_VEC3(): GLenum; get UNSIGNED_INT_VEC4(): GLenum; get UNSIGNED_NORMALIZED(): GLenum; get VERTEX_ARRAY_BINDING(): GLenum; get VERTEX_ATTRIB_ARRAY_DIVISOR(): GLenum; get VERTEX_ATTRIB_ARRAY_INTEGER(): GLenum; get WAIT_FAILED(): GLenum; get ACTIVE_ATTRIBUTES(): GLenum; get ACTIVE_TEXTURE(): GLenum; get ACTIVE_UNIFORMS(): GLenum; get ALIASED_LINE_WIDTH_RANGE(): GLenum; get ALIASED_POINT_SIZE_RANGE(): GLenum; get ALPHA(): GLenum; get ALPHA_BITS(): GLenum; get ALWAYS(): GLenum; get ARRAY_BUFFER(): GLenum; get ARRAY_BUFFER_BINDING(): GLenum; get ATTACHED_SHADERS(): GLenum; get BACK(): GLenum; get BLEND(): GLenum; get BLEND_COLOR(): GLenum; get BLEND_DST_ALPHA(): GLenum; get BLEND_DST_RGB(): GLenum; get BLEND_EQUATION(): GLenum; get BLEND_EQUATION_ALPHA(): GLenum; get BLEND_EQUATION_RGB(): GLenum; get BLEND_SRC_ALPHA(): GLenum; get BLEND_SRC_RGB(): GLenum; get BLUE_BITS(): GLenum; get BOOL(): GLenum; get BOOL_VEC2(): GLenum; get BOOL_VEC3(): GLenum; get BOOL_VEC4(): GLenum; get BROWSER_DEFAULT_WEBGL(): GLenum; get BUFFER_SIZE(): GLenum; get BUFFER_USAGE(): GLenum; get BYTE(): GLenum; get CCW(): GLenum; get CLAMP_TO_EDGE(): GLenum; get COLOR_ATTACHMENT0(): GLenum; get COLOR_BUFFER_BIT(): GLenum; get COLOR_CLEAR_VALUE(): GLenum; get COLOR_WRITEMASK(): GLenum; get COMPILE_STATUS(): GLenum; get COMPRESSED_TEXTURE_FORMATS(): GLenum; get CONSTANT_ALPHA(): GLenum; get CONSTANT_COLOR(): GLenum; get CONTEXT_LOST_WEBGL(): GLenum; get CULL_FACE(): GLenum; get CULL_FACE_MODE(): GLenum; get CURRENT_PROGRAM(): GLenum; get CURRENT_VERTEX_ATTRIB(): GLenum; get CW(): GLenum; get DECR(): GLenum; get DECR_WRAP(): GLenum; get DELETE_STATUS(): GLenum; get DEPTH_ATTACHMENT(): GLenum; get DEPTH_BITS(): GLenum; get DEPTH_BUFFER_BIT(): GLenum; get DEPTH_CLEAR_VALUE(): GLenum; get DEPTH_COMPONENT(): GLenum; get DEPTH_COMPONENT16(): GLenum; get DEPTH_FUNC(): GLenum; get DEPTH_RANGE(): GLenum; get DEPTH_STENCIL(): GLenum; get DEPTH_STENCIL_ATTACHMENT(): GLenum; get DEPTH_TEST(): GLenum; get DEPTH_WRITEMASK(): GLenum; get DITHER(): GLenum; get DONT_CARE(): GLenum; get DST_ALPHA(): GLenum; get DST_COLOR(): GLenum; get DYNAMIC_DRAW(): GLenum; get ELEMENT_ARRAY_BUFFER(): GLenum; get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum; get EQUAL(): GLenum; get FASTEST(): GLenum; get FLOAT(): GLenum; get FLOAT_MAT2(): GLenum; get FLOAT_MAT3(): GLenum; get FLOAT_MAT4(): GLenum; get FLOAT_VEC2(): GLenum; get FLOAT_VEC3(): GLenum; get FLOAT_VEC4(): GLenum; get FRAGMENT_SHADER(): GLenum; get FRAMEBUFFER(): GLenum; get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum; get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum; get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum; get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum; get FRAMEBUFFER_BINDING(): GLenum; get FRAMEBUFFER_COMPLETE(): GLenum; get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum; get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum; get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum; get FRAMEBUFFER_UNSUPPORTED(): GLenum; get FRONT(): GLenum; get FRONT_AND_BACK(): GLenum; get FRONT_FACE(): GLenum; get FUNC_ADD(): GLenum; get FUNC_REVERSE_SUBTRACT(): GLenum; get FUNC_SUBTRACT(): GLenum; get GENERATE_MIPMAP_HINT(): GLenum; get GEQUAL(): GLenum; get GREATER(): GLenum; get GREEN_BITS(): GLenum; get HIGH_FLOAT(): GLenum; get HIGH_INT(): GLenum; get IMPLEMENTATION_COLOR_READ_FORMAT(): GLenum; get IMPLEMENTATION_COLOR_READ_TYPE(): GLenum; get INCR(): GLenum; get INCR_WRAP(): GLenum; get INT(): GLenum; get INT_VEC2(): GLenum; get INT_VEC3(): GLenum; get INT_VEC4(): GLenum; get INVALID_ENUM(): GLenum; get INVALID_FRAMEBUFFER_OPERATION(): GLenum; get INVALID_OPERATION(): GLenum; get INVALID_VALUE(): GLenum; get INVERT(): GLenum; get KEEP(): GLenum; get LEQUAL(): GLenum; get LESS(): GLenum; get LINEAR(): GLenum; get LINEAR_MIPMAP_LINEAR(): GLenum; get LINEAR_MIPMAP_NEAREST(): GLenum; get LINES(): GLenum; get LINE_LOOP(): GLenum; get LINE_STRIP(): GLenum; get LINE_WIDTH(): GLenum; get LINK_STATUS(): GLenum; get LOW_FLOAT(): GLenum; get LOW_INT(): GLenum; get LUMINANCE(): GLenum; get LUMINANCE_ALPHA(): GLenum; get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum; get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum; get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum; get MAX_RENDERBUFFER_SIZE(): GLenum; get MAX_TEXTURE_IMAGE_UNITS(): GLenum; get MAX_TEXTURE_SIZE(): GLenum; get MAX_VARYING_VECTORS(): GLenum; get MAX_VERTEX_ATTRIBS(): GLenum; get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum; get MAX_VERTEX_UNIFORM_VECTORS(): GLenum; get MAX_VIEWPORT_DIMS(): GLenum; get MEDIUM_FLOAT(): GLenum; get MEDIUM_INT(): GLenum; get MIRRORED_REPEAT(): GLenum; get NEAREST(): GLenum; get NEAREST_MIPMAP_LINEAR(): GLenum; get NEAREST_MIPMAP_NEAREST(): GLenum; get NEVER(): GLenum; get NICEST(): GLenum; get NONE(): GLenum; get NOTEQUAL(): GLenum; get NO_ERROR(): GLenum; get ONE(): GLenum; get ONE_MINUS_CONSTANT_ALPHA(): GLenum; get ONE_MINUS_CONSTANT_COLOR(): GLenum; get ONE_MINUS_DST_ALPHA(): GLenum; get ONE_MINUS_DST_COLOR(): GLenum; get ONE_MINUS_SRC_ALPHA(): GLenum; get ONE_MINUS_SRC_COLOR(): GLenum; get OUT_OF_MEMORY(): GLenum; get PACK_ALIGNMENT(): GLenum; get POINTS(): GLenum; get POLYGON_OFFSET_FACTOR(): GLenum; get POLYGON_OFFSET_FILL(): GLenum; get POLYGON_OFFSET_UNITS(): GLenum; get RED_BITS(): GLenum; get RENDERBUFFER(): GLenum; get RENDERBUFFER_ALPHA_SIZE(): GLenum; get RENDERBUFFER_BINDING(): GLenum; get RENDERBUFFER_BLUE_SIZE(): GLenum; get RENDERBUFFER_DEPTH_SIZE(): GLenum; get RENDERBUFFER_GREEN_SIZE(): GLenum; get RENDERBUFFER_HEIGHT(): GLenum; get RENDERBUFFER_INTERNAL_FORMAT(): GLenum; get RENDERBUFFER_RED_SIZE(): GLenum; get RENDERBUFFER_STENCIL_SIZE(): GLenum; get RENDERBUFFER_WIDTH(): GLenum; get RENDERER(): GLenum; get REPEAT(): GLenum; get REPLACE(): GLenum; get RGB(): GLenum; get RGB565(): GLenum; get RGB5_A1(): GLenum; get RGBA(): GLenum; get RGBA4(): GLenum; get SAMPLER_2D(): GLenum; get SAMPLER_CUBE(): GLenum; get SAMPLES(): GLenum; get SAMPLE_ALPHA_TO_COVERAGE(): GLenum; get SAMPLE_BUFFERS(): GLenum; get SAMPLE_COVERAGE(): GLenum; get SAMPLE_COVERAGE_INVERT(): GLenum; get SAMPLE_COVERAGE_VALUE(): GLenum; get SCISSOR_BOX(): GLenum; get SCISSOR_TEST(): GLenum; get SHADER_TYPE(): GLenum; get SHADING_LANGUAGE_VERSION(): GLenum; get SHORT(): GLenum; get SRC_ALPHA(): GLenum; get SRC_ALPHA_SATURATE(): GLenum; get SRC_COLOR(): GLenum; get STATIC_DRAW(): GLenum; get STENCIL_ATTACHMENT(): GLenum; get STENCIL_BACK_FAIL(): GLenum; get STENCIL_BACK_FUNC(): GLenum; get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum; get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum; get STENCIL_BACK_REF(): GLenum; get STENCIL_BACK_VALUE_MASK(): GLenum; get STENCIL_BACK_WRITEMASK(): GLenum; get STENCIL_BITS(): GLenum; get STENCIL_BUFFER_BIT(): GLenum; get STENCIL_CLEAR_VALUE(): GLenum; get STENCIL_FAIL(): GLenum; get STENCIL_FUNC(): GLenum; get STENCIL_INDEX8(): GLenum; get STENCIL_PASS_DEPTH_FAIL(): GLenum; get STENCIL_PASS_DEPTH_PASS(): GLenum; get STENCIL_REF(): GLenum; get STENCIL_TEST(): GLenum; get STENCIL_VALUE_MASK(): GLenum; get STENCIL_WRITEMASK(): GLenum; get STREAM_DRAW(): GLenum; get SUBPIXEL_BITS(): GLenum; get TEXTURE(): GLenum; get TEXTURE0(): GLenum; get TEXTURE1(): GLenum; get TEXTURE10(): GLenum; get TEXTURE11(): GLenum; get TEXTURE12(): GLenum; get TEXTURE13(): GLenum; get TEXTURE14(): GLenum; get TEXTURE15(): GLenum; get TEXTURE16(): GLenum; get TEXTURE17(): GLenum; get TEXTURE18(): GLenum; get TEXTURE19(): GLenum; get TEXTURE2(): GLenum; get TEXTURE20(): GLenum; get TEXTURE21(): GLenum; get TEXTURE22(): GLenum; get TEXTURE23(): GLenum; get TEXTURE24(): GLenum; get TEXTURE25(): GLenum; get TEXTURE26(): GLenum; get TEXTURE27(): GLenum; get TEXTURE28(): GLenum; get TEXTURE29(): GLenum; get TEXTURE3(): GLenum; get TEXTURE30(): GLenum; get TEXTURE31(): GLenum; get TEXTURE4(): GLenum; get TEXTURE5(): GLenum; get TEXTURE6(): GLenum; get TEXTURE7(): GLenum; get TEXTURE8(): GLenum; get TEXTURE9(): GLenum; get TEXTURE_2D(): GLenum; get TEXTURE_BINDING_2D(): GLenum; get TEXTURE_BINDING_CUBE_MAP(): GLenum; get TEXTURE_CUBE_MAP(): GLenum; get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum; get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum; get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum; get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum; get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum; get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum; get TEXTURE_MAG_FILTER(): GLenum; get TEXTURE_MIN_FILTER(): GLenum; get TEXTURE_WRAP_S(): GLenum; get TEXTURE_WRAP_T(): GLenum; get TRIANGLES(): GLenum; get TRIANGLE_FAN(): GLenum; get TRIANGLE_STRIP(): GLenum; get UNPACK_ALIGNMENT(): GLenum; get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum; get UNPACK_FLIP_Y_WEBGL(): GLenum; get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum; get UNSIGNED_BYTE(): GLenum; get UNSIGNED_INT(): GLenum; get UNSIGNED_SHORT(): GLenum; get UNSIGNED_SHORT_4_4_4_4(): GLenum; get UNSIGNED_SHORT_5_5_5_1(): GLenum; get UNSIGNED_SHORT_5_6_5(): GLenum; get VALIDATE_STATUS(): GLenum; get VENDOR(): GLenum; get VERSION(): GLenum; get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum; get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum; get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum; get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum; get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum; get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum; get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum; get VERTEX_SHADER(): GLenum; get VIEWPORT(): GLenum; get ZERO(): GLenum; };

export external public interface ~WebGL2RenderingContextBase {
	beginQuery(target: GLenum, query: WebGLQuery): void;
	beginTransformFeedback(primitiveMode: GLenum): void;
	bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer): void;
	bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer, offset: GLintptr, size: GLsizeiptr): void;
	bindSampler(unit: GLuint, sampler: WebGLSampler): void;
	bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback): void;
	bindVertexArray(array: WebGLVertexArrayObject): void;
	blitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void;
	clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void;
	clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint = ): void;
	clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint = ): void;
	clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint = ): void;
	clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum;
	compressedTexImage3D(...args: any+): any+; // overloading not supported
	compressedTexSubImage3D(...args: any+): any+; // overloading not supported
	copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr): void;
	copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	createQuery(): WebGLQuery;
	createSampler(): WebGLSampler;
	createTransformFeedback(): WebGLTransformFeedback;
	createVertexArray(): WebGLVertexArrayObject;
	deleteQuery(query: WebGLQuery): void;
	deleteSampler(sampler: WebGLSampler): void;
	deleteSync(sync: WebGLSync): void;
	deleteTransformFeedback(tf: WebGLTransformFeedback): void;
	deleteVertexArray(vertexArray: WebGLVertexArrayObject): void;
	drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void;
	drawBuffers(buffers: Array<GLenum>): void;
	drawElementsInstanced(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, instanceCount: GLsizei): void;
	drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type: GLenum, offset: GLintptr): void;
	endQuery(target: GLenum): void;
	endTransformFeedback(): void;
	fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync;
	framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint, layer: GLint): void;
	getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): string;
	getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): any;
	getActiveUniforms(program: WebGLProgram, uniformIndices: Array<GLuint>, pname: GLenum): any;
	getBufferSubData(target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView, dstOffset: GLuint = , length: GLuint = ): void;
	getFragDataLocation(program: WebGLProgram, name: string): GLint;
	getIndexedParameter(target: GLenum, index: GLuint): any;
	getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): any;
	getQuery(target: GLenum, pname: GLenum): WebGLQuery;
	getQueryParameter(query: WebGLQuery, pname: GLenum): any;
	getSamplerParameter(sampler: WebGLSampler, pname: GLenum): any;
	getSyncParameter(sync: WebGLSync, pname: GLenum): any;
	getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo;
	getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): GLuint;
	getUniformIndices(program: WebGLProgram, uniformNames: Array<string>): Array<GLuint>;
	invalidateFramebuffer(target: GLenum, attachments: Array<GLenum>): void;
	invalidateSubFramebuffer(target: GLenum, attachments: Array<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	isQuery(query: WebGLQuery): GLboolean;
	isSampler(sampler: WebGLSampler): GLboolean;
	isSync(sync: WebGLSync): GLboolean;
	isTransformFeedback(tf: WebGLTransformFeedback): GLboolean;
	isVertexArray(vertexArray: WebGLVertexArrayObject): GLboolean;
	pauseTransformFeedback(): void;
	readBuffer(src: GLenum): void;
	renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
	resumeTransformFeedback(): void;
	samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat): void;
	samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint): void;
	texImage3D(...args: any+): any+; // overloading not supported
	texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
	texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei): void;
	texSubImage3D(...args: any+): any+; // overloading not supported
	transformFeedbackVaryings(program: WebGLProgram, varyings: Array<string>, bufferMode: GLenum): void;
	uniform1ui(location: WebGLUniformLocation, v0: GLuint): void;
	uniform1uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform2ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint): void;
	uniform2uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform3ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint): void;
	uniform3uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform4ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void;
	uniform4uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void;
	uniformMatrix2x3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix2x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix3x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix3x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix4x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix4x3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	vertexAttribDivisor(index: GLuint, divisor: GLuint): void;
	vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void;
	vertexAttribI4iv(index: GLuint, values: Int32List): void;
	vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void;
	vertexAttribI4uiv(index: GLuint, values: Uint32List): void;
	vertexAttribIPointer(index: GLuint, size: GLint, type: GLenum, stride: GLsizei, offset: GLintptr): void;
	waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64): void;
	get ACTIVE_UNIFORM_BLOCKS(): GLenum;
	get ALREADY_SIGNALED(): GLenum;
	get ANY_SAMPLES_PASSED(): GLenum;
	get ANY_SAMPLES_PASSED_CONSERVATIVE(): GLenum;
	get COLOR(): GLenum;
	get COLOR_ATTACHMENT1(): GLenum;
	get COLOR_ATTACHMENT10(): GLenum;
	get COLOR_ATTACHMENT11(): GLenum;
	get COLOR_ATTACHMENT12(): GLenum;
	get COLOR_ATTACHMENT13(): GLenum;
	get COLOR_ATTACHMENT14(): GLenum;
	get COLOR_ATTACHMENT15(): GLenum;
	get COLOR_ATTACHMENT2(): GLenum;
	get COLOR_ATTACHMENT3(): GLenum;
	get COLOR_ATTACHMENT4(): GLenum;
	get COLOR_ATTACHMENT5(): GLenum;
	get COLOR_ATTACHMENT6(): GLenum;
	get COLOR_ATTACHMENT7(): GLenum;
	get COLOR_ATTACHMENT8(): GLenum;
	get COLOR_ATTACHMENT9(): GLenum;
	get COMPARE_REF_TO_TEXTURE(): GLenum;
	get CONDITION_SATISFIED(): GLenum;
	get COPY_READ_BUFFER(): GLenum;
	get COPY_READ_BUFFER_BINDING(): GLenum;
	get COPY_WRITE_BUFFER(): GLenum;
	get COPY_WRITE_BUFFER_BINDING(): GLenum;
	get CURRENT_QUERY(): GLenum;
	get DEPTH(): GLenum;
	get DEPTH24_STENCIL8(): GLenum;
	get DEPTH32F_STENCIL8(): GLenum;
	get DEPTH_COMPONENT24(): GLenum;
	get DEPTH_COMPONENT32F(): GLenum;
	get DRAW_BUFFER0(): GLenum;
	get DRAW_BUFFER1(): GLenum;
	get DRAW_BUFFER10(): GLenum;
	get DRAW_BUFFER11(): GLenum;
	get DRAW_BUFFER12(): GLenum;
	get DRAW_BUFFER13(): GLenum;
	get DRAW_BUFFER14(): GLenum;
	get DRAW_BUFFER15(): GLenum;
	get DRAW_BUFFER2(): GLenum;
	get DRAW_BUFFER3(): GLenum;
	get DRAW_BUFFER4(): GLenum;
	get DRAW_BUFFER5(): GLenum;
	get DRAW_BUFFER6(): GLenum;
	get DRAW_BUFFER7(): GLenum;
	get DRAW_BUFFER8(): GLenum;
	get DRAW_BUFFER9(): GLenum;
	get DRAW_FRAMEBUFFER(): GLenum;
	get DRAW_FRAMEBUFFER_BINDING(): GLenum;
	get DYNAMIC_COPY(): GLenum;
	get DYNAMIC_READ(): GLenum;
	get FLOAT_32_UNSIGNED_INT_24_8_REV(): GLenum;
	get FLOAT_MAT2x3(): GLenum;
	get FLOAT_MAT2x4(): GLenum;
	get FLOAT_MAT3x2(): GLenum;
	get FLOAT_MAT3x4(): GLenum;
	get FLOAT_MAT4x2(): GLenum;
	get FLOAT_MAT4x3(): GLenum;
	get FRAGMENT_SHADER_DERIVATIVE_HINT(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_BLUE_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_GREEN_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_RED_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER(): GLenum;
	get FRAMEBUFFER_DEFAULT(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_MULTISAMPLE(): GLenum;
	get HALF_FLOAT(): GLenum;
	get INTERLEAVED_ATTRIBS(): GLenum;
	get INT_2_10_10_10_REV(): GLenum;
	get INT_SAMPLER_2D(): GLenum;
	get INT_SAMPLER_2D_ARRAY(): GLenum;
	get INT_SAMPLER_3D(): GLenum;
	get INT_SAMPLER_CUBE(): GLenum;
	get INVALID_INDEX(): GLenum;
	get MAX(): GLenum;
	get MAX_3D_TEXTURE_SIZE(): GLenum;
	get MAX_ARRAY_TEXTURE_LAYERS(): GLenum;
	get MAX_CLIENT_WAIT_TIMEOUT_WEBGL(): GLenum;
	get MAX_COLOR_ATTACHMENTS(): GLenum;
	get MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS(): GLenum;
	get MAX_COMBINED_UNIFORM_BLOCKS(): GLenum;
	get MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS(): GLenum;
	get MAX_DRAW_BUFFERS(): GLenum;
	get MAX_ELEMENTS_INDICES(): GLenum;
	get MAX_ELEMENTS_VERTICES(): GLenum;
	get MAX_ELEMENT_INDEX(): GLenum;
	get MAX_FRAGMENT_INPUT_COMPONENTS(): GLenum;
	get MAX_FRAGMENT_UNIFORM_BLOCKS(): GLenum;
	get MAX_FRAGMENT_UNIFORM_COMPONENTS(): GLenum;
	get MAX_PROGRAM_TEXEL_OFFSET(): GLenum;
	get MAX_SAMPLES(): GLenum;
	get MAX_SERVER_WAIT_TIMEOUT(): GLenum;
	get MAX_TEXTURE_LOD_BIAS(): GLenum;
	get MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS(): GLenum;
	get MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS(): GLenum;
	get MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS(): GLenum;
	get MAX_UNIFORM_BLOCK_SIZE(): GLenum;
	get MAX_UNIFORM_BUFFER_BINDINGS(): GLenum;
	get MAX_VARYING_COMPONENTS(): GLenum;
	get MAX_VERTEX_OUTPUT_COMPONENTS(): GLenum;
	get MAX_VERTEX_UNIFORM_BLOCKS(): GLenum;
	get MAX_VERTEX_UNIFORM_COMPONENTS(): GLenum;
	get MIN(): GLenum;
	get MIN_PROGRAM_TEXEL_OFFSET(): GLenum;
	get OBJECT_TYPE(): GLenum;
	get PACK_ROW_LENGTH(): GLenum;
	get PACK_SKIP_PIXELS(): GLenum;
	get PACK_SKIP_ROWS(): GLenum;
	get PIXEL_PACK_BUFFER(): GLenum;
	get PIXEL_PACK_BUFFER_BINDING(): GLenum;
	get PIXEL_UNPACK_BUFFER(): GLenum;
	get PIXEL_UNPACK_BUFFER_BINDING(): GLenum;
	get QUERY_RESULT(): GLenum;
	get QUERY_RESULT_AVAILABLE(): GLenum;
	get R11F_G11F_B10F(): GLenum;
	get R16F(): GLenum;
	get R16I(): GLenum;
	get R16UI(): GLenum;
	get R32F(): GLenum;
	get R32I(): GLenum;
	get R32UI(): GLenum;
	get R8(): GLenum;
	get R8I(): GLenum;
	get R8UI(): GLenum;
	get R8_SNORM(): GLenum;
	get RASTERIZER_DISCARD(): GLenum;
	get READ_BUFFER(): GLenum;
	get READ_FRAMEBUFFER(): GLenum;
	get READ_FRAMEBUFFER_BINDING(): GLenum;
	get RED(): GLenum;
	get RED_INTEGER(): GLenum;
	get RENDERBUFFER_SAMPLES(): GLenum;
	get RG(): GLenum;
	get RG16F(): GLenum;
	get RG16I(): GLenum;
	get RG16UI(): GLenum;
	get RG32F(): GLenum;
	get RG32I(): GLenum;
	get RG32UI(): GLenum;
	get RG8(): GLenum;
	get RG8I(): GLenum;
	get RG8UI(): GLenum;
	get RG8_SNORM(): GLenum;
	get RGB10_A2(): GLenum;
	get RGB10_A2UI(): GLenum;
	get RGB16F(): GLenum;
	get RGB16I(): GLenum;
	get RGB16UI(): GLenum;
	get RGB32F(): GLenum;
	get RGB32I(): GLenum;
	get RGB32UI(): GLenum;
	get RGB8(): GLenum;
	get RGB8I(): GLenum;
	get RGB8UI(): GLenum;
	get RGB8_SNORM(): GLenum;
	get RGB9_E5(): GLenum;
	get RGBA16F(): GLenum;
	get RGBA16I(): GLenum;
	get RGBA16UI(): GLenum;
	get RGBA32F(): GLenum;
	get RGBA32I(): GLenum;
	get RGBA32UI(): GLenum;
	get RGBA8(): GLenum;
	get RGBA8I(): GLenum;
	get RGBA8UI(): GLenum;
	get RGBA8_SNORM(): GLenum;
	get RGBA_INTEGER(): GLenum;
	get RGB_INTEGER(): GLenum;
	get RG_INTEGER(): GLenum;
	get SAMPLER_2D_ARRAY(): GLenum;
	get SAMPLER_2D_ARRAY_SHADOW(): GLenum;
	get SAMPLER_2D_SHADOW(): GLenum;
	get SAMPLER_3D(): GLenum;
	get SAMPLER_BINDING(): GLenum;
	get SAMPLER_CUBE_SHADOW(): GLenum;
	get SEPARATE_ATTRIBS(): GLenum;
	get SIGNALED(): GLenum;
	get SIGNED_NORMALIZED(): GLenum;
	get SRGB(): GLenum;
	get SRGB8(): GLenum;
	get SRGB8_ALPHA8(): GLenum;
	get STATIC_COPY(): GLenum;
	get STATIC_READ(): GLenum;
	get STENCIL(): GLenum;
	get STREAM_COPY(): GLenum;
	get STREAM_READ(): GLenum;
	get SYNC_CONDITION(): GLenum;
	get SYNC_FENCE(): GLenum;
	get SYNC_FLAGS(): GLenum;
	get SYNC_FLUSH_COMMANDS_BIT(): GLenum;
	get SYNC_GPU_COMMANDS_COMPLETE(): GLenum;
	get SYNC_STATUS(): GLenum;
	get TEXTURE_2D_ARRAY(): GLenum;
	get TEXTURE_3D(): GLenum;
	get TEXTURE_BASE_LEVEL(): GLenum;
	get TEXTURE_BINDING_2D_ARRAY(): GLenum;
	get TEXTURE_BINDING_3D(): GLenum;
	get TEXTURE_COMPARE_FUNC(): GLenum;
	get TEXTURE_COMPARE_MODE(): GLenum;
	get TEXTURE_IMMUTABLE_FORMAT(): GLenum;
	get TEXTURE_IMMUTABLE_LEVELS(): GLenum;
	get TEXTURE_MAX_LEVEL(): GLenum;
	get TEXTURE_MAX_LOD(): GLenum;
	get TEXTURE_MIN_LOD(): GLenum;
	get TEXTURE_WRAP_R(): GLenum;
	get TIMEOUT_EXPIRED(): GLenum;
	get TIMEOUT_IGNORED(): GLint64;
	get TRANSFORM_FEEDBACK(): GLenum;
	get TRANSFORM_FEEDBACK_ACTIVE(): GLenum;
	get TRANSFORM_FEEDBACK_BINDING(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_BINDING(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_MODE(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_SIZE(): GLenum;
	get TRANSFORM_FEEDBACK_BUFFER_START(): GLenum;
	get TRANSFORM_FEEDBACK_PAUSED(): GLenum;
	get TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN(): GLenum;
	get TRANSFORM_FEEDBACK_VARYINGS(): GLenum;
	get UNIFORM_ARRAY_STRIDE(): GLenum;
	get UNIFORM_BLOCK_ACTIVE_UNIFORMS(): GLenum;
	get UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES(): GLenum;
	get UNIFORM_BLOCK_BINDING(): GLenum;
	get UNIFORM_BLOCK_DATA_SIZE(): GLenum;
	get UNIFORM_BLOCK_INDEX(): GLenum;
	get UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER(): GLenum;
	get UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER(): GLenum;
	get UNIFORM_BUFFER(): GLenum;
	get UNIFORM_BUFFER_BINDING(): GLenum;
	get UNIFORM_BUFFER_OFFSET_ALIGNMENT(): GLenum;
	get UNIFORM_BUFFER_SIZE(): GLenum;
	get UNIFORM_BUFFER_START(): GLenum;
	get UNIFORM_IS_ROW_MAJOR(): GLenum;
	get UNIFORM_MATRIX_STRIDE(): GLenum;
	get UNIFORM_OFFSET(): GLenum;
	get UNIFORM_SIZE(): GLenum;
	get UNIFORM_TYPE(): GLenum;
	get UNPACK_IMAGE_HEIGHT(): GLenum;
	get UNPACK_ROW_LENGTH(): GLenum;
	get UNPACK_SKIP_IMAGES(): GLenum;
	get UNPACK_SKIP_PIXELS(): GLenum;
	get UNPACK_SKIP_ROWS(): GLenum;
	get UNSIGNALED(): GLenum;
	get UNSIGNED_INT_10F_11F_11F_REV(): GLenum;
	get UNSIGNED_INT_24_8(): GLenum;
	get UNSIGNED_INT_2_10_10_10_REV(): GLenum;
	get UNSIGNED_INT_5_9_9_9_REV(): GLenum;
	get UNSIGNED_INT_SAMPLER_2D(): GLenum;
	get UNSIGNED_INT_SAMPLER_2D_ARRAY(): GLenum;
	get UNSIGNED_INT_SAMPLER_3D(): GLenum;
	get UNSIGNED_INT_SAMPLER_CUBE(): GLenum;
	get UNSIGNED_INT_VEC2(): GLenum;
	get UNSIGNED_INT_VEC3(): GLenum;
	get UNSIGNED_INT_VEC4(): GLenum;
	get UNSIGNED_NORMALIZED(): GLenum;
	get VERTEX_ARRAY_BINDING(): GLenum;
	get VERTEX_ATTRIB_ARRAY_DIVISOR(): GLenum;
	get VERTEX_ATTRIB_ARRAY_INTEGER(): GLenum;
	get WAIT_FAILED(): GLenum;
}

export external public interface ~WebGL2RenderingContextOverloads {
	bufferData(...args: any+): any+; // overloading not supported
	bufferSubData(...args: any+): any+; // overloading not supported
	compressedTexImage2D(...args: any+): any+; // overloading not supported
	compressedTexSubImage2D(...args: any+): any+; // overloading not supported
	readPixels(...args: any+): any+; // overloading not supported
	texImage2D(...args: any+): any+; // overloading not supported
	texSubImage2D(...args: any+): any+; // overloading not supported
	uniform1fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform1iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform2fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform2iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform3fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform3iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform4fv(location: WebGLUniformLocation, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniform4iv(location: WebGLUniformLocation, data: Int32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = , srcLength: GLuint = ): void;
}

export external public interface ~WebGLActiveInfo {
	get name(): string;
	get size(): GLint;
	get type(): GLenum;
}

var WebGLActiveInfo: ~Object with { constructor(); };

export external public interface ~WebGLBuffer {}

var WebGLBuffer: ~Object with { constructor(); };

export external public interface ~WebGLContextEvent extends Event {
	get statusMessage(): string;
}

var WebGLContextEvent: ~Object with { constructor(type: string, eventInit: WebGLContextEventInit = ); };

export external public interface ~WebGLFramebuffer {}

var WebGLFramebuffer: ~Object with { constructor(); };

export external public interface ~WebGLProgram {}

var WebGLProgram: ~Object with { constructor(); };

export external public interface ~WebGLQuery {}

var WebGLQuery: ~Object with { constructor(); };

export external public interface ~WebGLRenderbuffer {}

var WebGLRenderbuffer: ~Object with { constructor(); };

export external public interface ~WebGLRenderingContext extends WebGLRenderingContextBase, WebGLRenderingContextOverloads {}

var WebGLRenderingContext: ~Object with { constructor(); get ACTIVE_ATTRIBUTES(): GLenum; get ACTIVE_TEXTURE(): GLenum; get ACTIVE_UNIFORMS(): GLenum; get ALIASED_LINE_WIDTH_RANGE(): GLenum; get ALIASED_POINT_SIZE_RANGE(): GLenum; get ALPHA(): GLenum; get ALPHA_BITS(): GLenum; get ALWAYS(): GLenum; get ARRAY_BUFFER(): GLenum; get ARRAY_BUFFER_BINDING(): GLenum; get ATTACHED_SHADERS(): GLenum; get BACK(): GLenum; get BLEND(): GLenum; get BLEND_COLOR(): GLenum; get BLEND_DST_ALPHA(): GLenum; get BLEND_DST_RGB(): GLenum; get BLEND_EQUATION(): GLenum; get BLEND_EQUATION_ALPHA(): GLenum; get BLEND_EQUATION_RGB(): GLenum; get BLEND_SRC_ALPHA(): GLenum; get BLEND_SRC_RGB(): GLenum; get BLUE_BITS(): GLenum; get BOOL(): GLenum; get BOOL_VEC2(): GLenum; get BOOL_VEC3(): GLenum; get BOOL_VEC4(): GLenum; get BROWSER_DEFAULT_WEBGL(): GLenum; get BUFFER_SIZE(): GLenum; get BUFFER_USAGE(): GLenum; get BYTE(): GLenum; get CCW(): GLenum; get CLAMP_TO_EDGE(): GLenum; get COLOR_ATTACHMENT0(): GLenum; get COLOR_BUFFER_BIT(): GLenum; get COLOR_CLEAR_VALUE(): GLenum; get COLOR_WRITEMASK(): GLenum; get COMPILE_STATUS(): GLenum; get COMPRESSED_TEXTURE_FORMATS(): GLenum; get CONSTANT_ALPHA(): GLenum; get CONSTANT_COLOR(): GLenum; get CONTEXT_LOST_WEBGL(): GLenum; get CULL_FACE(): GLenum; get CULL_FACE_MODE(): GLenum; get CURRENT_PROGRAM(): GLenum; get CURRENT_VERTEX_ATTRIB(): GLenum; get CW(): GLenum; get DECR(): GLenum; get DECR_WRAP(): GLenum; get DELETE_STATUS(): GLenum; get DEPTH_ATTACHMENT(): GLenum; get DEPTH_BITS(): GLenum; get DEPTH_BUFFER_BIT(): GLenum; get DEPTH_CLEAR_VALUE(): GLenum; get DEPTH_COMPONENT(): GLenum; get DEPTH_COMPONENT16(): GLenum; get DEPTH_FUNC(): GLenum; get DEPTH_RANGE(): GLenum; get DEPTH_STENCIL(): GLenum; get DEPTH_STENCIL_ATTACHMENT(): GLenum; get DEPTH_TEST(): GLenum; get DEPTH_WRITEMASK(): GLenum; get DITHER(): GLenum; get DONT_CARE(): GLenum; get DST_ALPHA(): GLenum; get DST_COLOR(): GLenum; get DYNAMIC_DRAW(): GLenum; get ELEMENT_ARRAY_BUFFER(): GLenum; get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum; get EQUAL(): GLenum; get FASTEST(): GLenum; get FLOAT(): GLenum; get FLOAT_MAT2(): GLenum; get FLOAT_MAT3(): GLenum; get FLOAT_MAT4(): GLenum; get FLOAT_VEC2(): GLenum; get FLOAT_VEC3(): GLenum; get FLOAT_VEC4(): GLenum; get FRAGMENT_SHADER(): GLenum; get FRAMEBUFFER(): GLenum; get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum; get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum; get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum; get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum; get FRAMEBUFFER_BINDING(): GLenum; get FRAMEBUFFER_COMPLETE(): GLenum; get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum; get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum; get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum; get FRAMEBUFFER_UNSUPPORTED(): GLenum; get FRONT(): GLenum; get FRONT_AND_BACK(): GLenum; get FRONT_FACE(): GLenum; get FUNC_ADD(): GLenum; get FUNC_REVERSE_SUBTRACT(): GLenum; get FUNC_SUBTRACT(): GLenum; get GENERATE_MIPMAP_HINT(): GLenum; get GEQUAL(): GLenum; get GREATER(): GLenum; get GREEN_BITS(): GLenum; get HIGH_FLOAT(): GLenum; get HIGH_INT(): GLenum; get IMPLEMENTATION_COLOR_READ_FORMAT(): GLenum; get IMPLEMENTATION_COLOR_READ_TYPE(): GLenum; get INCR(): GLenum; get INCR_WRAP(): GLenum; get INT(): GLenum; get INT_VEC2(): GLenum; get INT_VEC3(): GLenum; get INT_VEC4(): GLenum; get INVALID_ENUM(): GLenum; get INVALID_FRAMEBUFFER_OPERATION(): GLenum; get INVALID_OPERATION(): GLenum; get INVALID_VALUE(): GLenum; get INVERT(): GLenum; get KEEP(): GLenum; get LEQUAL(): GLenum; get LESS(): GLenum; get LINEAR(): GLenum; get LINEAR_MIPMAP_LINEAR(): GLenum; get LINEAR_MIPMAP_NEAREST(): GLenum; get LINES(): GLenum; get LINE_LOOP(): GLenum; get LINE_STRIP(): GLenum; get LINE_WIDTH(): GLenum; get LINK_STATUS(): GLenum; get LOW_FLOAT(): GLenum; get LOW_INT(): GLenum; get LUMINANCE(): GLenum; get LUMINANCE_ALPHA(): GLenum; get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum; get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum; get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum; get MAX_RENDERBUFFER_SIZE(): GLenum; get MAX_TEXTURE_IMAGE_UNITS(): GLenum; get MAX_TEXTURE_SIZE(): GLenum; get MAX_VARYING_VECTORS(): GLenum; get MAX_VERTEX_ATTRIBS(): GLenum; get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum; get MAX_VERTEX_UNIFORM_VECTORS(): GLenum; get MAX_VIEWPORT_DIMS(): GLenum; get MEDIUM_FLOAT(): GLenum; get MEDIUM_INT(): GLenum; get MIRRORED_REPEAT(): GLenum; get NEAREST(): GLenum; get NEAREST_MIPMAP_LINEAR(): GLenum; get NEAREST_MIPMAP_NEAREST(): GLenum; get NEVER(): GLenum; get NICEST(): GLenum; get NONE(): GLenum; get NOTEQUAL(): GLenum; get NO_ERROR(): GLenum; get ONE(): GLenum; get ONE_MINUS_CONSTANT_ALPHA(): GLenum; get ONE_MINUS_CONSTANT_COLOR(): GLenum; get ONE_MINUS_DST_ALPHA(): GLenum; get ONE_MINUS_DST_COLOR(): GLenum; get ONE_MINUS_SRC_ALPHA(): GLenum; get ONE_MINUS_SRC_COLOR(): GLenum; get OUT_OF_MEMORY(): GLenum; get PACK_ALIGNMENT(): GLenum; get POINTS(): GLenum; get POLYGON_OFFSET_FACTOR(): GLenum; get POLYGON_OFFSET_FILL(): GLenum; get POLYGON_OFFSET_UNITS(): GLenum; get RED_BITS(): GLenum; get RENDERBUFFER(): GLenum; get RENDERBUFFER_ALPHA_SIZE(): GLenum; get RENDERBUFFER_BINDING(): GLenum; get RENDERBUFFER_BLUE_SIZE(): GLenum; get RENDERBUFFER_DEPTH_SIZE(): GLenum; get RENDERBUFFER_GREEN_SIZE(): GLenum; get RENDERBUFFER_HEIGHT(): GLenum; get RENDERBUFFER_INTERNAL_FORMAT(): GLenum; get RENDERBUFFER_RED_SIZE(): GLenum; get RENDERBUFFER_STENCIL_SIZE(): GLenum; get RENDERBUFFER_WIDTH(): GLenum; get RENDERER(): GLenum; get REPEAT(): GLenum; get REPLACE(): GLenum; get RGB(): GLenum; get RGB565(): GLenum; get RGB5_A1(): GLenum; get RGBA(): GLenum; get RGBA4(): GLenum; get SAMPLER_2D(): GLenum; get SAMPLER_CUBE(): GLenum; get SAMPLES(): GLenum; get SAMPLE_ALPHA_TO_COVERAGE(): GLenum; get SAMPLE_BUFFERS(): GLenum; get SAMPLE_COVERAGE(): GLenum; get SAMPLE_COVERAGE_INVERT(): GLenum; get SAMPLE_COVERAGE_VALUE(): GLenum; get SCISSOR_BOX(): GLenum; get SCISSOR_TEST(): GLenum; get SHADER_TYPE(): GLenum; get SHADING_LANGUAGE_VERSION(): GLenum; get SHORT(): GLenum; get SRC_ALPHA(): GLenum; get SRC_ALPHA_SATURATE(): GLenum; get SRC_COLOR(): GLenum; get STATIC_DRAW(): GLenum; get STENCIL_ATTACHMENT(): GLenum; get STENCIL_BACK_FAIL(): GLenum; get STENCIL_BACK_FUNC(): GLenum; get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum; get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum; get STENCIL_BACK_REF(): GLenum; get STENCIL_BACK_VALUE_MASK(): GLenum; get STENCIL_BACK_WRITEMASK(): GLenum; get STENCIL_BITS(): GLenum; get STENCIL_BUFFER_BIT(): GLenum; get STENCIL_CLEAR_VALUE(): GLenum; get STENCIL_FAIL(): GLenum; get STENCIL_FUNC(): GLenum; get STENCIL_INDEX8(): GLenum; get STENCIL_PASS_DEPTH_FAIL(): GLenum; get STENCIL_PASS_DEPTH_PASS(): GLenum; get STENCIL_REF(): GLenum; get STENCIL_TEST(): GLenum; get STENCIL_VALUE_MASK(): GLenum; get STENCIL_WRITEMASK(): GLenum; get STREAM_DRAW(): GLenum; get SUBPIXEL_BITS(): GLenum; get TEXTURE(): GLenum; get TEXTURE0(): GLenum; get TEXTURE1(): GLenum; get TEXTURE10(): GLenum; get TEXTURE11(): GLenum; get TEXTURE12(): GLenum; get TEXTURE13(): GLenum; get TEXTURE14(): GLenum; get TEXTURE15(): GLenum; get TEXTURE16(): GLenum; get TEXTURE17(): GLenum; get TEXTURE18(): GLenum; get TEXTURE19(): GLenum; get TEXTURE2(): GLenum; get TEXTURE20(): GLenum; get TEXTURE21(): GLenum; get TEXTURE22(): GLenum; get TEXTURE23(): GLenum; get TEXTURE24(): GLenum; get TEXTURE25(): GLenum; get TEXTURE26(): GLenum; get TEXTURE27(): GLenum; get TEXTURE28(): GLenum; get TEXTURE29(): GLenum; get TEXTURE3(): GLenum; get TEXTURE30(): GLenum; get TEXTURE31(): GLenum; get TEXTURE4(): GLenum; get TEXTURE5(): GLenum; get TEXTURE6(): GLenum; get TEXTURE7(): GLenum; get TEXTURE8(): GLenum; get TEXTURE9(): GLenum; get TEXTURE_2D(): GLenum; get TEXTURE_BINDING_2D(): GLenum; get TEXTURE_BINDING_CUBE_MAP(): GLenum; get TEXTURE_CUBE_MAP(): GLenum; get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum; get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum; get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum; get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum; get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum; get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum; get TEXTURE_MAG_FILTER(): GLenum; get TEXTURE_MIN_FILTER(): GLenum; get TEXTURE_WRAP_S(): GLenum; get TEXTURE_WRAP_T(): GLenum; get TRIANGLES(): GLenum; get TRIANGLE_FAN(): GLenum; get TRIANGLE_STRIP(): GLenum; get UNPACK_ALIGNMENT(): GLenum; get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum; get UNPACK_FLIP_Y_WEBGL(): GLenum; get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum; get UNSIGNED_BYTE(): GLenum; get UNSIGNED_INT(): GLenum; get UNSIGNED_SHORT(): GLenum; get UNSIGNED_SHORT_4_4_4_4(): GLenum; get UNSIGNED_SHORT_5_5_5_1(): GLenum; get UNSIGNED_SHORT_5_6_5(): GLenum; get VALIDATE_STATUS(): GLenum; get VENDOR(): GLenum; get VERSION(): GLenum; get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum; get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum; get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum; get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum; get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum; get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum; get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum; get VERTEX_SHADER(): GLenum; get VIEWPORT(): GLenum; get ZERO(): GLenum; };

export external public interface ~WebGLRenderingContextBase {
	get canvas(): HTMLCanvasElement;
	get drawingBufferHeight(): GLsizei;
	get drawingBufferWidth(): GLsizei;
	activeTexture(texture: GLenum): void;
	attachShader(program: WebGLProgram, shader: WebGLShader): void;
	bindAttribLocation(program: WebGLProgram, index: GLuint, name: string): void;
	bindBuffer(target: GLenum, buffer: WebGLBuffer): void;
	bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer): void;
	bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer): void;
	bindTexture(target: GLenum, texture: WebGLTexture): void;
	blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;
	blendEquation(mode: GLenum): void;
	blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum): void;
	blendFunc(sfactor: GLenum, dfactor: GLenum): void;
	blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;
	checkFramebufferStatus(target: GLenum): GLenum;
	clear(mask: GLbitfield): void;
	clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;
	clearDepth(depth: GLclampf): void;
	clearStencil(s: GLint): void;
	colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void;
	compileShader(shader: WebGLShader): void;
	copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void;
	copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	createBuffer(): WebGLBuffer;
	createFramebuffer(): WebGLFramebuffer;
	createProgram(): WebGLProgram;
	createRenderbuffer(): WebGLRenderbuffer;
	createShader(type: GLenum): WebGLShader;
	createTexture(): WebGLTexture;
	cullFace(mode: GLenum): void;
	deleteBuffer(buffer: WebGLBuffer): void;
	deleteFramebuffer(framebuffer: WebGLFramebuffer): void;
	deleteProgram(program: WebGLProgram): void;
	deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void;
	deleteShader(shader: WebGLShader): void;
	deleteTexture(texture: WebGLTexture): void;
	depthFunc(func: GLenum): void;
	depthMask(flag: GLboolean): void;
	depthRange(zNear: GLclampf, zFar: GLclampf): void;
	detachShader(program: WebGLProgram, shader: WebGLShader): void;
	disable(cap: GLenum): void;
	disableVertexAttribArray(index: GLuint): void;
	drawArrays(mode: GLenum, first: GLint, count: GLsizei): void;
	drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr): void;
	enable(cap: GLenum): void;
	enableVertexAttribArray(index: GLuint): void;
	finish(): void;
	flush(): void;
	framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer): void;
	framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture, level: GLint): void;
	frontFace(mode: GLenum): void;
	generateMipmap(target: GLenum): void;
	getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo;
	getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo;
	getAttachedShaders(program: WebGLProgram): Array<WebGLShader>;
	getAttribLocation(program: WebGLProgram, name: string): GLint;
	getBufferParameter(target: GLenum, pname: GLenum): any;
	getContextAttributes(): WebGLContextAttributes;
	getError(): GLenum;
	getExtension(...args: any+): any+; // overloading not supported
	getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): any;
	getParameter(pname: GLenum): any;
	getProgramInfoLog(program: WebGLProgram): string;
	getProgramParameter(program: WebGLProgram, pname: GLenum): any;
	getRenderbufferParameter(target: GLenum, pname: GLenum): any;
	getShaderInfoLog(shader: WebGLShader): string;
	getShaderParameter(shader: WebGLShader, pname: GLenum): any;
	getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat;
	getShaderSource(shader: WebGLShader): string;
	getSupportedExtensions(): Array<string>;
	getTexParameter(target: GLenum, pname: GLenum): any;
	getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;
	getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation;
	getVertexAttrib(index: GLuint, pname: GLenum): any;
	getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr;
	hint(target: GLenum, mode: GLenum): void;
	isBuffer(buffer: WebGLBuffer): GLboolean;
	isContextLost(): boolean;
	isEnabled(cap: GLenum): GLboolean;
	isFramebuffer(framebuffer: WebGLFramebuffer): GLboolean;
	isProgram(program: WebGLProgram): GLboolean;
	isRenderbuffer(renderbuffer: WebGLRenderbuffer): GLboolean;
	isShader(shader: WebGLShader): GLboolean;
	isTexture(texture: WebGLTexture): GLboolean;
	lineWidth(width: GLfloat): void;
	linkProgram(program: WebGLProgram): void;
	pixelStorei(pname: GLenum, param: GLint | GLboolean): void;
	polygonOffset(factor: GLfloat, units: GLfloat): void;
	renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void;
	sampleCoverage(value: GLclampf, invert: GLboolean): void;
	scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	shaderSource(shader: WebGLShader, source: string): void;
	stencilFunc(func: GLenum, ref: GLint, mask: GLuint): void;
	stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void;
	stencilMask(mask: GLuint): void;
	stencilMaskSeparate(face: GLenum, mask: GLuint): void;
	stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void;
	stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void;
	texParameterf(target: GLenum, pname: GLenum, param: GLfloat): void;
	texParameteri(target: GLenum, pname: GLenum, param: GLint): void;
	uniform1f(location: WebGLUniformLocation, x: GLfloat): void;
	uniform1i(location: WebGLUniformLocation, x: GLint): void;
	uniform2f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat): void;
	uniform2i(location: WebGLUniformLocation, x: GLint, y: GLint): void;
	uniform3f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat): void;
	uniform3i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint): void;
	uniform4f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;
	uniform4i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint, w: GLint): void;
	useProgram(program: WebGLProgram): void;
	validateProgram(program: WebGLProgram): void;
	vertexAttrib1f(index: GLuint, x: GLfloat): void;
	vertexAttrib1fv(index: GLuint, values: Float32List): void;
	vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat): void;
	vertexAttrib2fv(index: GLuint, values: Float32List): void;
	vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void;
	vertexAttrib3fv(index: GLuint, values: Float32List): void;
	vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;
	vertexAttrib4fv(index: GLuint, values: Float32List): void;
	vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void;
	viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;
	get ACTIVE_ATTRIBUTES(): GLenum;
	get ACTIVE_TEXTURE(): GLenum;
	get ACTIVE_UNIFORMS(): GLenum;
	get ALIASED_LINE_WIDTH_RANGE(): GLenum;
	get ALIASED_POINT_SIZE_RANGE(): GLenum;
	get ALPHA(): GLenum;
	get ALPHA_BITS(): GLenum;
	get ALWAYS(): GLenum;
	get ARRAY_BUFFER(): GLenum;
	get ARRAY_BUFFER_BINDING(): GLenum;
	get ATTACHED_SHADERS(): GLenum;
	get BACK(): GLenum;
	get BLEND(): GLenum;
	get BLEND_COLOR(): GLenum;
	get BLEND_DST_ALPHA(): GLenum;
	get BLEND_DST_RGB(): GLenum;
	get BLEND_EQUATION(): GLenum;
	get BLEND_EQUATION_ALPHA(): GLenum;
	get BLEND_EQUATION_RGB(): GLenum;
	get BLEND_SRC_ALPHA(): GLenum;
	get BLEND_SRC_RGB(): GLenum;
	get BLUE_BITS(): GLenum;
	get BOOL(): GLenum;
	get BOOL_VEC2(): GLenum;
	get BOOL_VEC3(): GLenum;
	get BOOL_VEC4(): GLenum;
	get BROWSER_DEFAULT_WEBGL(): GLenum;
	get BUFFER_SIZE(): GLenum;
	get BUFFER_USAGE(): GLenum;
	get BYTE(): GLenum;
	get CCW(): GLenum;
	get CLAMP_TO_EDGE(): GLenum;
	get COLOR_ATTACHMENT0(): GLenum;
	get COLOR_BUFFER_BIT(): GLenum;
	get COLOR_CLEAR_VALUE(): GLenum;
	get COLOR_WRITEMASK(): GLenum;
	get COMPILE_STATUS(): GLenum;
	get COMPRESSED_TEXTURE_FORMATS(): GLenum;
	get CONSTANT_ALPHA(): GLenum;
	get CONSTANT_COLOR(): GLenum;
	get CONTEXT_LOST_WEBGL(): GLenum;
	get CULL_FACE(): GLenum;
	get CULL_FACE_MODE(): GLenum;
	get CURRENT_PROGRAM(): GLenum;
	get CURRENT_VERTEX_ATTRIB(): GLenum;
	get CW(): GLenum;
	get DECR(): GLenum;
	get DECR_WRAP(): GLenum;
	get DELETE_STATUS(): GLenum;
	get DEPTH_ATTACHMENT(): GLenum;
	get DEPTH_BITS(): GLenum;
	get DEPTH_BUFFER_BIT(): GLenum;
	get DEPTH_CLEAR_VALUE(): GLenum;
	get DEPTH_COMPONENT(): GLenum;
	get DEPTH_COMPONENT16(): GLenum;
	get DEPTH_FUNC(): GLenum;
	get DEPTH_RANGE(): GLenum;
	get DEPTH_STENCIL(): GLenum;
	get DEPTH_STENCIL_ATTACHMENT(): GLenum;
	get DEPTH_TEST(): GLenum;
	get DEPTH_WRITEMASK(): GLenum;
	get DITHER(): GLenum;
	get DONT_CARE(): GLenum;
	get DST_ALPHA(): GLenum;
	get DST_COLOR(): GLenum;
	get DYNAMIC_DRAW(): GLenum;
	get ELEMENT_ARRAY_BUFFER(): GLenum;
	get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum;
	get EQUAL(): GLenum;
	get FASTEST(): GLenum;
	get FLOAT(): GLenum;
	get FLOAT_MAT2(): GLenum;
	get FLOAT_MAT3(): GLenum;
	get FLOAT_MAT4(): GLenum;
	get FLOAT_VEC2(): GLenum;
	get FLOAT_VEC3(): GLenum;
	get FLOAT_VEC4(): GLenum;
	get FRAGMENT_SHADER(): GLenum;
	get FRAMEBUFFER(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum;
	get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum;
	get FRAMEBUFFER_BINDING(): GLenum;
	get FRAMEBUFFER_COMPLETE(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum;
	get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum;
	get FRAMEBUFFER_UNSUPPORTED(): GLenum;
	get FRONT(): GLenum;
	get FRONT_AND_BACK(): GLenum;
	get FRONT_FACE(): GLenum;
	get FUNC_ADD(): GLenum;
	get FUNC_REVERSE_SUBTRACT(): GLenum;
	get FUNC_SUBTRACT(): GLenum;
	get GENERATE_MIPMAP_HINT(): GLenum;
	get GEQUAL(): GLenum;
	get GREATER(): GLenum;
	get GREEN_BITS(): GLenum;
	get HIGH_FLOAT(): GLenum;
	get HIGH_INT(): GLenum;
	get IMPLEMENTATION_COLOR_READ_FORMAT(): GLenum;
	get IMPLEMENTATION_COLOR_READ_TYPE(): GLenum;
	get INCR(): GLenum;
	get INCR_WRAP(): GLenum;
	get INT(): GLenum;
	get INT_VEC2(): GLenum;
	get INT_VEC3(): GLenum;
	get INT_VEC4(): GLenum;
	get INVALID_ENUM(): GLenum;
	get INVALID_FRAMEBUFFER_OPERATION(): GLenum;
	get INVALID_OPERATION(): GLenum;
	get INVALID_VALUE(): GLenum;
	get INVERT(): GLenum;
	get KEEP(): GLenum;
	get LEQUAL(): GLenum;
	get LESS(): GLenum;
	get LINEAR(): GLenum;
	get LINEAR_MIPMAP_LINEAR(): GLenum;
	get LINEAR_MIPMAP_NEAREST(): GLenum;
	get LINES(): GLenum;
	get LINE_LOOP(): GLenum;
	get LINE_STRIP(): GLenum;
	get LINE_WIDTH(): GLenum;
	get LINK_STATUS(): GLenum;
	get LOW_FLOAT(): GLenum;
	get LOW_INT(): GLenum;
	get LUMINANCE(): GLenum;
	get LUMINANCE_ALPHA(): GLenum;
	get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum;
	get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum;
	get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum;
	get MAX_RENDERBUFFER_SIZE(): GLenum;
	get MAX_TEXTURE_IMAGE_UNITS(): GLenum;
	get MAX_TEXTURE_SIZE(): GLenum;
	get MAX_VARYING_VECTORS(): GLenum;
	get MAX_VERTEX_ATTRIBS(): GLenum;
	get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum;
	get MAX_VERTEX_UNIFORM_VECTORS(): GLenum;
	get MAX_VIEWPORT_DIMS(): GLenum;
	get MEDIUM_FLOAT(): GLenum;
	get MEDIUM_INT(): GLenum;
	get MIRRORED_REPEAT(): GLenum;
	get NEAREST(): GLenum;
	get NEAREST_MIPMAP_LINEAR(): GLenum;
	get NEAREST_MIPMAP_NEAREST(): GLenum;
	get NEVER(): GLenum;
	get NICEST(): GLenum;
	get NONE(): GLenum;
	get NOTEQUAL(): GLenum;
	get NO_ERROR(): GLenum;
	get ONE(): GLenum;
	get ONE_MINUS_CONSTANT_ALPHA(): GLenum;
	get ONE_MINUS_CONSTANT_COLOR(): GLenum;
	get ONE_MINUS_DST_ALPHA(): GLenum;
	get ONE_MINUS_DST_COLOR(): GLenum;
	get ONE_MINUS_SRC_ALPHA(): GLenum;
	get ONE_MINUS_SRC_COLOR(): GLenum;
	get OUT_OF_MEMORY(): GLenum;
	get PACK_ALIGNMENT(): GLenum;
	get POINTS(): GLenum;
	get POLYGON_OFFSET_FACTOR(): GLenum;
	get POLYGON_OFFSET_FILL(): GLenum;
	get POLYGON_OFFSET_UNITS(): GLenum;
	get RED_BITS(): GLenum;
	get RENDERBUFFER(): GLenum;
	get RENDERBUFFER_ALPHA_SIZE(): GLenum;
	get RENDERBUFFER_BINDING(): GLenum;
	get RENDERBUFFER_BLUE_SIZE(): GLenum;
	get RENDERBUFFER_DEPTH_SIZE(): GLenum;
	get RENDERBUFFER_GREEN_SIZE(): GLenum;
	get RENDERBUFFER_HEIGHT(): GLenum;
	get RENDERBUFFER_INTERNAL_FORMAT(): GLenum;
	get RENDERBUFFER_RED_SIZE(): GLenum;
	get RENDERBUFFER_STENCIL_SIZE(): GLenum;
	get RENDERBUFFER_WIDTH(): GLenum;
	get RENDERER(): GLenum;
	get REPEAT(): GLenum;
	get REPLACE(): GLenum;
	get RGB(): GLenum;
	get RGB565(): GLenum;
	get RGB5_A1(): GLenum;
	get RGBA(): GLenum;
	get RGBA4(): GLenum;
	get SAMPLER_2D(): GLenum;
	get SAMPLER_CUBE(): GLenum;
	get SAMPLES(): GLenum;
	get SAMPLE_ALPHA_TO_COVERAGE(): GLenum;
	get SAMPLE_BUFFERS(): GLenum;
	get SAMPLE_COVERAGE(): GLenum;
	get SAMPLE_COVERAGE_INVERT(): GLenum;
	get SAMPLE_COVERAGE_VALUE(): GLenum;
	get SCISSOR_BOX(): GLenum;
	get SCISSOR_TEST(): GLenum;
	get SHADER_TYPE(): GLenum;
	get SHADING_LANGUAGE_VERSION(): GLenum;
	get SHORT(): GLenum;
	get SRC_ALPHA(): GLenum;
	get SRC_ALPHA_SATURATE(): GLenum;
	get SRC_COLOR(): GLenum;
	get STATIC_DRAW(): GLenum;
	get STENCIL_ATTACHMENT(): GLenum;
	get STENCIL_BACK_FAIL(): GLenum;
	get STENCIL_BACK_FUNC(): GLenum;
	get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum;
	get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum;
	get STENCIL_BACK_REF(): GLenum;
	get STENCIL_BACK_VALUE_MASK(): GLenum;
	get STENCIL_BACK_WRITEMASK(): GLenum;
	get STENCIL_BITS(): GLenum;
	get STENCIL_BUFFER_BIT(): GLenum;
	get STENCIL_CLEAR_VALUE(): GLenum;
	get STENCIL_FAIL(): GLenum;
	get STENCIL_FUNC(): GLenum;
	get STENCIL_INDEX8(): GLenum;
	get STENCIL_PASS_DEPTH_FAIL(): GLenum;
	get STENCIL_PASS_DEPTH_PASS(): GLenum;
	get STENCIL_REF(): GLenum;
	get STENCIL_TEST(): GLenum;
	get STENCIL_VALUE_MASK(): GLenum;
	get STENCIL_WRITEMASK(): GLenum;
	get STREAM_DRAW(): GLenum;
	get SUBPIXEL_BITS(): GLenum;
	get TEXTURE(): GLenum;
	get TEXTURE0(): GLenum;
	get TEXTURE1(): GLenum;
	get TEXTURE10(): GLenum;
	get TEXTURE11(): GLenum;
	get TEXTURE12(): GLenum;
	get TEXTURE13(): GLenum;
	get TEXTURE14(): GLenum;
	get TEXTURE15(): GLenum;
	get TEXTURE16(): GLenum;
	get TEXTURE17(): GLenum;
	get TEXTURE18(): GLenum;
	get TEXTURE19(): GLenum;
	get TEXTURE2(): GLenum;
	get TEXTURE20(): GLenum;
	get TEXTURE21(): GLenum;
	get TEXTURE22(): GLenum;
	get TEXTURE23(): GLenum;
	get TEXTURE24(): GLenum;
	get TEXTURE25(): GLenum;
	get TEXTURE26(): GLenum;
	get TEXTURE27(): GLenum;
	get TEXTURE28(): GLenum;
	get TEXTURE29(): GLenum;
	get TEXTURE3(): GLenum;
	get TEXTURE30(): GLenum;
	get TEXTURE31(): GLenum;
	get TEXTURE4(): GLenum;
	get TEXTURE5(): GLenum;
	get TEXTURE6(): GLenum;
	get TEXTURE7(): GLenum;
	get TEXTURE8(): GLenum;
	get TEXTURE9(): GLenum;
	get TEXTURE_2D(): GLenum;
	get TEXTURE_BINDING_2D(): GLenum;
	get TEXTURE_BINDING_CUBE_MAP(): GLenum;
	get TEXTURE_CUBE_MAP(): GLenum;
	get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum;
	get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum;
	get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum;
	get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum;
	get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum;
	get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum;
	get TEXTURE_MAG_FILTER(): GLenum;
	get TEXTURE_MIN_FILTER(): GLenum;
	get TEXTURE_WRAP_S(): GLenum;
	get TEXTURE_WRAP_T(): GLenum;
	get TRIANGLES(): GLenum;
	get TRIANGLE_FAN(): GLenum;
	get TRIANGLE_STRIP(): GLenum;
	get UNPACK_ALIGNMENT(): GLenum;
	get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum;
	get UNPACK_FLIP_Y_WEBGL(): GLenum;
	get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum;
	get UNSIGNED_BYTE(): GLenum;
	get UNSIGNED_INT(): GLenum;
	get UNSIGNED_SHORT(): GLenum;
	get UNSIGNED_SHORT_4_4_4_4(): GLenum;
	get UNSIGNED_SHORT_5_5_5_1(): GLenum;
	get UNSIGNED_SHORT_5_6_5(): GLenum;
	get VALIDATE_STATUS(): GLenum;
	get VENDOR(): GLenum;
	get VERSION(): GLenum;
	get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum;
	get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum;
	get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum;
	get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum;
	get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum;
	get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum;
	get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum;
	get VERTEX_SHADER(): GLenum;
	get VIEWPORT(): GLenum;
	get ZERO(): GLenum;
}

export external public interface ~WebGLRenderingContextOverloads {
	bufferData(...args: any+): any+; // overloading not supported
	bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource): void;
	compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void;
	compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void;
	readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView): void;
	texImage2D(...args: any+): any+; // overloading not supported
	texSubImage2D(...args: any+): any+; // overloading not supported
	uniform1fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform1iv(location: WebGLUniformLocation, v: Int32List): void;
	uniform2fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform2iv(location: WebGLUniformLocation, v: Int32List): void;
	uniform3fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform3iv(location: WebGLUniformLocation, v: Int32List): void;
	uniform4fv(location: WebGLUniformLocation, v: Float32List): void;
	uniform4iv(location: WebGLUniformLocation, v: Int32List): void;
	uniformMatrix2fv(location: WebGLUniformLocation, transpose: GLboolean, value: Float32List): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: GLboolean, value: Float32List): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: GLboolean, value: Float32List): void;
}

export external public interface ~WebGLSampler {}

var WebGLSampler: ~Object with { constructor(); };

export external public interface ~WebGLShader {}

var WebGLShader: ~Object with { constructor(); };

export external public interface ~WebGLShaderPrecisionFormat {
	get precision(): GLint;
	get rangeMax(): GLint;
	get rangeMin(): GLint;
}

var WebGLShaderPrecisionFormat: ~Object with { constructor(); };

export external public interface ~WebGLSync {}

var WebGLSync: ~Object with { constructor(); };

export external public interface ~WebGLTexture {}

var WebGLTexture: ~Object with { constructor(); };

export external public interface ~WebGLTransformFeedback {}

var WebGLTransformFeedback: ~Object with { constructor(); };

export external public interface ~WebGLUniformLocation {}

var WebGLUniformLocation: ~Object with { constructor(); };

export external public interface ~WebGLVertexArrayObject {}

var WebGLVertexArrayObject: ~Object with { constructor(); };

export external public interface ~WebGLVertexArrayObjectOES {}

export external public interface ~WebSocketEventMap {
	close: CloseEvent;
	error: Event;
	message: MessageEvent;
	open: Event;
}

export external public interface ~WebSocket extends EventTarget {
	binaryType: BinaryType;
	get bufferedAmount(): number;
	get extensions(): string;
	onclose: ({@This(WebSocket) function(ev: CloseEvent): any});
	onerror: ({@This(WebSocket) function(ev: Event): any});
	onmessage: ({@This(WebSocket) function(ev: MessageEvent): any});
	onopen: ({@This(WebSocket) function(ev: Event): any});
	get protocol(): string;
	get readyState(): number;
	get url(): string;
	close(code: number = , reason: string = ): void;
	send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;
	get CLOSED(): number;
	get CLOSING(): number;
	get CONNECTING(): number;
	get OPEN(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var WebSocket: ~Object with { constructor(url: string | URL, protocols: string | Array<string> = ); get CLOSED(): number; get CLOSING(): number; get CONNECTING(): number; get OPEN(): number; };

export external public interface ~WheelEvent extends MouseEvent {
	get deltaMode(): number;
	get deltaX(): number;
	get deltaY(): number;
	get deltaZ(): number;
	get DOM_DELTA_LINE(): number;
	get DOM_DELTA_PAGE(): number;
	get DOM_DELTA_PIXEL(): number;
}

var WheelEvent: ~Object with { constructor(type: string, eventInitDict: WheelEventInit = ); get DOM_DELTA_LINE(): number; get DOM_DELTA_PAGE(): number; get DOM_DELTA_PIXEL(): number; };

export external public interface ~WindowEventMap extends GlobalEventHandlersEventMap, WindowEventHandlersEventMap {
	devicemotion: DeviceMotionEvent;
	deviceorientation: DeviceOrientationEvent;
	@Override
	gamepadconnected: GamepadEvent;
	@Override
	gamepaddisconnected: GamepadEvent;
	orientationchange: Event;
}

export external public interface ~Window extends EventTarget, AnimationFrameProvider, GlobalEventHandlers, WindowEventHandlers, WindowLocalStorage, WindowOrWorkerGlobalScope, WindowSessionStorage {
	get clientInformation(): Navigator;
	get closed(): boolean;
	get customElements(): CustomElementRegistry;
	get devicePixelRatio(): number;
	get document(): Document;
	get event(): Event;
	get external(): External;
	get frameElement(): Element;
	get frames(): WindowProxy;
	get history(): History;
	get innerHeight(): number;
	get innerWidth(): number;
	get length(): number;
	get location(): Location;
	get locationbar(): BarProp;
	get menubar(): BarProp;
	name: string;
	get navigator(): Navigator;
	ondevicemotion: ({@This(Window) function(ev: DeviceMotionEvent): any});
	ondeviceorientation: ({@This(Window) function(ev: DeviceOrientationEvent): any});
	onorientationchange: ({@This(Window) function(ev: Event): any});
	opener: any;
	get orientation(): number;
	get outerHeight(): number;
	get outerWidth(): number;
	get pageXOffset(): number;
	get pageYOffset(): number;
	get parent(): WindowProxy;
	get personalbar(): BarProp;
	get screen(): Screen;
	get screenLeft(): number;
	get screenTop(): number;
	get screenX(): number;
	get screenY(): number;
	get scrollX(): number;
	get scrollY(): number;
	get scrollbars(): BarProp;
	get self(): Window & any+;
	get speechSynthesis(): SpeechSynthesis;
	status: string;
	get statusbar(): BarProp;
	get toolbar(): BarProp;
	get top(): WindowProxy;
	get visualViewport(): VisualViewport;
	get window(): Window & any+;
	alert(message: any = ): void;
	blur(): void;
	cancelIdleCallback(handle: number): void;
	captureEvents(): void;
	close(): void;
	confirm(message: string = ): boolean;
	focus(): void;
	getComputedStyle(elt: Element, pseudoElt: string = ): CSSStyleDeclaration;
	getSelection(): Selection;
	matchMedia(query: string): MediaQueryList;
	moveBy(x: number, y: number): void;
	moveTo(x: number, y: number): void;
	open(url: string | URL = , target: string = , features: string = ): WindowProxy;
	postMessage(...args: any+): any+; // overloading not supported
	print(): void;
	prompt(message: string = , _default: string = ): string;
	releaseEvents(): void;
	requestIdleCallback(callback: IdleRequestCallback, options: IdleRequestOptions = ): number;
	resizeBy(x: number, y: number): void;
	resizeTo(width: number, height: number): void;
	scroll(...args: any+): any+; // overloading not supported
	scrollBy(...args: any+): any+; // overloading not supported
	scrollTo(...args: any+): any+; // overloading not supported
	stop(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var Window: ~Object with { constructor(); };

export external public interface ~WindowEventHandlersEventMap {
	afterprint: Event;
	beforeprint: Event;
	beforeunload: BeforeUnloadEvent;
	gamepadconnected: GamepadEvent;
	gamepaddisconnected: GamepadEvent;
	hashchange: HashChangeEvent;
	languagechange: Event;
	message: MessageEvent;
	messageerror: MessageEvent;
	offline: Event;
	online: Event;
	pagehide: PageTransitionEvent;
	pageshow: PageTransitionEvent;
	popstate: PopStateEvent;
	rejectionhandled: PromiseRejectionEvent;
	storage: StorageEvent;
	unhandledrejection: PromiseRejectionEvent;
	unload: Event;
}

export external public interface ~WindowEventHandlers {
	onafterprint: ({@This(WindowEventHandlers) function(ev: Event): any});
	onbeforeprint: ({@This(WindowEventHandlers) function(ev: Event): any});
	onbeforeunload: ({@This(WindowEventHandlers) function(ev: BeforeUnloadEvent): any});
	ongamepadconnected: ({@This(WindowEventHandlers) function(ev: GamepadEvent): any});
	ongamepaddisconnected: ({@This(WindowEventHandlers) function(ev: GamepadEvent): any});
	onhashchange: ({@This(WindowEventHandlers) function(ev: HashChangeEvent): any});
	onlanguagechange: ({@This(WindowEventHandlers) function(ev: Event): any});
	onmessage: ({@This(WindowEventHandlers) function(ev: MessageEvent): any});
	onmessageerror: ({@This(WindowEventHandlers) function(ev: MessageEvent): any});
	onoffline: ({@This(WindowEventHandlers) function(ev: Event): any});
	ononline: ({@This(WindowEventHandlers) function(ev: Event): any});
	onpagehide: ({@This(WindowEventHandlers) function(ev: PageTransitionEvent): any});
	onpageshow: ({@This(WindowEventHandlers) function(ev: PageTransitionEvent): any});
	onpopstate: ({@This(WindowEventHandlers) function(ev: PopStateEvent): any});
	onrejectionhandled: ({@This(WindowEventHandlers) function(ev: PromiseRejectionEvent): any});
	onstorage: ({@This(WindowEventHandlers) function(ev: StorageEvent): any});
	onunhandledrejection: ({@This(WindowEventHandlers) function(ev: PromiseRejectionEvent): any});
	onunload: ({@This(WindowEventHandlers) function(ev: Event): any});
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

export external public interface ~WindowLocalStorage {
	get localStorage(): Storage;
}

export external public interface ~WindowOrWorkerGlobalScope {
	get caches(): CacheStorage;
	get crossOriginIsolated(): boolean;
	get crypto(): Crypto;
	get indexedDB(): IDBFactory;
	get isSecureContext(): boolean;
	get origin(): string;
	get performance(): Performance;
	atob(data: string): string;
	btoa(data: string): string;
	clearInterval(handle: number = ): void;
	clearTimeout(handle: number = ): void;
	createImageBitmap(...args: any+): any+; // overloading not supported
	fetch(input: RequestInfo, init: RequestInit = ): Promise<Response>;
	queueMicrotask(callback: VoidFunction): void;
	setInterval(handler: TimerHandler, timeout: number = , ...arguments: any): number;
	setTimeout(handler: TimerHandler, timeout: number = , ...arguments: any): number;
}

export external public interface ~WindowSessionStorage {
	get sessionStorage(): Storage;
}

export external public interface ~WorkerEventMap extends AbstractWorkerEventMap {
	message: MessageEvent;
	messageerror: MessageEvent;
}

export external public interface ~Worker extends EventTarget, AbstractWorker {
	onmessage: ({@This(Worker) function(ev: MessageEvent): any});
	onmessageerror: ({@This(Worker) function(ev: MessageEvent): any});
	postMessage(...args: any+): any+; // overloading not supported
	terminate(): void;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var Worker: ~Object with { constructor(scriptURL: string | URL, options: WorkerOptions = ); };

export external public interface ~Worklet {
	addModule(moduleURL: string | URL, options: WorkletOptions = ): Promise<undefined>;
}

var Worklet: ~Object with { constructor(); };

export external public interface ~WritableStream<W=any> {
	get locked(): boolean;
	abort(reason: any = ): Promise<undefined>;
	close(): Promise<undefined>;
	getWriter(): WritableStreamDefaultWriter<W>;
}

var WritableStream: ~Object with { constructor(underlyingSink: UnderlyingSink<W> = , strategy: QueuingStrategy<W> = ); };

export external public interface ~WritableStreamDefaultController {
	error(e: any = ): void;
}

var WritableStreamDefaultController: ~Object with { constructor(); };

export external public interface ~WritableStreamDefaultWriter<W=any> {
	get closed(): Promise<undefined>;
	get desiredSize(): number;
	get ready(): Promise<undefined>;
	abort(reason: any = ): Promise<undefined>;
	close(): Promise<undefined>;
	releaseLock(): void;
	write(chunk: W = ): Promise<undefined>;
}

var WritableStreamDefaultWriter: ~Object with { constructor(stream: WritableStream<W>); };

export external public interface ~XMLDocument extends Document {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var XMLDocument: ~Object with { constructor(); };

export external public interface ~XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {
	readystatechange: Event;
}

export external public interface ~XMLHttpRequest extends XMLHttpRequestEventTarget {
	onreadystatechange: ({@This(XMLHttpRequest) function(ev: Event): any});
	get readyState(): number;
	get response(): any;
	get responseText(): string;
	responseType: XMLHttpRequestResponseType;
	get responseURL(): string;
	get responseXML(): Document;
	get status(): number;
	get statusText(): string;
	timeout: number;
	get upload(): XMLHttpRequestUpload;
	withCredentials: boolean;
	abort(): void;
	getAllResponseHeaders(): string;
	getResponseHeader(name: string): string;
	open(...args: any+): any+; // overloading not supported
	overrideMimeType(mime: string): void;
	send(body: Document | XMLHttpRequestBodyInit = ): void;
	setRequestHeader(name: string, value: string): void;
	get DONE(): number;
	get HEADERS_RECEIVED(): number;
	get LOADING(): number;
	get OPENED(): number;
	get UNSENT(): number;
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var XMLHttpRequest: ~Object with { constructor(); get DONE(): number; get HEADERS_RECEIVED(): number; get LOADING(): number; get OPENED(): number; get UNSENT(): number; };

export external public interface ~XMLHttpRequestEventTargetEventMap {
	abort: ProgressEvent<XMLHttpRequestEventTarget>;
	error: ProgressEvent<XMLHttpRequestEventTarget>;
	load: ProgressEvent<XMLHttpRequestEventTarget>;
	loadend: ProgressEvent<XMLHttpRequestEventTarget>;
	loadstart: ProgressEvent<XMLHttpRequestEventTarget>;
	progress: ProgressEvent<XMLHttpRequestEventTarget>;
	timeout: ProgressEvent<XMLHttpRequestEventTarget>;
}

export external public interface ~XMLHttpRequestEventTarget extends EventTarget {
	onabort: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	onerror: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	onload: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	onloadend: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	onloadstart: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	onprogress: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	ontimeout: ({@This(XMLHttpRequest) function(ev: ProgressEvent): any});
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var XMLHttpRequestEventTarget: ~Object with { constructor(); };

export external public interface ~XMLHttpRequestUpload extends XMLHttpRequestEventTarget {
	@Override
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions = ): void;
	@Override
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options: boolean | EventListenerOptions = ): void;
}

var XMLHttpRequestUpload: ~Object with { constructor(); };

export external public interface ~XMLSerializer {
	serializeToString(root: Node): string;
}

var XMLSerializer: ~Object with { constructor(); };

export external public interface ~XPathEvaluator extends XPathEvaluatorBase {}

var XPathEvaluator: ~Object with { constructor(); };

export external public interface ~XPathEvaluatorBase {
	createExpression(expression: string, resolver: XPathNSResolver = ): XPathExpression;
	createNSResolver(nodeResolver: Node): XPathNSResolver;
	evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver = , type: number = , result: XPathResult = ): XPathResult;
}

export external public interface ~XPathExpression {
	evaluate(contextNode: Node, type: number = , result: XPathResult = ): XPathResult;
}

var XPathExpression: ~Object with { constructor(); };

export external public interface ~XPathResult {
	get booleanValue(): boolean;
	get invalidIteratorState(): boolean;
	get numberValue(): number;
	get resultType(): number;
	get singleNodeValue(): Node;
	get snapshotLength(): number;
	get stringValue(): string;
	iterateNext(): Node;
	snapshotItem(index: number): Node;
	get ANY_TYPE(): number;
	get ANY_UNORDERED_NODE_TYPE(): number;
	get BOOLEAN_TYPE(): number;
	get FIRST_ORDERED_NODE_TYPE(): number;
	get NUMBER_TYPE(): number;
	get ORDERED_NODE_ITERATOR_TYPE(): number;
	get ORDERED_NODE_SNAPSHOT_TYPE(): number;
	get STRING_TYPE(): number;
	get UNORDERED_NODE_ITERATOR_TYPE(): number;
	get UNORDERED_NODE_SNAPSHOT_TYPE(): number;
}

var XPathResult: ~Object with { constructor(); get ANY_TYPE(): number; get ANY_UNORDERED_NODE_TYPE(): number; get BOOLEAN_TYPE(): number; get FIRST_ORDERED_NODE_TYPE(): number; get NUMBER_TYPE(): number; get ORDERED_NODE_ITERATOR_TYPE(): number; get ORDERED_NODE_SNAPSHOT_TYPE(): number; get STRING_TYPE(): number; get UNORDERED_NODE_ITERATOR_TYPE(): number; get UNORDERED_NODE_SNAPSHOT_TYPE(): number; };

export external public interface ~XSLTProcessor {
	clearParameters(): void;
	getParameter(namespaceURI: string, localName: string): any;
	importStylesheet(style: Node): void;
	removeParameter(namespaceURI: string, localName: string): void;
	reset(): void;
	setParameter(namespaceURI: string, localName: string, value: any): void;
	transformToDocument(source: Node): Document;
	transformToFragment(source: Node, output: Document): DocumentFragment;
}

var XSLTProcessor: ~Object with { constructor(); };

export external public interface ~Console {
	assert(condition: boolean = , ...data: any): void;
	clear(): void;
	count(label: string = ): void;
	countReset(label: string = ): void;
	debug(...data: any): void;
	dir(item: any = , options: any = ): void;
	dirxml(...data: any): void;
	error(...data: any): void;
	group(...data: any): void;
	groupCollapsed(...data: any): void;
	groupEnd(): void;
	info(...data: any): void;
	log(...data: any): void;
	table(tabularData: any = , properties: Array<string> = ): void;
	time(label: string = ): void;
	timeEnd(label: string = ): void;
	timeLog(label: string = , ...data: any): void;
	timeStamp(label: string = ): void;
	trace(...data: any): void;
	warn(...data: any): void;
}

var console: Console;

export external public interface ~BlobCallback {
	(blob: Blob): void;
}

export external public interface ~CustomElementConstructor {
	@CovariantConstructor
	constructor(...params: any);
}

export external public interface ~DecodeErrorCallback {
	(error: DOMException): void;
}

export external public interface ~DecodeSuccessCallback {
	(decodedData: AudioBuffer): void;
}

export external public interface ~ErrorCallback {
	(err: DOMException): void;
}

export external public interface ~FileCallback {
	(file: File): void;
}

export external public interface ~FileSystemEntriesCallback {
	(entries: Array<FileSystemEntry>): void;
}

export external public interface ~FileSystemEntryCallback {
	(entry: FileSystemEntry): void;
}

export external public interface ~FrameRequestCallback {
	(time: DOMHighResTimeStamp): void;
}

export external public interface ~FunctionStringCallback {
	(data: string): void;
}

export external public interface ~IdleRequestCallback {
	(deadline: IdleDeadline): void;
}

export external public interface ~IntersectionObserverCallback {
	(entries: Array<IntersectionObserverEntry>, observer: IntersectionObserver): void;
}

export external public interface ~MediaSessionActionHandler {
	(details: MediaSessionActionDetails): void;
}

export external public interface ~MutationCallback {
	(mutations: Array<MutationRecord>, observer: MutationObserver): void;
}

export external public interface ~NotificationPermissionCallback {
	(permission: NotificationPermission): void;
}

export external public interface ~OnBeforeUnloadEventHandlerNonNull {
	(event: Event): string;
}

export external public interface ~OnErrorEventHandlerNonNull {
	(event: Event | string, source: string = , lineno: number = , colno: number = , error: Error = ): any;
}

export external public interface ~PerformanceObserverCallback {
	(entries: PerformanceObserverEntryList, observer: PerformanceObserver): void;
}

export external public interface ~PositionCallback {
	(position: GeolocationPosition): void;
}

export external public interface ~PositionErrorCallback {
	(positionError: GeolocationPositionError): void;
}

export external public interface ~QueuingStrategySize<T=any> {
	(chunk: T = ): number;
}

export external public interface ~RTCPeerConnectionErrorCallback {
	(error: DOMException): void;
}

export external public interface ~RTCSessionDescriptionCallback {
	(description: RTCSessionDescriptionInit): void;
}

export external public interface ~RemotePlaybackAvailabilityCallback {
	(available: boolean): void;
}

export external public interface ~ResizeObserverCallback {
	(entries: Array<ResizeObserverEntry>, observer: ResizeObserver): void;
}

export external public interface ~TransformerFlushCallback<O> {
	(controller: TransformStreamDefaultController<O>): PromiseLike<undefined>;
}

export external public interface ~TransformerStartCallback<O> {
	(controller: TransformStreamDefaultController<O>): any;
}

export external public interface ~TransformerTransformCallback<I,O> {
	(chunk: I, controller: TransformStreamDefaultController<O>): PromiseLike<undefined>;
}

export external public interface ~UnderlyingSinkAbortCallback {
	(reason: any = ): PromiseLike<undefined>;
}

export external public interface ~UnderlyingSinkCloseCallback {
	(): PromiseLike<undefined>;
}

export external public interface ~UnderlyingSinkStartCallback {
	(controller: WritableStreamDefaultController): any;
}

export external public interface ~UnderlyingSinkWriteCallback<W> {
	(chunk: W, controller: WritableStreamDefaultController): PromiseLike<undefined>;
}

export external public interface ~UnderlyingSourceCancelCallback {
	(reason: any = ): PromiseLike<undefined>;
}

export external public interface ~UnderlyingSourcePullCallback<R> {
	(controller: ReadableStreamController<R>): PromiseLike<undefined>;
}

export external public interface ~UnderlyingSourceStartCallback<R> {
	(controller: ReadableStreamController<R>): any;
}

export external public interface ~VoidFunction {
	(): void;
}

export external public interface ~HTMLElementTagNameMap {
	a: HTMLAnchorElement;
	abbr: HTMLElement;
	address: HTMLElement;
	area: HTMLAreaElement;
	article: HTMLElement;
	aside: HTMLElement;
	audio: HTMLAudioElement;
	b: HTMLElement;
	base: HTMLBaseElement;
	bdi: HTMLElement;
	bdo: HTMLElement;
	blockquote: HTMLQuoteElement;
	body: HTMLBodyElement;
	br: HTMLBRElement;
	button: HTMLButtonElement;
	canvas: HTMLCanvasElement;
	caption: HTMLTableCaptionElement;
	cite: HTMLElement;
	code: HTMLElement;
	col: HTMLTableColElement;
	colgroup: HTMLTableColElement;
	data: HTMLDataElement;
	datalist: HTMLDataListElement;
	dd: HTMLElement;
	del: HTMLModElement;
	details: HTMLDetailsElement;
	dfn: HTMLElement;
	dialog: HTMLDialogElement;
	dir: HTMLDirectoryElement;
	div: HTMLDivElement;
	dl: HTMLDListElement;
	dt: HTMLElement;
	em: HTMLElement;
	embed: HTMLEmbedElement;
	fieldset: HTMLFieldSetElement;
	figcaption: HTMLElement;
	figure: HTMLElement;
	font: HTMLFontElement;
	footer: HTMLElement;
	form: HTMLFormElement;
	frame: HTMLFrameElement;
	frameset: HTMLFrameSetElement;
	h1: HTMLHeadingElement;
	h2: HTMLHeadingElement;
	h3: HTMLHeadingElement;
	h4: HTMLHeadingElement;
	h5: HTMLHeadingElement;
	h6: HTMLHeadingElement;
	head: HTMLHeadElement;
	header: HTMLElement;
	hgroup: HTMLElement;
	hr: HTMLHRElement;
	html: HTMLHtmlElement;
	i: HTMLElement;
	iframe: HTMLIFrameElement;
	img: HTMLImageElement;
	input: HTMLInputElement;
	ins: HTMLModElement;
	kbd: HTMLElement;
	label: HTMLLabelElement;
	legend: HTMLLegendElement;
	li: HTMLLIElement;
	link: HTMLLinkElement;
	main: HTMLElement;
	map: HTMLMapElement;
	mark: HTMLElement;
	marquee: HTMLMarqueeElement;
	menu: HTMLMenuElement;
	meta: HTMLMetaElement;
	meter: HTMLMeterElement;
	nav: HTMLElement;
	noscript: HTMLElement;
	object: HTMLObjectElement;
	ol: HTMLOListElement;
	optgroup: HTMLOptGroupElement;
	option: HTMLOptionElement;
	output: HTMLOutputElement;
	p: HTMLParagraphElement;
	param: HTMLParamElement;
	picture: HTMLPictureElement;
	pre: HTMLPreElement;
	progress: HTMLProgressElement;
	q: HTMLQuoteElement;
	rp: HTMLElement;
	rt: HTMLElement;
	ruby: HTMLElement;
	s: HTMLElement;
	samp: HTMLElement;
	script: HTMLScriptElement;
	section: HTMLElement;
	select: HTMLSelectElement;
	slot: HTMLSlotElement;
	small: HTMLElement;
	source: HTMLSourceElement;
	span: HTMLSpanElement;
	strong: HTMLElement;
	style: HTMLStyleElement;
	sub: HTMLElement;
	summary: HTMLElement;
	sup: HTMLElement;
	table: HTMLTableElement;
	tbody: HTMLTableSectionElement;
	td: HTMLTableCellElement;
	template: HTMLTemplateElement;
	textarea: HTMLTextAreaElement;
	tfoot: HTMLTableSectionElement;
	th: HTMLTableCellElement;
	thead: HTMLTableSectionElement;
	time: HTMLTimeElement;
	title: HTMLTitleElement;
	tr: HTMLTableRowElement;
	track: HTMLTrackElement;
	u: HTMLElement;
	ul: HTMLUListElement;
	var: HTMLElement;
	video: HTMLVideoElement;
	wbr: HTMLElement;
}

export external public interface ~HTMLElementDeprecatedTagNameMap {
	listing: HTMLPreElement;
	xmp: HTMLPreElement;
}

export external public interface ~SVGElementTagNameMap {
	a: SVGAElement;
	animate: SVGAnimateElement;
	animateMotion: SVGAnimateMotionElement;
	animateTransform: SVGAnimateTransformElement;
	circle: SVGCircleElement;
	clipPath: SVGClipPathElement;
	defs: SVGDefsElement;
	desc: SVGDescElement;
	ellipse: SVGEllipseElement;
	feBlend: SVGFEBlendElement;
	feColorMatrix: SVGFEColorMatrixElement;
	feComponentTransfer: SVGFEComponentTransferElement;
	feComposite: SVGFECompositeElement;
	feConvolveMatrix: SVGFEConvolveMatrixElement;
	feDiffuseLighting: SVGFEDiffuseLightingElement;
	feDisplacementMap: SVGFEDisplacementMapElement;
	feDistantLight: SVGFEDistantLightElement;
	feDropShadow: SVGFEDropShadowElement;
	feFlood: SVGFEFloodElement;
	feFuncA: SVGFEFuncAElement;
	feFuncB: SVGFEFuncBElement;
	feFuncG: SVGFEFuncGElement;
	feFuncR: SVGFEFuncRElement;
	feGaussianBlur: SVGFEGaussianBlurElement;
	feImage: SVGFEImageElement;
	feMerge: SVGFEMergeElement;
	feMergeNode: SVGFEMergeNodeElement;
	feMorphology: SVGFEMorphologyElement;
	feOffset: SVGFEOffsetElement;
	fePointLight: SVGFEPointLightElement;
	feSpecularLighting: SVGFESpecularLightingElement;
	feSpotLight: SVGFESpotLightElement;
	feTile: SVGFETileElement;
	feTurbulence: SVGFETurbulenceElement;
	filter: SVGFilterElement;
	foreignObject: SVGForeignObjectElement;
	g: SVGGElement;
	image: SVGImageElement;
	line: SVGLineElement;
	linearGradient: SVGLinearGradientElement;
	marker: SVGMarkerElement;
	mask: SVGMaskElement;
	metadata: SVGMetadataElement;
	mpath: SVGMPathElement;
	path: SVGPathElement;
	pattern: SVGPatternElement;
	polygon: SVGPolygonElement;
	polyline: SVGPolylineElement;
	radialGradient: SVGRadialGradientElement;
	rect: SVGRectElement;
	script: SVGScriptElement;
	set: SVGSetElement;
	stop: SVGStopElement;
	style: SVGStyleElement;
	svg: SVGSVGElement;
	switch: SVGSwitchElement;
	symbol: SVGSymbolElement;
	text: SVGTextElement;
	textPath: SVGTextPathElement;
	title: SVGTitleElement;
	tspan: SVGTSpanElement;
	use: SVGUseElement;
	view: SVGViewElement;
}

export external public type ElementTagNameMap = HTMLElementTagNameMap & Pick<SVGElementTagNameMap,Exclude<SVGElementTagNameMap,HTMLElementTagNameMap>>;

var Audio: ~Object with { constructor(src: string = ); };

var Image: ~Object with { constructor(width: number = , height: number = ); };

var Option: ~Object with { constructor(text: string = , value: string = , defaultSelected: boolean = , selected: boolean = ); };

var clientInformation: Navigator;

var closed: boolean;

var customElements: CustomElementRegistry;

var devicePixelRatio: number;

var document: Document;

var event: Event;

var external: External;

var frameElement: Element;

var frames: WindowProxy;

var history: History;

var innerHeight: number;

var innerWidth: number;

var length: number;

var location: Location;

var locationbar: BarProp;

var menubar: BarProp;

const name: undefined;

var navigator: Navigator;

var ondevicemotion: ({@This(Window) function(ev: DeviceMotionEvent): any});

var ondeviceorientation: ({@This(Window) function(ev: DeviceOrientationEvent): any});

var onorientationchange: ({@This(Window) function(ev: Event): any});

var opener: any;

var orientation: number;

var outerHeight: number;

var outerWidth: number;

var pageXOffset: number;

var pageYOffset: number;

var parent: WindowProxy;

var personalbar: BarProp;

var screen: Screen;

var screenLeft: number;

var screenTop: number;

var screenX: number;

var screenY: number;

var scrollX: number;

var scrollY: number;

var scrollbars: BarProp;

var self: Window & any+;

var speechSynthesis: SpeechSynthesis;

var status: string;

var statusbar: BarProp;

var toolbar: BarProp;

var top: WindowProxy;

var visualViewport: VisualViewport;

var window: Window & any+;

export external public function alert(message: any = ): void;

export external public function blur(): void;

export external public function cancelIdleCallback(handle: number): void;

export external public function captureEvents(): void;

export external public function close(): void;

export external public function confirm(message: string = ): boolean;

export external public function focus(): void;

export external public function getComputedStyle(elt: Element, pseudoElt: string = ): CSSStyleDeclaration;

export external public function getSelection(): Selection;

export external public function matchMedia(query: string): MediaQueryList;

export external public function moveBy(x: number, y: number): void;

export external public function moveTo(x: number, y: number): void;

export external public function open(url: string | URL = , target: string = , features: string = ): WindowProxy;

export external public function postMessage(...args: any+): any+; // overloading not supported

export external public function print(): void;

export external public function prompt(message: string = , _default: string = ): string;

export external public function releaseEvents(): void;

export external public function requestIdleCallback(callback: IdleRequestCallback, options: IdleRequestOptions = ): number;

export external public function resizeBy(x: number, y: number): void;

export external public function resizeTo(width: number, height: number): void;

export external public function scroll(...args: any+): any+; // overloading not supported

export external public function scrollBy(...args: any+): any+; // overloading not supported

export external public function scrollTo(...args: any+): any+; // overloading not supported

export external public function stop(): void;

export external public function toString(): string;

export external public function dispatchEvent(event: Event): boolean;

export external public function cancelAnimationFrame(handle: number): void;

export external public function requestAnimationFrame(callback: FrameRequestCallback): number;

var onabort: ({@This(Window) function(ev: UIEvent): any});

var onanimationcancel: ({@This(Window) function(ev: AnimationEvent): any});

var onanimationend: ({@This(Window) function(ev: AnimationEvent): any});

var onanimationiteration: ({@This(Window) function(ev: AnimationEvent): any});

var onanimationstart: ({@This(Window) function(ev: AnimationEvent): any});

var onauxclick: ({@This(Window) function(ev: MouseEvent): any});

var onblur: ({@This(Window) function(ev: FocusEvent): any});

var oncanplay: ({@This(Window) function(ev: Event): any});

var oncanplaythrough: ({@This(Window) function(ev: Event): any});

var onchange: ({@This(Window) function(ev: Event): any});

var onclick: ({@This(Window) function(ev: MouseEvent): any});

var onclose: ({@This(Window) function(ev: Event): any});

var oncontextmenu: ({@This(Window) function(ev: MouseEvent): any});

var oncuechange: ({@This(Window) function(ev: Event): any});

var ondblclick: ({@This(Window) function(ev: MouseEvent): any});

var ondrag: ({@This(Window) function(ev: DragEvent): any});

var ondragend: ({@This(Window) function(ev: DragEvent): any});

var ondragenter: ({@This(Window) function(ev: DragEvent): any});

var ondragleave: ({@This(Window) function(ev: DragEvent): any});

var ondragover: ({@This(Window) function(ev: DragEvent): any});

var ondragstart: ({@This(Window) function(ev: DragEvent): any});

var ondrop: ({@This(Window) function(ev: DragEvent): any});

var ondurationchange: ({@This(Window) function(ev: Event): any});

var onemptied: ({@This(Window) function(ev: Event): any});

var onended: ({@This(Window) function(ev: Event): any});

var onerror: OnErrorEventHandler;

var onfocus: ({@This(Window) function(ev: FocusEvent): any});

var onformdata: ({@This(Window) function(ev: FormDataEvent): any});

var ongotpointercapture: ({@This(Window) function(ev: PointerEvent): any});

var oninput: ({@This(Window) function(ev: Event): any});

var oninvalid: ({@This(Window) function(ev: Event): any});

var onkeydown: ({@This(Window) function(ev: KeyboardEvent): any});

var onkeypress: ({@This(Window) function(ev: KeyboardEvent): any});

var onkeyup: ({@This(Window) function(ev: KeyboardEvent): any});

var onload: ({@This(Window) function(ev: Event): any});

var onloadeddata: ({@This(Window) function(ev: Event): any});

var onloadedmetadata: ({@This(Window) function(ev: Event): any});

var onloadstart: ({@This(Window) function(ev: Event): any});

var onlostpointercapture: ({@This(Window) function(ev: PointerEvent): any});

var onmousedown: ({@This(Window) function(ev: MouseEvent): any});

var onmouseenter: ({@This(Window) function(ev: MouseEvent): any});

var onmouseleave: ({@This(Window) function(ev: MouseEvent): any});

var onmousemove: ({@This(Window) function(ev: MouseEvent): any});

var onmouseout: ({@This(Window) function(ev: MouseEvent): any});

var onmouseover: ({@This(Window) function(ev: MouseEvent): any});

var onmouseup: ({@This(Window) function(ev: MouseEvent): any});

var onpause: ({@This(Window) function(ev: Event): any});

var onplay: ({@This(Window) function(ev: Event): any});

var onplaying: ({@This(Window) function(ev: Event): any});

var onpointercancel: ({@This(Window) function(ev: PointerEvent): any});

var onpointerdown: ({@This(Window) function(ev: PointerEvent): any});

var onpointerenter: ({@This(Window) function(ev: PointerEvent): any});

var onpointerleave: ({@This(Window) function(ev: PointerEvent): any});

var onpointermove: ({@This(Window) function(ev: PointerEvent): any});

var onpointerout: ({@This(Window) function(ev: PointerEvent): any});

var onpointerover: ({@This(Window) function(ev: PointerEvent): any});

var onpointerup: ({@This(Window) function(ev: PointerEvent): any});

var onprogress: ({@This(Window) function(ev: ProgressEvent): any});

var onratechange: ({@This(Window) function(ev: Event): any});

var onreset: ({@This(Window) function(ev: Event): any});

var onresize: ({@This(Window) function(ev: UIEvent): any});

var onscroll: ({@This(Window) function(ev: Event): any});

var onseeked: ({@This(Window) function(ev: Event): any});

var onseeking: ({@This(Window) function(ev: Event): any});

var onselect: ({@This(Window) function(ev: Event): any});

var onselectionchange: ({@This(Window) function(ev: Event): any});

var onselectstart: ({@This(Window) function(ev: Event): any});

var onstalled: ({@This(Window) function(ev: Event): any});

var onsubmit: ({@This(Window) function(ev: SubmitEvent): any});

var onsuspend: ({@This(Window) function(ev: Event): any});

var ontimeupdate: ({@This(Window) function(ev: Event): any});

var ontoggle: ({@This(Window) function(ev: Event): any});

var ontouchcancel: ({@This(Window) function(ev: TouchEvent): any});

var ontouchend: ({@This(Window) function(ev: TouchEvent): any});

var ontouchmove: ({@This(Window) function(ev: TouchEvent): any});

var ontouchstart: ({@This(Window) function(ev: TouchEvent): any});

var ontransitioncancel: ({@This(Window) function(ev: TransitionEvent): any});

var ontransitionend: ({@This(Window) function(ev: TransitionEvent): any});

var ontransitionrun: ({@This(Window) function(ev: TransitionEvent): any});

var ontransitionstart: ({@This(Window) function(ev: TransitionEvent): any});

var onvolumechange: ({@This(Window) function(ev: Event): any});

var onwaiting: ({@This(Window) function(ev: Event): any});

var onwebkitanimationend: ({@This(Window) function(ev: Event): any});

var onwebkitanimationiteration: ({@This(Window) function(ev: Event): any});

var onwebkitanimationstart: ({@This(Window) function(ev: Event): any});

var onwebkittransitionend: ({@This(Window) function(ev: Event): any});

var onwheel: ({@This(Window) function(ev: WheelEvent): any});

var onafterprint: ({@This(Window) function(ev: Event): any});

var onbeforeprint: ({@This(Window) function(ev: Event): any});

var onbeforeunload: ({@This(Window) function(ev: BeforeUnloadEvent): any});

var ongamepadconnected: ({@This(Window) function(ev: GamepadEvent): any});

var ongamepaddisconnected: ({@This(Window) function(ev: GamepadEvent): any});

var onhashchange: ({@This(Window) function(ev: HashChangeEvent): any});

var onlanguagechange: ({@This(Window) function(ev: Event): any});

var onmessage: ({@This(Window) function(ev: MessageEvent): any});

var onmessageerror: ({@This(Window) function(ev: MessageEvent): any});

var onoffline: ({@This(Window) function(ev: Event): any});

var ononline: ({@This(Window) function(ev: Event): any});

var onpagehide: ({@This(Window) function(ev: PageTransitionEvent): any});

var onpageshow: ({@This(Window) function(ev: PageTransitionEvent): any});

var onpopstate: ({@This(Window) function(ev: PopStateEvent): any});

var onrejectionhandled: ({@This(Window) function(ev: PromiseRejectionEvent): any});

var onstorage: ({@This(Window) function(ev: StorageEvent): any});

var onunhandledrejection: ({@This(Window) function(ev: PromiseRejectionEvent): any});

var onunload: ({@This(Window) function(ev: Event): any});

var localStorage: Storage;

var caches: CacheStorage;

var crossOriginIsolated: boolean;

var crypto: Crypto;

var indexedDB: IDBFactory;

var isSecureContext: boolean;

var origin: string;

var performance: Performance;

export external public function atob(data: string): string;

export external public function btoa(data: string): string;

export external public function clearInterval(handle: number = ): void;

export external public function clearTimeout(handle: number = ): void;

export external public function createImageBitmap(...args: any+): any+; // overloading not supported

export external public function fetch(input: RequestInfo, init: RequestInit = ): Promise<Response>;

export external public function queueMicrotask(callback: VoidFunction): void;

export external public function setInterval(handler: TimerHandler, timeout: number = , ...arguments: any): number;

export external public function setTimeout(handler: TimerHandler, timeout: number = , ...arguments: any): number;

var sessionStorage: Storage;

export external public function addEventListener(...args: any+): any+; // overloading not supported

export external public function removeEventListener(...args: any+): any+; // overloading not supported

export external public type AlgorithmIdentifier = Algorithm | string;

export external public type BigInteger = Uint8Array;

export external public type BinaryData = ArrayBuffer | ArrayBufferView;

export external public type BlobPart = BufferSource | Blob | string;

export external public type BodyInit = ReadableStream | XMLHttpRequestBodyInit;

export external public type BufferSource = ArrayBufferView | ArrayBuffer;

export external public type COSEAlgorithmIdentifier = number;

export external public type CSSNumberish = number;

export external public type CanvasImageSource = HTMLOrSVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap;

export external public type ClipboardItemData = Promise<ClipboardItemDataType>;

export external public type ClipboardItemDataType = string | Blob;

export external public type ClipboardItems = Array<ClipboardItem>;

export external public type ConstrainBoolean = boolean | ConstrainBooleanParameters;

export external public type ConstrainDOMString = string | Array<string> | ConstrainDOMStringParameters;

export external public type ConstrainDouble = number | ConstrainDoubleRange;

export external public type ConstrainULong = number | ConstrainULongRange;

export external public type DOMHighResTimeStamp = number;

export external public type DOMTimeStamp = number;

export external public type EventListenerOrEventListenerObject = EventListener | EventListenerObject;

export external public type Float32List = Float32Array | Array<GLfloat>;

export external public type FormDataEntryValue = File | string;

export external public type GLbitfield = number;

export external public type GLboolean = boolean;

export external public type GLclampf = number;

export external public type GLenum = number;

export external public type GLfloat = number;

export external public type GLint = number;

export external public type GLint64 = number;

export external public type GLintptr = number;

export external public type GLsizei = number;

export external public type GLsizeiptr = number;

export external public type GLuint = number;

export external public type GLuint64 = number;

export external public type HTMLOrSVGImageElement = HTMLImageElement | SVGImageElement;

export external public type HTMLOrSVGScriptElement = HTMLScriptElement | SVGScriptElement;

export external public type HashAlgorithmIdentifier = AlgorithmIdentifier;

export external public type HeadersInit = Array<Array<string>> | Record<string,string> | Headers;

export external public type IDBValidKey = number | string | Date | BufferSource | Array<IDBValidKey>;

export external public type ImageBitmapSource = CanvasImageSource | Blob | ImageData;

export external public type InsertPosition = "beforebegin" | "afterbegin" | "beforeend" | "afterend";

export external public type Int32List = Int32Array | Array<GLint>;

export external public type LineAndPositionSetting = number | AutoKeyword;

export external public type MediaProvider = MediaStream | MediaSource | Blob;

export external public type MessageEventSource = WindowProxy | MessagePort | ServiceWorker;

export external public type MutationRecordType = "attributes" | "characterData" | "childList";

export external public type NamedCurve = string;

export external public type OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull;

export external public type OnErrorEventHandler = OnErrorEventHandlerNonNull;

export external public type PerformanceEntryList = Array<PerformanceEntry>;

export external public type ReadableStreamController<T> = ReadableStreamDefaultController<T>;

export external public type ReadableStreamDefaultReadResult<T> = ReadableStreamDefaultReadValueResult<T> | ReadableStreamDefaultReadDoneResult;

export external public type ReadableStreamReader<T> = ReadableStreamDefaultReader<T>;

export external public type RenderingContext = CanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext;

export external public type RequestInfo = Request | string;

export external public type TexImageSource = ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;

export external public type TimerHandler = string | Function;

export external public type Transferable = ArrayBuffer | MessagePort | ImageBitmap;

export external public type Uint32List = Uint32Array | Array<GLuint>;

export external public type UvmEntries = Array<UvmEntry>;

export external public type UvmEntry = Array<number>;

export external public type VibratePattern = number | Array<number>;

export external public type WindowProxy = Window;

export external public type XMLHttpRequestBodyInit = Blob | BufferSource | FormData | URLSearchParams | string;

export external public type AlignSetting = "center" | "end" | "left" | "right" | "start";

export external public type AnimationPlayState = "finished" | "idle" | "paused" | "running";

export external public type AnimationReplaceState = "active" | "persisted" | "removed";

export external public type AppendMode = "segments" | "sequence";

export external public type AttestationConveyancePreference = "direct" | "enterprise" | "indirect" | "none";

export external public type AudioContextLatencyCategory = "balanced" | "interactive" | "playback";

export external public type AudioContextState = "closed" | "running" | "suspended";

export external public type AuthenticatorAttachment = "cross-platform" | "platform";

export external public type AuthenticatorTransport = "ble" | "internal" | "nfc" | "usb";

export external public type AutoKeyword = "auto";

export external public type AutomationRate = "a-rate" | "k-rate";

export external public type BinaryType = "arraybuffer" | "blob";

export external public type BiquadFilterType = "allpass" | "bandpass" | "highpass" | "highshelf" | "lowpass" | "lowshelf" | "notch" | "peaking";

export external public type CanPlayTypeResult = "" | "maybe" | "probably";

export external public type CanvasDirection = "inherit" | "ltr" | "rtl";

export external public type CanvasFillRule = "evenodd" | "nonzero";

export external public type CanvasFontKerning = "auto" | "none" | "normal";

export external public type CanvasFontStretch = "condensed" | "expanded" | "extra-condensed" | "extra-expanded" | "normal" | "semi-condensed" | "semi-expanded" | "ultra-condensed" | "ultra-expanded";

export external public type CanvasFontVariantCaps = "all-petite-caps" | "all-small-caps" | "normal" | "petite-caps" | "small-caps" | "titling-caps" | "unicase";

export external public type CanvasLineCap = "butt" | "round" | "square";

export external public type CanvasLineJoin = "bevel" | "miter" | "round";

export external public type CanvasTextAlign = "center" | "end" | "left" | "right" | "start";

export external public type CanvasTextBaseline = "alphabetic" | "bottom" | "hanging" | "ideographic" | "middle" | "top";

export external public type CanvasTextRendering = "auto" | "geometricPrecision" | "optimizeLegibility" | "optimizeSpeed";

export external public type ChannelCountMode = "clamped-max" | "explicit" | "max";

export external public type ChannelInterpretation = "discrete" | "speakers";

export external public type ClientTypes = "all" | "sharedworker" | "window" | "worker";

export external public type ColorGamut = "p3" | "rec2020" | "srgb";

export external public type ColorSpaceConversion = "default" | "none";

export external public type CompositeOperation = "accumulate" | "add" | "replace";

export external public type CompositeOperationOrAuto = "accumulate" | "add" | "auto" | "replace";

export external public type ConnectionType = "bluetooth" | "cellular" | "ethernet" | "mixed" | "none" | "other" | "unknown" | "wifi";

export external public type CredentialMediationRequirement = "optional" | "required" | "silent";

export external public type DOMParserSupportedType = "application/xhtml+xml" | "application/xml" | "image/svg+xml" | "text/html" | "text/xml";

export external public type DirectionSetting = "" | "lr" | "rl";

export external public type DisplayCaptureSurfaceType = "application" | "browser" | "monitor" | "window";

export external public type DistanceModelType = "exponential" | "inverse" | "linear";

export external public type DocumentReadyState = "complete" | "interactive" | "loading";

export external public type EndOfStreamError = "decode" | "network";

export external public type EndingType = "native" | "transparent";

export external public type FillMode = "auto" | "backwards" | "both" | "forwards" | "none";

export external public type FontFaceLoadStatus = "error" | "loaded" | "loading" | "unloaded";

export external public type FontFaceSetLoadStatus = "loaded" | "loading";

export external public type FullscreenNavigationUI = "auto" | "hide" | "show";

export external public type GamepadHapticActuatorType = "vibration";

export external public type GamepadMappingType = "" | "standard" | "xr-standard";

export external public type HdrMetadataType = "smpteSt2086" | "smpteSt2094-10" | "smpteSt2094-40";

export external public type IDBCursorDirection = "next" | "nextunique" | "prev" | "prevunique";

export external public type IDBRequestReadyState = "done" | "pending";

export external public type IDBTransactionMode = "readonly" | "readwrite" | "versionchange";

export external public type ImageOrientation = "flipY" | "none";

export external public type ImageSmoothingQuality = "high" | "low" | "medium";

export external public type IterationCompositeOperation = "accumulate" | "replace";

export external public type KeyFormat = "jwk" | "pkcs8" | "raw" | "spki";

export external public type KeyType = "private" | "public" | "secret";

export external public type KeyUsage = "decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey";

export external public type LineAlignSetting = "center" | "end" | "start";

export external public type MediaDecodingType = "file" | "media-source" | "webrtc";

export external public type MediaDeviceKind = "audioinput" | "audiooutput" | "videoinput";

export external public type MediaEncodingType = "record" | "webrtc";

export external public type MediaKeyMessageType = "individualization-request" | "license-release" | "license-renewal" | "license-request";

export external public type MediaKeySessionClosedReason = "closed-by-application" | "hardware-context-reset" | "internal-error" | "release-acknowledged" | "resource-evicted";

export external public type MediaKeySessionType = "persistent-license" | "temporary";

export external public type MediaKeyStatus = "expired" | "internal-error" | "output-downscaled" | "output-restricted" | "released" | "status-pending" | "usable" | "usable-in-future";

export external public type MediaKeysRequirement = "not-allowed" | "optional" | "required";

export external public type MediaSessionAction = "hangup" | "nexttrack" | "pause" | "play" | "previoustrack" | "seekbackward" | "seekforward" | "seekto" | "skipad" | "stop" | "togglecamera" | "togglemicrophone";

export external public type MediaSessionPlaybackState = "none" | "paused" | "playing";

export external public type MediaStreamTrackState = "ended" | "live";

export external public type NavigationType = "back_forward" | "navigate" | "prerender" | "reload";

export external public type NotificationDirection = "auto" | "ltr" | "rtl";

export external public type NotificationPermission = "default" | "denied" | "granted";

export external public type OrientationLockType = "any" | "landscape" | "landscape-primary" | "landscape-secondary" | "natural" | "portrait" | "portrait-primary" | "portrait-secondary";

export external public type OrientationType = "landscape-primary" | "landscape-secondary" | "portrait-primary" | "portrait-secondary";

export external public type OscillatorType = "custom" | "sawtooth" | "sine" | "square" | "triangle";

export external public type OverSampleType = "2x" | "4x" | "none";

export external public type PanningModelType = "HRTF" | "equalpower";

export external public type PaymentComplete = "fail" | "success" | "unknown";

export external public type PermissionName = "geolocation" | "notifications" | "persistent-storage" | "push" | "screen-wake-lock";

export external public type PermissionState = "denied" | "granted" | "prompt";

export external public type PlaybackDirection = "alternate" | "alternate-reverse" | "normal" | "reverse";

export external public type PositionAlignSetting = "auto" | "center" | "line-left" | "line-right";

export external public type PredefinedColorSpace = "display-p3" | "srgb";

export external public type PremultiplyAlpha = "default" | "none" | "premultiply";

export external public type PresentationStyle = "attachment" | "inline" | "unspecified";

export external public type PublicKeyCredentialType = "public-key";

export external public type PushEncryptionKeyName = "auth" | "p256dh";

export external public type PushPermissionState = "denied" | "granted" | "prompt";

export external public type RTCBundlePolicy = "balanced" | "max-bundle" | "max-compat";

export external public type RTCDataChannelState = "closed" | "closing" | "connecting" | "open";

export external public type RTCDegradationPreference = "balanced" | "maintain-framerate" | "maintain-resolution";

export external public type RTCDtlsTransportState = "closed" | "connected" | "connecting" | "failed" | "new";

export external public type RTCIceCandidateType = "host" | "prflx" | "relay" | "srflx";

export external public type RTCIceComponent = "rtcp" | "rtp";

export external public type RTCIceConnectionState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new";

export external public type RTCIceCredentialType = "password";

export external public type RTCIceGathererState = "complete" | "gathering" | "new";

export external public type RTCIceGatheringState = "complete" | "gathering" | "new";

export external public type RTCIceProtocol = "tcp" | "udp";

export external public type RTCIceTcpCandidateType = "active" | "passive" | "so";

export external public type RTCIceTransportPolicy = "all" | "relay";

export external public type RTCIceTransportState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new";

export external public type RTCPeerConnectionState = "closed" | "connected" | "connecting" | "disconnected" | "failed" | "new";

export external public type RTCPriorityType = "high" | "low" | "medium" | "very-low";

export external public type RTCRtcpMuxPolicy = "require";

export external public type RTCRtpTransceiverDirection = "inactive" | "recvonly" | "sendonly" | "sendrecv" | "stopped";

export external public type RTCSdpType = "answer" | "offer" | "pranswer" | "rollback";

export external public type RTCSignalingState = "closed" | "have-local-offer" | "have-local-pranswer" | "have-remote-offer" | "have-remote-pranswer" | "stable";

export external public type RTCStatsIceCandidatePairState = "failed" | "frozen" | "in-progress" | "inprogress" | "succeeded" | "waiting";

export external public type RTCStatsType = "candidate-pair" | "certificate" | "codec" | "csrc" | "data-channel" | "inbound-rtp" | "local-candidate" | "media-source" | "outbound-rtp" | "peer-connection" | "remote-candidate" | "remote-inbound-rtp" | "remote-outbound-rtp" | "track" | "transport";

export external public type ReadyState = "closed" | "ended" | "open";

export external public type RecordingState = "inactive" | "paused" | "recording";

export external public type ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url";

export external public type RemotePlaybackState = "connected" | "connecting" | "disconnected";

export external public type RequestCache = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload";

export external public type RequestCredentials = "include" | "omit" | "same-origin";

export external public type RequestDestination = "" | "audio" | "audioworklet" | "document" | "embed" | "font" | "frame" | "iframe" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt";

export external public type RequestMode = "cors" | "navigate" | "no-cors" | "same-origin";

export external public type RequestRedirect = "error" | "follow" | "manual";

export external public type ResidentKeyRequirement = "discouraged" | "preferred" | "required";

export external public type ResizeObserverBoxOptions = "border-box" | "content-box" | "device-pixel-content-box";

export external public type ResizeQuality = "high" | "low" | "medium" | "pixelated";

export external public type ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect";

export external public type ScrollBehavior = "auto" | "smooth";

export external public type ScrollLogicalPosition = "center" | "end" | "nearest" | "start";

export external public type ScrollRestoration = "auto" | "manual";

export external public type ScrollSetting = "" | "up";

export external public type SecurityPolicyViolationEventDisposition = "enforce" | "report";

export external public type SelectionMode = "end" | "preserve" | "select" | "start";

export external public type ServiceWorkerState = "activated" | "activating" | "installed" | "installing" | "parsed" | "redundant";

export external public type ServiceWorkerUpdateViaCache = "all" | "imports" | "none";

export external public type ShadowRootMode = "closed" | "open";

export external public type SlotAssignmentMode = "manual" | "named";

export external public type SpeechSynthesisErrorCode = "audio-busy" | "audio-hardware" | "canceled" | "interrupted" | "invalid-argument" | "language-unavailable" | "network" | "not-allowed" | "synthesis-failed" | "synthesis-unavailable" | "text-too-long" | "voice-unavailable";

export external public type TextTrackKind = "captions" | "chapters" | "descriptions" | "metadata" | "subtitles";

export external public type TextTrackMode = "disabled" | "hidden" | "showing";

export external public type TouchType = "direct" | "stylus";

export external public type TransferFunction = "hlg" | "pq" | "srgb";

export external public type UserVerificationRequirement = "discouraged" | "preferred" | "required";

export external public type VideoFacingModeEnum = "environment" | "left" | "right" | "user";

export external public type VisibilityState = "hidden" | "visible";

export external public type WebGLPowerPreference = "default" | "high-performance" | "low-power";

export external public type WorkerType = "classic" | "module";

export external public type XMLHttpRequestResponseType = "" | "arraybuffer" | "blob" | "document" | "json" | "text";
