/*
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */



import {N4Type, N4Classifier, N4Class, N4Interface, N4EnumType, N4Annotation, N4DataField, N4Accessor, N4Method, N4Member} from 'N4BuiltInTypes';


const SYMBOL_IDENTIFIER_PREFIX = "#";



export function makeReflectionsForClass(staticProto: constructor{?}, reflectionString: string): N4Class {
    const reflectionValues = new ReflectionValues(reflectionString);
    const instanceProto = staticProto.prototype;
    const superclass = (staticProto.__proto__ as Object+).n4type as N4Class;
    const n4Class = new N4Class();
    setN4TypeProperties(n4Class, reflectionValues);
    const detectedMemberStrings = detectMembersForClass(instanceProto, staticProto);
    setN4ClassifierProperties(n4Class, superclass, instanceProto, staticProto, detectedMemberStrings, reflectionValues);
    return n4Class;
}

export function makeReflectionsForInterface(staticProto: constructor{?}, reflectionString: string): N4Interface {
    const reflectionValues = new ReflectionValues(reflectionString);
    const n4Interface = new N4Interface();
    setN4TypeProperties(n4Interface, reflectionValues);
    const detectedMemberStrings = detectMembersForInterface(staticProto);
    setN4ClassifierProperties(n4Interface, undefined, {}, {}, detectedMemberStrings, reflectionValues);
    return n4Interface;
}

export function makeReflectionsForEnum(staticProto: constructor{?}, reflectionString: string): N4EnumType {
    const reflectionValues = new ReflectionValues(reflectionString);
    const n4enumType = new N4EnumType();
    setN4TypeProperties(n4enumType, reflectionValues);
    return n4enumType;
}


function $interfaceDefaultFields(obj: any+) : Object {
    return obj.$fieldDefaults as Object;
}

function $interfaceDefaultMethods(obj: any+) : Object {
    return obj.$methodDefaults as Object;
}

function $interfaceExtends(obj: any+) : [] {
    return obj.$extends as [];
}


function setN4TypeProperties(n4Type: N4Type, reflectionValues: ReflectionValues) {
    n4Type.name = reflectionValues.name;
    n4Type.origin = reflectionValues.origin;
    n4Type.setAnnotations(createAnnotations(reflectionValues.annotations));
    n4Type.fqn = reflectionValues.modulePath + '/' + reflectionValues.name;
}

function setN4ClassifierProperties(n4Classifier: N4Classifier, superclass: N4Class, instanceProto: Object, staticProto, detectedMemberStrings:string[], reflectionValues: ReflectionValues) {
    const splitMembers = createMembers(instanceProto, staticProto, reflectionValues.members, reflectionValues.memberAnnotations, detectedMemberStrings);
    n4Classifier.n4superType = superclass;
    n4Classifier.setOwnedMembers(splitMembers.ownedMembers);
    n4Classifier.consumedMembers = splitMembers.consumedMembers;
    n4Classifier.allImplementedInterfaces = reflectionValues.allImplementedInterfaces;
}

function createMembers(instanceProto: Object, staticProto, memberStrings: string[], memberAnnotations: Object, detectedMemberStrings: string[]) : MemberContainer {
    const annotations = createMemberAnnotations(memberAnnotations);
    const ownedMembers : N4Member[] = [];
    const consumedMembers : N4Member[] = [];
    const detectedMemberStringsReduced : Array<string> = [];
    for (const memberString of detectedMemberStrings) {
        const memberAlreadyAsConsumedGiven = memberStrings && memberStrings.includes(toConsumedMemberString(memberString));
        if (!memberAlreadyAsConsumedGiven) {
            detectedMemberStringsReduced.push(memberString);
        }
    }
    const memberStringsPlusDetected = memberStrings? detectedMemberStringsReduced.concat(memberStrings) : detectedMemberStringsReduced;
    for (const memberString of memberStringsPlusDetected) {
        const memberInfo = parseMemberString(memberString);
        const member = createMember(instanceProto, staticProto, memberInfo, annotations);
        const members = (memberInfo.isConsumed) ? consumedMembers : ownedMembers;
        members.push(member);
    }

    return {ownedMembers: ownedMembers, consumedMembers: consumedMembers};
}

function toConsumedMemberString(memberString: string) : string {
    return memberString[0] + ':' + memberString.substring(2);
}

function detectMembersForClass(instanceProto: Object, staticProto: constructor{?}) : string[] {
    const memberStrings : string[] = [];
    const memberNamesInstance = Object.getOwnPropertyNames(instanceProto);
    for (const memberName of memberNamesInstance) {
        const memberString = detectMember(instanceProto, memberName, false);
        if (memberString) {
            memberStrings.push(memberString);
        }
    }
    const memberNamesStatic = Object.getOwnPropertyNames(staticProto);
    for (const memberName of memberNamesStatic) {
        const memberString = detectMember(staticProto, memberName, true)
        if (memberString) {
            memberStrings.push(memberString);
        }
    }
    return memberStrings;
}

function detectMembersForInterface(staticProto: constructor{?}) : string[] {
    const memberStrings : string[] = [];
    const interfaceDefaultFieldNames = Object.keys($interfaceDefaultFields(staticProto));
    const interfaceDefaultMethodNames = Object.keys($interfaceDefaultMethods(staticProto));
    const interfaceDefaultNames = interfaceDefaultFieldNames.concat(interfaceDefaultMethodNames);
    for (const memberName of interfaceDefaultNames) {
        const memberString = detectMember(instanceProto, memberName, false);
        if (memberString) {
            memberStrings.push(memberString);
        }
    }
    const memberNamesStatic = Object.getOwnPropertyNames(staticProto);
    for (const memberName of memberNamesStatic) {
        const memberString = detectMember(staticProto, memberName, true)
        if (memberString) {
            memberStrings.push(memberString);
        }
    }
    return memberStrings;
}

function detectMember(object: Object, memberName: string, isStatic: boolean):string {
    if (!isStatic && ['constructor'].includes(memberName)) {
        return null;
    }
    if (isStatic && ['length', 'name', 'prototype', 'n4type'].includes(memberName)) {
        return null;
    }
    const propDescriptor = Object.getOwnPropertyDescriptor(object, memberName);
    const kind = getKind(propDescriptor);

    return createMemberString(kind, isStatic, memberName);
}

function excludeDetected(memberName: string, isStatic) {
    if (!isStatic && ['constructor'].includes(memberName)) {
        return null;
    }
    if (isStatic && (['length', 'name', 'prototype', 'n4type'].includes(memberName)) || memberName.startsWith('$')) {
        return null;
    }
}

function getKind(propDescriptor: any+): string {
    const isFunction = propDescriptor.hasOwnProperty('value') && typeof propDescriptor.value == 'function';
    if (isFunction) {
        return 'm';
    }
    const isField = propDescriptor.hasOwnProperty('writable');
    if (isField) {
        return 'f';
    }
    const isSetter = propDescriptor.hasOwnProperty('set') && typeof propDescriptor.set == 'function';
    if (isSetter) {
        return 's';
    }
    const isGetter = propDescriptor.hasOwnProperty('get') && typeof propDescriptor.get == 'function';
    if (isGetter) {
        return 'g';
    }

    throw "Unknown member type detected";
}

function createMemberString(kind: string, isStatic: boolean, memberName: string): string {
    if (isStatic) {
        kind = kind.toUpperCase();
    }
    return kind + "." + memberName;
}

function createMemberAnnotations(memberAnnotations: Object) {
    const annotations : any+ = {};
    if (memberAnnotations) {
        for (const memberName of Object.keys(memberAnnotations)) {
            const annotationArray = [];
            annotations[memberName] = annotationArray;

            for (const memberAnnotation of (memberAnnotations[memberName] as [])) {
                const annotation = createAnnotation(memberAnnotation as (string|Array<string>));
                if (annotation) {
                    annotationArray.push(annotation);
                }
            }
        }
    }
    return annotations;
}

function createAnnotations(annotations: Array<string|Array<string>>): N4Annotation[] {
    const annotationArray = new Array<N4Annotation>;
    if (annotations) {
        for (const annotationValues of annotations) {
            const annotation = createAnnotation(annotationValues);
            if (annotation) {
                annotationArray.push(annotation);
            }
        }
    }
    return annotationArray;
}

function createAnnotation(annotationValues: string|Array<string>): N4Annotation {
    const annotation = new N4Annotation();
    if (typeof annotationValues === "string") {
        annotation.name = annotationValues as string;
        annotation.details = [];
    } else {
        const [name, details] = annotationValues as [];
        annotation.name = name as string;
        annotation.details = details as Array<string> || [];
        // FIXME: severe bug in LSP reveals the following line
        //annotation.details = (details as Array<string> || []) as as Array<string>;
    }
    return annotation;
}

function parseMemberString(memberString: string): MemberInfo {
    if (!/^[mMfFgGsS][\.:]/.test(memberString)) {
        return null;
    }
    const idxKind = 0;
    const idxConsumed = idxKind + 1;
    const idxNameStart = idxConsumed + 1;
    const kind = memberString[idxKind].toLowerCase();	
    const isUpperCase : boolean = (memberString[idxKind] == memberString[idxKind].toUpperCase());

    let isConsumed : boolean = undefined;
    switch (memberString[idxConsumed].toLowerCase()) {
        case '.': isConsumed = false; break;
        case ':': isConsumed = true; break;
        default: isConsumed = undefined;
    }
    
    const name = memberString.substring(idxNameStart);
    const jsFunctionRef = ((name.startsWith(SYMBOL_IDENTIFIER_PREFIX)) ? (Symbol as any+)[name.substring(1)] : name) as Object;

    return {memberString: memberString, name:name, kind:kind, isStatic: isUpperCase, isConsumed:isConsumed, jsFunctionRef:jsFunctionRef};
}

function createMember(instanceProto: any+, staticProto: any+, memberInfo: MemberInfo, annotations: any+) : N4Member {
    var member: N4Member = null;
    switch (memberInfo.kind) {
        case 'f':
            member = new N4DataField();
            break;
        case 'm': 
            member = new N4Method();
            (member as N4Method).jsFunction = (memberInfo.isStatic
                ? staticProto[memberInfo.jsFunctionRef]
                : instanceProto[memberInfo.jsFunctionRef])
                as Function;
            break;
        case 'g': 
            member = new N4Accessor();
            (member as N4Accessor).getter = true;
            break;
        case 's':
            member = new N4Accessor();
            (member as N4Accessor).getter = false;
            break;
        default:
            return null;
    }
    
    member.name = memberInfo.name;
    member.isStatic = memberInfo.isStatic;
    member.setAnnotations(annotations[memberInfo.memberString] as N4Annotation[] || []);
    return member;
}

class ReflectionValues {
    name: string;
    modulePath: string;
    origin: string;
    members: string[];
    memberAnnotations: Object;
    allImplementedInterfaces: string[];
    annotations: Array<string|Array<string>>;

    constructor(reflectionString: string) {
        const reflectionValues = JSON.parse(reflectionString) as [];
        const [name, modulePath, origin, members, memberAnnotations, allImplementedInterfaces, annotations] = reflectionValues;
        this.name = name as string;
        this.modulePath = modulePath as string;
        this.origin = origin as string;
        this.members = members as string[];
        this.memberAnnotations = memberAnnotations as Object;
        this.allImplementedInterfaces = allImplementedInterfaces as string[] || [];
        this.annotations = annotations as Array<string|Array<string>>;
    }
}

class ~MemberInfo {
    public memberString: string;
    public name: string;
    public kind: string;
    public isStatic: boolean;
    public isConsumed: boolean;
    public jsFunctionRef: Object;
}

class ~MemberContainer {
    public ownedMembers: N4Member[];
    public consumedMembers: N4Member[];
}
