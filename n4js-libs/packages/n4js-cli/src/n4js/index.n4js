/*
 * Copyright (c) 2019 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */


import * as childProcess from "child_process";
import * as npmlog+ from "npmlog";
import debug from "debug";
import {JAVA_VM_XMX, JAVA_VM_XMX_DEFAULT, N4JSC_JAR} from "Globals";
import {getJavaCommand} from "JreProvider";


const debugLog = debug("n4js-cli");
const logFn: {function(string)} = (text: string) => {debugLog(text);};


@StringBased
export public enum Goal {
    compile,
    lsp,
    api,
    watch
}

export public class Options {
    public version?: boolean;
    public help?: boolean;
    /** Clean the output folder before compiling. */
    public clean?: boolean;
    public noPersist?: boolean;
    public noTests?: boolean;
    public showSetup?: boolean;
    public stdio?: boolean;
    public testOnly?: boolean;
    public verbose?: boolean;
    public maxErrs?: int;
    public maxWarns?: int;
    public port?: int;
    /** Test catalog (JSON) to be used. If file path, will be written on --compile. */
    public testCatalog?: string;
}

export public class VmOptions {
    public xmx?: string;
}



/**
 * Calls n4jsc with the given set of arguments, e.g.
 *
 * "port": "1234"
 * "clean": true
 *
 * Any stdout/stderr will be logged as is.
 * 
 * Unless set per `JAVA_TOOL_OPTIONS` heap usage is defaulted to 4096m.
 *
 * Call `n4jsc -h` for more details.
 *
 * Returns a promise.
 */
export public function n4jsc(
        goal: Goal,
        dir: string=,
        options: ~Options+ =,
        vmOptions: ~VmOptions+ =,
        log: {function(string)} = logFn) : Promise<int, ?> {

    const args = getArgs(goal, dir, options, vmOptions, log);
    return runN4jsc(args, logFn);
}

/**
 * Calls n4jsc with the given set of arguments, e.g.
 *
 * "port": "1234"
 * "clean": true
 *
 * Any stdout/stderr will be logged as is.
 * 
 * Unless set per `JAVA_TOOL_OPTIONS` heap usage is defaulted to 4096m.
 *
 * Call `n4jsc -h` for more details.
 *
 * Returns a ChildProcess.
 */
export public function n4jscProcess(
        goal: Goal,
        dir: string,
        options: ~Options+,
        vmOptions: ~VmOptions+,
        spawnOptions: childProcess.SpawnOptions,
        log: {function(string)}) : childProcess.ChildProcess {

    const args = getArgs(goal, dir, options, vmOptions, log);
    return createN4JSProcess(args, spawnOptions, log);
}


/**
 * Runs N4jsc in a blocking fashion by executing n4jsc.jar with Java.
 * In case the bin folder contains a JRE, it will be used. Otherwise,
 * the globally available Java will be used. Java XmX option will be
 * set to 4GB if not set already.
 * The arguments will be collected from process.argv
 */
 export public async function runN4jscSync(log: {function(string)} = npmlog.info) {
    const args = getArgsFromProcess();
    try {
        let exitCode : int = await runN4jsc(args, log);
        process.exit(exitCode);
    } catch (error) {
        if (typeof error == 'number') {
            process.exit(error as number);
        } else {
            process.exit(1);
        }
    }
}

/**
 * Runs N4jsc by executing n4jsc.jar with Java and returns a promise.
 * In case the bin folder contains a JRE, it will be used. Otherwise,
 * the globally available Java will be used. Java XmX option will be
 * set to 4GB if not set already.
 */
export public function runN4jsc(args: string[], log: {function(string)} = npmlog.info) : Promise<int, ?> {
    let spawnOptions: childProcess.SpawnOptions = { stdio: "inherit", env: Object.assign({ NODEJS_PATH: process.argv[0] }, process.env)};
    let n4jscProcess = createN4JSProcess(args, spawnOptions, log);
    let promise: Promise<int, ?> = new Promise<int, int>((resolve, reject) => {
        n4jscProcess.on("close", (code: int) => {
            if (code === 0) {
                resolve(0);
            } else {
                reject(code);
            }
        });
    });

    return promise;
}

/**
 * Creates and returns a process to execute the n4jsc.jar with Java.
 * In case the bin folder contains a JRE, it will be used. Otherwise,
 * the globally available Java will be used. Java Xmx vm option will
 * overwritten iff defined in environment variable JAVA_TOOL_OPTIONS.
 */
export public function createN4JSProcess(args: string[], spawnOptions: childProcess.SpawnOptions, log: {function(string)} = npmlog.info) : childProcess.ChildProcess {
    const envJavaToolOptions = process.env.JAVA_TOOL_OPTIONS as string;
    const match = envJavaToolOptions?.match(/-xmx(?<size>[\S]*)/);
    const size = match?.groups?.size;
    if (size) {
        for (let i=0; i<args.length; i++) {
            const arg = args[i];
            if (arg.startsWith(JAVA_VM_XMX)) {
                args[i] = JAVA_VM_XMX + size;
            }
        }
    }

    let java = getJavaCommand(log);
    log("calling: " + java + " " + args.join(" "));
    let spawnedProcess = childProcess.spawn(java, args, spawnOptions);

    return spawnedProcess;
}


/**
 * Returns arguments for the call to Java which where passed to this script.
 * If not set by environment variable, a default Java maximum memory value of 4GB will be set.
 */
function getArgsFromProcess() : Array<string> {
    const args = ["-jar", N4JSC_JAR].concat(process.argv.slice(2));
    return args;
}


function getArgs(
        goal: Goal,
        dir: string,
        options: ~Options+,
        vmOptions: ~VmOptions+,
        log: {function(string)}) : string[] {

    const n4jscArgs = getN4jscArgs(goal, dir, options, log);
    const vmArgs = getVmArgs(vmOptions, log);
    const args = ["-jar", ...vmArgs, N4JSC_JAR, ...n4jscArgs];

    const n4jscOptionsString = options? Object.entries(options).map((entry) => Array.from(entry).join(":")).join(" ") : '';
    const vmOptionsString = vmOptions? Object.entries(vmOptions).map((entry) => Array.from(entry).join(":")).join(" ") : '';
    log(`goal=${goal}; dir=${dir}; options=${n4jscOptionsString}; vmOptions=${vmOptionsString}`);

    return args;
}

function getVmArgs(vmOptions: ~VmOptions+, log: {function(string)}): string[] {
    const args: string[] = [];

    if (!vmOptions) {
        vmOptions = {};
    }
    if (vmOptions.xmx === undefined) {
        // set vm Xmx option to default
        vmOptions.xmx = JAVA_VM_XMX_DEFAULT;
    }

    const vmOptionsFieldNames = new Set<string>(VmOptions.n4type.dataFields().map(f => f.name));
    for (const [key, value] of Object.entries(vmOptions)) {
        if (!vmOptionsFieldNames.has(key)) {
            log("unknown vm option: key=" + key + " value=" + value);
            continue;
        }
        const isBool = typeof value === "boolean";
        if (isBool && !value) {
            continue; // skip false boolean flags
        }
        if (value) {
            const option = capitalizeFirstLetter(key) + (isBool? '': value);
            args.push("-" + option);
        }
    }

    return args;
}

function getN4jscArgs(goal: Goal, dir: string, options: ~Options+, log: {function(string)}): string[] {
    const args: string[] = [];
    if (goal) {
        args.push(goal);
    }
    if (dir) {
        args.push(dir);
    }

    if (options) {
        const optionsFieldNames = new Set<string>(Options.n4type.dataFields().map(f => f.name));
        for (const [key, value] of Object.entries(options)) {
            if (!optionsFieldNames.has(key)) {
                log("unknown option: key=" + key + " value=" + value);
                continue;
            }
            const isBool = typeof value === "boolean";
            if (isBool && !value) {
                continue; // skip false boolean flags
            }
            args.push((key.length > 2 ? "--" : "-") + key);
            if (!isBool) {
                args.push(String(value));
            }
        }
    }

    if (debugLog.enabled) {
        args.push("--verbose");
    }

    return args;
}

function capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
