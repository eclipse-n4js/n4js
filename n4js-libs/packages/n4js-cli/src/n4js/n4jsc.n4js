/*
 * Copyright (c) 2019 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */


import * as path from "path";
import * as childProcess from "child_process";
import * as fs from "fs";

import * as lib_decompress+ from "decompress";
import * as log+ from "npmlog";
import * as followRedirects+ from 'follow-redirects';

const decompress  = (lib_decompress as any+) as {function(string, string): Promise<any,any>};
const decompress2 : any+ = require("decompress");



const NPM_NAME = process.env.npm_package_name ?? "n4js-cli";
const NPM_VERSION = process.env.npm_package_version ? "@"+process.env.npm_package_version : "";
const LOG_NAME = NPM_NAME + NPM_VERSION;
const JAVA_DEFAULT = "java";
const JRE_VERSION_START = "11.";
const BIN_DIR = path.resolve(__dirname, "..", "bin");
const JRE_DIR = path.resolve(BIN_DIR, "jre");
const JRE_URL_DIR = "https://github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11.0.6%2B10/";
const JRE_INFO_MAP = new Map<Platform, JreInfo>([
    [Platform.aix,     {bin: "bin/java", name: "OpenJDK11U-jre_ppc64_aix_hotspot_11.0.6_10.tar.gz"}],
    [Platform.darwin,  {bin: "Contents/Home/bin/java", name: "OpenJDK11U-jre_x64_mac_hotspot_11.0.6_10.tar.gz"}],
    [Platform.freebsd, {bin: "bin/java", name: "OpenJDK11U-jre_x64_linux_hotspot_11.0.6_10.tar.gz"}],
    [Platform.linux,   {bin: "bin/java", name: "OpenJDK11U-jre_x64_linux_hotspot_11.0.6_10.tar.gz"}],
    [Platform.openbsd, {bin: "bin/java", name: "OpenJDK11U-jre_x64_linux_hotspot_11.0.6_10.tar.gz"}],
    [Platform.sunos,   null],
    [Platform.win32,   {bin: "bin/java", name: "OpenJDK11U-jre_x86-32_windows_hotspot_11.0.6_10.zip"}]]
     as Iterable<Iterable2<Platform, JreInfo>>);


@StringBased
enum Platform {
    aix,
    darwin,
    freebsd,
    linux,
    openbsd,
    sunos,
    win32
}

interface ~JreInfo {
    public bin: string;
    public name: string;
}


/**
 * Runs N4jsc in a blocking fashion by executing n4jsc.jar with Java.
 * In case the bin folder contains a JRE, it will be used. Otherwise,
 * the globally available Java will be used.
 * The arguments will be collected from process.argv
 */
export public async function runN4jscSync() {
    const args = getArgs();

    let exitCode : int = await runN4jsc(args);
    if (exitCode !== 0) {
        process.exit(exitCode);
    }
}

/**
 * Runs N4jsc by executing n4jsc.jar with Java and returns a promise.
 * In case the bin folder contains a JRE, it will be used. Otherwise,
 * the globally available Java will be used.
 */
export public function runN4jsc(args: string[]) : Promise<int, ?> {
    let spawnOptions: childProcess.SpawnOptions = { stdio: "inherit", env: Object.assign({ NODEJS_PATH: process.argv[0] }, process.env)};
    let n4jscProcess = createN4JSProcess(args, spawnOptions);
    let promise: Promise<int, ?> = new Promise<int, int>((resolve, reject) => {
        n4jscProcess.on("close", (code: int) => {
            if (code === 0) {
                resolve(0);
            } else {
                reject(code);
            }
        });
    });

    return promise;
}

/**
 * Runs N4jsc by executing n4jsc.jar with Java and returns a promise.
 * In case the bin folder contains a JRE, it will be used. Otherwise,
 * the globally available Java will be used.
 */
export public function createN4JSProcess(args: string[], spawnOptions: childProcess.SpawnOptions) : childProcess.ChildProcess {
    let java = getJavaCommand();
    if (isLocalJre(java)) {
        log.info(LOG_NAME, "Using JRE at " + java);
    }

    if (!/-Xmx/.test(process.env.JAVA_TOOL_OPTIONS as string)) {
        args.unshift("-Xmx4096m");
    }

    let spawnedProcess = childProcess.spawn(java, args, spawnOptions);

    return spawnedProcess;
}


export public function getN4jscPath(): string {
    return path.resolve(BIN_DIR, "n4jsc.jar");
}

/**
 * Returns arguments for the call to Java which where passed to this script.
 * If not set by environment variable, a default Java maximum memory value of 4GB will be set.
 */
function getArgs() : Array<string> {
    const args = ["-jar", getN4jscPath()].concat(process.argv.slice(2));
    return args;
}

/**
 * Returns Java command "java".
 * In case the bin folder contains a JRE, this function returns the absolute path
 * to the Java executable.
 */
function getJavaCommand() : string {
    const jreInfo = JRE_INFO_MAP.get(process.platform as Platform);
    if (jreInfo && fs.existsSync(JRE_DIR)) {
        const directories = fs.readdirSync(JRE_DIR, { withFileTypes: true }) as fs.Dirent[];
        const dirNames = directories
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name) as string[];

        for (const dirName of dirNames) {
            const absJreJavaPath = path.resolve(JRE_DIR, dirName, jreInfo.bin);
            if (fs.existsSync(absJreJavaPath)) {
                return absJreJavaPath;
            }
        }
    }

    return JAVA_DEFAULT;
}

export public async function ensureJRE() : void {
    const java = getJavaCommand();
    if (isLocalJre(java)) {
        log.info(LOG_NAME, "Local JRE found.");
        return;
    }

    const version = getJavaVersion();
    if (version && version.startsWith(JRE_VERSION_START)) {
        log.info(LOG_NAME, "Global JRE found with version " + version);
        return;
    }

    // Download and extract JRE
    const jreInfo = JRE_INFO_MAP.get(process.platform as Platform);
    if (jreInfo) {
        let msg = version? "Global JRE found but version not starting with '" + JRE_VERSION_START + "'." : "Global JRE found.";
        msg += " Downloading and extracting JRE into local folder.";
        log.info(LOG_NAME, msg);

        await downloadJRE(jreInfo);
        extractJRE(jreInfo);

    } else {
        log.info(LOG_NAME, "Platform not supported: " + process.platform);
        log.info(LOG_NAME, "Please install JRE11+ and make the call to 'bin/java' globally available.");
    }
}

function isLocalJre(javaPath: string): boolean {
    return !!javaPath && (javaPath != JAVA_DEFAULT);
}

/**
 * Returns the version of the installed Java.
 */
function getJavaVersion() : string {
    const spawn = childProcess.spawnSync('java', ['-version']);
    if (spawn.error) {
        return spawn.error.toString();
    }
    if (spawn.stderr) {
        const data = spawn.stderr.toString().split('\n')[0];
        const javaVersion : string|boolean = new RegExp('java version').test(data) ? data.split(' ')[2].replace(/"/g, '') : false;
        if (javaVersion !== false) {
            // Java installed
            return javaVersion as string;
        } else {
            // No Java installed
            return null;
        }
    }
    return null;
}

/**
 * Downloads the AdoptOpenJDK JRE.
 */
async function downloadJRE(jreInfo: JreInfo) : Promise<any, any> {
    const jreUrl = JRE_URL_DIR + jreInfo.name;
    log.info(LOG_NAME, "downloading JRE from " + jreUrl);

    if (!fs.existsSync(BIN_DIR)) {
        log.info(LOG_NAME, "creating dir " + BIN_DIR);
        fs.mkdirSync(BIN_DIR);
    }

    return new Promise<any, any>((resolve, reject) => {
            followRedirects.https.get(jreUrl,
                (response : any+) => {
                    const jreFileName = getJreFileName(jreInfo);
                    const file = fs.createWriteStream(jreFileName);
                    response.pipe(file);
                    log.info(LOG_NAME, "receiving JRE ...");

                    response.on("error",
                        err => {
                            log.error("n4js-cli", err);
                            reject(err);
                        });
                    response.on("end",
                        () => {
                            log.info(LOG_NAME, "JRE written to file " + jreFileName);
                            resolve();
                        });
                });
        });
}

/** 
 * Extracts the downloaded JRE to the folder bin/JRE_LOCAL_DIR
 */
function extractJRE(jreInfo: JreInfo) {
    if (fs.existsSync(JRE_DIR)) {
        log.info(LOG_NAME, "Cleaning " + JRE_DIR);
        fs.rmdirSync(JRE_DIR, {recursive: true});
    }

    const jreFileName = getJreFileName(jreInfo);
    decompress2(jreFileName, JRE_DIR)
        .then(files => {
            log.info(LOG_NAME, "JRE extracted to " + JRE_DIR);
        });
}

function getJreFileName(jreInfo: JreInfo): string {
    return path.resolve(BIN_DIR, jreInfo.name);
}
