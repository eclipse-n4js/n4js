// Generated by N4JS transpiler; for copyright see original N4JS source file.

(function(System) {
	'use strict';
	System.register([
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/InstrumentedTest',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/TestExecutor',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroup',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroups',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestFunctionType',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestMethodDescriptor',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestSpy',
		'org.eclipse.n4js.mangelhaft.assert/src-gen/org/eclipse/n4js/mangelhaft/precondition/PreconditionNotMet',
		'n4js.lang/src-gen/n4js/lang/N4Injector'
	], function($n4Export) {
		var InstrumentedTest, TestExecutor, ResultGroup, ResultGroups, TestFunctionType, TestMethodDescriptor, TestSpy, PreconditionNotMet, N4Injector, TestController;
		TestController = function TestController() {
			this.spy = undefined;
			this.executor = undefined;
			this.injector = undefined;
			this.reportersVal = [];
		};
		$n4Export('TestController', TestController);
		return {
			setters: [
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/InstrumentedTest
					InstrumentedTest = $exports.InstrumentedTest;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/TestExecutor
					TestExecutor = $exports.TestExecutor;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroup
					ResultGroup = $exports.ResultGroup;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroups
					ResultGroups = $exports.ResultGroups;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestFunctionType
					TestFunctionType = $exports.TestFunctionType;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestMethodDescriptor
					TestMethodDescriptor = $exports.TestMethodDescriptor;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestSpy
					TestSpy = $exports.TestSpy;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft.assert/src-gen/org/eclipse/n4js/mangelhaft/precondition/PreconditionNotMet
					PreconditionNotMet = $exports.PreconditionNotMet;
				},
				function($exports) {
					// n4js.lang/src-gen/n4js/lang/N4Injector
					N4Injector = $exports.N4Injector;
				}
			],
			execute: function() {
				$makeClass(TestController, N4Object, [], {
					runGroups: {
						value: async function runGroups___n4(testInfoObject, numTests, scope) {
							if (!testInfoObject) {
								throw new Error("TestController::runGroups called with a null testInfoObject");
							}
							let executor = this.executor, reses = [], res, testInfos = testInfoObject.testDescriptors, batchedTestInfos = [], ii = 0, testInfosBatch, instrumentedTestsBatch2d, instrumentedTestsBatch;
							;
							if (numTests === undefined) {
								numTests = testInfoObject.testDescriptors.reduce(function(acc, info) {
									return acc + info.testMethods.length;
								}, 0);
							}
							testInfoObject.testDescriptors = testInfoObject.testDescriptors.sort((x, y)=>{
								let xVal = x.fqn ? x.fqn : x.module, yVal = y.fqn ? y.fqn : y.module;
								return xVal.localeCompare(yVal);
							});
							try {
								await this.spy.testingStarted.dispatch([
									testInfos.length,
									testInfoObject.sessionId,
									numTests
								]);
							} catch(ex) {
								console.log("testingStarted.dispatch is bad", ex);
							}
							for(ii = 0;ii < testInfos.length;ii += TestController.MAX_GROUPS_PER_TEST_BATCH) {
								batchedTestInfos.push(testInfos.slice(ii, ii + TestController.MAX_GROUPS_PER_TEST_BATCH));
							}
							for(ii = 0, instrumentedTestsBatch = [];ii < batchedTestInfos.length;++ii, instrumentedTestsBatch = []) {
								testInfosBatch = batchedTestInfos[ii];
								try {
									instrumentedTestsBatch2d = (await Promise.resolve(await Promise.all(testInfosBatch.map(this.instrument.bind(this)).filter(function(test) {
										return test !== null;
									}))));
									instrumentedTestsBatch = (Array.prototype.concat.apply([], instrumentedTestsBatch2d));
									res = await executor.runTestsAsync(instrumentedTestsBatch, scope);
									reses.push(res);
								} catch(er) {
									console.error(er);
									throw er;
								}
							}
							;
							res = ResultGroups.concatArray(reses);
							await this.spy.testingFinished.dispatch([
								res
							]);
							return res;
						}
					},
					errorGroup: {
						value: async function errorGroup___n4(info, loadPath, testObject, originalError) {
							let error = originalError ? originalError : new Error("could not load test " + loadPath), that = this, testResult, testResults = [], unknownTest = new TestMethodDescriptor({
								name: "",
								type: TestFunctionType.TEST,
								value: function() {}
							});
							;
							if (!testObject) {
								testObject = new InstrumentedTest();
								info.module = info.module || "";
								info.fqn = info.fqn || info.module.replace(/\//g, ".") + ".*";
								testObject.load(N4Object, info).setTestObject(new N4Object());
								testObject.tests = info.testMethods ? info.testMethods.map(function(methName) {
									return new TestMethodDescriptor({
										name: methName,
										type: TestFunctionType.TEST,
										value: function() {}
									});
								}) : [
									unknownTest
								];
							}
							await this.spy.groupStarted.dispatch([
								testObject
							]);
							for(let test of testObject.tests) {
								await that.spy.testStarted.dispatch([
									testObject,
									test
								]);
								testResult = TestExecutor.generateFailureTestResult(error, "could not load test " + loadPath);
								testResults.push(testResult);
								await that.spy.testFinished.dispatch([
									testObject,
									test,
									testResult
								]);
							}
							await this.spy.groupFinished.dispatch([
								testObject,
								new ResultGroup(testResults, `${info.fqn} ${testObject.parameterizedName}`)
							]);
							return true;
						}
					},
					instrument: {
						value: async function instrument___n4(info) {
							let parts, ctorName, groupModule, testClasses, testClass, instrumentedTestObjects = [], moduleName;
							;
							parts = info.fqn.split("/");
							ctorName = parts.pop();
							moduleName = parts.join("/");
							try {
								groupModule = System.throwPendingError(await System.import(info.origin + "/" + moduleName));
							} catch(ex) {
								await this.errorGroup(info, info.origin + "/" + moduleName, null, ex);
								return null;
							}
							testClasses = [
								groupModule[ctorName]
							];
							if (testClasses) {
								instrumentedTestObjects = [];
								for(testClass of testClasses) {
									if (!testClass) {
										await this.errorGroup(info, info.origin + "/" + moduleName, null, new Error("Empty object loaded (is the test class exported?)"));
										continue;
									} else {
										try {
											let diClass = testClass;
											let testInjector;
											let testType = testClass.n4type;
											for(;testType;testType = testType.n4superType, diClass = Object.getPrototypeOf(diClass)) {
												if (testType.allAnnotations("GenerateInjector").length) {
													if (testType.allAnnotations("WithParentInjector").length) {
														if (!this.injector.canBeParentOf(diClass)) {
															throw new PreconditionNotMet("Test called with incompatible parent injector");
														}
														testInjector = N4Injector.of.call(N4Injector, diClass, this.injector);
													} else {
														testInjector = N4Injector.of.call(N4Injector, diClass);
													}
													break;
												}
											}
											if (!testType) {
												testInjector = this.injector;
											}
											let classITO = InstrumentedTest.getInstrumentedTest(testClass, info, testInjector);
											instrumentedTestObjects.push(classITO);
										} catch(ex2) {
											instrumentedTestObjects.push(new InstrumentedTest(testClass, info).setTestObject(new N4Object()).setError(ex2));
										}
									}
								}
							} else {
								await this.errorGroup(info, info.origin + "/" + parts.join("/"));
								return null;
							}
							let arr = (await Promise.all(instrumentedTestObjects)).filter((item)=>item !== null);
							return arr;
						}
					},
					reporters: {
						set: function setReporters___n4(reporters) {
							reporters.forEach(function(reporter) {
								let dummy = reporter.register();
								dummy;
							});
							this.reportersVal = reporters;
						}
					},
					spy: {
						value: undefined,
						writable: true
					},
					executor: {
						value: undefined,
						writable: true
					},
					injector: {
						value: undefined,
						writable: true
					},
					reportersVal: {
						value: undefined,
						writable: true
					}
				}, {
					MAX_GROUPS_PER_TEST_BATCH: {
						value: undefined,
						writable: true
					}
				}, function(instanceProto, staticProto) {
					var metaClass = new N4Class({
						name: 'TestController',
						origin: 'org.eclipse.n4js.mangelhaft',
						fqn: 'org.eclipse.n4js.mangelhaft.TestController.TestController',
						n4superType: N4Object.n4type,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'MAX_GROUPS_PER_TEST_BATCH',
								isStatic: true,
								annotations: []
							}),
							new N4DataField({
								name: 'spy',
								isStatic: false,
								annotations: [
									new N4Annotation({
										name: 'Inject',
										details: []
									})
								]
							}),
							new N4DataField({
								name: 'executor',
								isStatic: false,
								annotations: [
									new N4Annotation({
										name: 'Inject',
										details: []
									})
								]
							}),
							new N4DataField({
								name: 'injector',
								isStatic: false,
								annotations: [
									new N4Annotation({
										name: 'Inject',
										details: []
									})
								]
							}),
							new N4DataField({
								name: 'reportersVal',
								isStatic: false,
								annotations: []
							}),
							new N4Accessor({
								name: 'reporters',
								getter: false,
								isStatic: false,
								annotations: []
							}),
							new N4Method({
								name: 'runGroups',
								isStatic: false,
								jsFunction: instanceProto['runGroups'],
								annotations: []
							}),
							new N4Method({
								name: 'errorGroup',
								isStatic: false,
								jsFunction: instanceProto['errorGroup'],
								annotations: []
							}),
							new N4Method({
								name: 'instrument',
								isStatic: false,
								jsFunction: instanceProto['instrument'],
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				TestController.MAX_GROUPS_PER_TEST_BATCH = 10;
				Object.defineProperty(TestController, '$di', {
					value: {
						fieldsInjectedTypes: [
							{
								name: 'spy',
								type: TestSpy
							},
							{
								name: 'executor',
								type: TestExecutor
							},
							{
								name: 'injector',
								type: N4Injector
							}
						]
					}
				});
			}
		};
	});
})(typeof module !== 'undefined' && module.exports ? require('n4js-node').System(require, module) : System);
//# sourceMappingURL=TestController.map
