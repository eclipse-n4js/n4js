// Generated by N4JS transpiler; for copyright see original N4JS source file.

(function(System) {
	'use strict';
	System.register([
		'org.eclipse.n4js.mangelhaft.assert/src-gen/org/eclipse/n4js/mangelhaft/assert/AssertionError',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroup',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroups',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestResult',
		'org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestSpy',
		'org.eclipse.n4js.mangelhaft.assert/src-gen/org/eclipse/n4js/mangelhaft/precondition/PreconditionNotMet'
	], function($n4Export) {
		var AssertionError, ResultGroup, ResultGroups, TestResult, TestSpy, PreconditionNotMet, TestExecutor;
		TestExecutor = function TestExecutor(spy) {
			this.spy = undefined;
			this.constext = undefined;
			this.spy = spy;
		};
		$n4Export('TestExecutor', TestExecutor);
		return {
			setters: [
				function($exports) {
					// org.eclipse.n4js.mangelhaft.assert/src-gen/org/eclipse/n4js/mangelhaft/assert/AssertionError
					AssertionError = $exports.AssertionError;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroup
					ResultGroup = $exports.ResultGroup;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/ResultGroups
					ResultGroups = $exports.ResultGroups;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestResult
					TestResult = $exports.TestResult;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft/src-gen/org/eclipse/n4js/mangelhaft/types/TestSpy
					TestSpy = $exports.TestSpy;
				},
				function($exports) {
					// org.eclipse.n4js.mangelhaft.assert/src-gen/org/eclipse/n4js/mangelhaft/precondition/PreconditionNotMet
					PreconditionNotMet = $exports.PreconditionNotMet;
				}
			],
			execute: function() {
				$makeClass(TestExecutor, N4Object, [], {
					handleFixme: {
						value: function handleFixme___n4(testObject, scope, testRes) {
							if (testObject.fixme && (!testObject.fixmeScopes || testObject.fixmeScopes.has(scope))) {
								if (testRes.testStatus === 'PASSED') {
									testRes.testStatus = 'FAILED';
									testRes.message = "Test marked with @Fixme annotation but was successful. Issue blocking test has probably been fixed. Try removing annotation.";
									if (testObject.fixmeReason != null) {
										testRes.message += " (reason was '" + testObject.fixmeReason + "')";
									}
									testRes.trace = [
										String(testRes)
									];
								} else if (testRes.testStatus === 'FAILED' || testRes.testStatus === 'ERROR') {
									testRes.testStatus = 'SKIPPED_FIXME';
									testRes.message = testObject.fixmeReason;
									testRes.actual = testRes.expected = testRes.trace = null;
								}
							}
							return testRes;
						}
					},
					callAll: {
						value: async function callAll___n4(instrumentedTest, testMethodDescriptors) {
							let results = [];
							var runTest = async function runTest(testMethodDescriptor) {
								let timeoutId, testResult;
								async function doPromise(resolve, reject) {
									let res;
									timeoutId = setTimeout(function() {
										reject(new Error("Test object " + testMethodDescriptor.name + " timed out after " + testMethodDescriptor.timeout + " milliseconds"));
									}, testMethodDescriptor.timeout);
									try {
										res = await Promise.resolve(testMethodDescriptor.value.call(instrumentedTest.testObject));
									} catch(error) {
										reject(error);
									} finally {
										clearTimeout(timeoutId);
									}
									resolve(res);
								}
								testResult = await new Promise(doPromise);
								return testResult;
							};
							if (testMethodDescriptors) {
								results = (await Promise.all(testMethodDescriptors.map(runTest)));
							}
							return results;
						}
					},
					getAncestorTestMethods: {
						value: function getAncestorTestMethods___n4(iTest, testMethodName) {
							let testMethods = [], nodeTestMethods, node = iTest;
							;
							while(node.parent) {
								node = node.parent;
							}
							do {
								let nodeObj = node;
								nodeTestMethods = nodeObj[testMethodName];
								if (nodeTestMethods && nodeTestMethods.length) {
									testMethods = testMethods.concat(nodeTestMethods);
								}
							} while(node = node.child);
							return testMethods;
						}
					},
					runTestAsync: {
						value: async function runTestAsync___n4(instrumentedTest) {
							return await this.runTestsAsync([
								instrumentedTest
							]);
						}
					},
					runGroup: {
						value: async function runGroup___n4(iTest, scope) {
							let rg, testObject, testRes, testResults = [], beforeAlls = this.getAncestorTestMethods(iTest, "beforeAlls"), befores = this.getAncestorTestMethods(iTest, "befores"), afters = this.getAncestorTestMethods(iTest, "afters").reverse(), afterAlls = this.getAncestorTestMethods(iTest, "afterAlls").reverse(), numTests, ii, start, end;
							;
							await this.spy.groupStarted.dispatch([
								iTest
							]);
							if (iTest.error) {
								testResults = await this.errorTests(iTest, iTest.error);
							} else {
								try {
									await this.callAll(iTest, beforeAlls);
									numTests = iTest.tests.length;
									for(ii = 0;ii < numTests;++ii) {
										testObject = iTest.tests[ii];
										try {
											await this.spy.testStarted.dispatch([
												iTest,
												testObject
											]);
											start = new Date().getTime();
											if (testObject.ignore) {
												testRes = new TestResult({
													testStatus: 'SKIPPED_IGNORE',
													message: testObject.ignoreReason,
													description: testObject.name
												});
											} else {
												try {
													await this.callAll(iTest, befores);
													await this.callAll(iTest, [
														testObject
													]);
													testRes = new TestResult({
														testStatus: 'PASSED',
														description: testObject.name
													});
												} finally {
													await this.callAll(iTest, afters);
												}
											}
											end = new Date().getTime();
										} catch(er) {
											let err = er;
											end = new Date().getTime();
											testRes = TestExecutor.generateFailureTestResult(err, testObject.name);
										}
										testRes.elapsedTime = end - start;
										testRes = this.handleFixme(testObject, scope, testRes);
										await this.spy.testFinished.dispatch([
											iTest,
											testObject,
											testRes,
											async()=>{
												let allTests = iTest.tests;
												;
												iTest.tests = [
													testObject
												];
												try {
													await this.runTestsAsync([
														iTest
													]);
												} finally {
													iTest.tests = allTests;
												}
											}
										]);
										testResults.push(testRes);
									}
									await this.callAll(iTest, afterAlls);
								} catch(error) {
									let results = await this.errorTests(iTest, error);
									testResults = testResults.concat(results);
								}
							}
							rg = new ResultGroup(testResults, `${iTest.name}`);
							await this.spy.groupFinished.dispatch([
								iTest,
								rg
							]);
							return rg;
						}
					},
					runTestsAsync: {
						value: async function runTestsAsync___n4(instrumentedTests, scope) {
							let results = [];
							for(let test of instrumentedTests) {
								if (test) {
									if (test.hasParameterizedTests) {
										let pResults = [];
										await this.spy.parameterizedGroupsStarted.dispatch([
											test
										]);
										for(let ptest of test.parameterizedTests) {
											let testRes = await this.runGroup(ptest, scope);
											pResults.push(testRes);
											results.push(testRes);
										}
										await this.spy.parameterizedGroupsFinished.dispatch([
											new ResultGroups(pResults)
										]);
									} else {
										let testRes = await this.runGroup(test, scope);
										results.push(testRes);
									}
								}
							}
							let resultGroups = new ResultGroups(results);
							return resultGroups;
						}
					},
					errorTests: {
						value: async function errorTests___n4(instrumentedTest, error) {
							let len = instrumentedTest.tests.length, testResult, testResults = [], test, ii;
							;
							for(ii = 0;ii < len;++ii) {
								test = instrumentedTest.tests[ii];
								await this.spy.testStarted.dispatch([
									instrumentedTest,
									test
								]);
								testResult = TestExecutor.generateFailureTestResult(error, test.name);
								testResult.elapsedTime = 0;
								await this.spy.testFinished.dispatch([
									instrumentedTest,
									test,
									testResult
								]);
								testResults.push(testResult);
							}
							return testResults;
						}
					},
					spy: {
						value: undefined,
						writable: true
					},
					constext: {
						value: undefined,
						writable: true
					}
				}, {
					getStringFromAbiguous: {
						value: function getStringFromAbiguous___n4(thing) {
							let str;
							if (thing === null) {
								str = "null";
							} else if (typeof thing === "object") {
								str = Object.prototype.hasOwnProperty.call(thing, "toString") ? "" + thing : "prototypeless object";
							} else {
								str = "" + thing;
							}
							return str;
						}
					},
					generateFailureTestResult: {
						value: function generateFailureTestResult___n4(ex, description) {
							if (!ex) {
								ex = new Error("Unknown error: " + description);
							} else if (typeof ex === "string") {
								ex = new Error(ex);
							}
							let e = ex instanceof AssertionError ? ex : ex, reason = e.toString(), tr, status, trace;
							;
							if (reason.charAt(0) === "[") {
								reason = e.name ? `${e.name} : ${description}` : description;
							}
							if (ex instanceof AssertionError) {
								status = 'FAILED';
							} else if (ex instanceof PreconditionNotMet) {
								status = 'SKIPPED_PRECONDITION';
							} else if (ex instanceof N4ApiNotImplementedError) {
								status = 'SKIPPED_NOT_IMPLEMENTED';
							} else {
								status = 'ERROR';
							}
							if (e.message) {
								reason = String(e);
							}
							if (e.stack) {
								if (typeof e.stack === "string") {
									trace = (e.stack).split("\n");
								} else if (Array.isArray(e.stack)) {
									trace = e.stack;
								} else {
									trace = [
										(e.stack).toString()
									];
								}
								trace = trace.map(function(line) {
									return line.trim();
								});
							}
							tr = new TestResult({
								testStatus: status,
								message: reason,
								trace: trace,
								description: description,
								expected: e.hasOwnProperty("expected") ? this.getStringFromAbiguous(e.expected) : undefined,
								actual: e.hasOwnProperty("actual") ? this.getStringFromAbiguous(e.actual) : undefined
							});
							return tr;
						}
					}
				}, function(instanceProto, staticProto) {
					var metaClass = new N4Class({
						name: 'TestExecutor',
						origin: 'org.eclipse.n4js.mangelhaft',
						fqn: 'org.eclipse.n4js.mangelhaft.TestExecutor.TestExecutor',
						n4superType: N4Object.n4type,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'spy',
								isStatic: false,
								annotations: [
									new N4Annotation({
										name: 'Inject',
										details: []
									})
								]
							}),
							new N4DataField({
								name: 'constext',
								isStatic: false,
								annotations: []
							}),
							new N4Method({
								name: 'constructor',
								isStatic: false,
								jsFunction: instanceProto['constructor'],
								annotations: []
							}),
							new N4Method({
								name: 'getStringFromAbiguous',
								isStatic: true,
								jsFunction: staticProto['getStringFromAbiguous'],
								annotations: []
							}),
							new N4Method({
								name: 'generateFailureTestResult',
								isStatic: true,
								jsFunction: staticProto['generateFailureTestResult'],
								annotations: []
							}),
							new N4Method({
								name: 'handleFixme',
								isStatic: false,
								jsFunction: instanceProto['handleFixme'],
								annotations: []
							}),
							new N4Method({
								name: 'callAll',
								isStatic: false,
								jsFunction: instanceProto['callAll'],
								annotations: []
							}),
							new N4Method({
								name: 'getAncestorTestMethods',
								isStatic: false,
								jsFunction: instanceProto['getAncestorTestMethods'],
								annotations: []
							}),
							new N4Method({
								name: 'runTestAsync',
								isStatic: false,
								jsFunction: instanceProto['runTestAsync'],
								annotations: []
							}),
							new N4Method({
								name: 'runGroup',
								isStatic: false,
								jsFunction: instanceProto['runGroup'],
								annotations: []
							}),
							new N4Method({
								name: 'runTestsAsync',
								isStatic: false,
								jsFunction: instanceProto['runTestsAsync'],
								annotations: []
							}),
							new N4Method({
								name: 'errorTests',
								isStatic: false,
								jsFunction: instanceProto['errorTests'],
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				Object.defineProperty(TestExecutor, '$di', {
					value: {
						fieldsInjectedTypes: [
							{
								name: 'spy',
								type: TestSpy
							}
						]
					}
				});
			}
		};
	});
})(typeof module !== 'undefined' && module.exports ? require('n4js-node').System(require, module) : System);
//# sourceMappingURL=TestExecutor.map
