// Generated by N4JS transpiler; for copyright see original N4JS source file.

(function(System) {
	'use strict';
	System.register([], function($n4Export) {
		var DI_PROP_NAME, InjectedTypeMeta, InjectedClassMeta, BindingInfo, ProvideMethodInfo, BinderMeta, DIComponentMeta, hasDIMeta, getInjectedClassMeta, getBinderMeta, getDIComponentMeta, _$, getOFQN, DIConfigurationError, DIUnsatisfiedBindingError, N4Injector;
		InjectedTypeMeta = {};
		$n4Export('InjectedTypeMeta', InjectedTypeMeta);
		InjectedClassMeta = {};
		$n4Export('InjectedClassMeta', InjectedClassMeta);
		BindingInfo = {};
		$n4Export('BindingInfo', BindingInfo);
		ProvideMethodInfo = {};
		$n4Export('ProvideMethodInfo', ProvideMethodInfo);
		BinderMeta = {};
		$n4Export('BinderMeta', BinderMeta);
		DIComponentMeta = {};
		$n4Export('DIComponentMeta', DIComponentMeta);
		hasDIMeta = function hasDIMeta(type) {
			let typeObj = type;
			return typeof typeObj[DI_PROP_NAME] === typeof {};
		};
		$n4Export('hasDIMeta', hasDIMeta);
		getInjectedClassMeta = function getInjectedClassMeta(type) {
			let typeObj = type;
			return typeObj[DI_PROP_NAME];
		};
		$n4Export('getInjectedClassMeta', getInjectedClassMeta);
		getBinderMeta = function getBinderMeta(type) {
			let typeObj = type;
			return typeObj[DI_PROP_NAME];
		};
		$n4Export('getBinderMeta', getBinderMeta);
		getDIComponentMeta = function getDIComponentMeta(type) {
			let typeObj = type;
			return typeObj[DI_PROP_NAME];
		};
		$n4Export('getDIComponentMeta', getDIComponentMeta);
		_$ = function _$(fn) {
			this.fn = undefined;
			this.fn = fn;
		};
		getOFQN = function getOFQN(ctor) {
			return ctor.n4type.origin + ctor.n4type.fqn;
		};
		DIConfigurationError = function DIConfigurationError(message) {
			var err = new Error(message);
			this.message = err.message;
			this.name = this.constructor.n4type.name;
			Object.defineProperty(this, 'stack', { get: function() { return err.stack; }, set: function(value) { err.stack = value; } });
		};
		$n4Export('DIConfigurationError', DIConfigurationError);
		DIUnsatisfiedBindingError = function DIUnsatisfiedBindingError(unsatisfiedBinding, message) {
			DIConfigurationError.prototype.constructor.call(this, message || '');
			this.binding = undefined;
			this.binding = unsatisfiedBinding;
		};
		$n4Export('DIUnsatisfiedBindingError', DIUnsatisfiedBindingError);
		N4Injector = function N4Injector(dicInfo, bindings, parent) {
			this.explicitBindings = undefined;
			this.scopedInstances = new Map();
			this.dicInfo = undefined;
			this.parent = undefined;
			this.dicInfo = dicInfo;
			if (parent) {
				this.parent = parent;
			}
			this.explicitBindings = bindings;
		};
		$n4Export('N4Injector', N4Injector);
		return {
			setters: [],
			execute: function() {
				DI_PROP_NAME = '$di';
				InjectedTypeMeta.$fieldInit = function InjectedTypeMeta_fieldInit(spec, mixinExclusion) {
					if (spec) {
						if (!(mixinExclusion.hasOwnProperty('type') || this.hasOwnProperty('type'))) {
							this.type = 'type' in spec ? spec.type : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('name') || this.hasOwnProperty('name'))) {
							this.name = 'name' in spec ? spec.name : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('typeVar') || this.hasOwnProperty('typeVar'))) {
							this.typeVar = 'typeVar' in spec ? spec.typeVar : undefined;
						}
					} else {
						if (!(mixinExclusion.hasOwnProperty('type') || this.hasOwnProperty('type'))) {
							this.type = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('name') || this.hasOwnProperty('name'))) {
							this.name = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('typeVar') || this.hasOwnProperty('typeVar'))) {
							this.typeVar = undefined;
						}
					}
				};
				InjectedTypeMeta.$methods = {};
				$makeInterface(InjectedTypeMeta, function(instanceProto, staticProto) {
					var metaClass = new N4Interface({
						name: 'InjectedTypeMeta',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.InjectedTypeMeta',
						n4superType: undefined,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'type',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'name',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'typeVar',
								isStatic: false,
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				InjectedClassMeta.$fieldInit = function InjectedClassMeta_fieldInit(spec, mixinExclusion) {
					if (spec) {
						if (!(mixinExclusion.hasOwnProperty('scope') || this.hasOwnProperty('scope'))) {
							this.scope = 'scope' in spec ? spec.scope : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('superType') || this.hasOwnProperty('superType'))) {
							this.superType = 'superType' in spec ? spec.superType : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('injectCtorParams') || this.hasOwnProperty('injectCtorParams'))) {
							this.injectCtorParams = 'injectCtorParams' in spec ? spec.injectCtorParams : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('fieldsInjectedTypes') || this.hasOwnProperty('fieldsInjectedTypes'))) {
							this.fieldsInjectedTypes = 'fieldsInjectedTypes' in spec ? spec.fieldsInjectedTypes : undefined;
						}
					} else {
						if (!(mixinExclusion.hasOwnProperty('scope') || this.hasOwnProperty('scope'))) {
							this.scope = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('superType') || this.hasOwnProperty('superType'))) {
							this.superType = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('injectCtorParams') || this.hasOwnProperty('injectCtorParams'))) {
							this.injectCtorParams = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('fieldsInjectedTypes') || this.hasOwnProperty('fieldsInjectedTypes'))) {
							this.fieldsInjectedTypes = undefined;
						}
					}
				};
				InjectedClassMeta.$methods = {};
				$makeInterface(InjectedClassMeta, function(instanceProto, staticProto) {
					var metaClass = new N4Interface({
						name: 'InjectedClassMeta',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.InjectedClassMeta',
						n4superType: undefined,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'scope',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'superType',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'injectCtorParams',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'fieldsInjectedTypes',
								isStatic: false,
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				BindingInfo.$fieldInit = function BindingInfo_fieldInit(spec, mixinExclusion) {
					if (spec) {
						if (!(mixinExclusion.hasOwnProperty('from') || this.hasOwnProperty('from'))) {
							this.from = 'from' in spec ? spec.from : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('to') || this.hasOwnProperty('to'))) {
							this.to = 'to' in spec ? spec.to : undefined;
						}
					} else {
						if (!(mixinExclusion.hasOwnProperty('from') || this.hasOwnProperty('from'))) {
							this.from = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('to') || this.hasOwnProperty('to'))) {
							this.to = undefined;
						}
					}
				};
				BindingInfo.$methods = {};
				$makeInterface(BindingInfo, function(instanceProto, staticProto) {
					var metaClass = new N4Interface({
						name: 'BindingInfo',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.BindingInfo',
						n4superType: undefined,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'from',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'to',
								isStatic: false,
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				ProvideMethodInfo.$fieldInit = function ProvideMethodInfo_fieldInit(spec, mixinExclusion) {
					if (spec) {
						if (!(mixinExclusion.hasOwnProperty('to') || this.hasOwnProperty('to'))) {
							this.to = 'to' in spec ? spec.to : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('name') || this.hasOwnProperty('name'))) {
							this.name = 'name' in spec ? spec.name : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('args') || this.hasOwnProperty('args'))) {
							this.args = 'args' in spec ? spec.args : undefined;
						}
					} else {
						if (!(mixinExclusion.hasOwnProperty('to') || this.hasOwnProperty('to'))) {
							this.to = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('name') || this.hasOwnProperty('name'))) {
							this.name = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('args') || this.hasOwnProperty('args'))) {
							this.args = undefined;
						}
					}
				};
				ProvideMethodInfo.$methods = {};
				$makeInterface(ProvideMethodInfo, function(instanceProto, staticProto) {
					var metaClass = new N4Interface({
						name: 'ProvideMethodInfo',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.ProvideMethodInfo',
						n4superType: undefined,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'to',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'name',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'args',
								isStatic: false,
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				BinderMeta.$fieldInit = function BinderMeta_fieldInit(spec, mixinExclusion) {
					if (spec) {
						if (!(mixinExclusion.hasOwnProperty('bindings') || this.hasOwnProperty('bindings'))) {
							this.bindings = 'bindings' in spec ? spec.bindings : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('methodBindings') || this.hasOwnProperty('methodBindings'))) {
							this.methodBindings = 'methodBindings' in spec ? spec.methodBindings : undefined;
						}
					} else {
						if (!(mixinExclusion.hasOwnProperty('bindings') || this.hasOwnProperty('bindings'))) {
							this.bindings = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('methodBindings') || this.hasOwnProperty('methodBindings'))) {
							this.methodBindings = undefined;
						}
					}
					InjectedClassMeta.$fieldInit.call(this, spec, mixinExclusion);
				};
				BinderMeta.$methods = {};
				$makeInterface(BinderMeta, function(instanceProto, staticProto) {
					var metaClass = new N4Interface({
						name: 'BinderMeta',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.BinderMeta',
						n4superType: undefined,
						allImplementedInterfaces: [
							'n4js.lang.N4Injector.InjectedClassMeta'
						],
						ownedMembers: [
							new N4DataField({
								name: 'bindings',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'methodBindings',
								isStatic: false,
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				DIComponentMeta.$fieldInit = function DIComponentMeta_fieldInit(spec, mixinExclusion) {
					if (spec) {
						if (!(mixinExclusion.hasOwnProperty('parent') || this.hasOwnProperty('parent'))) {
							this.parent = 'parent' in spec ? spec.parent : undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('binders') || this.hasOwnProperty('binders'))) {
							this.binders = 'binders' in spec ? spec.binders : undefined;
						}
					} else {
						if (!(mixinExclusion.hasOwnProperty('parent') || this.hasOwnProperty('parent'))) {
							this.parent = undefined;
						}
						if (!(mixinExclusion.hasOwnProperty('binders') || this.hasOwnProperty('binders'))) {
							this.binders = undefined;
						}
					}
					InjectedClassMeta.$fieldInit.call(this, spec, mixinExclusion);
				};
				DIComponentMeta.$methods = {};
				$makeInterface(DIComponentMeta, function(instanceProto, staticProto) {
					var metaClass = new N4Interface({
						name: 'DIComponentMeta',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.DIComponentMeta',
						n4superType: undefined,
						allImplementedInterfaces: [
							'n4js.lang.N4Injector.InjectedClassMeta'
						],
						ownedMembers: [
							new N4DataField({
								name: 'parent',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'binders',
								isStatic: false,
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				$makeClass(_$, N4Object, [], {
					get: {
						value: function get___n4() {
							return this.fn();
						}
					},
					fn: {
						value: undefined,
						writable: true
					}
				}, {}, function(instanceProto, staticProto) {
					var metaClass = new N4Class({
						name: '_$',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector._$',
						n4superType: N4Object.n4type,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'fn',
								isStatic: false,
								annotations: []
							}),
							new N4Method({
								name: 'constructor',
								isStatic: false,
								jsFunction: instanceProto['constructor'],
								annotations: []
							}),
							new N4Method({
								name: 'get',
								isStatic: false,
								jsFunction: instanceProto['get'],
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				$makeClass(DIConfigurationError, Error, [], {}, {}, function(instanceProto, staticProto) {
					var metaClass = new N4Class({
						name: 'DIConfigurationError',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.DIConfigurationError',
						n4superType: undefined,
						allImplementedInterfaces: [],
						ownedMembers: [],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				$makeClass(DIUnsatisfiedBindingError, DIConfigurationError, [], {
					unsatisfiedBinding: {
						get: function getUnsatisfiedBinding___n4() {
							return this.binding;
						}
					},
					binding: {
						value: undefined,
						writable: true
					}
				}, {}, function(instanceProto, staticProto) {
					var metaClass = new N4Class({
						name: 'DIUnsatisfiedBindingError',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.DIUnsatisfiedBindingError',
						n4superType: DIConfigurationError.n4type,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'binding',
								isStatic: false,
								annotations: []
							}),
							new N4Method({
								name: 'constructor',
								isStatic: false,
								jsFunction: instanceProto['constructor'],
								annotations: []
							}),
							new N4Accessor({
								name: 'unsatisfiedBinding',
								getter: true,
								isStatic: false,
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: []
					});
					return metaClass;
				});
				Object.defineProperty(DIUnsatisfiedBindingError, '$di', {
					value: {
						superType: DIConfigurationError,
						fieldsInjectedTypes: []
					}
				});
				$makeClass(N4Injector, N4Object, [], {
					create: {
						value: function create___n4(ctor) {
							let cachedInstances = new Map();
							return this.internalCreate(ctor, this, cachedInstances);
						}
					},
					internalCreate: {
						value: function internalCreate___n4(ctor, delegate, cachedInstances) {
							if (!ctor) {
								throw new DIConfigurationError('Requested injection of undefined or null ctor.');
							}
							let fqn = ctor.n4type.fqn;
							if (!fqn) {
								throw new DIConfigurationError('Cannot resolve FQN for ' + ctor + '.');
							}
							if (fqn === N4Type.of(this).fqn) {
								let that = this;
								return that;
							}
							if (fqn === N4Provider.n4type.fqn) {
								let pMeta = Object.create(null);
								pMeta.type = ctor;
								return this.createAnonymousProvider(pMeta);
							}
							let pairInjectorBinding = this.findBinding(ctor);
							if (pairInjectorBinding) {
								let [
									injector,
									binder
								] = pairInjectorBinding;
								if (binder && injector) {
									return injector.createFromBinder(ctor, binder, delegate, cachedInstances);
								}
								throw new DIConfigurationError("Cannot obtain Injector->Binder pair");
							}
							if (this.declaredSingleton(ctor)) {
								let isBindingTarget = this.checkOwnBindingTargets(ctor);
								if (isBindingTarget) {
									return this.createNewInjected(ctor, delegate, cachedInstances);
								}
								let scopedInstance = this.findScopedInstanceInParentChain(ctor);
								if (scopedInstance) {
									return scopedInstance;
								}
								return this.getRootParent().createNewInjected(ctor, delegate, cachedInstances);
							}
							return this.createInstance(ctor, delegate, cachedInstances);
						}
					},
					checkOwnBindingTargets: {
						value: function checkOwnBindingTargets___n4(ctor) {
							if (!this.explicitBindings.size) {
								return false;
							}
							for(let bx of this.explicitBindings.values()) {
								let binderMeta = getBinderMeta(bx.constructor);
								if (binderMeta.bindings.some((b)=>b.to === ctor) || binderMeta.methodBindings.some((m)=>m.to === ctor)) {
									return true;
								}
							}
							return false;
						}
					},
					findScopedInstanceInParentChain: {
						value: function findScopedInstanceInParentChain___n4(ctor) {
							let key = getOFQN(ctor);
							if (this.scopedInstances.has(key)) {
								return this.scopedInstances.get(key);
							}
							if (this.parent) {
								if (this.parent.scopedInstances.has(key)) {
									return this.parent.scopedInstances.get(key);
								}
								return this.parent.findScopedInstanceInParentChain(ctor);
							}
						}
					},
					getRootParent: {
						value: function getRootParent___n4() {
							if (this.parent) {
								return this.parent.getRootParent();
							}
							return this;
						}
					},
					createInstance: {
						value: function createInstance___n4(ctor, delegate, cachedInstances) {
							if (hasDIMeta(ctor)) {
								return this.createNewInjected(ctor, delegate, cachedInstances);
							}
							if (!hasDIMeta(ctor)) {
								return this.createNewNotInjected(ctor);
							}
							throw new DIConfigurationError('Type ' + getOFQN(ctor) + ' could not be created.');
						}
					},
					createNewNotInjected: {
						value: function createNewNotInjected___n4(ctor) {
							let typeInstance = this.createNew(ctor, []);
							if (!typeInstance) {
								throw new DIConfigurationError('Could not create valid instance for ' + getOFQN(ctor) + '.');
							}
							return typeInstance;
						}
					},
					declaredSingleton: {
						value: function declaredSingleton___n4(ctor) {
							if (hasDIMeta(ctor)) {
								return getInjectedClassMeta(ctor).scope === "Singleton";
							}
							return false;
						}
					},
					findBinding: {
						value: function findBinding___n4(ctor) {
							let key = getOFQN(ctor);
							if (this.explicitBindings.has(key)) {
								return [
									this,
									this.explicitBindings.get(key)
								];
							}
							if (this.parent) {
								return this.parent.findBinding(ctor);
							}
						}
					},
					createFromBinder: {
						value: function createFromBinder___n4(ctor, binder, delegate, cachedInstances) {
							let bm = getBinderMeta(binder.constructor);
							let annotationMappings = bm.bindings.filter((k)=>k.from === ctor);
							if (annotationMappings.length > 1) {
								throw new Error("too many mappings for" + ctor);
							}
							if (annotationMappings.length === 1) {
								let target = annotationMappings[0].to;
								if (this === delegate) {
									if (this.scopedInstances.has(getOFQN(target))) {
										return this.scopedInstances.get(getOFQN(target));
									}
								}
								if (target === ctor) {
									return this.createInstance(ctor, delegate, cachedInstances);
								}
								return delegate.internalCreate(target, delegate, cachedInstances);
							}
							let methodMappings = bm.methodBindings.filter((k)=>k.to === ctor);
							if (methodMappings.length > 1) {
								throw new Error("too many mappings for" + ctor);
							}
							if (methodMappings.length === 1) {
								if (this === delegate) {
									if (this.scopedInstances.has(getOFQN(ctor))) {
										return this.scopedInstances.get(getOFQN(ctor));
									}
								}
								return this.createProvided(binder, methodMappings[0], delegate, cachedInstances);
							}
							throw new DIConfigurationError("trouble resolving binding for " + ctor);
						}
					},
					createNew: {
						value: function createNew___n4(ctor, parameters) {
							if (!ctor) {
								throw new DIConfigurationError("Tried to create instance from null or undefined ctor" + ctor);
							}
							if (!ctor.n4type.isClass) {
								if (ctor.n4type.isInterface) {
									throw new DIUnsatisfiedBindingError((ctor), 'No binding for ' + getOFQN(ctor) + ' interface');
								}
								if (ctor.n4type.isEnum) {
									throw new DIConfigurationError("Tried to create instance from enum" + getOFQN(ctor));
								}
							}
							return Reflect.construct(ctor, parameters);
						}
					},
					createFromInjectedTypeMeta: {
						value: function createFromInjectedTypeMeta___n4(meta, delegate, cachedInstances) {
							if (!meta.type) {
								throw new DIConfigurationError("DI meta information corrupted, no type available.");
							}
							if (meta.type.n4type.fqn === N4Provider.n4type.fqn) {
								if (!meta.typeVar) {
									throw new DIConfigurationError('Cannot create provider ' + meta.type + " typelet is " + meta.typeVar);
								}
								return this.createAnonymousProvider(meta.typeVar);
							}
							return this.internalCreate(meta.type, delegate, cachedInstances);
						}
					},
					createNewInjected: {
						value: function createNewInjected___n4(ctor, delegate, cachedInstances) {
							let ofqn = getOFQN(ctor);
							if (cachedInstances.has(ofqn)) {
								return cachedInstances.get(ofqn);
							}
							if (this.scopedInstances.has(ofqn)) {
								return this.scopedInstances.get(ofqn);
							}
							let ctorParams = this.getInjectorParams(ctor).map((fp)=>delegate.createFromInjectedTypeMeta(fp, delegate, new Map(cachedInstances)));
							let instance = this.createNew(ctor, ctorParams);
							cachedInstances.set(ofqn, instance);
							delegate.injectDataFields(instance, ctor, new Set(), delegate, cachedInstances);
							if (this.declaredSingleton(ctor)) {
								this.scopedInstances.set(ofqn, instance);
							}
							return instance;
						}
					},
					getInjectorParams: {
						value: function getInjectorParams___n4(type) {
							if (hasDIMeta(type)) {
								let meta = getInjectedClassMeta(type);
								if (meta.injectCtorParams) {
									return meta.injectCtorParams;
								}
								if (meta.superType) {
									return this.getInjectorParams(meta.superType);
								}
							}
							return [];
						}
					},
					injectDataFields: {
						value: function injectDataFields___n4(instance, type, usedNames, delegate, cachedInstances) {
							if (hasDIMeta(type)) {
								let meta = getInjectedClassMeta(type);
								meta.fieldsInjectedTypes.forEach((f)=>{
									if (!usedNames.has(f.name)) {
										usedNames.add(f.name);
										let instanceObj = instance;
										instanceObj[f.name] = delegate.createFromInjectedTypeMeta(f, delegate, new Map(cachedInstances));
									}
								});
								if (meta.superType) {
									delegate.injectDataFields(instance, meta.superType, usedNames, delegate, cachedInstances);
								}
							}
						}
					},
					createProvided: {
						value: function createProvided___n4(binder, info, delegate, cachedInstances) {
							let params = info.args.map((e)=>this.createFromInjectedTypeMeta(e, delegate, cachedInstances));
							let binderObj = binder;
							return (binderObj[info.name]).apply(binder, params);
						}
					},
					createAnonymousProvider: {
						value: function createAnonymousProvider___n4(meta) {
							let injector = this;
							let f;
							if (!meta.typeVar) {
								f = function() {
									return injector.internalCreate(meta.type, injector, new Map());
								};
							} else {
								f = (function() {
									let p = injector.createAnonymousProvider(meta.typeVar);
									return function() {
										return p;
									};
								})();
							}
							return new _$(f);
						}
					},
					isInjectorOf: {
						value: function isInjectorOf___n4(dic) {
							return this.dicInfo === getOFQN(dic);
						}
					},
					isCompatibleWith: {
						value: function isCompatibleWith___n4(dic) {
							return this.isInjectorOf(dic) || N4Injector.isParentCompatible(this, dic);
						}
					},
					canBeParentOf: {
						value: function canBeParentOf___n4(dic) {
							if (!hasDIMeta(dic)) {
								return false;
							}
							let expectedParent = getDIComponentMeta(dic).parent;
							return expectedParent ? this.isCompatibleWith(expectedParent) : false;
						}
					},
					explicitBindings: {
						value: undefined,
						writable: true
					},
					scopedInstances: {
						value: undefined,
						writable: true
					},
					dicInfo: {
						value: undefined,
						writable: true
					},
					parent: {
						value: undefined,
						writable: true
					}
				}, {
					prepareBindingsMap: {
						value: function prepareBindingsMap___n4(providedBinders, expectedBindersTypes) {
							let bindings = [];
							if (expectedBindersTypes) {
								let expectedBindersMap = new Map();
								expectedBindersTypes.forEach((eb)=>expectedBindersMap.set(getOFQN(eb), eb));
								providedBinders.forEach((bi)=>{
									if (bi) {
										let biType = bi.constructor;
										if (!expectedBindersMap.has(getOFQN(biType))) {
											throw new DIConfigurationError("provided Binder instance is not of any expected type");
										}
										bindings.push(bi);
										expectedBindersMap.delete(getOFQN(bi.constructor));
									}
								});
								expectedBindersMap.forEach((bt)=>{
									let _b = Reflect.construct(bt, []);
									bindings.push(_b);
								});
							}
							let bindingsMap = new Map();
							bindings.forEach((binder)=>{
								let binderType = binder.constructor;
								if (hasDIMeta(binderType)) {
									let meta = getBinderMeta(binderType);
									meta.bindings.forEach((b)=>bindingsMap.set(getOFQN(b.from), binder));
									meta.methodBindings.forEach((b)=>bindingsMap.set(getOFQN(b.to), binder));
								}
							});
							return bindingsMap;
						}
					},
					expectedParent: {
						value: function expectedParent___n4(ctorDIC) {
							let parent = getDIComponentMeta(ctorDIC).parent;
							if (!parent) {
								return void (0);
							}
							return getOFQN(parent);
						}
					},
					checkParent: {
						value: function checkParent___n4(dic, parent) {
							let expectedParent = getDIComponentMeta(dic).parent;
							if (parent) {
								if (!expectedParent) {
									throw new DIConfigurationError('Injector of ' + getOFQN(dic) + ' expects no parent, but was given ' + parent.dicInfo + '.');
								}
								if (!parent.isCompatibleWith(expectedParent)) {
									throw new DIConfigurationError('Injector of ' + getOFQN(dic) + ' expects parent compatible with ' + expectedParent + ', but was given incompatible ' + parent.dicInfo + '.');
								}
							} else {
								if (expectedParent) {
									throw new DIConfigurationError('Injector of ' + getOFQN(dic) + ' parent compatible with ' + expectedParent + ', but no injector was passed.');
								}
							}
						}
					},
					getMetaData: {
						value: function getMetaData___n4(type) {
							if (!type) {
								throw new DIConfigurationError("cannot create N4Injector without DIComponent type");
							}
							if (!hasDIMeta(type)) {
								throw new DIConfigurationError("provided DIComponent did not had proper di meta information");
							}
							return getDIComponentMeta(type);
						}
					},
					of: {
						value: function of___n4(type, parent, ...providedBinders) {
							let dicMeta = N4Injector.getMetaData(type);
							N4Injector.checkParent(type, parent);
							let bindings = N4Injector.prepareBindingsMap(providedBinders, dicMeta.binders);
							return new N4Injector(getOFQN(type), bindings, parent);
						}
					},
					isParentCompatible: {
						value: function isParentCompatible___n4(injector, dic) {
							if (injector.parent) {
								let inj = injector.parent;
								return inj.isInjectorOf(dic) || N4Injector.isParentCompatible(inj, dic);
							}
							return false;
						}
					}
				}, function(instanceProto, staticProto) {
					var metaClass = new N4Class({
						name: 'N4Injector',
						origin: 'n4js.lang',
						fqn: 'n4js.lang.N4Injector.N4Injector',
						n4superType: N4Object.n4type,
						allImplementedInterfaces: [],
						ownedMembers: [
							new N4DataField({
								name: 'explicitBindings',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'scopedInstances',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'dicInfo',
								isStatic: false,
								annotations: []
							}),
							new N4DataField({
								name: 'parent',
								isStatic: false,
								annotations: [
									new N4Annotation({
										name: 'Final',
										details: []
									})
								]
							}),
							new N4Method({
								name: 'constructor',
								isStatic: false,
								jsFunction: instanceProto['constructor'],
								annotations: []
							}),
							new N4Method({
								name: 'create',
								isStatic: false,
								jsFunction: instanceProto['create'],
								annotations: []
							}),
							new N4Method({
								name: 'internalCreate',
								isStatic: false,
								jsFunction: instanceProto['internalCreate'],
								annotations: []
							}),
							new N4Method({
								name: 'checkOwnBindingTargets',
								isStatic: false,
								jsFunction: instanceProto['checkOwnBindingTargets'],
								annotations: []
							}),
							new N4Method({
								name: 'findScopedInstanceInParentChain',
								isStatic: false,
								jsFunction: instanceProto['findScopedInstanceInParentChain'],
								annotations: []
							}),
							new N4Method({
								name: 'getRootParent',
								isStatic: false,
								jsFunction: instanceProto['getRootParent'],
								annotations: []
							}),
							new N4Method({
								name: 'createInstance',
								isStatic: false,
								jsFunction: instanceProto['createInstance'],
								annotations: []
							}),
							new N4Method({
								name: 'createNewNotInjected',
								isStatic: false,
								jsFunction: instanceProto['createNewNotInjected'],
								annotations: []
							}),
							new N4Method({
								name: 'declaredSingleton',
								isStatic: false,
								jsFunction: instanceProto['declaredSingleton'],
								annotations: []
							}),
							new N4Method({
								name: 'findBinding',
								isStatic: false,
								jsFunction: instanceProto['findBinding'],
								annotations: []
							}),
							new N4Method({
								name: 'createFromBinder',
								isStatic: false,
								jsFunction: instanceProto['createFromBinder'],
								annotations: []
							}),
							new N4Method({
								name: 'createNew',
								isStatic: false,
								jsFunction: instanceProto['createNew'],
								annotations: []
							}),
							new N4Method({
								name: 'createFromInjectedTypeMeta',
								isStatic: false,
								jsFunction: instanceProto['createFromInjectedTypeMeta'],
								annotations: []
							}),
							new N4Method({
								name: 'createNewInjected',
								isStatic: false,
								jsFunction: instanceProto['createNewInjected'],
								annotations: []
							}),
							new N4Method({
								name: 'getInjectorParams',
								isStatic: false,
								jsFunction: instanceProto['getInjectorParams'],
								annotations: []
							}),
							new N4Method({
								name: 'injectDataFields',
								isStatic: false,
								jsFunction: instanceProto['injectDataFields'],
								annotations: []
							}),
							new N4Method({
								name: 'createProvided',
								isStatic: false,
								jsFunction: instanceProto['createProvided'],
								annotations: []
							}),
							new N4Method({
								name: 'createAnonymousProvider',
								isStatic: false,
								jsFunction: instanceProto['createAnonymousProvider'],
								annotations: []
							}),
							new N4Method({
								name: 'prepareBindingsMap',
								isStatic: true,
								jsFunction: staticProto['prepareBindingsMap'],
								annotations: []
							}),
							new N4Method({
								name: 'expectedParent',
								isStatic: true,
								jsFunction: staticProto['expectedParent'],
								annotations: []
							}),
							new N4Method({
								name: 'checkParent',
								isStatic: true,
								jsFunction: staticProto['checkParent'],
								annotations: []
							}),
							new N4Method({
								name: 'getMetaData',
								isStatic: true,
								jsFunction: staticProto['getMetaData'],
								annotations: []
							}),
							new N4Method({
								name: 'of',
								isStatic: true,
								jsFunction: staticProto['of'],
								annotations: []
							}),
							new N4Method({
								name: 'isInjectorOf',
								isStatic: false,
								jsFunction: instanceProto['isInjectorOf'],
								annotations: []
							}),
							new N4Method({
								name: 'isCompatibleWith',
								isStatic: false,
								jsFunction: instanceProto['isCompatibleWith'],
								annotations: []
							}),
							new N4Method({
								name: 'isParentCompatible',
								isStatic: true,
								jsFunction: staticProto['isParentCompatible'],
								annotations: []
							}),
							new N4Method({
								name: 'canBeParentOf',
								isStatic: false,
								jsFunction: instanceProto['canBeParentOf'],
								annotations: []
							})
						],
						consumedMembers: [],
						annotations: [
							new N4Annotation({
								name: 'Final',
								details: []
							})
						]
					});
					return metaClass;
				});
			}
		};
	});
})(typeof module !== 'undefined' && module.exports ? require('n4js-node').System(require, module) : System);
//# sourceMappingURL=N4Injector.map
