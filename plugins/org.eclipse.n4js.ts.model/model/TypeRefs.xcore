/**
 * Copyright (c) 2016 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */
@Ecore(nsURI="http://www.eclipse.org/n4js/ts/TypeRefs")
@GenModel(fileExtensions="n4trs",
// modelPluginID isn't strictly necessary but causes some trouble
//	modelPluginID="org.eclipse.n4js.ts.model",
	rootExtendsClass="org.eclipse.n4js.utils.emf.ProxyResolvingEObjectImpl",
	modelDirectory="/org.eclipse.n4js.ts.model/emf-gen",
	forceOverwrite="true",
	updateClasspath="false",
	complianceLevel="11.0",
	copyrightFields="false",
	// both copyrightText and documentation are required to align the output of the MWE2 and incremental builder (see GH-841)
	copyrightText="Copyright (c) 2016 NumberFour AG.\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nwhich accompanies this distribution, and is available at\nhttp://www.eclipse.org/legal/epl-v10.html\n\nContributors:\n  NumberFour AG - Initial API and implementation",
	documentation="*\nCopyright (c) 2016 NumberFour AG.\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nwhich accompanies this distribution, and is available at\nhttp://www.eclipse.org/legal/epl-v10.html\n * Contributors:\n  NumberFour AG - Initial API and implementation",
	language="")
package org.eclipse.n4js.ts.typeRefs

import java.util.UUID
import org.eclipse.n4js.ts.types.AnyType
import org.eclipse.n4js.ts.types.ContainerType
import org.eclipse.n4js.ts.types.ModuleNamespaceVirtualType
import org.eclipse.n4js.ts.types.TFormalParameter
import org.eclipse.n4js.ts.types.TFunction
import org.eclipse.n4js.ts.types.TN4Classifier
import org.eclipse.n4js.ts.types.TStructMember
import org.eclipse.n4js.ts.types.TStructuralType
import org.eclipse.n4js.ts.types.Type
import org.eclipse.n4js.ts.types.TypeVariable
import org.eclipse.n4js.ts.types.TypingStrategy
import org.eclipse.n4js.ts.types.UndefinedType
import org.eclipse.n4js.ts.types.internal.WildcardAsStringUtils

type UUID wraps UUID

/*
 * Base class for all things that can provide a version. The returned value will be 0 in any language that does not
 * support versions. In those languages that do support versions, the return value depends on the semantics of the
 * actual subclass and how it implements the getVersion method.
 *
 * All type references and all types extend this class. In addition, some AST nodes such as IdentifierRef and
 * N4IDLClassDeclaration also extend this class.
 *
 * Type references generally delegate a call to getVersion to the type that they reference (via declaredType).
 * Exceptions are BoundThisTypeRef, which delegates to actualThisTypeRef, and ParameterizedTypeRef, which will return
 * the requested version if the user provided one.
 *
 * Types usually return 0 unless they are explicitly versionable, in which case they return the declared version.
 * In N4IDL, this only applies to TClassifier, which returns the version that was declared by the user (as set by the
 * types builder).
 *
 * For AST nodes, the return value depends highly on the type of the node itself. For example, the IdentifierRef returns
 * the explicitly requested version if the user provided one, otherwise it returns 0. For an N4IDLClassDeclaration,
 * getVersion returns the version that was declared by the user for that class.
 *
 * It was decided that TypeRef and Type should extend Versionable to avoid switching on the type of a the Type or
 * TypeRef instance under consideration. This is possible since 0 is a sensible default for unversioned objects.
 */
abstract class Versionable {
	op int getVersion() {
		return 0
	}
}

/*
 * Optional field strategy enum defines three strategies for handling optional fields while checking structural subtypes.
 * The optional field strategy is calculated based on the kind of AST node. Each {@code TypeRef} is associated with an optional field strategy.
 * <p>
 * It is important to note that this optional field strategy is introduced to as a workaround to solve the transitivity problem with structural subtyping
 * in the presence of optional fields. As opposed to e.g. typing strategy, the optional field strategy is NOT passed through the type system in anyway.
 * <p>
 * For further details, see IDE-2405, GHOLD-411.
 */
enum OptionalFieldStrategy {
	/** Default: optionality is turned of, e.g. both fields and accessors are mandatory */
	^OFF = 0
	/** Only getters are optional */
	GETTERS_OPTIONAL = 1
	/** Both fields and accessors are optional */
	FIELDS_AND_ACCESSORS_OPTIONAL = 2
}

/*
 * Base class for all type references
 */
abstract class TypeRef extends TypeArgument, Versionable {

	/*
	 * <b>SHOULD NOT BE USED, EXCEPT FOR DECLARATION OF OPTIONAL RETURN VALUES</b>
	 * <p>
	 * Represents the old ? after a type reference for defining optional fields / return values. At the moment, this is
	 * used only for declaring the return value of a function optional. In the future, this might be used for
	 * undefined/null-analysis. For example, <code>string?</code> might be syntactic sugar for
	 * <code>string|undefined</code>.
	 */
	boolean followedByQuestionMark

	/*
	 * Returns all type modifiers of the receiving type reference as a string, similar to N4JS syntax. This method is
	 * called by subclasses in overridden method. Currently, the <code>+</code> for dynamic is the only existing type
	 * modifier.
	 */
	op String getModifiersAsString() {
		 return "";
	}
	/*
	 * Returns true if the type referenced is either class which is declared final, an enum or a primitive. This is needed in case of type
	 * casts, for example.
	 * <p>
	 * The method is robust, if declared type is null, false is returned.
	 */
	op boolean isFinalByType() {
		val dtype = declaredType;
		return dtype!==null && dtype.final
	}

	/*
	 * Tells if this type reference has a declared type which is "array like" as defined by {@link Type#isArrayLike()}.
	 */
	op boolean isArrayLike() {
		val dtype = declaredType;
		return dtype!==null && dtype.isArrayLike;
	}

	/* Tells whether the receiving type reference is an {@link UnknownTypeRef}. */
	op boolean isUnknown() {
		return false;
	}

	/*
	 * Convenience method, flag indicating whether user can add properties to the instance not defined in the type.
	 */
	op boolean isDynamic() {
		return false
	}
	/*
	 * Convenience method, flag indicating whether the type reference is an existential type created on the fly
	 * by the type inferencer from parameterized types with wildcards.
	 * This returns false for all type references except {@link ExistentialTypeRef}
	 */
	op boolean isExistential() {
		return false
	}
	/*
	 * Convenience method, returns true if and only if the referenced type is generic, i.e. declared type variables.
	 * Note that it may be possible that the referenced type is generic, but the reference is not parameterized
	 * (raw reference), but not vice versa.
	 */
	op boolean isGeneric() {
		return false;
	}
	/*
	 * Convenience method, returns true if and only if the reference has type arguments. Note that it may be possible that
	 * the referenced type is generic, but the reference is not parameterized (raw reference), but not vice versa.
	 */
	op boolean isParameterized() {
		return false;
	}
	/*
	 * Convenience method, returns true if and only if the referenced type is generic <em>and</em> the reference has
	 * fewer type arguments than the number of type parameters of the referenced type.<p>
	 * Note that N4JS does not allow raw type references as in Java, for example. However, raw type references can
	 * occur due to (1) a broken AST (2) during type inference in InferenceContext (when deriving constraints from
	 * ClassifierTypeRefs) and (3) bugs in the type system and other internal code.
	 */
	op boolean isRaw() {
		return false;
	}
	/*
	 * Convenience method to avoid type casts, does return null except type ref is a wildcard.
	 */
	op ParameterizedTypeRef getDeclaredUpperBound() {
		return null
	}
	/*
	 * Convenience method to avoid type casts, does return null except type ref is a wildcard.
	 */
	op ParameterizedTypeRef getDeclaredLowerBound() {
		return null
	}
	/*
	 * Convenience method to avoid type casts, does return unmodifiable empty list for all type references except parameterized type refs.
	 */
	op TypeArgument[] getTypeArgs() {
		return emptyEList
	}
	/*
	 * Convenience method, returns the type expression, usually the type name, as a string. The
	 * returned string representation usually reflect the N4JS syntax. Basically used for testing.
	 * As the returned string is used for comparison in tests, this method should not be changed.
	 * This method actually overrides {@link TypeArgument#getTypeRefAsString()}.
	 */
	op String getTypeRefAsString() {
	}
//	op String getTypeRefAsHTML() {
//		return UtilN4.sanitizeForHTML(getTypeRefAsString());
//	}
	op String toString() {
		return getTypeRefAsString();
	}
	/* Convenience method, returns only true for parameterized type refs if the declared type is any */
	op boolean isTopType() {
		return declaredType instanceof AnyType
	}
	/* Convenience method, returns only true for parameterized type refs if the declared type is undefined */
	op boolean isBottomType() {
		return declaredType instanceof UndefinedType
	}
	/**
	 * Returns the typing strategy, either the use or def site, usually NOMINAL.
	 */
	op TypingStrategy getTypingStrategy() {
		return TypingStrategy.NOMINAL
	}

	/**
	 * Convenience method, returns empty list for simply reference by default.
	 * Overridden in {@link ParameterizedTypeRefStructural}
	 */
	op TStructMember[] getStructuralMembers() {
		return emptyEList();
	}
	/*
	 * Returns true if type ref is structural. This is different from {@link #getTypingStrategy}, which
	 * returns true if either use or def site structural typing is true.
	 */
	op boolean isUseSiteStructuralTyping() {
		return false
	}
	/*
	 * Returns true if type is defined structurally defined. This is different from {@link #getTypingStrategy}, which
	 * returns true if either use or def site structural typing is true.
	 */
	op boolean isDefSiteStructuralTyping() {
		return false
	}

	/*
	 * Tells the optional field strategy.
	 * Used to activate the special semantics of optional fields in certain cases.
	 */
	 /* @see ParameterizedTypeRef#astOptionalFieldStrategy */
	op OptionalFieldStrategy getASTNodeOptionalFieldStrategy() {
		return OptionalFieldStrategy.OFF;
	}

	/*
	 * Override Versioned#getVersion()
	 */
	op int getVersion() {
		if (declaredType !== null) declaredType.version else 0
	}
}

abstract class StaticBaseTypeRef extends TypeRef {
	// pulled nullModififer and UndefModdifier up as part of IDEBUG-596
}

abstract class BaseTypeRef extends StaticBaseTypeRef {
	/*
	 * Flag indicating that new properties can be dynamically added to the type. Default value is false.
	 */
	boolean dynamic = "false"
	/*
	 * Override for {@link TypeRef#getModifiersAsString()}.
	 */
	op String getModifiersAsString() {
		return (if (dynamic) {
			"+"
		} else {
			""
		}) + super.getModifiersAsString();
	}
}

/*
 * Base class for type references containing an ordered set of other types, that is
 * {@link UnionTypeExpression} and {@link IntersectionTypeExpression}.
 */
abstract class ComposedTypeRef extends StaticBaseTypeRef {
	/*
	 * Union type cannot be marked as dynamic
	 */
	op boolean isDynamic() {
		return false;
	}
	contains TypeRef[] typeRefs
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}, only returns list of composed members, to be called by subclass.
	 */
	op String getTypeRefAsString() {
		return "{" + typeRefs.map[it.typeRefAsString].join(',') + "}" + getModifiersAsString();
	}
}

/*
 * Union type
 */
class UnionTypeExpression extends ComposedTypeRef {
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return "union" + super.getTypeRefAsString();
	}
}

/*
 * Intersection type can be specified by the user directly in terms of an intersection type expression
 * or in the context of a type variable. It may also be inferred by the type system.
 */
class IntersectionTypeExpression extends ComposedTypeRef {
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return "intersection" + super.getTypeRefAsString();
	}
}

/*
 * Unbound this type reference.
 */
// TODO kick me!
class ThisTypeRef extends BaseTypeRef {
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return "this" + getModifiersAsString();
	}
	/**
	 * Always returns NOMINAL for simple this type references
	 */
	op TypingStrategy getTypingStrategy() {
		return TypingStrategy.NOMINAL
	}
	/**
	 * Convenience method, returns empty list for simply reference by default.
	 * Overridden in {@link ParameterizedTypeRefStructural}
	 */
	op TStructMember[] getStructuralMembers() {
		return emptyEList();
	}
	/*
	 * Always returns false for simple this type references
	 */
	op boolean isUseSiteStructuralTyping() {
		return false
	}
}

class  ThisTypeRefNominal extends ThisTypeRef {
}

class  ThisTypeRefStructural extends ThisTypeRef, StructuralTypeRef {
	/*
	 * The defined (declared or inferred) typing strategy on use site, nominal typing by default. Could be changed to structural or structural
	 * field (via tilde or tilde-tilde operators).
	 */
	TypingStrategy definedTypingStrategy
	/**
	 * Returns the actual typing strategy, that is either the defined typing strategy of the reference, or the typing strategy of the
	 * actual this type.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			return TypingStrategy.NOMINAL
		}
		return definedTypingStrategy;
	}
	op void setTypingStrategy(TypingStrategy typingStrategy) {
		definedTypingStrategy = typingStrategy
	}
	/*
	 * Convenience method, returns true if typingStrategy is neither NOMINAL nor DEFAULT
	 */
	op boolean isUseSiteStructuralTyping() {
		return typingStrategy !== TypingStrategy.NOMINAL && typingStrategy !== TypingStrategy.DEFAULT
	}
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return typingStrategy + "this" + getModifiersAsString();
	}
}

/*
 * Reference to this type actually bound to a concrete type,
 * this is only done by the type system and not by a user declaration.
 */
class BoundThisTypeRef extends ThisTypeRef, StructuralTypeRef {
	contains ParameterizedTypeRef actualThisTypeRef
	/*
	 * The defined (declared or inferred) typing strategy on use site, nominal typing by default. Could be changed to structural or structural
	 * field (via tilde or tilde-tilde operators).
	 */
	TypingStrategy definedTypingStrategy
	/**
	 * Returns the actual typing strategy, that is either the defined typing strategy of the reference, or the typing strategy of the
	 * actual this type.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			return actualThisTypeRef.typingStrategy;
		} else {
			return definedTypingStrategy
		}
	}
	op void setTypingStrategy(TypingStrategy typingStrategy) {
		definedTypingStrategy = typingStrategy;
	}
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return typingStrategy + "this[" + actualThisTypeRef.getTypeRefAsString() + "]" + getModifiersAsString();
	}
	op ParameterizedTypeRef getDeclaredUpperBound() {
		return actualThisTypeRef;
	}
	/*
	 * Convenience method, returns true if typingStrategy of the declared type is STRUCTURAL
	 */
	op boolean isDefSiteStructuralTyping() {
		if (actualThisTypeRef instanceof TN4Classifier) {
			return (actualThisTypeRef as TN4Classifier).typingStrategy === TypingStrategy.STRUCTURAL
		}
		if (actualThisTypeRef instanceof TStructuralType) {
			return true;
		}
		return false
	}
	/**
	 * Returns true if defined typing strategy neither DEFAULT nor NOMINAL.
	 */
	op boolean isUseSiteStructuralTyping() {
		return definedTypingStrategy !== TypingStrategy.DEFAULT &&
			definedTypingStrategy !== TypingStrategy.NOMINAL
	}
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}

	/*
	 * Override VersionedElement#getVersion() to return the version of the actual this type reference.
	 */
	op int getVersion() {
		actualThisTypeRef.version
	}
}

/**
 * Type reference to declared types which may be parameterized. This is
 * probably the most often used type reference. This base version always
 * uses nominal typing on use site, there is a sub class
 * {@link ParameterizedTypeRefStructural} which support structural typing
 * on use site. However, the latter is not allowed everywhere.
 */
class ParameterizedTypeRef extends BaseTypeRef {
	refers Type declaredType
	contains TypeArgument[] typeArgs
	boolean arrayTypeExpression = "false"
	boolean iterableTypeExpression = "false"

	/*
	 * If and only if this {@code ParameterizedTypeRef} is used as an AST node and the declared type is, in the source
	 * code, referred to via the namespace of a namespace import, then this is non-null and points to that namespace.
	 */
	refers transient ModuleNamespaceVirtualType astNamespace

	/* @see TypeRef#getASTOptionalFieldStrategy() */
	transient OptionalFieldStrategy aSTNodeOptionalFieldStrategy

	/*
	 * The defined (declared or inferred) typing strategy on use site, nominal typing by default. Could be changed to structural or structural
	 * field (via tilde or tilde-tilde operators).
	 */
	TypingStrategy definedTypingStrategy

	/**
	 * Returns the actual typing strategy, that is either the defined typing strategy, or the typing strategy of the declared type.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			if (isDefSiteStructuralTyping) {
				return TypingStrategy.STRUCTURAL
			} else {
				return TypingStrategy.NOMINAL
			}
		}
		return definedTypingStrategy
	}
	/* @see TypeArgument#containsWildcard() */
	op boolean containsWildcards() {
		return (typeArgs.empty && ! declaredType.generic) || typeArgs.exists[it.containsWildcards]
	}
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return declaredType?.rawTypeAsString
		+ if (version > 0) { "#" + version } else { "" }
		+ (if (typeArgs.empty) {
			""
		} else {
			"<" + typeArgs.map[typeRefAsString].join(",") + ">"
		})
		+ getModifiersAsString();
	}
	/*
	 * Convenience method, returns true if type reference contains type arguments.
	 */
	op boolean isParameterized() {
		return ! typeArgs.empty;
	}
	/*
	 * Delegates to {@link Type.isGeneric()}
	 */
	op boolean isGeneric() {
		return declaredType!==null && declaredType.generic;
	}
	/*
	 * Overrides {@link TypeRef#isRaw()}.
	 */
	op boolean isRaw() {
		return isGeneric() && typeArgs.size<declaredType.typeVars.size;
	}
	/*
	 * @see TypeArgument#containsUnboundTypeVariables()
	 */
	op boolean containsUnboundTypeVariables() {
		return declaredType instanceof TypeVariable // ok, that's simple
		|| (!parameterized && declaredType.generic) // no type args, type variable is indirectly referenced from raw type
		|| typeArgs.exists[it.containsUnboundTypeVariables] // transitively
	}

	/*
	 * Convenience method, returns true if typingStrategy is neither NOMINAL nor DEFAULT, and if is is not
	 * definition site.
	 */
	op boolean isUseSiteStructuralTyping() {
		return definedTypingStrategy !== TypingStrategy.NOMINAL &&
			definedTypingStrategy !== TypingStrategy.DEFAULT
	}
	/*
	 * Convenience method, returns true if typingStrategy of the declared type is STRUCTURAL or in case of Object literals.
	 */
	op boolean isDefSiteStructuralTyping() {
		if (declaredType instanceof TN4Classifier) {
			return (declaredType as TN4Classifier).typingStrategy === TypingStrategy.STRUCTURAL
		}
		if (declaredType instanceof TStructuralType) {
			return true;
		}
		return false
	}
}

/**
 * There are three use cases:
 * <ol>
 * <li>the StructuralTypeRef plays the role of an AST node,
 * <li>the StructuralTypeRef is a copy of an AST node (maybe modified),
 * <li>the StructuralTypeRef was created programmatically.
 * </ol>
 * The handling of structural members defined in with-clauses is a bit tricky and different across
 * these use cases. In case 1. the StructuralTypeRef may contain structural members in 'astStructuralMembers'
 * and the types builder will have created a TStructuralType in the module (referred to by property
 * 'structuralType'). In case 2. it will point to the TStructuralType in the module via 'structuralType'
 * (and useless copies of the original astStructuralMembers may be lying around in 'astStructuralMembers'
 * -> ignore them!). In case 3. it has only 'genStructuralMembers'.
 * <p>
 * When copying StructuralTypeRefs, the property 'astStructuralMembers' need not be copied because it only contains
 * members if the StructuralTypeRef is an AST node, but then the types builder will have created a TStructuralType
 * with the same members that is referred to via cross-reference property 'structuralType', so copying the value of
 * that cross-reference is sufficient. It is best to always use one of the copy methods in TypeUtils, i.e. TypeUtils#copy(),
 * TypeUtils#copyIfContained(), etc. because they take of that.
 * <p>
 * Note: copying StructuralTypeRefs directly with {@link EcoreUtil#copy(EObject)}, etc. won't do any harm; you just
 * have unnecessary members contained in your copied typeRef.
 */
abstract class StructuralTypeRef {
	/*
	 * If and only if the StructuralTypeRef is used as an AST node, this property holds the structural
	 * members and 'genStructuralMembers' is empty and 'structuralType' is <code>null</code>.
	 * This occurs in a situation like this:
	 * <pre>
	 * class C { ... }
	 * var ~C with { number n; } myC_withN;
	 * </pre>
	 * Members should <b>never</b> be added to this property, except by the parser (in file N4JS.xtext).
	 */
	contains TStructMember[] astStructuralMembers
	/*
	 * If this StructuralTypeRef is used inside a TModule, this property <em>refers</em> to the TStructuralType that
	 * contains the structural members. In this case, properties 'astStructuralType' and 'genStructuralType'
	 * are empty.
	 */
	refers TStructuralType structuralType
	/*
	 * If a StructuralTypeRef with additional structural members is to be generated programmatically <em>without
	 * having a TModule</em> at hand, then the structural members can be added to this property. If a TModule is
	 * available, it is better to create a TStructuralType and let the StructuralTypeRef refer to that via property
	 * 'structuralType'.
	 * <p>
	 * This property should be used only as a last resort if no containing TModule is available.
	 */
	contains TStructMember[] genStructuralMembers
	/*
	 * Postponed substitutions of type variables in the structural members of the receiving StructuralTypeRef.
	 * <p>
	 * When performing a type variable substitution on a StructuralTypeRef, we do not copy and change the
	 * structural members but instead postpone substitution until the types stored in the members (e.g. type
	 * of a field, return type of a method) are actually required and perform the substitution then. To do
	 * this, we store the mappings from type variables to type arguments at the time of the first substitution
	 * in this property and restore them into the rule environment when obtaining a type from a structural member.
	 *
	 * @see GenericsComputer#substTypeVariablesInStructuralMembers(RuleEnvironment,StructuralTypeRef)
	 * @see GenericsComputer#storePostponedSubstitutionsIn(RuleEnvironment,StructuralTypeRef)
	 * @see GenericsComputer#restorePostponedSubstitutionsFrom(RuleEnvironment,StructuralTypeRef)
	 */
	contains TypeVariableMapping[] postponedSubstitutions
	/**
	 * Returns the actual typing strategy.
	 */
	op TypingStrategy getTypingStrategy()
	/**
	 * Sets the actual typing strategy, required for copy operation.
	 */
	op void setTypingStrategy(TypingStrategy typingStrategy)
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}
	/*
	 * Returns true iff there exists a type variable mapping for 'typeVar' in property 'typeVarMappings'.
	 */
	op boolean hasPostponedSubstitutionFor(TypeVariable typeVar) {
		return postponedSubstitutions.exists[m| m?.typeVar === typeVar];
	}
}

/**
 * A {@link ParameterizedTypeRef} with use site structural typing. Note
 * that use site structural typing is not allowed everywhere. E.g., it
 * is not allowed for specifying super types of a class, interface or role.
 * It is mainly used for the type of formal parameters.
 */
class ParameterizedTypeRefStructural extends ParameterizedTypeRef, StructuralTypeRef {
	/**
	 * Returns the actual typing strategy.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			return TypingStrategy.STRUCTURAL
		} else {
			return definedTypingStrategy
		}
	}
	/**
	 * Sets the actual typing strategy, required for copy operation.
	 */
	op void setTypingStrategy(TypingStrategy typingStrategy) {
		if (typingStrategy == TypingStrategy.NOMINAL) {
			throw new IllegalArgumentException("cannot set structural type reference to nominal")
		}
		definedTypingStrategy = typingStrategy;
	}
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return typingStrategy + declaredType?.rawTypeAsString + (if (typeArgs.empty) {
			""
		} else {
			"<" + typeArgs.map[typeRefAsString].join(",") + ">"
		}) + (if (structuralMembers.empty) {
			""
		} else {
			" with { " + structuralMembers.map[memberAsString].join("; ") + " }" +
			(if (postponedSubstitutions.empty) "" else " [[" + postponedSubstitutions.map[it.typeVar.typeAsString + "->" + it.typeArg.typeRefAsString].join(", ") + "]]")
		});
	}
}

/*
 * Existential type references are parameterized type references inferred from wildcards and
 * bound to type variables during substitution.
 * <p>
 * E.g., the type {@code G<? extends A>} implicitly defines an
 * existential type <i>E</i>, which is a subtype of A, but for all other
 * subtypes <i>S</i> of A, neither <i>E&lt;:S</i> nor <i>S&lt;:E</i> is true.
 * Same is true for wildcards without bounds.
 * <p>
 * Example: Assuming that both B and C extends A, and the following variable declarations:
 * <pre>
 * var G&lt;? extends A> g1 = new G&lt;B>();
 * var G&lt;? extends A> g2 = new G&lt;C>();
 * var G&lt;?> g = new G&lt;A>
 * </pre>
 * With the typical getter/setter methods in G (T get(), set(T)), the following
 * calls must not be allowed:
 * <pre>
 * g1.set(g2.get()); // cannot convert C to B
 * g2.set(g.get());  // cannot convert A to C
 * </pre>
 * Note that the explanation in the example requires knowledge of the actual type
 * which is usually not available at compile time. (That is, in the example, the
 * declared type of g1, g2, and g3 could have been specified without wildcards).
 * <p>
 * For details, see<br/>
 * S. Wehr and P. Thiemann: Subtyping Existential Types. 2008, <a href="http://www.stefanwehr.de/publications/Wehr_Subtyping_existential_types.pdf">PDF</a><br/>
 * N. Cameron, S. Drossopoulou, and E. Ernst: A Model for Java with Wildcards. Springer, 2008,<a href="https://doi.org/10.1007/978-3-540-70592-5_2">DOI</a><br/>
 * M. Torgersen, E. Ernst, and C. P. Hansen: Wild FJ. 2005
 */
class ExistentialTypeRef extends TypeRef {
	/*
	 * Globally unique identifier of this capture. Required due to the copying semantics of
	 * {@code TypeRef}s: unlike types, type references may be copied at will and therefore a
	 * plain POJO identity comparison of two ExistentialTypeRefs cannot be used to check if
	 * two {@code ExistentialTypeRef}s refer to the same capture.
	 */
	UUID ^id
	/*
	 * If true, this existential type roughly behaves like the wildcard it was created from.
	 * For detailed semantics see {@code SubtypeJudgment#applyExistentialTypeRef_Left|Right()}.
	 */
	boolean reopened

	refers Wildcard wildcard

	/*
	 * Always returns true for existential types.
	 */
	op boolean isExistential() {
		return true
	}
	/*
	 * Always returns true for existential types.
	 */
	op boolean isGeneric() {
		return true;
	}
	/*
	 * Always returns true for existential types.
	 */
	op boolean isParameterized() {
		return true;
	}
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return getWildcard?.typeRefAsString
	}
}

/*
 * Unknown type references are the result of an unresolved link or other form of error.
 * No follow up errors should be produced for such unknown type references.
 * <pre>
 * var x = doesNotExist // error here; type of x will be UnknownTypeRef
 * x.cannotKnowIfThisExists // no error here
 * var s: String = x // no error here, either
 * x = s // nor here
 * </pre>
 * Because {@code UnknownTypeRef}s suppress consequential errors, they must never
 * appear in an N4JSResource that does not have any original parse or validation errors!
 */
class UnknownTypeRef extends TypeRef {
	op boolean isUnknown() {
		return true;
	}
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return "[unknown]";
	}
}

/**
 * A reference to the constructor of a type. The constructor
 * can be used in a NewExpression. It is a subtype of the equivalent
 * ClassifierTypeRef.
 */
class TypeTypeRef extends BaseTypeRef {
	contains TypeArgument typeArg
	/*
	 * Tells if this {@link TypeTypeRef} is declared to be a reference to a constructor. This is the case if, in the
	 * source code, keyword {@code constructor} has been used instead of keyword {@code type}:
	 * <pre>
	 * type{C} // flag will be false
	 * constructor{C} // flag will be true
	 * </pre>
	 */
	boolean constructorRef
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		val kwd = if (isConstructorRef) "constructor" else "type";
		val refName = if (null === getTypeArg) '' else getTypeArg.typeRefAsString;
		return kwd + "{" + refName + "}" + getModifiersAsString();
	}

	// note: operation getStaticType moved to TypeSystemHelper#getStaticType()
}

/*
 * Type argument used in parameterized types.
 */
abstract class TypeArgument {
	/*
	 * Convenience method, returns the type expression, usually the type name, as a string. Basically used for testing.
	 * As the returned string is used for comparison in tests, this method should not be changed.
	 */
	op String getTypeRefAsString()
	/*
	 * Convenience method, returns true if this type reference or one of its type arguments (transitively) contains references to type variables, or if the reference is not parameterized and the referenced type is generic.
	 * Returns false for all type arguments and type references except parameterized type references.
	 */
	op boolean containsWildcards() {
		return false
	}
	/*
	 * Convenience method, returns true if type reference or one of its type
	 * arguments (transitively) contains references to type variables, or if the
	 * reference is not parameterized  (or one of its nested references) but refers to a generic type.
	 * Returns false for all type references except parameterized type references.
	 */
	op boolean containsUnboundTypeVariables() {
		return false
	}
	/*
	 * Convenience method, returns null for all type arguments except parameterized type references.
	 * Reduces number of casts in client code.
	 */
	op Type getDeclaredType() {
		return null;
	}
}

/*
 * Note: Wildcard has special copy-semantics to preserve the implicit upper bound returned by method
 * {@link Wildcard#getDeclaredOrImplicitUpperBounds()}. When copied, the implicit upper bound is set
 * as declared upper bound in the copy. For details see TypeUtils#copy().
 */
class Wildcard extends TypeArgument {
	contains TypeRef declaredUpperBound
	contains TypeRef declaredLowerBound
	/*
	 * For wildcards contained in the AST, this tells if the wildcard was written in the source code using in/out
	 * notation, i.e. returns <code>true</code> for <code>G&lt;out C></code> and <code>false</code> for
	 * <code>G&lt;? extends C></code>.
	 */
	boolean usingInOutNotation
	/*
	 * An unbounded wildcard given as type argument to a bounded type parameter is implicitly bounded.
	 * For example:
	 * <pre>
	 * class A {}
	 * class G&lt;T extends A> {}
	 *
	 * var G&lt;?> g; // "?" is actually "? extends A"
	 * class H extends G&lt;?> {} // "?" is actually "? extends A"
	 * </pre>
	 * This method returns the declared upper bound of the receiving wildcard or, if the wildcard is unbounded,
	 * tries to obtain the implicit upper bound from the corresponding type parameter of the containing
	 * ParameterizedTypeRef's declared type (if any).
	 * <p>
	 * <b>IMPORTANT:</b> Use of such implicit bounds is prone to infinite recursion and must therefore be guarded
	 * appropriately. Take these two examples:
	 * <pre>
	 * class A&lt;T extends A&lt;?>> {} // directly
	 * </pre><pre>
	 * class X&lt;T extends B&lt;?>> {}
	 * class Y&lt;T extends X&lt;?>> {}
	 * class B&lt;T extends Y&lt;?>> {} // indirectly
	 * </pre>
	 */
	op TypeRef getDeclaredOrImplicitUpperBound() {
		val declUB = declaredUpperBound; // containment -> won't trigger resolution
		if (declUB !== null)
			return declUB;
		if (declaredLowerBound !== null)
			return null; // important: do not inherit upper bounds if we have a declared lower bound!
		// try to compute implicit upper bound from corresponding type parameter (without resolving proxies!)
		val parent = eContainer;
		if (parent instanceof ParameterizedTypeRef) {
			val typeArgIndex = parent.getTypeArgs().indexOf(this);
			if (typeArgIndex >= 0) {
				val declType = parent.eGet(TypeRefsPackage.eINSTANCE.getParameterizedTypeRef_DeclaredType(), false);
				if (declType instanceof ContainerType<?>) {
					if(!declType.eIsProxy()) {
						val typeVars = declType.typeVars;
						val typeVar = if(typeArgIndex < typeVars.size) typeVars.get(typeArgIndex) else null;
						if (typeVar !== null) {
							val implicitUB = typeVar.declaredUpperBound; // containment -> won't trigger resolution
							return implicitUB;
						}
					}
				}
			}
		}
		return null; // no implicit upper bound
	}
	/*
	 * Tells if an implicit upper bound is in effect for the given wildcard, i.e. the wildcards does not have declared
	 * bounds (upper or lower) and obtains an implicit bound from the corresponding type parameter.
	 *
	 * @see #getDeclaredOrImplicitUpperBounds()
	 */
	op boolean isImplicitUpperBoundInEffect() {
		return declaredUpperBound === null && declaredLowerBound === null && getDeclaredOrImplicitUpperBound()!==null;
	}
	/*
	 * Convenience method, returns the type expression, usually the type name, as a string. Basically used for testing.
	 * See {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return WildcardAsStringUtils.getTypeRefAsString_workaround(this);
	}
}


/*
 * Base class for {@link FunctionTypeRef} and {@link FunctionTypeExpression}.
 */
abstract class FunctionTypeExprOrRef extends StaticBaseTypeRef {
	/*
	 * optional thisType declaration e.g. for a given class A it's member-type can be specified as "{A.function():void}"
	 */
	op TypeRef getDeclaredThisType()
	/*
	 * Convenience method, returns the declared type casted to a TFunction
	 */
	op TFunction getFunctionType() {
		return declaredType as TFunction
	}
	/*
	 * The type variables as declared in the expression or of the referenced function type.
	 */
	op TypeVariable[] getTypeVars()
	/*
	 * Returns the upper bounds of the given type variable (which should be one of those returned by
	 * {@link FunctionTypeExprOrRef#getTypeVars()}). Never read the upper bounds directly from the type variable in
	 * case of type variables coming from a FunctionTypeExprOrRef; for more info why this is required, see
	 * {@link FunctionTypeExpression#getTypeVarUpperBound(TypeVariable)}.
	 */
	op TypeRef getTypeVarUpperBound(TypeVariable typeVar)
	/*
	 * The formal parameters as declared in the expression or of the referenced function type.
	 */
	op TFormalParameter[] getFpars()
	op boolean isReturnValueOptional() {
		return returnTypeRef!==null && returnTypeRef.followedByQuestionMark;
	}
	/*
	 * The return type as declared in the expression or of the referenced function type.
	 */
	op TypeRef getReturnTypeRef()
	// TODO returntype -> declaredReturnType
	// TODO returntype = declared || default (Any!?)
	/*
	 * Overrides {@link TypeRef#isGeneric()}
	 */
	op boolean isGeneric() {
		return !typeVars.empty;
	}
	/*
	 * Overrides {@link TypeRef#isRaw()}.
	 */
	op boolean isRaw() {
		return isGeneric() && typeArgs.size<typeVars.size;
	}
	/**
	 * Returns the formal parameter corresponding to the argument at index 'argIndex' in a function call
	 * or 'null' if 'argIndex' is invalid. This method takes into account optional and variadic parameters.
	 */
	op TFormalParameter getFparForArgIdx(int argIndex) {

		// NOTE: code copied from TFunction#getFparForArgIdx(int) because we might not have a TFunction here!
		val fparsSize = fpars.size();
		if (argIndex >= 0 && argIndex < fparsSize) {
			return fpars.get(argIndex);
		} else if (argIndex >= fparsSize && fparsSize > 0 && fpars.get(fparsSize - 1).isVariadic) {
			return fpars.get(fparsSize - 1);
		}
		return null;
	}
	/*
	 * Overrides {@link TypeRef#getTypeRefAsString()}
	 */
	op String getTypeRefAsString() {
		return "{" + (if (declaredThisType !== null) "@This(" + declaredThisType.typeRefAsString + ") " else "")
			+ "function"
			+ (if (generic) {
				"<" + typeVars.map[it.getTypeVariableAsString(getTypeVarUpperBound(it))].join(",") + ">"
			} else "")
			+ "(" + fpars.map[it.getFormalParameterAsTypesString].join(",") + ")"
			+ (if (returnTypeRef !== null) ":" + returnTypeRef.typeRefAsString else "")
			+ (if (returnValueOptional) "?" else "")
			+ "}" + getModifiersAsString();
	}
}

/*
 * Function type, always references a function, that is, declaredType returns a TFunction.
 * This kind of reference is created implicitly by function calls. Clients only <em>using</em> this kind
 * of references should probably better use {@link FunctionTypeExprOrRef}.
 */
class FunctionTypeRef extends ParameterizedTypeRef, FunctionTypeExprOrRef {
	/*
	 * Convenience method, returns the declared this type of the referenced function type.
	 */
	op TypeRef getDeclaredThisType() {
		return functionType.declaredThisType
	}
	/*
	 * Convenience method, returns the type variables of the referenced function type.
	 */
	op TypeVariable[] getTypeVars() {
		return functionType.typeVars
	}
	/*
	 * Simply returns the given type variable's declared upper bounds (required by super class API).
	 */
	op TypeRef getTypeVarUpperBound(TypeVariable typeVar) {
		return typeVar.declaredUpperBound;
	}
	/*
	 * Convenience method, returns the fpars of the referenced function type.
	 */
	op TFormalParameter[] getFpars() {
		return functionType.fpars
	}
	/*
	 * Convenience method, returns the return type of the referenced function type.
	 */
	op TypeRef getReturnTypeRef() {
		return functionType.returnTypeRef
	}
}

/*
 * Function type expression for declaring the type of a variable, parameter, etc. as a function.
 * Clients only <em>using</em> these kind of references should probably better use the API of
 * {@link FunctionTypeExprOrRef}.
 * <p>
 * There are the following use cases of FunctionTypeExpressions:
 * <ol>
 * <li>ordinary, self-contained function type expressions, in particular (i) non-generic
 *     <em>and</em> generic function type expressions that were created programmatically and
 *     (ii) AST nodes for non(!)-generic function type expressions (<b>standard use case</b>).
 * <li>those that are created by type system rule 'substTypeVariablesInFunctionType[ExprOr]Ref'
 *     as a copy of another
 *     <ol type="a">
 *     <li>FunctionTypeRef or
 *     <li>FunctionTypeExpression
 *     </ol>
 *     to represent a particular binding of the original FunctionTypeRef/FunctionTypeExpression
 *     (<b>work-around case</b>).
 * <li>those that represent AST nodes for <em>generic</em> function type expressions
 *     (<b>work-around case</b>).
 * </ol>
 * In standard case 1 the FunctionTypeExpression does *not* have a 'declaredType', because it
 * does not define an actual function (no element like TFunction to be stored in type model).
 * This is why class FunctionTypeExpression does not inherit from BaseTypeRef.
 * <p>
 * Case 2 is only a work-around, because the FunctionTypeRef cannot hold bound references to the
 * function's parameters, and therefore a FunctionTypeExpression is created in the xsemantics rule
 * 'substTypeVariablesInFunctionType[ExprOr]Ref' to represent the binding. In case 2.a only, the
 * FunctionTypeExpression will have a 'declaredType' pointing to the TFunction of the original
 * FunctionTypeRef.
 * <p>
 * Case 3 is also a work-around, required because resolution of lazy links takes place after the
 * types builder may have copied the FunctionTypeExpression contained in the AST and therefore the
 * lazy references to the type variables will be copied to the types model as well. As a result,
 * it is impossible to let the type variable references point to different type variables in the
 * original and copied function type expressions (which would be required for the "self-contained"
 * use case #1 above). The solution is to create a TFunction from the function type expression
 * contained in the AST and let all type variable references point to the type variables in that
 * TFunction. After this adjustment, the function type expression in the AST can be copied without
 * any special handling.
 * <p>
 * Note: this class is intended for function type(!) expressions and may play the role of an
 * ordinary type reference or an AST node; for function expressions there exists a different
 * class {@link org.eclipse.n4js.n4JS.FunctionExpression FunctionExpression} that can
 * only be used as an AST node.
 */
class FunctionTypeExpression extends FunctionTypeExprOrRef {

	/*
	 * Tells if this FunctionTypeExpression represents a binding of a TFunction or
	 * another FunctionTypeExpression (use cases 2.a and 2.b, respectively).
	 * Always true in use case 2; always false in use cases 1 and 3.
	 */
	boolean binding

	/*
	 * Always <code>null</code> in use case 1. In use case 2.a (not 2.b) this refers(!)
	 * to the original TFunction for which this FunctionTypeExpression represents a binding.
	 * In use case 3 this refers(!) to the TFunction in the type model generated from
	 * the FunctionTypeExpression in the AST.
	 * For more details on use cases see API doc of {@link FunctionTypeExpression}.
	 */
	refers TFunction declaredType
	/*
	 * Reference to the declared this-type via @This annotation inside the FunctionTypeExpression.
	 * In use case 2.a this is a copy of <code>declaredType.declaredThisType</code>, in use case
	 * 2.b this is a copy of the original FunctionTypeExperession's declaredThisType.
	 */
	contains TypeRef declaredThisType
	/*
	 * Type variables declared in FunctionTypeExpression (programmatically or in the AST).
	 * In use case #2 this is always empty.
	 */
	contains TypeVariable[] ownedTypeVars
	/*
	 * Always empty in use cases #1 and #3.
	 * In use case #2 this refers(!) to those type variables of the 'declaredType' (case 2.a)
	 * or original FunctionTypeExpression (case 2.b) that were *not* bound when creating this
	 * FunctionTypeExpression as a representation of a particular type variable binding of the
	 * 'declaredType' / original FunctionTypeExpression.
	 */
	refers TypeVariable[] unboundTypeVars
	/*
	 * Property 'unboundTypeVars' refers to type variables contained somewhere else. During type variable substitution,
	 * we would have to substitute type variables in these upper bounds, but we cannot, of course, directly change them.
	 * Thus, for the type variables in unboundTypeVars, rule 'substTypeVariablesInFunctionType[ExprOr]Ref' will store
	 * the upper bounds here, but only if they are different from the type variables original upper bounds. If they are
	 * not different, then an UnknownTypeRef will be used in this list for padding.
	 */
	contains TypeRef[] unboundTypeVarsUpperBounds
	/*
	 * Returns 'ownedTypeVars' in use case #1, 'unboundTypeVars' in use case #2 and the type
	 * variables of the TFunction that was generated from the AST node in use case #3.
	 * For more details on use cases see API doc of {@link FunctionTypeExpression}.
	 */
	op TypeVariable[] getTypeVars() {
		return if(isBinding) unboundTypeVars else ( if(declaredType!==null) declaredType.typeVars else ownedTypeVars );
	}
	/*
	 * Returns the upper bounds of the given type variable (which should be one of those returned by
	 * {@link FunctionTypeExprOrRef#getTypeVars()}). Usually, this will just return
	 * {@link TypeVariable#getDeclaredUpperBounds()}, but in case of a FunctionTypeExpression created during type
	 * variable substitution, a different upper bound might be returned (i.e. original upper bound after type variable
	 * substitution).
	 * <p>
	 * See property {@link FunctionTypeExpression#getUnboundTypeVarsUpperBounds() unboundTypeVarsUpperBounds} and
	 * method {@link SubstTypeVariablesJudgment#performSubstitutionOnUpperBounds()}.
	 */
	op TypeRef getTypeVarUpperBound(TypeVariable typeVar) {
		if(typeVar===null) {
			throw new IllegalArgumentException("given type variable may not be null");
		}
		val idx = unboundTypeVars.indexOf(typeVar);
		if(idx>=0 && idx<unboundTypeVarsUpperBounds.size) {
			val modifiedUpperBound = unboundTypeVarsUpperBounds.get(idx);
			if(!modifiedUpperBound.isUnknown) { // we allow 'unboundTypeVarsUpperBounds' to contain UnknownTypeRefs for padding
				return modifiedUpperBound;
			}
		}
		return typeVar.declaredUpperBound;
	}
	// TODO extract FormalParameterContainer
	/*
	 * Formal parameters declared in the FunctionTypeExpression in the AST or
	 * a copy of the formal parameters of the 'declaredType' or original FunctionTypeExpression.
	 */
	contains TFormalParameter[] fpars
	/*
	 * Explicitly marks the return value of this FunctionTypeExpression as optional. This only used for function type
	 * expressions that are created programmatically. Those that appear in the AST will instead have a 'returnTypeRef'
	 * with 'followedByQuestionMark' set to <code>true</code>.
	 * This will probably become obsolete once we implement undefined/null analysis.
	 */
	boolean returnValueMarkedOptional
	op boolean isReturnValueOptional() {
		return returnValueMarkedOptional || (returnTypeRef!==null && returnTypeRef.followedByQuestionMark);
	}
	/*
	 * Return type declared in the FunctionTypeExpression in the AST or
	 * a copy of the return type of the 'declaredType' or original FunctionTypeExpression.
	 */
	contains TypeRef returnTypeRef
}

/**
 * A TypeRef used by the types builder to denote that some other part of the implementation is responsible
 * for creating a certain type reference. FIXME more info
 */
class DeferredTypeRef extends TypeRef {
	op String getTypeRefAsString() {
		return "*deferred*";
	}
}

/*
 * Helper class to store a type variable mapping,
 * i.e. a particular type variable and its type argument.
 */
class TypeVariableMapping {
	refers TypeVariable typeVar
	contains TypeArgument typeArg
}

// ****************************************************************************************************
// N4IDL related model elements
// ****************************************************************************************************

/*
 * This is a base class for all AST nodes that represent a reference to a versioned object and where the user can
 * explicitly request a specific version. Currently, this includes ParameterizedTypeRef (for explicitly versioned
 * parameter types and local variables in N4IDL migration scripts) and IdentifierRef (for explicitly versioned
 * references to identifiers as the callee of a NewExpression).
 *
 * If an instance of this class does not have an explicitly requested version (set by the parser), then the type system
 * may compute the requested version from context information and store the result in the requestedVersion attribute.
 *
 * The latter only happens in N4IDL via N4IDLVersionResolver.
 */
abstract class VersionedReference {
	BigDecimal requestedVersion

	/*
	 * Indicates whether this type reference has an explicitly requested version. A requested version can either be
	 * set by the parser when the user explicitly requests a specific version in source code, or by the type system
	 * when computing the implicitly requested version, e.g. for property access expressions.
	 */
	op boolean hasRequestedVersion() {
		return requestedVersion !== null
	}

	op int getRequestedVersionOrZero() {
		if (hasRequestedVersion) requestedVersion.intValue else 0
	}
}

class VersionedParameterizedTypeRef extends ParameterizedTypeRef, VersionedReference {
	op int getVersion() {
		/*
		 * If a specific version was requested, then we return that, otherwise we delegate to the overridden method,
		 * which will delegate to the declared type.
		 */
		if (hasRequestedVersion) requestedVersion.intValue else super.version
	}
}


class VersionedFunctionTypeRef extends VersionedParameterizedTypeRef, FunctionTypeRef {}

class VersionedParameterizedTypeRefStructural extends VersionedParameterizedTypeRef, ParameterizedTypeRefStructural {}

