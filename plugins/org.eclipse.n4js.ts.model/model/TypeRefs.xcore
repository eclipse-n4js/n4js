/**
 * Copyright (c) 2016 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */
@Ecore(nsURI="http://www.eclipse.org/n4js/ts/TypeRefs")
@GenModel(fileExtensions="n4trs",
// modelPluginID isn't strictly necessary but causes some trouble
//	modelPluginID="org.eclipse.n4js.ts.model",
	rootExtendsClass="org.eclipse.n4js.utils.emf.ProxyResolvingEObjectImpl",
	modelDirectory="/org.eclipse.n4js.ts.model/emf-gen",
	forceOverwrite="true",
	updateClasspath="false",
	complianceLevel="11.0",
	copyrightFields="false",
	// both copyrightText and documentation are required to align the output of the MWE2 and incremental builder (see GH-841)
	copyrightText="Copyright (c) 2016 NumberFour AG.\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nwhich accompanies this distribution, and is available at\nhttp://www.eclipse.org/legal/epl-v10.html\n\nContributors:\n  NumberFour AG - Initial API and implementation",
	documentation="*\nCopyright (c) 2016 NumberFour AG.\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nwhich accompanies this distribution, and is available at\nhttp://www.eclipse.org/legal/epl-v10.html\n * Contributors:\n  NumberFour AG - Initial API and implementation",
	language="")
package org.eclipse.n4js.ts.typeRefs

import org.eclipse.emf.common.util.ECollections
import org.eclipse.emf.ecore.EObject
import org.eclipse.n4js.ts.types.AnyType
import org.eclipse.n4js.ts.types.ContainerType
import org.eclipse.n4js.ts.types.TEnum
import org.eclipse.n4js.ts.types.TEnumLiteral
import org.eclipse.n4js.ts.types.TFormalParameter
import org.eclipse.n4js.ts.types.TFunction
import org.eclipse.n4js.ts.types.TN4Classifier
import org.eclipse.n4js.ts.types.TStructMember
import org.eclipse.n4js.ts.types.TStructMethod
import org.eclipse.n4js.ts.types.TStructuralType
import org.eclipse.n4js.ts.types.Type
import org.eclipse.n4js.ts.types.TypeVariable
import org.eclipse.n4js.ts.types.TypingStrategy
import org.eclipse.n4js.ts.types.UndefinedType
import org.eclipse.n4js.ts.types.internal.WildcardAsStringUtils
import org.eclipse.n4js.ts.types.util.TypeModelUtils
import org.eclipse.n4js.utils.Strings



/*
 * Optional field strategy enum defines three strategies for handling optional fields while checking structural subtypes.
 * The optional field strategy is calculated based on the kind of AST node. Each {@code TypeRef} is associated with an optional field strategy.
 * <p>
 * It is important to note that this optional field strategy is introduced to as a workaround to solve the transitivity problem with structural subtyping
 * in the presence of optional fields. As opposed to e.g. typing strategy, the optional field strategy is NOT passed through the type system in anyway.
 * <p>
 * For further details, see IDE-2405, GHOLD-411.
 */
enum OptionalFieldStrategy {
	/** Default: optionality is turned of, e.g. both fields and accessors are mandatory */
	^OFF = 0
	/** Only getters are optional */
	GETTERS_OPTIONAL = 1
	/** Both fields and accessors are optional */
	FIELDS_AND_ACCESSORS_OPTIONAL = 2
}

/*
 * Type argument used in parameterized types.
 */
abstract class TypeArgument {
	/* Tells whether this type argument is a type reference. Used to avoid instanceof checks. */
	op boolean isTypeRef() {
		return false;
	}
	/*
	 * Convenience method, returns null for all type arguments except parameterized type references.
	 * Reduces number of casts in client code.
	 */
	op Type getDeclaredType() {
		return null;
	}

	/*
	 * Returns this type argument/reference as a string, usually according to N4JS syntax.
	 * Both unresolved and resolved references to a type alias will be shown as a reference to the type alias
	 * (i.e. only the name of the type alias is included; the aliased/actual type is ignored).
	 */
	op String getTypeRefAsString() {
		return getTypeRefAsString(true);
	}
	/* See {@link TypeArgument#getTypeRefAsString()}. */
	op String getTypeRefAsString(boolean resolveProxies) {
		// note: for the handling of resolved references to a type alias see the override in subclass TypeRef
		return internalGetTypeRefAsString(resolveProxies);
	}

	/*
	 * Same as {@link TypeArgument#getTypeRefAsString()}, except that resolved(!) references to
	 * a type alias are handled differently: only the aliased/actual type will be shown (the type
	 * alias will be ignored).
	 */
	op String getTypeRefAsStringWithAliasResolution() {
		return getTypeRefAsStringWithAliasResolution(true);
	}
	/* See {@link TypeArgument#getTypeRefAsStringWithAliasResolution()}. */
	op String getTypeRefAsStringWithAliasResolution(boolean resolveProxies) {
		return internalGetTypeRefAsString(resolveProxies);
	}

	/*
	 * Same as {@link TypeArgument#getTypeRefAsString()}, except that resolved(!) references to
	 * a type alias are handled differently: both the name of the type alias and the aliased/actual
	 * type are shown, separated by {@code <=>}.
	 */
	op String getTypeRefAsStringWithAliasExpansion() {
		return getTypeRefAsStringWithAliasExpansion(true);
	}
	/* See {@link TypeArgument#getTypeRefAsStringWithAliasExpansion()}. */
	op String getTypeRefAsStringWithAliasExpansion(boolean resolveProxies) {
		// note: for the handling of resolved references to a type alias see the override in subclass TypeRef
		return internalGetTypeRefAsString(resolveProxies);
	}

	/*
	 * Actual computation of the string representation of this type argument/reference.
	 * <p>
	 * Unresolved references to a type alias will be represented as such (i.e. only the
	 * name of the type alias is included; the aliased/actual type is ignored), whereas
	 * resolved references to a type alias will only include the aliased/actual type
	 * (the fact that a type alias is involved is not shown at all).
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies)

	op String toString() {
		return getTypeRefAsStringWithAliasExpansion(false);
	}
}

/*
 * Base class for all type references
 */
abstract class TypeRef extends TypeArgument {

	/*
	 * <b>SHOULD NOT BE USED, EXCEPT FOR DECLARATION OF OPTIONAL RETURN VALUES</b>
	 * <p>
	 * Represents the old ? after a type reference for defining optional fields / return values. At the moment, this is
	 * used only for declaring the return value of a function optional. In the future, this might be used for
	 * undefined/null-analysis. For example, <code>string?</code> might be syntactic sugar for
	 * <code>string|undefined</code>.
	 */
	boolean followedByQuestionMark

	/*
	 * If this type reference represents a resolved(!) reference to an alias, this property is
	 * the original, unresolved type reference to the alias, i.e. {@link TypeRef#isAliasUnresolved()}
	 * will always return <code>true</code> for the value of this property. In all other cases,
	 * this property is <code>null</code>.
	 */
	contains ParameterizedTypeRef originalAliasTypeRef

	/*
	 * Returns all type modifiers of the receiving type reference as a string, similar to N4JS syntax. This method is
	 * called by subclasses in overridden method. Currently, the <code>+</code> for dynamic is the only existing type
	 * modifier.
	 */
	op String getModifiersAsString() {
		 return "";
	}

	/*
	 * Overrides {@link TypeArgument#isTypeRef()}.
	 */
	op boolean isTypeRef() {
		return true;
	}

	/*
	 * Returns true iff this is an <em>unresolved</em> reference to a type alias. For the difference
	 * between resolved and unresolved references to type aliases, see {@link #isAliasResolved()}.
	 */
	op boolean isAliasUnresolved() {
		val declType = declaredType;
		return declType !== null && declType.isAlias();
	}

	/*
	 * Returns true iff this is a <em>resolved</em> reference to a type alias.
	 * <p>
	 * For comparison:
	 * <ul>
	 * <li>An <em>unresolved</em> reference to a type alias is always a {@link ParameterizedTypeRef} with
	 * a {@link ParameterizedTypeRef#getDeclaredType() declared type} that is an instance of {@link TypeAlias}.
	 * <li>A <em>resolved</em> reference to a type alias can be any kind of type reference (i.e. an instance of
	 * any subclass of {@link TypeRef}), depending on the aliased (or "actual") type of the type alias. It always
	 * contains a copy of the original, unresolved reference it was derived from (returned by {@link #getOriginalAliasTypeRef()}).
	 * </ul>
	 * For example, given the declaration
	 * <pre>
	 * type MyAlias = (string)=>number;
	 * </pre>
	 * in the N4JS source code, an unresolved reference to this type alias would be a {@code ParameterizedTypeRef}
	 * with 'MyAlias' as {@link ParameterizedTypeRef#getDeclaredType() declared type}. A resolved reference to this
	 * type alias would be a {@link FunctionTypeExpression} with a {@code string} parameter and a return type of
	 * {@code number}.
	 * <p>
	 * The reason for having type alias resolution is that we do not yet properly hide all characteristics of
	 * a type reference behind a single, common interface and that our code base is heavily using instanceof checks
	 * to find out the nature of a type reference, which would fail in case of unresolved type references.
	 */
	op boolean isAliasResolved() {
		return originalAliasTypeRef !== null;
	}

	/*
	 * Returns true if the type referenced is either class which is declared final, an enum or a primitive. This is needed in case of type
	 * casts, for example.
	 * <p>
	 * The method is robust, if declared type is null, false is returned.
	 */
	op boolean isFinalByType() {
		val dtype = declaredType;
		return dtype!==null && dtype.final
	}

	/*
	 * Tells if this type reference has a declared type which is "array like" as defined by {@link Type#isArrayLike()}.
	 */
	op boolean isArrayLike() {
		val dtype = declaredType;
		return dtype!==null && dtype.isArrayLike;
	}

	/* Tells whether the receiving type reference is an {@link UnknownTypeRef}. */
	op boolean isUnknown() {
		return false;
	}

	/*
	 * Convenience method, flag indicating whether user can add properties to the instance not defined in the type.
	 */
	op boolean isDynamic() {
		return false
	}
	/*
	 * Convenience method, flag indicating whether the type reference is an existential type created on the fly
	 * by the type inferencer from parameterized types with wildcards.
	 * This returns false for all type references except {@link ExistentialTypeRef}
	 */
	op boolean isExistential() {
		return false
	}
	/*
	 * Convenience method, returns true if and only if the referenced type is generic, i.e. declared type variables.
	 * Note that it may be possible that the referenced type is generic, but the reference is not parameterized
	 * (raw reference), but not vice versa.
	 */
	op boolean isGeneric() {
		return false;
	}
	/*
	 * Convenience method, returns true if and only if the reference has type arguments. Note that it may be possible that
	 * the referenced type is generic, but the reference is not parameterized (raw reference), but not vice versa.
	 */
	op boolean isParameterized() {
		return false;
	}
	/*
	 * Convenience method, returns true if and only if the referenced type is generic <em>and</em> the reference has
	 * fewer type arguments than the number of type parameters of the referenced type.<p>
	 * Note that N4JS does not allow raw type references as in Java, for example. However, raw type references can
	 * occur due to (1) a broken AST (2) during type inference in InferenceContext (when deriving constraints from
	 * ClassifierTypeRefs) and (3) bugs in the type system and other internal code.
	 */
	op boolean isRaw() {
		return false;
	}
	/*
	 * Convenience method to avoid type casts, does return null except type ref is a wildcard.
	 */
	op ParameterizedTypeRef getDeclaredUpperBound() {
		return null
	}
	/*
	 * Convenience method to avoid type casts, does return null except type ref is a wildcard.
	 */
	op ParameterizedTypeRef getDeclaredLowerBound() {
		return null
	}
	/*
	 * Convenience method to avoid type casts, does return unmodifiable empty list for all type references except parameterized type refs.
	 */
	op TypeArgument[] getDeclaredTypeArgs() {
		return emptyEList
	}
	/*
	 * Convenience method to avoid type casts, does return unmodifiable empty list for all type references except parameterized type refs.
	 */
	op TypeArgument[] getTypeArgsWithDefaults() {
		return emptyEList
	}
	/* Overrides {@link TypeArgument#getTypeRefAsString(boolean)}. */
	op String getTypeRefAsString(boolean resolveProxies) {
		if (isAliasResolved()) {
			return getOriginalAliasTypeRef().getTypeRefAsString(resolveProxies);
		}
		return internalGetTypeRefAsString(resolveProxies);
	}
	/* Overrides {@link TypeArgument#getTypeRefAsStringWithAliasExpansion(boolean)}. */
	op String getTypeRefAsStringWithAliasExpansion(boolean resolveProxies) {
		if (isAliasResolved()) {
			return getTypeRefAsString(resolveProxies) + " <=> " + internalGetTypeRefAsString(resolveProxies);
		}
		return getTypeRefAsString(resolveProxies);
	}
	/* Convenience method, returns only true for parameterized type refs if the declared type is any */
	op boolean isTopType() {
		return declaredType instanceof AnyType
	}
	/* Convenience method, returns only true for parameterized type refs if the declared type is undefined */
	op boolean isBottomType() {
		return declaredType instanceof UndefinedType
	}
	/**
	 * Returns the typing strategy, either the use or def site, usually NOMINAL.
	 */
	op TypingStrategy getTypingStrategy() {
		return TypingStrategy.NOMINAL
	}

	/**
	 * Convenience method, returns empty list for simply reference by default.
	 * Overridden in {@link ParameterizedTypeRefStructural}
	 */
	op TStructMember[] getStructuralMembers() {
		return emptyEList();
	}
	/*
	 * Returns true if type ref is structural. This is different from {@link #getTypingStrategy}, which
	 * returns true if either use or def site structural typing is true.
	 */
	op boolean isStructuralTyping() {
		return TypeModelUtils.isStructural(getTypingStrategy());
	}
	/*
	 * Returns true if type ref is structural. This is different from {@link #getTypingStrategy}, which
	 * returns true if either use or def site structural typing is true.
	 */
	op boolean isUseSiteStructuralTyping() {
		return false
	}
	/*
	 * Returns true if type is defined structurally defined. This is different from {@link #getTypingStrategy}, which
	 * returns true if either use or def site structural typing is true.
	 */
	op boolean isDefSiteStructuralTyping() {
		return false
	}

	/*
	 * Tells the optional field strategy.
	 * Used to activate the special semantics of optional fields in certain cases.
	 */
	 /* @see ParameterizedTypeRef#astOptionalFieldStrategy */
	op OptionalFieldStrategy getASTNodeOptionalFieldStrategy() {
		return OptionalFieldStrategy.OFF;
	}
}

abstract class StaticBaseTypeRef extends TypeRef {
	// pulled nullModififer and UndefModdifier up as part of IDEBUG-596
}

abstract class BaseTypeRef extends StaticBaseTypeRef {
	/*
	 * Flag indicating that new properties can be dynamically added to the type. Default value is false.
	 */
	boolean dynamic = "false"
	/*
	 * Override for {@link TypeRef#getModifiersAsString()}.
	 */
	op String getModifiersAsString() {
		return (if (dynamic) {
			"+"
		} else {
			""
		}) + super.getModifiersAsString();
	}
}

/*
 * Base class for type references containing an ordered set of other types, that is
 * {@link UnionTypeExpression} and {@link IntersectionTypeExpression}.
 */
abstract class ComposedTypeRef extends StaticBaseTypeRef {
	/*
	 * Union type cannot be marked as dynamic
	 */
	op boolean isDynamic() {
		return false;
	}
	contains TypeRef[] typeRefs
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}, only returns list of composed members, to be called by subclass.
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return "{" + typeRefs.map[it.getTypeRefAsString(resolveProxies)].join(',') + "}" + getModifiersAsString();
	}
}

/*
 * Union type
 */
class UnionTypeExpression extends ComposedTypeRef {
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return "union" + super.internalGetTypeRefAsString(resolveProxies);
	}
}

/*
 * Intersection type can be specified by the user directly in terms of an intersection type expression
 * or in the context of a type variable. It may also be inferred by the type system.
 */
class IntersectionTypeExpression extends ComposedTypeRef {
	
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return "intersection" + super.internalGetTypeRefAsString(resolveProxies);
	}
	
	/*
	 * Convenience method, returns true iff all composed type refs are use site structural typed.
	 */
	op boolean isUseSiteStructuralTyping() {
		return typeRefs.forall[isUseSiteStructuralTyping];
	}
	
	/*
	 * Convenience method, returns true iff all composed type refs are def site structural typed.
	 */
	op boolean isDefSiteStructuralTyping() {
		return typeRefs.forall[isDefSiteStructuralTyping];
	}
	
	/**
	 * Returns true iff all composed type refs are typed either def or use site structural
	 */
	op boolean isStructuralTyping() {
		return typeRefs.forall[isUseSiteStructuralTyping || isDefSiteStructuralTyping];
	}
	
	/**
	 * Returns the actual typing strategy, that is TypingStrategy.STRUCTURAL iff this type is def site structural typing.
	 */
	op TypingStrategy getTypingStrategy() {
		if (isStructuralTyping) {
			return TypingStrategy.STRUCTURAL
		}
		return TypingStrategy.NOMINAL
	}
}

/*
 * Unbound this type reference.
 */
// TODO kick me!
abstract class ThisTypeRef extends BaseTypeRef {
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return "this" + getModifiersAsString();
	}
	/**
	 * Always returns NOMINAL for simple this type references
	 */
	op TypingStrategy getTypingStrategy() {
		return TypingStrategy.NOMINAL
	}
	/**
	 * Convenience method, returns empty list for simply reference by default.
	 * Overridden in {@link ParameterizedTypeRefStructural}
	 */
	op TStructMember[] getStructuralMembers() {
		return emptyEList();
	}
	/*
	 * Always returns false for simple this type references
	 */
	op boolean isUseSiteStructuralTyping() {
		return false
	}
}

class  ThisTypeRefNominal extends ThisTypeRef {
}

class  ThisTypeRefStructural extends ThisTypeRef, StructuralTypeRef {
	/*
	 * The defined (declared or inferred) typing strategy on use site, nominal typing by default. Could be changed to structural or structural
	 * field (via tilde or tilde-tilde operators).
	 */
	TypingStrategy definedTypingStrategy
	/**
	 * Returns the actual typing strategy, that is either the defined typing strategy of the reference, or the typing strategy of the
	 * actual this type.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			return TypingStrategy.NOMINAL
		}
		return definedTypingStrategy;
	}
	op void setTypingStrategy(TypingStrategy typingStrategy) {
		definedTypingStrategy = typingStrategy
	}
	/*
	 * Convenience method, returns true if typingStrategy is neither NOMINAL nor DEFAULT
	 */
	op boolean isUseSiteStructuralTyping() {
		return typingStrategy !== TypingStrategy.NOMINAL && typingStrategy !== TypingStrategy.DEFAULT
	}
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return typingStrategy + "this" + getModifiersAsString();
	}
}

/*
 * Reference to this type actually bound to a concrete type,
 * this is only done by the type system and not by a user declaration.
 */
class BoundThisTypeRef extends ThisTypeRef, StructuralTypeRef {
	contains ParameterizedTypeRef actualThisTypeRef
	/*
	 * The defined (declared or inferred) typing strategy on use site, nominal typing by default. Could be changed to structural or structural
	 * field (via tilde or tilde-tilde operators).
	 */
	TypingStrategy definedTypingStrategy
	/**
	 * Returns the actual typing strategy, that is either the defined typing strategy of the reference, or the typing strategy of the
	 * actual this type.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			return actualThisTypeRef.typingStrategy;
		} else {
			return definedTypingStrategy
		}
	}
	op void setTypingStrategy(TypingStrategy typingStrategy) {
		definedTypingStrategy = typingStrategy;
	}
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return typingStrategy + "this[" + actualThisTypeRef.internalGetTypeRefAsString(resolveProxies) + "]" + getModifiersAsString();
	}
	op ParameterizedTypeRef getDeclaredUpperBound() {
		return actualThisTypeRef;
	}
	/*
	 * Convenience method, returns true if typingStrategy of the declared type is STRUCTURAL
	 */
	op boolean isDefSiteStructuralTyping() {
		if (actualThisTypeRef instanceof TN4Classifier) {
			return (actualThisTypeRef as TN4Classifier).typingStrategy === TypingStrategy.STRUCTURAL
		}
		if (actualThisTypeRef instanceof TStructuralType) {
			return true;
		}
		return false
	}
	/**
	 * Returns true if defined typing strategy neither DEFAULT nor NOMINAL.
	 */
	op boolean isUseSiteStructuralTyping() {
		return definedTypingStrategy !== TypingStrategy.DEFAULT &&
			definedTypingStrategy !== TypingStrategy.NOMINAL
	}
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}
}

/**
 * Type reference to declared types which may be parameterized. This is
 * probably the most often used type reference. This base version always
 * uses nominal typing on use site, there is a sub class
 * {@link ParameterizedTypeRefStructural} which support structural typing
 * on use site. However, the latter is not allowed everywhere.
 */
class ParameterizedTypeRef extends BaseTypeRef {
	refers Type declaredType
	transient String declaredTypeAsText
	/*
	 * The type arguments provided with this type reference, <b>NOT</b> including defaults for optional type parameters.
	 * Use {@link ParameterizedTypeRef#getTypeArgsWithDefaults() #getTypeArgsWithDefaults()} to also obtain those defaults.
	 */
	contains TypeArgument[] declaredTypeArgs
	/* An array type in the AST, i.e. something like {@code let x: string[];}. Don't confuse with {@link ParameterizedTypeRef#isArrayNTypeExpression() arrayNTypeExpression}. */
	boolean arrayTypeExpression = "false"
	/* An ArrayN type in the AST, i.e. something like {@code let x: [string,number];}. Don't confuse with {@link ParameterizedTypeRef#isArrayTypeExpression() arrayTypeExpression}. */
	boolean arrayNTypeExpression = "false"

	/*
	 * If and only if this {@code ParameterizedTypeRef} represents an AST node (i.e. was created by the parser).
	 * The array consists of references in the following order:
	 * ModuleNamespaceVirtualType? [TNamespace]* TEnum?
	 */
	contains NamespaceLikeRef[] astNamespaceLikeRefs

	op NamespaceLikeRef getPreviousSibling(NamespaceLikeRef nslRef) {
		if (nslRef === null || nslRef.eContainer !== this) {
			return null;
		}
		for (var i=1; i<astNamespaceLikeRefs.length; i++) {
			if (astNamespaceLikeRefs.get(i) == nslRef) {
				return astNamespaceLikeRefs.get(i - 1);
			}
		}
		return null;
	}

	/* @see TypeRef#getASTOptionalFieldStrategy() */
	transient OptionalFieldStrategy aSTNodeOptionalFieldStrategy

	/*
	 * The defined (declared or inferred) typing strategy on use site, nominal typing by default. Could be changed to structural or structural
	 * field (via tilde or tilde-tilde operators).
	 */
	TypingStrategy definedTypingStrategy

	/**
	 * Returns the actual typing strategy, that is either the defined typing strategy, or the typing strategy of the declared type.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			if (isDefSiteStructuralTyping) {
				return TypingStrategy.STRUCTURAL
			} else {
				return TypingStrategy.NOMINAL
			}
		}
		return definedTypingStrategy
	}

	/*
	 * @see TypeModelUtils#getTypeArgsWithDefaults(Type, EList<TypeArgument>)
	 */
	op TypeArgument[] getTypeArgsWithDefaults() {
	 	return TypeModelUtils.getTypeArgsWithDefaults(this.getDeclaredType(), this.getDeclaredTypeArgs());
	}

	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return internalGetDeclaredTypeAsString(resolveProxies)
		+ (if (declaredTypeArgs.empty) {
			""
		} else {
			"<" + declaredTypeArgs.map[it.getTypeRefAsString(resolveProxies)].join(",") + ">"
		})
		+ getModifiersAsString();
	}
	op String internalGetDeclaredTypeAsString(boolean resolveProxies) {
		val declType = this.eGet(TypeRefsPackage.Literals.PARAMETERIZED_TYPE_REF__DECLARED_TYPE, resolveProxies) as Type;
		val declTypeStr = if (declType === null) {
			"«null»"
		} else if (declType.eIsProxy) {
			(declaredTypeAsText ?: "") + "«proxy»"
		} else {
			declType.rawTypeAsString
		};
		return declTypeStr;
	}
	/*
	 * Convenience method, returns true if type reference contains type arguments.
	 */
	op boolean isParameterized() {
		return ! declaredTypeArgs.empty;
	}
	/*
	 * Delegates to {@link Type#isGeneric()}
	 */
	op boolean isGeneric() {
		return declaredType!==null && declaredType.generic;
	}
	/*
	 * Returns true iff the given type reference is "raw", i.e. if it points to a generic type and has fewer type
	 * arguments than the generic type has mandatory(!) type parameters.
	 *
	 * Overrides {@link TypeRef#isRaw()}.
	 */
	op boolean isRaw() {
		if (isGeneric()) {
			val mandatoryTypeParamsCount = declaredType.typeVars.filter[!optional].size;
			return declaredTypeArgs.size < mandatoryTypeParamsCount;
		}
		return false;
	}

	/*
	 * Convenience method, returns true if typingStrategy is neither NOMINAL nor DEFAULT, and if is is not
	 * definition site.
	 */
	op boolean isUseSiteStructuralTyping() {
		return definedTypingStrategy !== TypingStrategy.NOMINAL &&
			definedTypingStrategy !== TypingStrategy.DEFAULT
	}
	/*
	 * Convenience method, returns true if typingStrategy of the declared type is STRUCTURAL or in case of Object literals.
	 */
	op boolean isDefSiteStructuralTyping() {
		if (declaredType instanceof TN4Classifier) {
			return (declaredType as TN4Classifier).typingStrategy === TypingStrategy.STRUCTURAL
		}
		if (declaredType instanceof TStructuralType) {
			return true;
		}
		return false
	}
}

/**
 * There are three use cases:
 * <ol>
 * <li>the StructuralTypeRef plays the role of an AST node,
 * <li>the StructuralTypeRef is a copy of an AST node (maybe modified),
 * <li>the StructuralTypeRef was created programmatically.
 * </ol>
 * The handling of structural members defined in with-clauses is a bit tricky and different across
 * these use cases. In case 1. the StructuralTypeRef may contain structural members in 'astStructuralMembers'
 * and the types builder will have created a TStructuralType in the module (referred to by property
 * 'structuralType'). In case 2. it will point to the TStructuralType in the module via 'structuralType'
 * (and useless copies of the original astStructuralMembers may be lying around in 'astStructuralMembers'
 * -> ignore them!). In case 3. it has only 'genStructuralMembers'.
 * <p>
 * When copying StructuralTypeRefs, the property 'astStructuralMembers' need not be copied because it only contains
 * members if the StructuralTypeRef is an AST node, but then the types builder will have created a TStructuralType
 * with the same members that is referred to via cross-reference property 'structuralType', so copying the value of
 * that cross-reference is sufficient. It is best to always use one of the copy methods in TypeUtils, i.e. TypeUtils#copy(),
 * TypeUtils#copyIfContained(), etc. because they take of that.
 * <p>
 * Note: copying StructuralTypeRefs directly with {@link EcoreUtil#copy(EObject)}, etc. won't do any harm; you just
 * have unnecessary members contained in your copied typeRef.
 */
abstract class StructuralTypeRef {
	/*
	 * If and only if the StructuralTypeRef is used as an AST node, this property holds the structural
	 * members and 'genStructuralMembers' is empty and 'structuralType' is <code>null</code>.
	 * This occurs in a situation like this:
	 * <pre>
	 * class C { ... }
	 * var myC_withN : ~C with { number n; };
	 * </pre>
	 * Members should <b>never</b> be added to this property, except by the parser (in file N4JS.xtext).
	 */
	contains TStructMember[] astStructuralMembers
	/*
	 * If this StructuralTypeRef is used inside a TModule, this property <em>refers</em> to the TStructuralType that
	 * contains the structural members. In this case, properties 'astStructuralType' and 'genStructuralType'
	 * are empty.
	 */
	refers TStructuralType structuralType
	/*
	 * If a StructuralTypeRef with additional structural members is to be generated programmatically <em>without
	 * having a TModule</em> at hand, then the structural members can be added to this property. If a TModule is
	 * available, it is better to create a TStructuralType and let the StructuralTypeRef refer to that via property
	 * 'structuralType'.
	 * <p>
	 * This property should be used only as a last resort if no containing TModule is available.
	 */
	contains TStructMember[] genStructuralMembers
	/*
	 * Postponed substitutions of type variables in the structural members of the receiving StructuralTypeRef.
	 * <p>
	 * When performing a type variable substitution on a StructuralTypeRef, we do not copy and change the
	 * structural members but instead postpone substitution until the types stored in the members (e.g. type
	 * of a field, return type of a method) are actually required and perform the substitution then. To do
	 * this, we store the mappings from type variables to type arguments at the time of the first substitution
	 * in this property and restore them into the rule environment when obtaining a type from a structural member.
	 *
	 * @see GenericsComputer#substTypeVariablesInStructuralMembers(RuleEnvironment,StructuralTypeRef)
	 * @see GenericsComputer#storePostponedSubstitutionsIn(RuleEnvironment,StructuralTypeRef)
	 * @see GenericsComputer#restorePostponedSubstitutionsFrom(RuleEnvironment,StructuralTypeRef)
	 */
	contains TypeVariableMapping[] postponedSubstitutions
	/**
	 * Returns the actual typing strategy.
	 */
	op TypingStrategy getTypingStrategy()
	/**
	 * Sets the actual typing strategy, required for copy operation.
	 */
	op void setTypingStrategy(TypingStrategy typingStrategy)
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}
	op TStructMember[] getStructuralMembersWithCallConstructSignatures() {
		val structType = getStructuralType();
		val callSig = structType?.callSignature as TStructMethod;
		val constructSig = structType?.constructSignature as TStructMethod;
		if (callSig !== null || constructSig !== null) {
			val structMembers = getStructuralMembers();
			val result = ECollections.<TStructMember>newBasicEListWithCapacity(structMembers.size + 2);
			if (callSig !== null) {
				result += callSig;
			}
			if (constructSig !== null) {
				result += constructSig;
			}
			result += structMembers;
			return result;
		}
		return getStructuralMembers();
	}

	/*
	 * Returns true iff there exists a type variable mapping for 'typeVar' in property 'typeVarMappings'.
	 */
	op boolean hasPostponedSubstitutionFor(TypeVariable typeVar) {
		return postponedSubstitutions.exists[m| m?.typeVar === typeVar];
	}
}

/**
 * A {@link ParameterizedTypeRef} with use site structural typing. Note
 * that use site structural typing is not allowed everywhere. E.g., it
 * is not allowed for specifying super types of a class, interface or role.
 * It is mainly used for the type of formal parameters.
 */
class ParameterizedTypeRefStructural extends ParameterizedTypeRef, StructuralTypeRef {
	/**
	 * Returns the actual typing strategy.
	 */
	op TypingStrategy getTypingStrategy() {
		if (definedTypingStrategy === TypingStrategy.DEFAULT) {
			return TypingStrategy.STRUCTURAL
		} else {
			return definedTypingStrategy
		}
	}
	/**
	 * Sets the actual typing strategy, required for copy operation.
	 */
	op void setTypingStrategy(TypingStrategy typingStrategy) {
		if (typingStrategy == TypingStrategy.NOMINAL) {
			throw new IllegalArgumentException("cannot set structural type reference to nominal")
		}
		definedTypingStrategy = typingStrategy;
	}
	/*
	 * Convenience method, returns either the members of the structuralType (if non-null) or the astStructuralMembers
	 * (if non-empty) or the genStructuralMembers.
	 */
	op TStructMember[] getStructuralMembers() {
		return (if (structuralType !== null) structuralType.ownedMembers else if (!astStructuralMembers.empty) astStructuralMembers else genStructuralMembers).
			unmodifiableView;
	}
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		val membersWithCallConstructSigs = getStructuralMembersWithCallConstructSignatures();
		return typingStrategy + internalGetDeclaredTypeAsString(resolveProxies) + (if (declaredTypeArgs.empty) {
			""
		} else {
			"<" + declaredTypeArgs.map[it.getTypeRefAsString(resolveProxies)].join(",") + ">"
		}) + (if (membersWithCallConstructSigs.empty) {
			""
		} else {
			" with { " + (#[] + membersWithCallConstructSigs).map[memberAsString].join("; ") + " }" +
			(if (postponedSubstitutions.empty) "" else " [[" + postponedSubstitutions.map[it.typeVar.typeAsString + "->" + it.typeArg.getTypeRefAsString(resolveProxies)].join(", ") + "]]")
		});
	}
}

/*
 * Existential type references are parameterized type references inferred from wildcards and
 * bound to type variables during substitution.
 * <p>
 * E.g., the type {@code G<? extends A>} implicitly defines an
 * existential type <i>E</i>, which is a subtype of A, but for all other
 * subtypes <i>S</i> of A, neither <i>E&lt;:S</i> nor <i>S&lt;:E</i> is true.
 * Same is true for wildcards without bounds.
 * <p>
 * Example: Assuming that both B and C extends A, and the following variable declarations:
 * <pre>
 * var G&lt;? extends A> g1 = new G&lt;B>();
 * var G&lt;? extends A> g2 = new G&lt;C>();
 * var G&lt;?> g = new G&lt;A>
 * </pre>
 * With the typical getter/setter methods in G (T get(), set(T)), the following
 * calls must not be allowed:
 * <pre>
 * g1.set(g2.get()); // cannot convert C to B
 * g2.set(g.get());  // cannot convert A to C
 * </pre>
 * Note that the explanation in the example requires knowledge of the actual type
 * which is usually not available at compile time. (That is, in the example, the
 * declared type of g1, g2, and g3 could have been specified without wildcards).
 * <p>
 * For details, see<br/>
 * S. Wehr and P. Thiemann: Subtyping Existential Types. 2008, <a href="http://www.stefanwehr.de/publications/Wehr_Subtyping_existential_types.pdf">PDF</a><br/>
 * N. Cameron, S. Drossopoulou, and E. Ernst: A Model for Java with Wildcards. Springer, 2008,<a href="https://doi.org/10.1007/978-3-540-70592-5_2">DOI</a><br/>
 * M. Torgersen, E. Ernst, and C. P. Hansen: Wild FJ. 2005
 */
class ExistentialTypeRef extends TypeRef {
	/*
	 * Globally unique identifier of this capture. Required due to the copying semantics of
	 * {@code TypeRef}s: unlike types, type references may be copied at will and therefore a
	 * plain POJO identity comparison of two ExistentialTypeRefs cannot be used to check if
	 * two {@code ExistentialTypeRef}s refer to the same capture.
	 */
	String ^id
	/*
	 * If true, this existential type roughly behaves like the wildcard it was created from.
	 * For detailed semantics see {@code SubtypeJudgment#applyExistentialTypeRef_Left|Right()}.
	 */
	boolean reopened

	refers Wildcard wildcard

	/*
	 * Always returns true for existential types.
	 */
	op boolean isExistential() {
		return true
	}
	/*
	 * Always returns true for existential types.
	 */
	op boolean isGeneric() {
		return true;
	}
	/*
	 * Always returns true for existential types.
	 */
	op boolean isParameterized() {
		return true;
	}
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		val wc = this.eGet(TypeRefsPackage.Literals.EXISTENTIAL_TYPE_REF__WILDCARD, resolveProxies) as Wildcard;
		val wcStr = if (wc === null) {
			"«null»"
		} else if (wc.eIsProxy) {
			"?«proxy»"
		} else {
			wc.getTypeRefAsString(resolveProxies)
		};
		return wcStr;
	}
}

/*
 * Unknown type references are the result of an unresolved link or other form of error.
 * No follow up errors should be produced for such unknown type references.
 * <pre>
 * var x = doesNotExist // error here; type of x will be UnknownTypeRef
 * x.cannotKnowIfThisExists // no error here
 * var s: String = x // no error here, either
 * x = s // nor here
 * </pre>
 * Because {@code UnknownTypeRef}s suppress consequential errors, they must never
 * appear in an N4JSResource that does not have any original parse or validation errors!
 */
class UnknownTypeRef extends TypeRef {
	op boolean isUnknown() {
		return true;
	}
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return "«unknown»";
	}
}

/**
 * A reference to the constructor of a type. The constructor
 * can be used in a NewExpression. It is a subtype of the equivalent
 * ClassifierTypeRef.
 */
class TypeTypeRef extends BaseTypeRef {
	contains TypeArgument typeArg
	/*
	 * Tells if this {@link TypeTypeRef} is declared to be a reference to a constructor. This is the case if, in the
	 * source code, keyword {@code constructor} has been used instead of keyword {@code type}:
	 * <pre>
	 * type{C} // flag will be false
	 * constructor{C} // flag will be true
	 * </pre>
	 */
	boolean constructorRef
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		val kwd = if (isConstructorRef) "constructor" else "type";
		val _typeArg = getTypeArg();
		val refName = if (_typeArg === null) '' else _typeArg.getTypeRefAsString(resolveProxies);
		return kwd + "{" + refName + "}" + getModifiersAsString();
	}

	// note: operation getStaticType moved to TypeSystemHelper#getStaticType()
}

class NamespaceLikeRef {
	transient String declaredTypeAsText
	refers Type declaredType
	
	
	op NamespaceLikeRef getPreviousSibling() {
		if (!(eContainer instanceof ParameterizedTypeRef)) {
			return null;
		}
		return (eContainer as ParameterizedTypeRef).getPreviousSibling(this);
	}
}

/*
 * Note: Wildcard has special copy-semantics to preserve the implicit upper bound returned by method
 * {@link Wildcard#getDeclaredOrImplicitUpperBounds()}. When copied, the implicit upper bound is set
 * as declared upper bound in the copy. For details see TypeUtils#copy().
 */
class Wildcard extends TypeArgument {
	contains TypeRef declaredUpperBound
	contains TypeRef declaredLowerBound
	/*
	 * For wildcards contained in the AST, this tells if the wildcard was written in the source code using in/out
	 * notation, i.e. returns <code>true</code> for <code>G&lt;out C></code> and <code>false</code> for
	 * <code>G&lt;? extends C></code>.
	 */
	boolean usingInOutNotation
	/*
	 * An unbounded wildcard given as type argument to a bounded type parameter is implicitly bounded.
	 * For example:
	 * <pre>
	 * class A {}
	 * class G&lt;T extends A> {}
	 *
	 * var G&lt;?> g; // "?" is actually "? extends A"
	 * class H extends G&lt;?> {} // "?" is actually "? extends A"
	 * </pre>
	 * This method returns the declared upper bound of the receiving wildcard or, if the wildcard is unbounded,
	 * tries to obtain the implicit upper bound from the corresponding type parameter of the containing
	 * ParameterizedTypeRef's declared type (if any).
	 * <p>
	 * <b>IMPORTANT:</b> Use of such implicit bounds is prone to infinite recursion and must therefore be guarded
	 * appropriately. Take these two examples:
	 * <pre>
	 * class A&lt;T extends A&lt;?>> {} // directly
	 * </pre><pre>
	 * class X&lt;T extends B&lt;?>> {}
	 * class Y&lt;T extends X&lt;?>> {}
	 * class B&lt;T extends Y&lt;?>> {} // indirectly
	 * </pre>
	 */
	op TypeRef getDeclaredOrImplicitUpperBound() {
		val declUB = declaredUpperBound; // containment -> won't trigger resolution
		if (declUB !== null)
			return declUB;
		if (declaredLowerBound !== null)
			return null; // important: do not inherit upper bounds if we have a declared lower bound!
		// try to compute implicit upper bound from corresponding type parameter (without resolving proxies!)
		val parent = eContainer;
		if (parent instanceof ParameterizedTypeRef) {
			val typeArgIndex = parent.declaredTypeArgs.indexOf(this);
			if (typeArgIndex >= 0) {
				val declType = parent.eGet(TypeRefsPackage.eINSTANCE.getParameterizedTypeRef_DeclaredType(), false);
				if (declType instanceof ContainerType<?>) {
					if(!declType.eIsProxy()) {
						val typeVars = declType.typeVars;
						val typeVar = if(typeArgIndex < typeVars.size) typeVars.get(typeArgIndex) else null;
						if (typeVar !== null) {
							val implicitUB = typeVar.declaredUpperBound; // containment -> won't trigger resolution
							return implicitUB;
						}
					}
				}
			}
		}
		return null; // no implicit upper bound
	}
	/*
	 * Tells if an implicit upper bound is in effect for the given wildcard, i.e. the wildcards does not have declared
	 * bounds (upper or lower) and obtains an implicit bound from the corresponding type parameter.
	 *
	 * @see #getDeclaredOrImplicitUpperBounds()
	 */
	op boolean isImplicitUpperBoundInEffect() {
		return declaredUpperBound === null && declaredLowerBound === null && getDeclaredOrImplicitUpperBound()!==null;
	}
	/*
	 * Convenience method, returns the type expression, usually the type name, as a string. Basically used for testing.
	 * See {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return WildcardAsStringUtils.internalGetTypeRefAsString_workaround(this, resolveProxies);
	}
}


/*
 * Base class for {@link FunctionTypeRef} and {@link FunctionTypeExpression}.
 */
abstract class FunctionTypeExprOrRef extends StaticBaseTypeRef {
	/*
	 * optional thisType declaration e.g. for a given class A it's member-type can be specified as "{A.function():void}"
	 */
	op TypeRef getDeclaredThisType()
	/*
	 * Convenience method, returns the declared type casted to a TFunction
	 */
	op TFunction getFunctionType() {
		return declaredType as TFunction
	}
	/*
	 * The type variables as declared in the expression or of the referenced function type.
	 */
	op TypeVariable[] getTypeVars()
	/*
	 * Returns the upper bounds of the given type variable (which should be one of those returned by
	 * {@link FunctionTypeExprOrRef#getTypeVars()}). Never read the upper bounds directly from the type variable in
	 * case of type variables coming from a FunctionTypeExprOrRef; for more info why this is required, see
	 * {@link FunctionTypeExpression#getTypeVarUpperBound(TypeVariable)}.
	 */
	op TypeRef getTypeVarUpperBound(TypeVariable typeVar)
	/*
	 * The formal parameters as declared in the expression or of the referenced function type.
	 */
	op TFormalParameter[] getFpars()
	op boolean isReturnValueOptional() {
		return returnTypeRef!==null && returnTypeRef.followedByQuestionMark;
	}
	/*
	 * The return type as declared in the expression or of the referenced function type.
	 */
	op TypeRef getReturnTypeRef()
	// TODO returntype -> declaredReturnType
	// TODO returntype = declared || default (Any!?)
	/*
	 * Overrides {@link TypeRef#isGeneric()}
	 */
	op boolean isGeneric() {
		return !typeVars.empty;
	}
	/*
	 * Overrides {@link TypeRef#isRaw()}.
	 */
	op boolean isRaw() {
		if (isGeneric()) {
			val mandatoryTypeParamsCount = typeVars.filter[!optional].size;
			return declaredTypeArgs.size < mandatoryTypeParamsCount;
		}
		return false;
	}
	/**
	 * Returns the formal parameter corresponding to the argument at index 'argIndex' in a function call
	 * or 'null' if 'argIndex' is invalid. This method takes into account optional and variadic parameters.
	 */
	op TFormalParameter getFparForArgIdx(int argIndex) {

		// NOTE: code copied from TFunction#getFparForArgIdx(int) because we might not have a TFunction here!
		val fparsSize = fpars.size();
		if (argIndex >= 0 && argIndex < fparsSize) {
			return fpars.get(argIndex);
		} else if (argIndex >= fparsSize && fparsSize > 0 && fpars.get(fparsSize - 1).isVariadic) {
			return fpars.get(fparsSize - 1);
		}
		return null;
	}
	/*
	 * Overrides {@link TypeRef#internalGetTypeRefAsString(boolean)}
	 */
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		if (!resolveProxies) {
			val _this = this;
			if (_this instanceof FunctionTypeRef) {
				val declType = _this.eGet(TypeRefsPackage.Literals.PARAMETERIZED_TYPE_REF__DECLARED_TYPE, false) as EObject;
				if (declType !== null && declType.eIsProxy) {
					if (_this.declaredTypeAsText !== null) {
						return _this.declaredTypeAsText + "«proxy»";
					}
					return "{function(???):???}«proxy»";
				}
			}
		}
		return "{" + (if (declaredThisType !== null) "@This(" + declaredThisType.getTypeRefAsString(resolveProxies) + ") " else "")
			+ "function"
			+ (if (generic) {
				"<" + typeVars.map[it.getTypeVariableAsString(getTypeVarUpperBound(it))].join(",") + ">"
			} else "")
			+ "(" + fpars.map[it.getFormalParameterAsTypesString].join(",") + ")"
			+ (if (returnTypeRef !== null) ":" + returnTypeRef.getTypeRefAsString(resolveProxies) else "")
			+ (if (returnValueOptional) "?" else "")
			+ "}" + getModifiersAsString();
	}
}

/*
 * Function type, always references a function, that is, declaredType returns a TFunction.
 * This kind of reference is created implicitly by function calls. Clients only <em>using</em> this kind
 * of references should probably better use {@link FunctionTypeExprOrRef}.
 */
class FunctionTypeRef extends ParameterizedTypeRef, FunctionTypeExprOrRef {
	/*
	 * Convenience method, returns the declared this type of the referenced function type.
	 */
	op TypeRef getDeclaredThisType() {
		return functionType.declaredThisType
	}
	/*
	 * Convenience method, returns the type variables of the referenced function type.
	 */
	op TypeVariable[] getTypeVars() {
		return functionType.typeVars
	}
	/*
	 * Simply returns the given type variable's declared upper bounds (required by super class API).
	 */
	op TypeRef getTypeVarUpperBound(TypeVariable typeVar) {
		return typeVar.declaredUpperBound;
	}
	/*
	 * Convenience method, returns the fpars of the referenced function type.
	 */
	op TFormalParameter[] getFpars() {
		return functionType.fpars
	}
	/*
	 * Convenience method, returns the return type of the referenced function type.
	 */
	op TypeRef getReturnTypeRef() {
		return functionType.returnTypeRef
	}
}

/*
 * Function type expression for declaring the type of a variable, parameter, etc. as a function.
 * Clients only <em>using</em> these kind of references should probably better use the API of
 * {@link FunctionTypeExprOrRef}.
 * <p>
 * There are the following use cases of FunctionTypeExpressions:
 * <ol>
 * <li>ordinary, self-contained function type expressions, in particular (i) non-generic
 *     <em>and</em> generic function type expressions that were created programmatically and
 *     (ii) AST nodes for non(!)-generic function type expressions (<b>standard use case</b>).
 * <li>those that are created by type system rule 'substTypeVariablesInFunctionType[ExprOr]Ref'
 *     as a copy of another
 *     <ol type="a">
 *     <li>FunctionTypeRef or
 *     <li>FunctionTypeExpression
 *     </ol>
 *     to represent a particular binding of the original FunctionTypeRef/FunctionTypeExpression
 *     (<b>work-around case</b>).
 * <li>those that represent AST nodes for <em>generic</em> function type expressions
 *     (<b>work-around case</b>).
 * </ol>
 * In standard case 1 the FunctionTypeExpression does *not* have a 'declaredType', because it
 * does not define an actual function (no element like TFunction to be stored in type model).
 * This is why class FunctionTypeExpression does not inherit from BaseTypeRef.
 * <p>
 * Case 2 is only a work-around, because the FunctionTypeRef cannot hold bound references to the
 * function's parameters, and therefore a FunctionTypeExpression is created in the xsemantics rule
 * 'substTypeVariablesInFunctionType[ExprOr]Ref' to represent the binding. In case 2.a only, the
 * FunctionTypeExpression will have a 'declaredType' pointing to the TFunction of the original
 * FunctionTypeRef.
 * <p>
 * Case 3 is also a work-around, required because resolution of lazy links takes place after the
 * types builder may have copied the FunctionTypeExpression contained in the AST and therefore the
 * lazy references to the type variables will be copied to the types model as well. As a result,
 * it is impossible to let the type variable references point to different type variables in the
 * original and copied function type expressions (which would be required for the "self-contained"
 * use case #1 above). The solution is to create a TFunction from the function type expression
 * contained in the AST and let all type variable references point to the type variables in that
 * TFunction. After this adjustment, the function type expression in the AST can be copied without
 * any special handling.
 * <p>
 * Note: this class is intended for function type(!) expressions and may play the role of an
 * ordinary type reference or an AST node; for function expressions there exists a different
 * class {@link org.eclipse.n4js.n4JS.FunctionExpression FunctionExpression} that can
 * only be used as an AST node.
 */
class FunctionTypeExpression extends FunctionTypeExprOrRef {

	/*
	 * Tells if this FunctionTypeExpression represents a binding of a TFunction or
	 * another FunctionTypeExpression (use cases 2.a and 2.b, respectively).
	 * Always true in use case 2; always false in use cases 1 and 3.
	 */
	boolean binding

	/*
	 * Always <code>null</code> in use case 1. In use case 2.a (not 2.b) this refers(!)
	 * to the original TFunction for which this FunctionTypeExpression represents a binding.
	 * In use case 3 this refers(!) to the TFunction in the type model generated from
	 * the FunctionTypeExpression in the AST.
	 * For more details on use cases see API doc of {@link FunctionTypeExpression}.
	 */
	refers TFunction declaredType
	/*
	 * Reference to the declared this-type via @This annotation inside the FunctionTypeExpression.
	 * In use case 2.a this is a copy of <code>declaredType.declaredThisType</code>, in use case
	 * 2.b this is a copy of the original FunctionTypeExperession's declaredThisType.
	 */
	contains TypeRef declaredThisType
	/*
	 * Type variables declared in FunctionTypeExpression (programmatically or in the AST).
	 * In use case #2 this is always empty.
	 */
	contains TypeVariable[] ownedTypeVars
	/*
	 * Always empty in use cases #1 and #3.
	 * In use case #2 this refers(!) to those type variables of the 'declaredType' (case 2.a)
	 * or original FunctionTypeExpression (case 2.b) that were *not* bound when creating this
	 * FunctionTypeExpression as a representation of a particular type variable binding of the
	 * 'declaredType' / original FunctionTypeExpression.
	 */
	refers TypeVariable[] unboundTypeVars
	/*
	 * Property 'unboundTypeVars' refers to type variables contained somewhere else. During type variable substitution,
	 * we would have to substitute type variables in these upper bounds, but we cannot, of course, directly change them.
	 * Thus, for the type variables in unboundTypeVars, rule 'substTypeVariablesInFunctionType[ExprOr]Ref' will store
	 * the upper bounds here, but only if they are different from the type variables original upper bounds. If they are
	 * not different, then an UnknownTypeRef will be used in this list for padding.
	 */
	contains TypeRef[] unboundTypeVarsUpperBounds
	/*
	 * Returns 'ownedTypeVars' in use case #1, 'unboundTypeVars' in use case #2 and the type
	 * variables of the TFunction that was generated from the AST node in use case #3.
	 * For more details on use cases see API doc of {@link FunctionTypeExpression}.
	 */
	op TypeVariable[] getTypeVars() {
		return if(isBinding) unboundTypeVars else ( if(declaredType!==null) declaredType.typeVars else ownedTypeVars );
	}
	/*
	 * Returns the upper bounds of the given type variable (which should be one of those returned by
	 * {@link FunctionTypeExprOrRef#getTypeVars()}). Usually, this will just return
	 * {@link TypeVariable#getDeclaredUpperBounds()}, but in case of a FunctionTypeExpression created during type
	 * variable substitution, a different upper bound might be returned (i.e. original upper bound after type variable
	 * substitution).
	 * <p>
	 * See property {@link FunctionTypeExpression#getUnboundTypeVarsUpperBounds() unboundTypeVarsUpperBounds} and
	 * method {@link SubstTypeVariablesJudgment#performSubstitutionOnUpperBounds()}.
	 */
	op TypeRef getTypeVarUpperBound(TypeVariable typeVar) {
		if(typeVar===null) {
			throw new IllegalArgumentException("given type variable may not be null");
		}
		val idx = unboundTypeVars.indexOf(typeVar);
		if(idx>=0 && idx<unboundTypeVarsUpperBounds.size) {
			val modifiedUpperBound = unboundTypeVarsUpperBounds.get(idx);
			if(!modifiedUpperBound.isUnknown) { // we allow 'unboundTypeVarsUpperBounds' to contain UnknownTypeRefs for padding
				return modifiedUpperBound;
			}
		}
		return typeVar.declaredUpperBound;
	}
	// TODO extract FormalParameterContainer
	/*
	 * Formal parameters declared in the FunctionTypeExpression in the AST or
	 * a copy of the formal parameters of the 'declaredType' or original FunctionTypeExpression.
	 */
	contains TFormalParameter[] fpars
	/*
	 * Explicitly marks the return value of this FunctionTypeExpression as optional. This only used for function type
	 * expressions that are created programmatically. Those that appear in the AST will instead have a 'returnTypeRef'
	 * with 'followedByQuestionMark' set to <code>true</code>.
	 * This will probably become obsolete once we implement undefined/null analysis.
	 */
	boolean returnValueMarkedOptional
	op boolean isReturnValueOptional() {
		return returnValueMarkedOptional || (returnTypeRef!==null && returnTypeRef.followedByQuestionMark);
	}
	/*
	 * Return type declared in the FunctionTypeExpression in the AST or
	 * a copy of the return type of the 'declaredType' or original FunctionTypeExpression.
	 */
	contains TypeRef returnTypeRef
	
	/* @see TypeRef#getASTOptionalFieldStrategy() */
	transient OptionalFieldStrategy aSTNodeOptionalFieldStrategy
}

/**
 * A TypeRef used by the types builder to denote that some other part of the implementation is responsible
 * for creating a certain type reference. Usually created by the {@code N4JSTypesBuilder} and replaced by
 * a correct type reference during post-processing by {@code TypeDeferredProcessor}.
 */
class DeferredTypeRef extends TypeRef {
	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return "«deferred»";
	}
}

/*
 * Helper class to store a type variable mapping,
 * i.e. a particular type variable and its type argument.
 */
class TypeVariableMapping {
	refers TypeVariable typeVar
	contains TypeArgument typeArg
}


abstract class LiteralTypeRef extends TypeRef {
	transient Object astValue
	op Object getValue()
}

class BooleanLiteralTypeRef extends LiteralTypeRef {
	Boolean value

	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return value?.toString ?: astValue?.toString ?: "«null»";
	}
}

class NumericLiteralTypeRef extends LiteralTypeRef {
	/* True iff this is used as an AST node <em>and</em> the {@link LiteralTypeRef#getAstValue() astValue} needs to be negated to obtain the actual value. */
	boolean astNegated
	BigDecimal value

	op String internalGetTypeRefAsString(boolean resolveProxies) {
		return value?.stripTrailingZeros?.toPlainString ?: astValue?.toString ?: "«null»";
	}
}

class StringLiteralTypeRef extends LiteralTypeRef {
	String value

	op String internalGetTypeRefAsString(boolean resolveProxies) {
		if (value === null && astValue === null) {
			return "«null»";
		}
		return '"' + (if (value !== null) Strings.escapeNonPrintable(value) else astValue.toString) + '"';
	}
}

/*
 * Not directly available to the programmer. Only used internally as the type of enum literals.
 */
class EnumLiteralTypeRef extends LiteralTypeRef {
	refers TEnumLiteral value

	op TEnum getEnumType() {
		return value?.eContainer as TEnum;
	}

	op String internalGetTypeRefAsString(boolean resolveProxies) {
		if (value === null && astValue !== null) {
			return astValue.toString;
		}
		return (enumType?.name ?: "«null»") + "." + (value?.name ?: "«null»");
	}
}
