/**
 * Copyright (c) 2016 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */
@Ecore(nsURI="http://www.eclipse.org/n4js/n4js/N4JS")
@GenModel(fileExtensions="n4js",
//	modelPluginID="org.eclipse.n4js.model",
	rootExtendsClass="org.eclipse.n4js.utils.emf.ProxyResolvingEObjectImpl",
	modelDirectory="/org.eclipse.n4js.model/emf-gen",
	forceOverwrite="true",
	updateClasspath="false",
	literalsInterface="true",
	loadInitialization="false",
	complianceLevel="11.0",
	copyrightFields="false",
	// both copyrightText and documentation are required to align the output of the MWE2 and incremental builder (see GH-841)
	copyrightText="Copyright (c) 2016 NumberFour AG.\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nwhich accompanies this distribution, and is available at\nhttp://www.eclipse.org/legal/epl-v10.html\n\nContributors:\n  NumberFour AG - Initial API and implementation",
	documentation="*\nCopyright (c) 2016 NumberFour AG.\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License v1.0\nwhich accompanies this distribution, and is available at\nhttp://www.eclipse.org/legal/epl-v10.html\n * Contributors:\n  NumberFour AG - Initial API and implementation",
	language="")

package org.eclipse.n4js.n4JS

import java.util.Collections
import java.util.Iterator
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.ecore.EObject
import org.eclipse.n4js.ts.typeRefs.ParameterizedTypeRef
import org.eclipse.n4js.ts.typeRefs.TypeRef
import org.eclipse.n4js.ts.types.ComposedMemberCache
import org.eclipse.n4js.ts.types.IdentifiableElement
import org.eclipse.n4js.ts.types.ModuleNamespaceVirtualType
import org.eclipse.n4js.ts.types.TAbstractVariable
import org.eclipse.n4js.ts.types.TClass
import org.eclipse.n4js.ts.types.TDynamicElement
import org.eclipse.n4js.ts.types.TEnum
import org.eclipse.n4js.ts.types.TEnumLiteral
import org.eclipse.n4js.ts.types.TExportableElement
import org.eclipse.n4js.ts.types.TField
import org.eclipse.n4js.ts.types.TFormalParameter
import org.eclipse.n4js.ts.types.TFunction
import org.eclipse.n4js.ts.types.TGetter
import org.eclipse.n4js.ts.types.TInterface
import org.eclipse.n4js.ts.types.TMember
import org.eclipse.n4js.ts.types.TModule
import org.eclipse.n4js.ts.types.TNamespace
import org.eclipse.n4js.ts.types.TSetter
import org.eclipse.n4js.ts.types.TStructField
import org.eclipse.n4js.ts.types.TStructGetter
import org.eclipse.n4js.ts.types.TStructMember
import org.eclipse.n4js.ts.types.TStructMethod
import org.eclipse.n4js.ts.types.TStructSetter
import org.eclipse.n4js.ts.types.TVariable
import org.eclipse.n4js.ts.types.TypableElement
import org.eclipse.n4js.ts.types.Type
import org.eclipse.n4js.ts.types.TypeAlias
import org.eclipse.n4js.ts.types.TypeVariable
import org.eclipse.n4js.ts.types.TypingStrategy
import org.eclipse.n4js.utils.EcoreUtilN4
import org.eclipse.n4js.utils.UtilN4

type IteratorOfExpression wraps Iterator<Expression>
type IteratorOfYieldExpression wraps Iterator<YieldExpression>
type IteratorOfStatement wraps Iterator<Statement>
type IteratorOfReturnStatement wraps Iterator<ReturnStatement>
type ParameterizedTypeRefNodeIterable wraps Iterable<TypeReferenceNode<ParameterizedTypeRef>>

/**
 * Common interface for all AST elements providing a name.
 * Note that this is different from the types base class IdentifiableElement on purpose, in order
 * to help distinguishing between AST and types model.
 *
 * Could be modeled as abstract super class, but we do not want to run into problems with Xcore and
 * operation overriding.
 */
interface NamedElement {
	op String getName()
}

/**
 * Common interface for all AST elements that contain a control flow.
 */
interface ControlFlowElement {
	// empty (marker interface)
}

// ****************************************************************************************************
// Root element is a script,
// cf. http://wiki.ecmascript.org/doku.php?id=harmony:modules
// ****************************************************************************************************


/*
 * Root element
 */
class Script extends VariableEnvironmentElement, AnnotableElement, ControlFlowElement {
	String hashbang
	contains Annotation[] annotations
	contains ScriptElement[] scriptElements
	refers transient TModule module
	/**
	 * Flag set after linking-phase is closed. Model is in it's final state and computation
	 * of element-usage is sealed.
	 */
	transient boolean flaggedUsageMarkingFinished
}

abstract class ScriptElement {
}

// ****************************************************************************************************
// Export and Import
// ****************************************************************************************************
class ExportDeclaration extends AnnotableScriptElement, NamespaceElement, ModuleRef {
	contains ExportableElement exportedElement
	contains Expression defaultExportedExpression
	contains NamespaceExportSpecifier namespaceExport
	contains NamedExportSpecifier[] namedExports
	boolean defaultExport

	op boolean isHollow() {
		return exportedElement.isHollow();
	}

	/*
	 * Tells whether this is a "re-export", i.e. something like:
	 * <pre>export { Cls } from "a/b/module";</pre>
	 * <b>not</b> something like:
	 * <pre>export { Cls };</pre>
	 */
	op boolean isReexport() {
		return isReferringToOtherModule();
	}
}

class NamespaceExportSpecifier extends TypeDefiningElement {
	String alias
}

class NamedExportSpecifier {
	contains IdentifierRef exportedElement
	String alias
}

/*
 * TODO add support for separated export statements, i.e. code like this:
 * <pre>
 * class C {}
 * export {C as X}
 * </pre>
 */
abstract class ExportableElement extends NamespaceElement {
	op boolean isExported() {
		return isDeclaredExported() || isExportedByNamespace();
	}
	op boolean isDeclaredExported() {
		return eContainer instanceof ExportDeclaration;
	}
	op boolean isExportedByNamespace() {
		var ns = namespace;
		if (ns !== null) {
			return ns.isExported;
		}
		return false;
	}
	op boolean isExportedAsDefault() {
		return isDeclaredExported() && (eContainer as ExportDeclaration).isDefaultExport;
	}
	// FIXME clean up
	op String getExportedName() {
		if (isExported) {
			if (isDeclaredExported()) {
				val exportDecl = eContainer as ExportDeclaration;
				if (exportDecl.defaultExport) {
					// note: using name "default" below seems like a dirty hack, but this is actually consistent with how
					// ES6 default import/export is defined ("The default export is actually just a named export with the
					// special name default.", A. Rauschmayer in "Exploring ES6", Section 16.4.5.2).
					// For example, the following two lines are equivalent in ES6:
					//     import myFoo from "Other"
					//     import {default as myFoo} from "Other"
					return UtilN4.EXPORT_DEFAULT_NAME;
				}
			}
			val me = this;
			return switch(me) {
				NamedElement: me.name
				IdentifiableElement: me.name
			};
		}
		return null;
	}
	/**
	 * Returns true if element is a top-level declaration in the script, this is also true if element is actually exported
	 * (and is a child of an export statements). This should be true for most declarations, however some (as function declaration) may be nested (and
	 * transpiled to expressions later).
	 */
	op boolean isToplevel() {
		if (eContainer instanceof ExportDeclaration) {
			return eContainer.eContainer instanceof Script
		}
		return eContainer instanceof Script;
	}
	
	op boolean isHollow() {
		return false;
	}
}

/*
 * Abstract base for elements that may refer to another module, i.e. {@link ImportDeclaration}s (always)
 * and {@link ExportDeclaration}s (in case of re-exports).
 */
abstract class ModuleRef {

	refers TModule module
	transient String moduleSpecifierAsText
	transient ModuleSpecifierForm moduleSpecifierForm

	/* Tells whether this {@link ModuleRef} is actually referring to another model, without triggering proxy resolution. */
	op boolean isReferringToOtherModule() {
		return eGet(N4JSPackage.Literals.MODULE_REF__MODULE, false) !== null;
	}
}

class ImportDeclaration extends AnnotableScriptElement, ModuleRef {
	contains ImportSpecifier[] importSpecifiers
	boolean importFrom

	/*
	 * Tells if this import is a so-called "bare import" of the form:
	 * <pre>
	 * import "path/to/SomeModule"
	 * </pre>
	 */
	op boolean isBare() {
		return importSpecifiers.empty;
	}

	/*
	 * Tells whether this import declaration will be present in the transpiled output code.
	 * Derived from {@link ImportSpecifier#isRetainedAtRuntime() retainedAtRuntime} and
	 * therefore only valid after AST traversal has completed.
	 */
	op boolean isRetainedAtRuntime() {
		return isBare() || importSpecifiers.exists[isRetainedAtRuntime()];
	}
}

enum ModuleSpecifierForm {
	/*
	 * Unknown form. This is the default value and will be changed in {@code ProjectImportEnablingScope}.
	 */
	UNKNOWN,
	/*
	 * A module specifier without leading project name.<p>
	 * Example: <code>import {C} from "path/to/module"</code>.
	 */
	PLAIN,
	/*
	 * A module specifier including the target project's name.<p>
	 * Example: <code>import {C} from "project-name/path/to/module"</code>.
	 */
	COMPLETE,
	/* 
	 * A module specifier consisting only of a project name (a.k.a. "bare import").
	 * The target project defines a main module in its package.json.<p>
	 * Example: <code>import {C} from "project-name"</code>.
	 */
	PROJECT,
	/* 
	 * Error case. Same as {@link #PROJECT}, but the target project does not
	 * define a main module in its package.json.
	 */
	PROJECT_NO_MAIN
}

abstract class ImportSpecifier {
	/*
	 * True iff this import specifier is actually used during scoping.
	 * See {@code org.eclipse.n4js.scoping.imports.OriginAwareScope}
	 */
	transient boolean flaggedUsedInCode
	/*
	 * Tells whether this import specifier will be present in the transpiled output code.
	 * Set at the end of AST traversal.
	 */
	transient boolean retainedAtRuntime

	boolean declaredDynamic
}

class NamedImportSpecifier extends ImportSpecifier {

	refers transient TDynamicElement definedDynamicElement

	refers TExportableElement importedElement
	transient String importedElementAsText

	String alias

	op boolean isDefaultImport() {
		false
	}
}

class DefaultImportSpecifier extends NamedImportSpecifier {

	op String getAlias() {
		return importedElementAsText;
	}

	op boolean isDefaultImport() {
		true
	}
}

class NamespaceImportSpecifier extends ImportSpecifier, TypeDefiningElement {
	String alias
}

// ****************************************************************************************************
// Abstract Base Elements
// ****************************************************************************************************

/*
 * All type references contained in the AST are represented by this class, so this provides
 * a common bridge from the AST model to the Type/TypeRefs models.
 */
class TypeReferenceNode<T extends TypeRef> {
	/*
	 * Same as {@link #getTypeRefInAST()}, but processed by the {@code TypeRefProcessor} during
	 * post-processing. Currently, this processing only includes resolution of type aliases but
	 * more may be added in the future.
	 * <p>
	 * The returned type reference may or may not be identical with the one returned from
	 * {@link #getTypeRefInAST()}, and thus it may or may not be contained in the AST.
	 * <p>
	 * Since a type reference can change from {@code ParameterizedTypeRef} to something else
	 * (e.g. {@code FunctionTypeExpression}) during type alias resolution, depending on the
	 * aliased type, the type of this property must be {@link TypeRef} instead of {@code T}.
	 */
	op TypeRef getTypeRef() {
		val result = this.cachedProcessedTypeRef;
		if (result === null && typeRefInAST !== null) {
			throw new IllegalStateException("attempt to access resolution of a typeRefInAST before it was computed by TypeRefProcessor");
		}
		return result;
	}
	refers transient TypeRef cachedProcessedTypeRef
	/**
	 * The type reference contained in the AST as created by the parser. When an AST node is
	 * required (e.g. creating an issue during validation) this property should be used; when
	 * actual type information is needed (e.g. for type checking purposes) getter {@link getTypeRef()}
	 * should be used, because it returns the processed type reference (i.e. with type aliases
	 * being resolved).
	 */
	contains T typeRefInAST
}

/*
 * Element which may contain a declared type, typically a typed element.
 * Some rare elements have a declared type contained in some child element, e.g. getters.
 */
interface TypeProvidingElement {
	op TypeRef getDeclaredTypeRef()
	op TypeRef getDeclaredTypeRefInAST()
	op TypeReferenceNode<TypeRef> getDeclaredTypeRefNode()
}

/* A typed element, such as Variable, a Member or a NameValuePair, may provide a declared type.
 * Note firstly that the declared type may be empty, and secondly that the declared type is different from the
 * inferred type. The latter means that it is of course possible to infer the type of non-typed elements,
 * such as expressions!
 * Note that a function definition is not a typed element, as it is a type definition rather than a type reference.
 * This is indicated by possibly unbound type parameters!
 */
abstract class TypedElement extends TypeProvidingElement {
	op TypeRef getDeclaredTypeRef() {
		return declaredTypeRefNode?.typeRef;
	}
	op TypeRef getDeclaredTypeRefInAST() {
		return declaredTypeRefNode?.typeRefInAST;
	}
	contains TypeReferenceNode<TypeRef> declaredTypeRefNode
}

// TODO jvp: check ECMAScript spec and probably update this environment things with function and classes
/* Element to which a lexical environment (containing a dictionary of variables, the variable environment) may be
 * associated with
 * (cf. ECMAScript Language Specification. International Standard ECMA-262, 5.1 Edition, paragraph 10.2).
 * This is true for Script, FunctionDefintion, WithStatement, and CatchBlock.
 * Note that this is not true for classes (or object literals in general),
 * as members are only accessed via "this" (which is not modeled as a variable, but as an expression
 * allowing access to properties of the current context).
 */
abstract class VariableEnvironmentElement {
	/**
	 * Tells if this variable environment element applies only to block scoped elements, i.e. let & const.
	 * Returns <code>true</code> for {@link Block} and {@link ForStatement}, <code>false</code> otherwise.
	 */
	op boolean appliesOnlyToBlockScopedElements() {
		false // overridden by Block, ForStatement, and SwitchStatment to return true
	}
}

/* Possible target to which a this expression may be bound. This is used in the type inferrer.
 * Note that this is not bound by local scoping, as \'this\' is not a variable (or cross reference)!
 */
abstract class ThisTarget {
}

/*
 * Depending on the mode the this keyword may be bound to the thisArg, implicitly
 * set in case of function calls. Thus, a "ThisArgProvider" may be a function,
 * which could also be a getter or setter (which are not defined as function definitions).
 * (cf ECMAScript 10.4.3 Entering Function Code)
 * Note that this is not bound by local scoping, as \'this\' is not a variable (or cross reference)!
 */
abstract class ThisArgProvider {
}

/* Abstract super type of
 * <ul>
 * <li>declared variables ({@link VariableDeclaration}),
 * <li>formal parameters ({@link FormalParameter}),
 * <li>variables declared in catch clause ({@link CatchVariable}).
 * </ul>
 * but *not* of {@link N4TypeVariable}.
 */
abstract class AbstractVariable<T extends TAbstractVariable> extends TypedElement, TypableElement, NamedElement {

	String name

	refers transient T definedVariable

	/**
	 * Returns true if variable is defined as const. This is only true for variables declared in const statement.
	 */
	op boolean isConst() {
		return false;
	}
}

// ****************************************************************************************************
// N4 Annotations
// ****************************************************************************************************
/*
 * Abstract base class or all elements which can be annotated.
 * The associated annotations are obtained via {@link #getAnnotations()}.
 * Concrete annotable elements may use an {@link AbstractAnnotationList} or a containment
 * reference to hold the annotations.
 *
 * Annotations are best retrieved via AnnotationDefinition.hasAnnotation(), as this takes transitivity into account as well.
 */
abstract class AnnotableElement {
	/**
	 * Returns the owned annotations of the AST element; however it is recommended to access
	 * annotations only via AnnotationDefinition and use type model annotation (or fields) if ever possible.
	 */
	op Annotation[] getAnnotations()

	/**
	 * Returns the effective annotations of this annotable element. This includes the {@link #getAnnotations()}
	 * and the annotations on the containing ExportDeclaration, if any.
	 */
	op Annotation[] getAllAnnotations() {
		val result = <Annotation>newBasicEList()
		val parent = eContainer
		if(parent instanceof ExportDeclaration) {
			result += parent.annotations
		}
		result += annotations
		return result
	}
}

abstract class AnnotableScriptElement extends AnnotableElement, ScriptElement {
	contains AnnotationList annotationList
	op Annotation[] getAnnotations() {
		annotationList?.annotations ?: emptyEList
	}
}

abstract class AnnotableExpression extends AnnotableElement, Expression {
	contains ExpressionAnnotationList annotationList
	op Annotation[] getAnnotations() {
		annotationList?.annotations ?: emptyEList
	}
}

/*
 * A simple container for a bunch of annotations.
 */
abstract class AbstractAnnotationList {
	/**
	 * AST Annotations, it is recommended to use
	 * TAnnotations or corresponding fields defined in the types model.
	 */
	contains Annotation[] annotations
}

/*
 * An {@link AnnotationList} holds annotations and can be directly contained
 * in a script, block or may be a placeholder for exported elements.
 * This allows to handle syntax errors in the input file gracefully while
 * being able to left factor the grammar to make it parseable.
 */
class AnnotationList extends AbstractAnnotationList, Statement, ExportableElement {
}

/*
 * An {@link ExpressionAnnotationList} holds annotations and can be a placeholder
 * where an {@link Expression} is expected.
 * This allows to handle syntax errors in the input file gracefully while
 * being able to left factor the grammar to make it parseable.
 */
class ExpressionAnnotationList extends AbstractAnnotationList, Expression {
}

/**
 * AST Annotation element. Most information defined in annotations is either
 * available via fields or corresponding annotations in the type model. It
 * is recommended to use the information found in the type model (see
 * TAnnotation) instead of recurring to the AST annotations.
 */
class Annotation extends NamedElement {
	String name
	contains AnnotationArgument[] args
	/**
	 * Returns the annotated element. This is usually an AnnotableElement, but in some cases
	 * annotations are hold in an annotation list. In the later case, the container of the list
	 * is returned.
	 */
	op EObject getAnnotatedElement() {
		if (eContainer instanceof AbstractAnnotationList) {
			return eContainer.eContainer;
		}
		return eContainer
	}
}

abstract class AnnotationArgument {
	/** Convenience method, returns the literal or type reference */
	op EObject value()
	/**
	  * Convenience method, returns the value of the argument as string, or null, if no such value is present.
	  */
	op String getValueAsString() {
		val value = value();
		if (value === null) {
			return null;
		}
		return switch (value) {
			Literal: value.getValueAsString()
			TypeRef: value.typeRefAsString
			default: value.toString()
		}
	}
}

/**
 * AST Annotation Argument with a literal, it is recommended to use
 * TAnnotationStringArgument or corresponding type model related field
 * to access this information.
 */
class LiteralAnnotationArgument extends AnnotationArgument {
	contains Literal literal
	op Literal value() {
		return literal;
	}
}

/**
 * AST Annotation Argument with a type reference, it is recommended to use
 * TAnnotationTypeRefArgument or corresponding type model related field
 * to access this information.
 */
class TypeRefAnnotationArgument extends AnnotationArgument {
	op TypeRef getTypeRef() {
		return typeRefNode?.typeRef;
	}
	contains TypeReferenceNode<TypeRef> typeRefNode

	op TypeRef value() {
		return typeRef;
	}
}

// ****************************************************************************************************
// ECMAScript Elements
// ****************************************************************************************************
/*
 * Base class for functions or getter/setter.
 */
abstract class FunctionOrFieldAccessor extends AnnotableElement, VariableEnvironmentElement, ThisArgProvider, TypableElement {
	contains Block body
	op String getName()

	refers transient TVariable implicitArgumentsVariable

	op boolean isReturnValueOptional() {
		return false;
	}

	/**
	 * Default implementation, always returns false (since accessors cannot be async), overridden in FunctionDefinition
	 */
	op boolean isAsync() {
		return false;
	}

	op IdentifiableElement getDefinedFunctionOrAccessor() {
		val _this = this;
		return switch(_this) {
			FunctionDefinition: _this.definedType
			FieldAccessor: _this.definedAccessor
		};
	}
}



/* A function definition is either a FunctionDeclaration, a FunctionExpression or a MethodDeclaration.
 * Note that, since an anonymous function expression has no name, the function definition is not a named element.
 */
abstract class FunctionDefinition extends FunctionOrFieldAccessor, TypeDefiningElement {
	contains FormalParameter[] fpars
	/*
	 * Tells if the return value is optional.
	 */
	op boolean isReturnValueOptional() {
		return (definedFunction!==null && definedFunction.returnValueOptional) // see (*) below
			|| (declaredReturnTypeRefNode?.typeRefInAST!==null && declaredReturnTypeRefNode.typeRefInAST.followedByQuestionMark);
		// regarding (*) above: in case of arrow functions, the optionality of the return value can be "inferred" from a
		// type expectation and in this case the 'returnValueOptional' flag will be true only in the defined function in
		// the TModule; hence, it is important to check for an existing defined function here.
	}
	op TypeRef getDeclaredReturnTypeRef() {
		return declaredReturnTypeRefNode?.typeRef;
	}
	op TypeRef getDeclaredReturnTypeRefInAST() {
		return declaredReturnTypeRefNode?.typeRefInAST;
	}
	/*
	 * Developer-provided hint for the return type of this FunctionDefinition.
	 * In case it's not provided, this reference remains null.
	 * In contrast, reference definedType contains a TFunction whose returnTypeRef is always non-null irrespective of whether the hint was provided or not.
	 */
	contains TypeReferenceNode<TypeRef> declaredReturnTypeRefNode

	/*
	 * Whether the function is a generator
	 */
	boolean generator

	/**
	 * Whether the function has been defined with the async keyword. In order to query if a function definition is
	 * async, use isAsync as this is maybe derived from other fields.
	 */
	boolean declaredAsync

	/**
	 * Default implementation just returns declaredAsync value, also overrides default implementation in FunctionOrFieldAcccessor
	 */
	op boolean isAsync() {
		return declaredAsync;
	}

	/* Convenience method returning the 'definedType' if it is a TFunction, otherwise <code>null</code>. */
	op TFunction getDefinedFunction() {
		val defType = definedType;
		return if(defType instanceof TFunction) { defType };
	}
}

/*
 * Base class for getters and setter, of either object literals (PropertyG/SetterDeclaration) or classes (N4G/SetterDeclaration).
 */
abstract class FieldAccessor extends FunctionOrFieldAccessor, TypeProvidingElement, PropertyNameOwner { // note: super-class is TypableElement

	boolean declaredOptional

	/*
     * The declared type of the field accessor (resolved), which is either the return type of the getter or the type of the formal parameter in case of a setter.
     */
	op TypeRef getDeclaredTypeRef()
	/*
     * The declared type of the field accessor (from the AST), which is either the return type of the getter or the type of the formal parameter in case of a setter.
     */
	op TypeRef getDeclaredTypeRefInAST()
	/*
     * The declared type of the field accessor (as node), which is either the return type of the getter or the type of the formal parameter in case of a setter.
     */
	op TypeReferenceNode<TypeRef> getDeclaredTypeRefNode()

	/*
	 * Returns the defined FieldAccessor in the TModule, either a TGetter or a TSetter.
	 */
	op org.eclipse.n4js.ts.types.FieldAccessor getDefinedAccessor()

	op boolean isOptional() {
		return declaredOptional;
	}
}

// TODO jvp: probably need operation getTypeRef(), should be similarly handled as variables
/**
 * Function declarations should only be contained in the script or functions, that is, they should not be nested in blocks.
 * This is ensured by the ASTStructureValidator.
 */
class FunctionDeclaration extends AnnotableScriptElement, ModifiableElement, Statement, FunctionDefinition, GenericDeclaration, ExportableElement, NamedElement {
	/*
	 * Function declarations are not treated as identifiable elements, as the binding should
	 * refer to the inferred TFunction rather than this declaration. The name is mandatory.
	 */
	String name
	/**
	 * Returns true if type is declared as external.
	 */
	op boolean isExternal() {
		return isDeclaredExternal() || isDefaultExternal();
	}
}

class FunctionExpression extends FunctionDefinition, AnnotableExpression, GenericDeclaration, NamedElement {
	/*
	 * Function expression are not treated as identifiable elements, as the binding should
	 * refer to the inferred TFunction rather than this declaration. The name is optional.
	 */
	String name
	/**
	 * Whether this function expression was defined as an arrow function or not.
	 * Overridden in subclass ArrowFunction.
	 */
	op boolean isArrowFunction() { false }

//	/*
//	 * Convenience method,  returns true if the function is a property's value of
//	 * an ObjectLiteral or if it is a method.
//	 */
//	op boolean isPropertyOrMethod() {
//		return eContainer!=null && eContainer.eContainer instanceof ObjectLiteral;
//	}

}

class ArrowFunction extends FunctionExpression {

	/**
	 * Whether this arrow function has braces around its (single or multiple statements) body.
	 */
	boolean hasBracesAroundBody

	op boolean isArrowFunction() { true }

	/**
	 * This method reports whether the body of the lambda consists of a single expression not enclosed in braces.
	 *
	 * The presence of enclosing braces implies block semantics for the lambda's body,
	 * ie a block encloses statements (even if only one, an expression statement).
	 * As usual, the block can be void-typed or some-value-typed;
	 * the latter case requires the presence of explicit return-some-value statements.
	 *
	 * An arrow function lacking braces and having a body consisting of just:
	 *   - return-some-value --- is malformed (syntax error)
	 *   - return;           --- is malformed (syntax error)
	 *   - expr              --- is ok, where expr instanceof ExpressionStatement;
	 *                           otherwise malformed and caught by the grammar.
	 *
	 * This method returns true only for the last case above.
	 * Please notice that isSingleExprImplicitReturn() === true doesn't allow drawing conclusion on the type of the lambda body,
	 * i.e. it could be either void-typed (eg, expr denotes the invocation of a void method)
	 * or some-value-typed. An implicit return is warranted only in the latter sub-case.
	 */
	op boolean isSingleExprImplicitReturn() {
		arrowFunction &&
		!hasBracesAroundBody &&
		(body !== null) &&
		!body.statements.isEmpty &&
		(body.statements.head instanceof ExpressionStatement)
	}

	/**
	 * If {@link #isSingleExprImplicitReturn()} returns <code>true</code>, this method will return the single expression
	 * that makes up the body of this arrow function, otherwise the behavior is undefined (might throw exception).
	 * <p>
	 * In case of broken AST, this method may return <code>null</code> even if {@link #isSingleExprImplicitReturn()}
	 * returns <code>true</code>.
	 */
	op Expression getSingleExpression() {
		return (body.statements.head as ExpressionStatement).expression;
	}

	/**
	 * The lambda's implicit return expression (precondition: isSingleExprImplicitReturn).
	 */
	op Expression implicitReturnExpr() {
		if (isSingleExprImplicitReturn) {
			// the expression below never throws because the condition above guards against that
			(body.statements.get(0) as ExpressionStatement).expression
		} else {
			null
		}
	}

}

class FormalParameter extends AnnotableElement, AbstractVariable<TFormalParameter> {
	contains Annotation[] annotations
	boolean variadic
	/* A formal parameter with a default value in a function 'foo' can look like this:
	 * foo(defParam = undefined){}, with 'undefined' as the initializing expression, which can be omitted.
	 * When the initializer is omitted, it evaluates to 'undefined'. To know whether a parameter is a
	 * default parameter, we need to know about the existence of the initializer assignment sign '='.
	 * Hence, the following boolean property exists. */
	boolean hasInitializerAssignment
	/* The initializer can be null despite being a default parameter. */
	contains Expression initializer
	contains BindingPattern bindingPattern
}

class Block extends Statement, VariableEnvironmentElement {
	contains Statement[] statements

	/** See {@link VariableEnvironmentElement#appliesOnlyToBlockScopedElements()}. */
	op boolean appliesOnlyToBlockScopedElements() {
		true
	}

	/*
	 * Returns all return expressions contained in this block, including those in nested blocks
	 * but without delving into nested classes, or into nested expressions including functions.
	 */
	op IteratorOfExpression getAllExpressions() {
		EcoreUtilN4.getAllContentsFiltered(this, [!(it instanceof FunctionDefinition)]).filter(Expression)
	}
	/*
	 * Returns all return yield expressions contained in this block, including those in nested blocks
	 * but without delving into nested classes, or into nested expressions including functions.
	 */
	op IteratorOfYieldExpression getAllYieldExpressions() {
		getAllExpressions().filter(YieldExpression)
	}
	/*
	 * Returns all return yield expressions contained in this block that dont't return any value, including those in nested blocks
	 * but without delving into nested classes, or into nested expressions including functions.
	 */
	op IteratorOfYieldExpression getAllVoidYieldExpressions() {
		getAllYieldExpressions().filter([it.expression === null])
	}
	/*
	 * Returns all return yield expressions contained in this block that return some value, including those in nested blocks
	 * but without delving into nested classes, or into nested expressions including functions.
	 */
	op IteratorOfYieldExpression getAllNonVoidYieldExpressions() {
		getAllYieldExpressions().filter([it.expression !== null])
	}
	/*
	 * True iff one or more yield expressions exist in this block that return some value.
	 */
	op boolean hasNonVoidYield() {
		!(allNonVoidYieldExpressions.isEmpty)
	}

	/*
	 * Returns all statements that belong to this block. This includes statements of nested blocks
	 * but excludes statements in nested classes, nested functions, etc.
	 */
	op IteratorOfStatement getAllStatements() {
		EcoreUtilN4.getAllContentsFiltered(this, [!(it instanceof Expression || it instanceof FunctionDefinition)]).
			filter(Statement)
	}
	/*
	 * Returns all return statements contained in this block (whether they return a value or not), including those in nested blocks
	 * but without delving into nested classes, or into nested expressions including functions.
	 */
	op IteratorOfReturnStatement getAllReturnStatements() {
		getAllStatements.filter(ReturnStatement)
	}
	/*
	 * Returns all return statements contained in this block that return some value, including those in nested blocks
	 * but without delving into nested classes, or into nested expressions including functions.
	 */
	op IteratorOfReturnStatement getAllNonVoidReturnStatements() {
		getAllReturnStatements.filter([it.expression !== null])
	}
	/*
	 * Returns all return statements contained in this block that don't return any value, including those in nested blocks
	 * but without delving into nested classes, or into nested expressions including functions.
	 */
	op IteratorOfReturnStatement getAllVoidReturnStatements() {
		getAllReturnStatements.filter([it.expression === null])
	}
	/*
	 * True iff one or more return statements exist in this block that return some value.
	 */
	op boolean hasNonVoidReturn() {
		!(allNonVoidReturnStatements.isEmpty)
	}
}

class Statement extends ScriptElement, ControlFlowElement {
}

enum VariableStatementKeyword {
	^var
	, const
	, let
}

/**
 * Base class for elements containing variable declarations.
 * <p>
 * IMPORTANT: the variable declarations need not be <em>directly</em> contained! In order to support destructuring, a
 * {@link VariableBinding} and other destructuring-related nodes might appear in between. To get from a
 * {@link VariableDeclaration} to its <code>VariableDeclarationContainer</code> use method
 * {@link org.eclipse.n4js.n4JS.N4JSASTUtils#getVariableDeclarationContainer(VariableDeclaration)}.
 */
abstract class VariableDeclarationContainer {
	contains VariableDeclarationOrBinding[] varDeclsOrBindings
	VariableStatementKeyword varStmtKeyword

	op VariableDeclaration[] getVarDecl() {
		varDeclsOrBindings.map[it.getAllVariableDeclarations()].flatten.toEList
	}
	op boolean isBlockScoped() {
		switch(varStmtKeyword) {
			case LET: true
			case CONST: true
			case VAR: false
			default: throw new UnsupportedOperationException("unsupported enum literal: " + varStmtKeyword)
		}
	}
}

class VariableStatement extends Statement, VariableDeclarationContainer, NamespaceElement, ExportableElement, AnnotableScriptElement, ModifiableElement {
}

abstract class VariableDeclarationOrBinding extends ControlFlowElement {

	op VariableDeclaration[] getAllVariableDeclarations() {
		switch(this) {
		VariableDeclaration: #[this as VariableDeclaration].toEList
		VariableBinding: eAllContents.filter(VariableDeclaration).toEList
		default: #[].toEList
		}
	}

	op Expression getExpression()
}

class VariableBinding extends VariableDeclarationOrBinding {
	contains BindingPattern pattern
	contains Expression expression
}

class VariableDeclaration extends VariableDeclarationOrBinding, AnnotableElement, AbstractVariable<TVariable>  {
	contains Annotation[] annotations
	contains Expression expression
	/**
	 * Returns true if variable is declared as const.
	 */
	op boolean isConst() {
		val varDeclContainer = N4JSASTUtils.getVariableDeclarationContainer(this);
		return varDeclContainer?.varStmtKeyword === VariableStatementKeyword.CONST
	}

	// Variables are a tricky special case of exportable element, because each variable is represented by two AST nodes:
	// 1) the variable statement (must inherit from ExportableElement because it will be the node directly contained in an ExportDeclaration),
	// 2) the variable declaration (holds the name of the exportable element).
	// Due to this split, #getExportedName() will return incorrect results when invoked on the variable statement
	// and we provide the following two operations as a work-around:

	op boolean isExported() {
		val parent = this.eContainer;
		if (parent instanceof VariableStatement) {
			return parent.exported;
		}
		return false;
	}

	op String getExportedName() {
		val parent = this.eContainer;
		if (parent instanceof VariableStatement) {
			if (parent.exported) {
				return parent.exportedName ?: this.name;
			}
		}
		return null;
	}
}

class EmptyStatement extends Statement {
}

class ExpressionStatement extends Statement {
	contains Expression expression
}

class IfStatement extends Statement {
	contains Expression expression
	contains Statement ifStmt
	contains Statement elseStmt
}

class IterationStatement extends Statement {
	contains Statement statement
	contains Expression expression
}

class DoStatement extends IterationStatement {
}

class WhileStatement extends IterationStatement {
}

class ForStatement extends VariableDeclarationContainer, IterationStatement, VariableEnvironmentElement {
	contains Expression initExpr
	contains Expression updateExpr
	/* Note: it is a syntax error if this is true while {@code #forOf} is false. */
	boolean await
	boolean forIn
	boolean forOf
	op boolean isForPlain() {
		return !forIn && !forOf;
	}
	/** See {@link VariableEnvironmentElement#appliesOnlyToBlockScopedElements()}. */
	op boolean appliesOnlyToBlockScopedElements() {
		true
	}
}

abstract class LabelRef {
	refers LabelledStatement label
	transient String labelAsText
}

class ContinueStatement extends Statement, LabelRef {
}

class BreakStatement extends Statement, LabelRef {
}

class ReturnStatement extends Statement {
	contains Expression expression
}

class WithStatement extends Statement, VariableEnvironmentElement {
	contains Expression expression
	contains Statement statement
}

// bug in XCore maven plugin:
// [ERROR] 0    [main] ERROR org.eclipse.xtext.generator.LanguageConfig  - Error loading 'classpath:/org.eclipse.n4js/N4JS.xcore': [XtextLinkingDiagnostic: null:254 Couldn't resolve reference to JvmType 'CaseClause'.
// type CaseClauseIterable wraps Iterable<CaseClause>
class SwitchStatement extends Statement, VariableEnvironmentElement {
	/*
	 * The discriminant of the switch statement.
	 */
	contains Expression expression
	/*
	 * All cases of the switch statement, i.e. all CaseClauses and not more than one DefaultClause.
	 */
	contains AbstractCaseClause[] cases

	/** See {@link VariableEnvironmentElement#appliesOnlyToBlockScopedElements()}. */
	op boolean appliesOnlyToBlockScopedElements() {
		true
	}
	/*
	 * Convenience method returns default clause if switch statement defines such as clause or null.
	 */
	op DefaultClause getDefaultClause() {
		cases.findFirst[it instanceof DefaultClause] as DefaultClause
	}
	/*
	 * Convenience method filters all CaseClauses from clauses.
	 */
	op CaseClause[] getCaseClauses() {

		// TODO change to Iterable
		cases.filter(CaseClause).toEList
	}
}

abstract class AbstractCaseClause extends ControlFlowElement {
	/*
	 * The consequent of the clause.
	 */
	contains Statement[] statements
}

class CaseClause extends AbstractCaseClause {
	/*
	 * The test of the case clause.
	 */
	contains Expression expression
}

class DefaultClause extends AbstractCaseClause {
}

/*
 * Statement with a label, which can be referred to by a break or continue statement.
 * <p><small>"labelled" or "labeled" -- this is a different question, only comparable to
 * "modelling" vs. "modeling". The ECMAScript spec uses the british version: labelled.</small>
 */
class LabelledStatement extends Statement, NamedElement {
	String name
	contains Statement statement
}

class ThrowStatement extends Statement {
	/*
	 * The argument to be thrown.
	 */
	contains Expression expression
}

class TryStatement extends Statement {
	contains Block block
	contains CatchBlock ^catch
	contains FinallyBlock ^finally
}

abstract class AbstractCatchBlock {
	contains Block block
}

class CatchBlock extends AbstractCatchBlock, VariableEnvironmentElement {
	contains CatchVariable catchVariable
}

class CatchVariable extends AbstractVariable<TVariable> {
	contains BindingPattern bindingPattern
}

class FinallyBlock extends AbstractCatchBlock {
}

class DebuggerStatement extends Statement {
}

// TODO (sz): What's the purpose of a type PrimaryExpression?
class PrimaryExpression extends Expression {
}

class ParenExpression extends PrimaryExpression {
	contains Expression expression
	/**
	 * Return IsValidSimpleAssignmentTarget of expression.
	 */
	op boolean isValidSimpleAssignmentTarget() {
		if (expression !== null)
			return expression.isValidSimpleAssignmentTarget
		// avoid follow up problem
		return true
	}
}

class IdentifierRef extends PrimaryExpression, StrictModeRelevant {
	refers IdentifiableElement ^id
	transient String idAsText

	/*
	 * If the element returned by {@link IdentifierRef#getId() getId()} was imported, this refers to
	 * the corresponding import. Will be set during proxy resolution of property 'id'.
	 */
	refers transient ImportSpecifier originImport

	/*
	 * Similar to {@link IdentifierRef#getId() getId()}, but in case of references via the namespace of
	 * a namespace import this method returns the actually referenced element instead of the
	 * {@link ModuleNamespaceVirtualType} representing the namespace.
	 */
	op IdentifiableElement getTargetElement() {
		val targetRaw = this.id;
		if (targetRaw instanceof ModuleNamespaceVirtualType) {
			val parent = this.eContainer;
			if (parent instanceof ParameterizedPropertyAccessExpression) {
				return parent.property;
			}
		}
		return targetRaw;
	}

	/**
	 * IdentifierReference : Identifier
	 * 1. If this IdentifierReference is contained in strict mode code and StringValue of Identifier is "eval" or "arguments", return false.
	 * 2. Return true.
	 * IdentifierReference : yield
	 * 1. Return true.
	 */
	op boolean isValidSimpleAssignmentTarget() {
		if (strictMode) {
			return idAsText !== null && 'arguments' != idAsText && 'eval' != idAsText
		}
		return true
	}
}

abstract class StrictModeRelevant {
	derived transient boolean strictMode
}

class SuperLiteral extends PrimaryExpression {
	/**
  	 * Convenience method, returns true if super literal is directly contained in a call expression.
  	 * This is a call to the super constructor of a class, which is only allowed in a constructor of a subclass.
  	 */
	op boolean isSuperConstructorAccess() {
		eContainer instanceof ParameterizedCallExpression
	}
	/**
  	 * Convenience method, returns true if super literal is directly contained in a property or index access expression.
	 * This is a call to a super's member, e.g., via "super.foo()".
  	 */
	op boolean isSuperMemberAccess() {
		eContainer instanceof ParameterizedPropertyAccessExpression || eContainer instanceof IndexedAccessExpression
	}
}

class ThisLiteral extends PrimaryExpression, StrictModeRelevant {
}

class ArrayLiteral extends PrimaryExpression {
	contains ArrayElement[] elements
	boolean trailingComma
}

class ArrayElement extends TypableElement {
	boolean spread
	contains Expression expression
}

class ArrayPadding extends ArrayElement {
}

class ObjectLiteral extends PrimaryExpression, ThisTarget, TypeDefiningElement {
	contains PropertyAssignment[] propertyAssignments
}

/*
 * A PropertyAssignment is either a simple {@link PropertyNameValuePair},
 * or a property accessor, that is a {@link PropertyGetterDeclaration} or
 * {@link PropertySetterDeclaration}.
 */
abstract class PropertyAssignment extends AnnotableElement, VariableEnvironmentElement, PropertyNameOwner, TypableElement {
	op TStructMember getDefinedMember()
	/**
	 * Properties may not be called 'prototype' or 'constructor' (except for computed names).
	 */
	op boolean isValidName() {
		if ('prototype' == name) {
			return false
		}
		if ('constructor' == name && declaredName?.kind !== PropertyNameKind.COMPUTED) {
			return false
		}
		return true
	}
}

/*
 * Base for all entities that can have a literal or computed property name (see grammar rule
 * LiteralOrComputedPropertyName).
 */
abstract class PropertyNameOwner extends NamedElement {
	contains LiteralOrComputedPropertyName declaredName
	/* Convenience method; same as {@link LiteralOrComputedPropertyName#getName()}. */
	op String getName() {
		return declaredName?.name;
	}
	/* Convenience method; same as {@link LiteralOrComputedPropertyName#hasComputedPropertyName()}. */
	op boolean hasComputedPropertyName() {
		val declName = declaredName;
		return declName!==null && declName.hasComputedPropertyName;
	}
	/**
	 * Used to detect early errors according the the ES6 spec.
	 */
	op boolean isValidName()
}

class LiteralOrComputedPropertyName {
	/* This is set by the IAstFactory while parsing a property assignment. */
	transient PropertyNameKind kind
	/* The literal name given in the source code or <code>null</code> iff this is a computed property name. */
	String literalName
	/*
	 * Iff this is a computed property name and the expression is one of the special cases that can be evaluated at
	 * compile time, then during post-processing this will be set to the value of the expression, i.e. the computed name.
	 * @see ComputedNameProcessor
	 */
	transient String computedName
	/*
	 * Iff this is a computed property name and the expression is one of the special cases that can be evaluated at
	 * compile time, then this will tell whether the expression evaluated to a symbol.
	 */
	transient boolean computedSymbol
	/* The expression provided in the source code for computing the property name, or <code>null</code>. */
	contains Expression expression

	/* Tells if this element has a name computed from an expression instead of a literal name given in the source code. */
	op boolean hasComputedPropertyName() {
		return kind===PropertyNameKind.COMPUTED && expression!==null;
	}

	/*
	 * Returns either the literal name given in the source code or the computed name.
	 * In case of computed names, this method will return <code>null</code> if the expression is invalid (e.g.
	 * not a constant expression) or if it has not yet been evaluated (this happens during post-processing).
	 */
	op String getName() {
		return literalName ?: computedName;
	}
}

abstract class AnnotablePropertyAssignment extends PropertyAssignment {
	contains PropertyAssignmentAnnotationList annotationList
	op Annotation[] getAnnotations() {
		annotationList?.annotations ?: emptyEList
	}
}

/*
 * A {@link PropertyAssignmentAnnotationList} holds annotations and can be a placeholder
 * where a {@link PropertyAssignment} is expected.
 * This allows to handle syntax errors in the input file gracefully while
 * being able to left factor the grammar to make it parseable.
 */
class PropertyAssignmentAnnotationList extends AbstractAnnotationList, PropertyAssignment {
	op TStructMember getDefinedMember() {
		val c = eContainer
		if (c instanceof PropertyAssignment) {
			return c.getDefinedMember();
		}
		return null
	}
}

enum PropertyNameKind {
	/*
	 * The name is assigned from a object literal property with
	 * an identifier as the concrete syntax for the name.
	 */
	identifier
	,
	/*
	 * The name is assigned from a object literal property with
	 * a string literal as the concrete syntax for the name. This variant is discouraged.
	 */
	string
	,
	/*
	 * The name is assigned from a object literal property with
	 * a number as the concrete syntax for the name. This variant is discouraged.
	 */
	number
	,
	/*
	 * The name is assigned from a object literal property with
	 * a computed property name expression as the concrete syntax for the name. This variant is discouraged.
	 */
	computed
}

class PropertyNameValuePair extends AnnotablePropertyAssignment, TypedElement, TypableElement {
	refers transient TStructField definedField
	boolean declaredOptional
	/*
	 * The (initial) value of the property.
	 */
	contains Expression expression
	op TStructField getDefinedMember() {
		definedField
	}
	/**
	 * Methods in object literals may not be called 'prototype'.
	 */
	op boolean isValidName() {
		if ('prototype' == name) {
			return false
		}
		return true
	}
}

class PropertyNameValuePairSingleName extends PropertyNameValuePair {
	op IdentifierRef getIdentifierRef() {
		val expr = getExpression();
		val candidate = if (expr instanceof AssignmentExpression) expr.lhs else expr;
		return if (candidate instanceof IdentifierRef) candidate;
	}
	/*
	 * Note: if this AST node was created by the parser, then super.getName() will always be null and we get
	 * the name from the parse tree; if this AST node is created programmatically (e.g. refactoring), then
	 * the name has to be set explicitly!
	 */
	op String getName() {
		super.getName() ?: identifierRef?.idAsText
	}
}

class PropertyMethodDeclaration extends AnnotablePropertyAssignment, MethodDeclaration  {
	// IMPORTANT: don't introduce a property 'definedMethod' here, because PropertyMethodDeclaration inherits from
	// TypeDefiningElement (via FunctionDefinition) and that class already has a property 'definedType' for this
	// purpose; if we were using a separate property, it would break code that handles instances of
	// PropertyMethodDeclaration as instances of TypeDefiningElement or FunctionDefinition!

	op TStructMethod getDefinedMember() {
		definedType as TStructMethod
	}
}

/*
 * Base class for getters, of either object literals (PropertyGetterDeclaration) or classes (N4GetterDeclaration).
 */
abstract class GetterDeclaration extends FieldAccessor, TypedElement {
	refers transient TGetter definedGetter

	op TGetter getDefinedAccessor() {
		return definedGetter;
	}
}

/*
 * Base class for setters, of either object literals (PropertySetterDeclaration) or classes (N4SetterDeclaration).
 */
abstract class SetterDeclaration extends FieldAccessor {
	refers transient TSetter definedSetter
	contains FormalParameter fpar
	op TSetter getDefinedAccessor() {
		return definedSetter;
	}
	op TypeRef getDeclaredTypeRef() {
		return fpar?.declaredTypeRefNode?.typeRef;
	}
	op TypeReferenceNode<TypeRef> getDeclaredTypeRefNode() {
		return fpar?.declaredTypeRefNode;
	}
	/*
	 * Returns the declared type of the formal parameter
	 */
	op TypeRef getDeclaredTypeRefInAST() {
		return fpar?.declaredTypeRefNode?.typeRefInAST;
	}
}

class PropertyGetterDeclaration extends GetterDeclaration, AnnotablePropertyAssignment {
	op TStructGetter getDefinedGetter() {
		super.getDefinedGetter() as TStructGetter
	}
	op TStructGetter getDefinedMember() {
		definedGetter
	}
	/**
	 * Getters in object literals may not be named 'prototype'.
	 */
	op boolean isValidName() {
		if ('prototype' == name) {
			return false
		}
		return true
	}
}

class PropertySetterDeclaration extends SetterDeclaration, AnnotablePropertyAssignment {
	op TStructSetter getDefinedSetter() {
		super.getDefinedSetter() as TStructSetter
	}
	op TStructSetter getDefinedMember() {
		definedSetter
	}
	/**
	 * Setters in object literals may not be named 'prototype'.
	 */
	op boolean isValidName() {
		if ('prototype' == name) {
			return false
		}
		return true
	}
}

class PropertySpread extends AnnotablePropertyAssignment {
	contains Expression expression

	op TStructField getDefinedMember() {
		null
	}
}

enum PostfixOperator {
	inc as "++"
	dec as "--" = 1
}

enum UnaryOperator {
	delete
	^void = 1
	^typeof = 2
	inc as "++" = 3
	dec as "--" = 4
	pos as "+" = 5
	neg as "-" = 6
	inv as "~" = 7
	not as "!" = 8
}

enum MultiplicativeOperator {
	times as "*"
	div as "/" = 1
	mod as "%" = 2
}

enum AdditiveOperator {
	add as "+"
	sub as "-" = 1
}

enum RelationalOperator {
	lt as "<"
	gt as ">" = 1
	lte as "<=" = 2
	gte as ">=" = 3
	^instanceof = 4
	in = 5
}

enum EqualityOperator {
	same as "==="
	nsame as "!==" = 1
	eq as "==" = 2
	neq as "!=" = 3
}

enum BinaryBitwiseOperator {
	and as "&"
	or as "|" = 1
	xor as "^" = 2
}

enum BinaryLogicalOperator {
	and as "&&"
	or as "||" = 1
}

/**
 * Also see utility methods in N4JSASTUtils
 */
abstract class Expression extends TypableElement, ControlFlowElement {
	/**
	 * Implements the method #isValidSimpleAssignmentTarget from ES6 spec.
	 * Returns false by default.
	 *
	 * See chapters 12.1.3, 12.2.1.5, 12.2.10.3, 12.3.1.5, 12.4.3, 12.5.3, 12.6.2,
	 * 12.7.2, 12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.
	 */
	op boolean isValidSimpleAssignmentTarget() {
		return false
	}
}

// see http://www.ecma-international.org/ecma-262/6.0/index.html#sec-left-hand-side-expressions
class NewTarget extends Expression {
}

class NewExpression extends Expression, ParameterizedAccess {
	contains Expression callee
	contains Argument[] arguments
	boolean withArgs
}

abstract class ParameterizedAccess {
	contains TypeReferenceNode<TypeRef>[] typeArgs
	/**
	 * Returns <code>true<code> if the expression has type arguments.
	 */
	op boolean isParameterized() {
		return !typeArgs.isEmpty
	}
}

/**
 * Abstract base class for expressions that do have a target and are potentially null safe.
 */
abstract class ExpressionWithTarget extends Expression {
	/**
	 * The target of this dereferencing expression (aka receiver).
	 */
	contains Expression target
	boolean optionalChaining

	/** Tells if this expression lies within a long short-circuiting range of an optional chaining operator. */	
	op boolean isOrHasTargetWithOptionalChaining() {
		if (optionalChaining) {
			return true;
		}
		val _target = target;
		if (_target instanceof ExpressionWithTarget) {
			return _target.isOrHasTargetWithOptionalChaining();
		}
		return false;
	}
}

class ParameterizedCallExpression extends ExpressionWithTarget, ParameterizedAccess {
	/*
	 * About the target property:
	 * It is the callee or target of the call, e.g. the name of the called function. This is not the receiver (which may be null).
	 */
	// inherits contains Expression target
	
	contains Argument[] arguments
	/*
	 * Convenience method returning the receiver expression or null, if call has no receiver.
	 * 
	 * The semantics of receiver and target are best understood by example:
	 * <code> receiver.target(arguments) </code>
	 */
	op Expression getReceiver() {
		if (target instanceof ParameterizedPropertyAccessExpression) {
			(target as ParameterizedPropertyAccessExpression).target
		} else {
			null;
		}
	}
}

class ImportCallExpression extends Expression {
	contains Argument[] arguments

	/*
	 * Import call expressions must have exactly one argument. This argument is returned by
	 * this method (or <code>null</code> in case of invalid source code).
	 */
	op Argument getArgument() {
		return arguments.head;
	}
}

/* Argument in a new or call expression. */
class Argument extends TypableElement {
	boolean spread
	contains Expression expression
}

class IndexedAccessExpression extends ExpressionWithTarget, MemberAccess {
	contains Expression index
	/**
	 * Returns iff this expression is allowed to appear on the LHS of an expression.
	 */
	op boolean isValidSimpleAssignmentTarget() {
		return !isOrHasTargetWithOptionalChaining();
	}
}

/**
 * An invocation of the form
 * {@code method `template`}
 */
class TaggedTemplateString extends ExpressionWithTarget {
	contains TemplateLiteral template
}

/*
 * An AST node accessing the member of a ContainerType via member scoping. In the default case, member scoping will
 * require an object of this type as 'context', cf. {@code MemberScopingHelper#createMemberScope()}.
 */
abstract class MemberAccess {
	/*
	 * This points to a cache of members that can be accessed via member access on union/intersection
	 * types directly, because they are, for example, common to all types contained in a UnionTypeExpression.
	 * These members are cached for two reasons: (1) performance, (2) TMembers have to be contained in a resource.
	 * The cache will be filled lazily by ComposedMemberScope, so client code should usually not assume this
	 * information to be complete and best not use it at all. Instead, access these members only via the scoping.
	 */
	refers transient ComposedMemberCache composedMemberCache
}

class ParameterizedPropertyAccessExpression extends ExpressionWithTarget, MemberAccess, ParameterizedAccess {
	refers IdentifiableElement property
	transient String propertyAsText
	/**
	 * Returns iff this expression is allowed to appear on the LHS of an expression.
	 */
	op boolean isValidSimpleAssignmentTarget() {
		return !isOrHasTargetWithOptionalChaining();
	}
}

class AwaitExpression extends Expression {
	contains Expression expression
}

class PromisifyExpression extends Expression {
	contains Expression expression
}

class YieldExpression extends Expression {
	contains Expression expression
	boolean many
}

class Literal extends PrimaryExpression {
	/**
	 * Convenience method, returns the actual value of the literal as string. To be overridden by subclasses.
	 */
	op String getValueAsString() {
		return null
	}
}

// TODO (ß): There is NullLiteral->Literal->PrimaryExpression->Expression - looks overly complex to me
// What's the purpose of Literal and PrimaryExpression?
class NullLiteral extends Literal {
	op String getValueAsString() {
		return "null"
	}
}

class BooleanLiteral extends Literal {
	boolean ^true
	op String getValueAsString() {
		return Boolean.toString(^true);
	}
}

class StringLiteral extends Literal {
	String value
	/**
	 * The value as it was read from the model. Not updated on modifications via #setValue(String).
	 * Includes the leading/trailing single or double quotes, as used in the source code.
	 */
	transient String rawValue
	op String getValueAsString() {
		return value
	}
}

/**
 * A template expression as defined for ECMA6
 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literals
 */
class TemplateLiteral extends PrimaryExpression {
	contains Expression[] segments
	op String getValueAsString() {
		val result = new StringBuilder('`')
		val appender = [ Expression expr |
			switch (expr) {
				Literal: result.append(valueAsString)
				default: result.append('<<').append(eClass.name).append('>>')
			}
		]
		segments.fold(true) [ isRaw, expression |
			if (!isRaw) {
				result.append('${')
				appender.apply(expression)
				result.append('}')
			} else {
				appender.apply(expression)
			}
			return !isRaw
		]
		result.append('`')
		return result.toString
	}
}

/**
 * A template segment is a string literal that occurs in
 * template literals between interpolated expressions.
 * It has a dedicated type to allow to distinguish between
 * string literals that are interpolated expressions and the
 * raw value in a template literal.
 */
class TemplateSegment extends Literal {
	String value
	/**
	 * The raw value of the template segment. Just like 'rawValue' in {@link StringLiteral}
	 * includes the leading/trailing quotes, this value includes the segment's leading and
	 * trailing delimiters, i.e. <code>"`"</code>, <code>"}"</code>, or <code>"${"</code>.
	 * <p>
	 * Example:
	 * <pre>
	 * let str = 'zzz';
	 * console.log(`aaa${str}bbb${str}ccc`);
	 * </pre>
	 * will produce a single {@link StringLiteral} with a {@link StringLiteral#getRawValue() rawValue} of
	 * <pre>
	 * "'zzz'"
	 * </pre>
	 * and three {@link TemplateSegment}s with the following {@link TemplateSegment#getRawValue() rawValue}s:
	 * <ol>
	 * <li><code>"`aaa${"</code>
	 * <li><code>"}bbb${"</code>
	 * <li><code>"}ccc`"</code>
	 * </ol>
	 */
	transient String rawValue
	/**
	 * Returns the "template value (TV)" of the template segment as defined in
	 * the ECMA spec 11.8.6.1 Static Semantics: TV’s and TRV’s
	 */
	op String getValueAsString() {
		return value
	}
}

class NumericLiteral extends Literal {
	BigDecimal value
	op String getValueAsString() {
		if(value === null) return null;
		return value.toString();
	}
}

class DoubleLiteral extends NumericLiteral {
	op double toDouble() {
		value.doubleValue
	}
	op String getValueAsString() {
		if(value === null) return null;
		return value.toString();
	}
}

class AbstractIntLiteral extends NumericLiteral {
	op int toInt() {
		value.intValue
	}
	op long toLong() {
		value.longValue
	}
	op BigInteger toBigInteger() {
		value.toBigInteger
	}
}

/**
 * Concrete implementation of an {@link AbstractIntLiteral}
 * which allows to keep track of the syntactic representation of the value.
 */
class IntLiteral extends AbstractIntLiteral {
}

/**
 * Concrete implementation of an {@link AbstractIntLiteral}
 * which allows to keep track of the syntactic representation of the value.
 */
class BinaryIntLiteral extends AbstractIntLiteral {
}

/**
 * Concrete implementation of an {@link AbstractIntLiteral}
 * which allows to keep track of the syntactic representation of the value.
 */
class OctalIntLiteral extends AbstractIntLiteral {
}

/**
 * Concrete implementation of an {@link AbstractIntLiteral}
 * which allows to keep track of the syntactic representation of the value.
 *
 * @see http://www.ecma-international.org/ecma-262/6.0/index.html#sec-additional-syntax-numeric-literals
 */
class LegacyOctalIntLiteral extends AbstractIntLiteral {
}

/**
 * Concrete implementation of an {@link AbstractIntLiteral}
 * which allows to keep track of the syntactic representation of the value.
 */
class HexIntLiteral extends AbstractIntLiteral {
}

/**
 * Concrete implementation of an {@link AbstractIntLiteral}
 * which allows to keep track of the syntactic representation of the value.
 */
class ScientificIntLiteral extends AbstractIntLiteral {
}

class RegularExpressionLiteral extends Literal {
	String value
	op String getValueAsString() {
		return value
	}
}

class PostfixExpression extends Expression {
	contains Expression expression
	PostfixOperator ^op
}

class UnaryExpression extends Expression {
	UnaryOperator ^op
	contains Expression expression
}

/**
 * Type cast expression "as".
 * See 5.5.1 and 6.2.3 for details.
 */
class CastExpression extends Expression {
	contains Expression expression
	op TypeRef getTargetTypeRef() {
		return targetTypeRefNode?.typeRef;
	}
	contains TypeReferenceNode<TypeRef> targetTypeRefNode
}

class MultiplicativeExpression extends Expression {
	contains Expression lhs
	MultiplicativeOperator ^op
	contains Expression rhs
}

class AdditiveExpression extends Expression {
	contains Expression lhs
	AdditiveOperator ^op
	contains Expression rhs
}

enum ShiftOperator {
	shl as "<<"
	shr as ">>" = 1
	ushr as ">>>" = 2
}

class ShiftExpression extends Expression {
	contains Expression lhs
	ShiftOperator ^op
	contains Expression rhs
}

class RelationalExpression extends Expression {
	contains Expression lhs
	RelationalOperator ^op
	contains Expression rhs
}

class EqualityExpression extends Expression {
	contains Expression lhs
	EqualityOperator ^op
	contains Expression rhs
}

class BinaryBitwiseExpression extends Expression {
	contains Expression lhs
	BinaryBitwiseOperator ^op
	contains Expression rhs
}

class BinaryLogicalExpression extends Expression {
	contains Expression lhs
	BinaryLogicalOperator ^op
	contains Expression rhs
}

class CoalesceExpression extends Expression {
	contains Expression expression
	contains Expression defaultExpression
}

class ConditionalExpression extends Expression {
	contains Expression expression
	contains Expression trueExpression
	contains Expression falseExpression
}

enum AssignmentOperator {
	assign as '='
	mulAssign as '*=' = 1
	divAssign as '/=' = 2
	modAssign as '%=' = 3
	addAssign as '+=' = 4
	subAssign as '-=' = 5
	shlAssign as '<<=' = 6
	shrAssign as '>>=' = 7
	ushrAssign as '>>>=' = 8
	andAssign as '&='  = 9
	xorAssign as '^=' = 10
	orAssign as '|=' = 11
}

class AssignmentExpression extends Expression {
	contains Expression lhs
	AssignmentOperator ^op
	contains Expression rhs
}

class CommaExpression extends Expression {
	contains Expression[] exprs
}

// ****************************************************************************************************
// N4 Meta Types
// ****************************************************************************************************
/*
 * Elements such as type or functions definitions defining a {@link  org.eclipse.n4js.ts.model.Type}.
 */
abstract class TypeDefiningElement extends TypableElement {
	refers transient Type definedType
}

/**
 * Abstract base class for generic type declarations, that is declarations possibly containing
 * type parameters. This is true for function and method declarations and N4 classifier declarations.
 * Do not use this method in the context of binding: instead, refer to the defined type (of the type model) and
 * query its type variables.
 */
abstract class GenericDeclaration extends TypeDefiningElement {
	/*
	 * Type variables as declared by the declaration of the AST. These type variables are copied to the type model,
	 * so in most cases, the type model type variables are to be used.
	 */
	contains N4TypeVariable[] typeVars
}

class N4TypeVariable extends TypableElement, NamedElement {

	refers transient TypeVariable definedTypeVariable

	String name

	boolean declaredCovariant
	boolean declaredContravariant
	boolean declaredOptional

	contains TypeReferenceNode<TypeRef> declaredUpperBoundNode

	/* The default type argument or {@code null}. */
	contains TypeReferenceNode<TypeRef> declaredDefaultArgumentNode 

	op TypeRef getDeclaredUpperBound() {
		return declaredUpperBoundNode?.typeRef;
	}
	op boolean isOptional() {
		return declaredOptional;
	}
}

/*
 * Base class for N4 type declarations and expression. This is a general pattern we use here:
 * definition = declaration | expression.
 */
abstract class N4TypeDefinition extends AnnotableElement, TypeDefiningElement {
	/**
	 * Returns true if the classifier is only a declaration of an external implementation.
	 */
	op boolean isExternal() {
		return false;
	}
}

// TODO jvp: probably need operation getTypeRef(), should be similarly handled as variables
/*
 * Abstract base class for N4 specific type declarations. These declarations contain an
 * type access modifier.
 */
abstract class N4TypeDeclaration extends N4TypeDefinition, AnnotableScriptElement, ModifiableElement, ExportableElement, NamedElement {
	String name
	/**
	 * Returns true if type is declared as external.
	 */
	op boolean isExternal() {
		return isDeclaredExternal() || isDefaultExternal();
	}
}

abstract class N4ClassifierDeclaration extends N4TypeDeclaration, N4ClassifierDefinition , GenericDeclaration, ThisTarget {
	TypingStrategy typingStrategy
}

/*
 * Abstract base class for n4 classifiers, that is types containing members such as fields or methods.
 * Note that not all types can contain any members, e.g., interfaces must not contain fields.
 */
abstract class N4ClassifierDefinition extends N4TypeDefinition {
	/**
	 * Members directly defined in this classifier, i.e. w/o inherited members.
	 * Includes also constructors and call/construct signatures.
	 */
	contains N4MemberDeclaration[] ownedMembersRaw opposite owner
	/**
	 * Returns a view on ownedMembersRaw filtering out call/construct signatures.
 	 */
	op N4MemberDeclaration[] getOwnedMembers() {
		val methods = ownedMembersRaw.filter[!isCallSignature && !isConstructSignature];
		return new BasicEList(methods.toList);
	}
	/**
	 * Returns explicitly defined constructor of receiving class or <code>null</code> if none was defined.
 	 */
	op N4MethodDeclaration getOwnedCtor() {
		return ownedMembersRaw.filter(N4MethodDeclaration).findFirst[isConstructor]
	}
	/**
	 * Returns the explicitly defined call signature of the receiving class or <code>null</code> if none was defined.
	 * This is *not* the actual constructor but instead the signature used for direct invocations in call expressions.
 	 */
	op N4MethodDeclaration getOwnedCallSignature() {
		return ownedMembersRaw.filter(N4MethodDeclaration).findFirst[isCallSignature]
	}
	/**
	 * Returns the explicitly defined construct signature of the receiving class or <code>null</code> if none was defined.
 	 */
	op N4MethodDeclaration getOwnedConstructSignature() {
		return ownedMembersRaw.filter(N4MethodDeclaration).findFirst[isConstructSignature]
	}
	/**
	 * Returns a view on ownedMembersRaw filtering out non-methods and call/construct signatures.
 	 */
	op N4MethodDeclaration[] getOwnedMethods() {
		val methods = ownedMembersRaw.filter(N4MethodDeclaration).filter[!isConstructor && !isCallSignature]
		return new BasicEList(methods.toList)
	}
	/**
	 * Returns a view on ownedMembersRaw filtering out non-fields.
	 */
	op N4FieldDeclaration[] getOwnedFields() {
		val fields = ownedMembersRaw.filter(N4FieldDeclaration)
		return new BasicEList(fields.toList)
	}
	/**
	 * Returns a view on ownedMembersRaw filtering out non-getters.
	 */
	op N4GetterDeclaration[] getOwnedGetters() {
		val getters = ownedMembersRaw.filter(N4GetterDeclaration)
		return new BasicEList(getters.toList)
	}
	/**
	 * Returns a view on ownedMembersRaw filtering out non-setters.
	 */
	op N4SetterDeclaration[] getOwnedSetters() {
		val setters = ownedMembersRaw.filter(N4SetterDeclaration)
		return new BasicEList(setters.toList)
	}
	/**
	 * Derived, returns extended class (if any) and implemented or extended interfaces.
	 */
	op ParameterizedTypeRefNodeIterable getSuperClassifierRefs() {
		return Collections.<TypeReferenceNode<ParameterizedTypeRef>>emptyList;
	}
	/**
	 * Derived, returns implemented or extended interfaces.
	 */
	op ParameterizedTypeRefNodeIterable getImplementedOrExtendedInterfaceRefs() {
		return Collections.<TypeReferenceNode<ParameterizedTypeRef>>emptyList;
	}
}

/**
 * Base class for {@link N4ClassDeclaration} and {@link N4ClassExpression}
 */
abstract class N4ClassDefinition extends N4ClassifierDefinition, ThisTarget {
	contains TypeReferenceNode<ParameterizedTypeRef> superClassRef
	contains Expression superClassExpression
	contains TypeReferenceNode<ParameterizedTypeRef>[] implementedInterfaceRefs
	/*
	 * Convenience method, returns {@link #getDefinedType()} casted to {@link TClass}.
	 */
	op TClass getDefinedTypeAsClass() {
		return definedType as TClass;
	}
	op ParameterizedTypeRefNodeIterable getSuperClassifierRefs() {
		val _superClassRef = superClassRef;
		return if (_superClassRef !== null) #[_superClassRef] + implementedInterfaceRefs else implementedInterfaceRefs;
	}
	op ParameterizedTypeRefNodeIterable getImplementedOrExtendedInterfaceRefs() {
		return implementedInterfaceRefs;
	}
}


class N4NamespaceDeclaration extends N4TypeDefinition, VariableEnvironmentElement, ModifiableElement, ExportableElement, NamedElement {
	String name
	contains NamespaceElement[] ownedElementsRaw

	/**
	 * Returns true if type is declared as external.
	 */
	op boolean isExternal() {
		return isDeclaredExternal() || isDefaultExternal();
	}

	/**
	 * Namespaces do not have annotations
	 */
	op Annotation[] getAnnotations() {
		emptyEList
	}

	op boolean isHollow() {
		val hollow = ownedElementsRaw.forall[isHollow];
		return hollow
	}

	op TNamespace getDefinedNamespace() {
		definedType as TNamespace
	}
}

class NamespaceElement extends ScriptElement {
	op N4NamespaceDeclaration getNamespace() {
		var parent = eContainer;
		if (parent instanceof ExportDeclaration) {
			parent = parent.eContainer;
		}
		if (parent instanceof N4NamespaceDeclaration) {
			return parent;
		}
		return null;
	}
	op boolean isInNamespace() {
		return getNamespace() !== null;
	}
	op boolean isHollow() {
		return false;
	}
}


class N4ClassDeclaration extends N4ClassDefinition, N4ClassifierDeclaration {
	/**
	 * Returns true if the class is declared as abstract.
	 */
	op boolean isAbstract() {
		declaredModifiers.contains(N4Modifier.ABSTRACT)
	}
}

class N4ClassExpression extends N4ClassDefinition, PrimaryExpression, AnnotableExpression, NamedElement {
	/*
	 * The optional name of the class expression.
	 */
	String name
}

class N4InterfaceDeclaration extends N4ClassifierDeclaration {
	contains TypeReferenceNode<ParameterizedTypeRef>[] superInterfaceRefs
	/*
	 * Convenience method, returns {@link #getDefinedType()} casted to {@link TInterface}.
	 */
	op TInterface getDefinedTypeAsInterface() {
		return definedType as TInterface;
	}
	op ParameterizedTypeRefNodeIterable getSuperClassifierRefs() {
		return superInterfaceRefs;
	}
	op ParameterizedTypeRefNodeIterable getImplementedOrExtendedInterfaceRefs() {
		return superInterfaceRefs;
	}
	
	op boolean isHollow() {
		return isExternal() && !allAnnotations.exists[it.name == "N4JS"]
	}
}

class N4EnumDeclaration extends N4TypeDeclaration {
	contains N4EnumLiteral[] literals
	/*
	 * Convenience method, returns {@link #getDefinedType()} casted to {@link TEnum}.
	 */
	op TEnum getDefinedTypeAsEnum() {
		return definedType as TEnum;
	}
}

class N4EnumLiteral extends NamedElement, TypableElement {
	String name
	contains Expression valueExpression
	refers transient TEnumLiteral definedLiteral
}


class N4TypeAliasDeclaration extends N4TypeDeclaration, GenericDeclaration, TypedElement {

	op TypeAlias getDefinedTypeAsTypeAlias() {
		return definedType as TypeAlias;
	}
	
	
	op boolean isHollow() {
		return true;
	}
}


/*
 * On AST side, all modifiers are included in this enumeration. In the types model, however,
 * the individual modifiers are mapped to two different enumerations of <em>access</em> modifiers
 * (namely TypeAccessModifier and MemberAccessModifier) and boolean properties (in case of
 * non-access modifiers such as 'abstract' or 'static'). This mapping is done by the types
 * builder, mostly by calling method in ModifierUtils.
 * <p>
 * Rules where a certain modifier may appear in the AST are implemented in method
 * {@code ModifierUtils#isValid(EClass,N4Modifier)} and checked in {@code N4JSSyntaxValidator}.
 * <p>
 * See {@link ModifierUtils} for some utility methods for dealing with modifiers.
 */
enum N4Modifier {
	// the order defined by the literals' values is important and defines in which order
	// the modifiers have to appear in code! (see ModifierUtils#getSortedModifiers())
	undefined = 0
	external = 01
	private = 11
	project = 12
	protected = 13
	public = 14
	^abstract = 21
	^static = 22
	const = 23
}

/*
 * Abstract base class for elements that may have declared modifiers.
 * See {@link N4Modifier}.
 */
abstract class ModifiableElement {
	N4Modifier[] declaredModifiers
	
	
	op boolean isExternal() {
		return isDeclaredExternal() || isDefaultExternal();
	}
	op boolean isDeclaredExternal() {
		return declaredModifiers.contains(N4Modifier.EXTERNAL)
	}
	op boolean isDefaultExternal() {
		var parent = eContainer();
		if (parent instanceof ExportDeclaration) {
			parent = parent.eContainer();
		}
		if (parent instanceof N4NamespaceDeclaration) {
			return parent.isExternal;
		}
		return false;
	}
}

abstract class N4MemberDeclaration extends AnnotableElement, ModifiableElement, TypableElement, NamedElement {
	/**
	 * The classifier owning this member.
	 */
	container N4ClassifierDefinition owner opposite ownedMembersRaw
	op TMember getDefinedTypeElement()
	/** Returns true iff this member is declared abstract. */
	op boolean isDeclaredAbstract() {
		declaredModifiers.contains(N4Modifier.ABSTRACT)
	}
	/**
	 * Tells if this member is abstract. Fields are never abstract; other members are abstract
	 * iff they are declared abstract or contained in an interface without having a body.
	 */
	op boolean isAbstract() {
		false // will be overridden below in N4FieldAccessor and N4MethodDeclaration
	}
	/** Returns true if the member is declared as static. */
	op boolean isDeclaredStatic() {
		declaredModifiers.contains(N4Modifier.STATIC)
	}
	op boolean isStatic() {
		declaredStatic
	}
	/** Returns true if the member is declared as static. */
	op boolean isDeclaredFinal() {
		annotations.exists[it.name == "Final"]
	} // cannot access AnnotationDefinition :(
	op boolean isFinal() {
		declaredFinal
	}
	op boolean isConstructor() {
		false // will be overridden below in N4MethodDeclaration
	}
	op boolean isCallSignature() {
		false // will be overridden below in N4MethodDeclaration
	}
	op boolean isConstructSignature() {
		false // will be overridden below in N4MethodDeclaration
	}
}

abstract class AnnotableN4MemberDeclaration extends N4MemberDeclaration {
	contains N4MemberAnnotationList annotationList
	op Annotation[] getAnnotations() {
		annotationList?.annotations ?: emptyEList
	}
}

/*
 * A {@link N4MemberAnnotationList} holds annotations and can be a placeholder
 * where a {@link N4MemberDeclaration} is expected.
 * This allows to handle syntax errors in the input file gracefully while
 * being able to left factor the grammar to make it parseable.
 */
class N4MemberAnnotationList extends AbstractAnnotationList, N4MemberDeclaration {
	op TMember getDefinedTypeElement() {
		val c = eContainer
		if (c instanceof N4MemberDeclaration) {
			return c.getDefinedTypeElement();
		}
		return null
	}
	op String getName() {
		return null
	}
}

class N4FieldDeclaration extends AnnotableN4MemberDeclaration, TypedElement, ThisArgProvider, PropertyNameOwner {
	refers transient TField definedField
	boolean declaredOptional
	/*
	 * Initializer expression.
	 */
	contains Expression expression
	op TMember getDefinedTypeElement() {
		return definedField;
	}
	/**
	 * Returns true if the field is declared as const.
	 */
	op boolean isConst() {
		declaredModifiers.contains(N4Modifier.CONST)
	}
	op boolean isStatic() {
		declaredStatic || const
	}
	op boolean isValid() {
		if ('prototype' == name) {
			return false
		}
		return true
	}
	op boolean isValidName() {
		if ('prototype' == name) {
			return false
		}
		// TODO double check the logic here
		return true
	}
}

abstract class MethodDeclaration extends FunctionDefinition, GenericDeclaration, PropertyNameOwner {
	/**
	 * Convenience method, returns true if an explicit call to the super constructor is found.
	 * Of course, this is only allowed in constructors. Note that this method searches for ALL
	 * statements in the body, not only the first one (which is the only valid place).
	 */
	op boolean existsExplicitSuperCall() {
		val existsSuperCall = EcoreUtilN4.getAllDirectlyFoundContentsOfType(body, Statement).filter(ExpressionStatement).
			map[expression].filter(ParameterizedCallExpression).exists[target instanceof SuperLiteral]
		return existsSuperCall;
	}
	op TMember getDefinedTypeElement() {
		return if(definedType === null) /*wrong parsed*/ null else if(definedType instanceof TMember) definedType as TMember else throw new IllegalArgumentException(
			"");
	}
	op boolean isStatic() {
		return false
	}
}

class N4MethodDeclaration extends AnnotableN4MemberDeclaration, MethodDeclaration {
	op boolean isAbstract() {
		return (eContainer instanceof N4InterfaceDeclaration && body === null &&
			! annotations.exists[name == "ProvidesDefaultImplementation"]
		) || isDeclaredAbstract()
	}
	op boolean isConstructor() {
		return name == 'constructor' && !isStatic
	}
	op boolean isCallSignature() {
		return declaredName === null;
	}
	op boolean isConstructSignature() {
		return name == 'new' && !isStatic && eContainer instanceof N4InterfaceDeclaration;
	}
	op boolean isStatic() {
		return declaredModifiers.contains(N4Modifier.STATIC)
	}
	/**
	 * Methods in classes may not be called 'prototype'.
	 * Generators may not be called 'constructor' either (except for computed names).
	 */
	op boolean isValidName() {
		if ('prototype' == name) {
			return false
		}
		if ('constructor' == name && isGenerator && declaredName?.kind !== PropertyNameKind.COMPUTED) {
			return false
		}
		return true
	}
}

abstract class N4FieldAccessor extends AnnotableN4MemberDeclaration, FieldAccessor {
	op boolean isAbstract() {
		return (eContainer instanceof N4InterfaceDeclaration && body === null &&
			! annotations.exists[name == "ProvidesDefaultImplementation"]
		) || isDeclaredAbstract()
	}
	/**
	 * Field accessors in classes may not be called 'prototype' or 'constructor' (except for computed names).
	 */
	op boolean isValidName() {
		if ('prototype' == name) {
			return false
		}
		if ('constructor' == name && declaredName?.kind !== PropertyNameKind.COMPUTED) {
			return false
		}
		return true
	}
}

class N4GetterDeclaration extends GetterDeclaration, N4FieldAccessor {
	op TMember getDefinedTypeElement() {
		return definedGetter;
	}
}

class N4SetterDeclaration extends SetterDeclaration, N4FieldAccessor {
	op TMember getDefinedTypeElement() {
		return definedSetter;
	}
}

abstract class BindingPattern extends ControlFlowElement {

	op VariableDeclaration[] getAllVariableDeclarations() {
		eAllContents.filter(VariableDeclaration).toEList
	}
}

/*
 * A binding pattern used for object destructuring within a variable declaration statement, produced by code such as
 * <pre>
 * let {prop: myVar} = {prop: 'hello'};
 * </pre>
 * where the <code>{prop: myVar}</code> part will be represented in the AST as an {@code ObjectBindingPattern}.
 */
class ObjectBindingPattern extends BindingPattern {
	contains BindingProperty[] properties
}

/*
 * A binding pattern used for array destructuring within a variable declaration statement, produced by code such as
 * <pre>
 * let [myVar] = ['hello'];
 * </pre>
 * where the <code>[myVar]</code> part will be represented in the AST as an {@code ArrayBindingPattern}.
 */
class ArrayBindingPattern extends BindingPattern {
	contains BindingElement[] elements
}

class BindingProperty extends PropertyNameOwner {
	contains BindingElement value
	op String getName() {
		super.getName() ?: value?.varDecl?.name
	}
	op boolean isValidName() {
		true
	}
}

class BindingElement extends ControlFlowElement {
	/* Corresponds to spread in ArrayLiterals (but called 'rest' in ES6 specification within array binding patterns). */
	boolean rest
	contains VariableDeclaration varDecl
	contains BindingPattern nestedPattern
	contains Expression expression

	/*
	 * Tells if this {@link BindingElement} is an "empty" element, corresponding to an {@link ArrayPadding} element in
	 * an {@link ArrayLiteral}.
	 */
	op boolean isElision() {
		return varDecl===null && nestedPattern===null;
	}
}

// ****************************************************************************************************
// JSX extensions
// cf. https://facebook.github.io/jsx/
// ****************************************************************************************************


abstract class JSXChild {}

class JSXElementName {
	contains Expression expression
}

class JSXText extends JSXChild {}

class JSXExpression extends JSXChild {
	contains Expression expression
}


abstract class JSXAttribute extends ControlFlowElement {}

class JSXPropertyAttribute extends JSXAttribute, MemberAccess {
	refers IdentifiableElement property
	transient String propertyAsText
	contains Expression jsxAttributeValue
}

class JSXSpreadAttribute extends JSXAttribute {
	contains Expression expression
}

/** Common abstract class of JSXElement and JSXFragment */
abstract class JSXAbstractElement extends Expression {
	contains JSXChild[] jsxChildren
}

class JSXElement extends Expression, JSXChild, JSXAbstractElement {
	contains JSXElementName jsxElementName
	contains JSXAttribute[] jsxAttributes
	contains JSXElementName jsxClosingName
}

class JSXFragment extends JSXChild, JSXAbstractElement {
}
