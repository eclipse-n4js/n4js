/*
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

import * as n4jscli from "n4js-cli";
import * as n4jsc from "n4js-cli/n4jsc";
import * as net from "net";
import * as childProcess from "child_process";
import * as VSCodeJRCP+ from "vscode-jsonrpc";

const PORT = 5007;

let n4jscProcess: childProcess.ChildProcess;

export function getActivate(vscode: any+, vscodeLC: any+): any {
    return (context: any+ /*VSCode.ExtensionContext*/) => {
        let outputChannel = vscode.window.createOutputChannel('N4JS Language Server');

        let serverOptions = async () => {
            outputChannel.appendLine("Start LSP extension");
            //vscode.window.showErrorMessage("my error");


            let socket = await connectToRunningN4jsLspServer(PORT, outputChannel);
            if (!socket) {
                outputChannel.appendLine("Unable to connect to an already running LSP server (port="+PORT+"). Start new instance.");
                socket = await startN4jsLspServerAndConnect(PORT, outputChannel);
            }

            let result = {
                writer: socket,
                reader: socket,
                process: n4jscProcess,
                detached: true
            };
            return Promise.resolve(result);
        };

        let clientOptions = {
            documentSelector: [
                { scheme: 'file', language: 'n4js' },
                { scheme: 'n4scheme', language: 'n4js' },
                { scheme: 'untitled', language: 'n4js' }
            ],
            synchronize: {
                fileEvents: vscode.workspace.createFileSystemWatcher('{/**/*.+(n4js|n4jsd|n4jsx|n4idl),/**/package.json}')
            },
            outputChannel: outputChannel,
        };
        
        // Create the language client and start the client.
        let lc = new vscodeLC.LanguageClient('N4JS Language Server', serverOptions, clientOptions, true);
        // enable tracing (.Off, .Messages, .Verbose)
        lc.trace = VSCodeJRCP.Trace.Verbose;


        lc.onReady().then(() => {
            const requestType = new vscodeLC.RequestType ('n4/documentContents');
            const textDocumentContentProvider = {
                provideTextDocumentContent: (uri: any+, token: any+): any+ => {
                    return lc.sendRequest(requestType, { uri: uri.toString() }, token).then((v: string): string => {
                        return v || '';
                    });
                }
            };
            context.subscriptions.push(vscode.workspace.registerTextDocumentContentProvider('n4scheme', textDocumentContentProvider));
        });


        let disposableLangClient = lc.start();
        
        // Push the disposable to the context's subscriptions so that the 
        // client can be deactivated on extension deactivation
        context.subscriptions.push(disposableLangClient);
    };
}

export function getDeactivate(vscode: any+, vscodeLC: any+): {function() : Promise<any, any> } {
    return () => {
        if (!n4jscProcess) {
            return undefined;
        }

        n4jscProcess.kill();

        return new Promise<any, any>((resolve, reject) => {
            n4jscProcess.on('exit', () => {
                resolve();
            });
        });
    };
}


async function startN4jsLspServerAndConnect(port: number, outputChannel: any+): net.Socket {
    let logFn = (text: string) => outputChannel.appendLine(text) as {function(string)};
    await n4jsc.ensureJRE(logFn);

    let env = Object.assign({ NODEJS_PATH: process.argv[0] }, process.env);
    let spawnOptions: childProcess.SpawnOptions = { env: env };

    // The server is started as a separate app and listens on port 5007
    n4jscProcess = n4jscli.n4jscProcess(n4jscli.Goal.lsp, undefined, {port: port}, spawnOptions, logFn);
    n4jscProcess.stdout.on('data', (data:any+) => outputChannel.append(data.toString()));
    n4jscProcess.stderr.on('data', (data:any+) => outputChannel.append(data.toString()));
    n4jscProcess.on('message', (data:any+) => outputChannel.append(data.toString()));

    let serverReady = new Promise<any, any>((resolve, reject) => {
        let waitForListenMsg = (data:any+) => {
            let receivedServerOutput = data.toString();
            if (receivedServerOutput?.startsWith("Listening for LSP clients")) {
                n4jscProcess.stdout.removeListener("data", waitForListenMsg);
                resolve();
            }
        };

        n4jscProcess.stdout.on('data', waitForListenMsg);
    });
    await serverReady;

    // Connect to language server via socket
    let socket = net.connect({port: port});
    return socket;
}

async function connectToRunningN4jsLspServer(port: number, outputChannel: any+): net.Socket {
    let timeout = 1000;

    let connectionPromise = new Promise<net.Socket, any>((resolve, reject) => {
        try {
            let timer = setTimeout(() => {
                    clientSocket.end();
                    resolve(null);
                }, timeout);

            let clientSocket = net.createConnection({port: port});
            clientSocket.on('connect', () => {
                    outputChannel.appendLine("Connected to a already running LSP server (port="+PORT+")");
                    clearTimeout(timer);
                    resolve(clientSocket);
                })
            clientSocket.on('error', (err: any+) => {
                    clearTimeout(timer);
                    clientSocket.destroy();
                    resolve(null);
                })
            clientSocket.on('disconnect', () => {
                    resolve(null);
                });

            //resolve(clientSocket);
        } catch(err) {}
        
        return null;
    });

    let result = await connectionPromise;
    return result;
};

async function sleep(ms: number) {
    return new Promise<any,any>((resolve) => {
        setTimeout(resolve, ms);
    });
}
