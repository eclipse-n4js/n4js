// Generated by N4JS transpiler; for copyright see original N4JS source file.

import 'n4js-runtime'

export default class LSPMessageReader extends N4Object {
	constructor(stream, errorChannel, ...messageHandlers) {
		super();
		this.errorChannel = undefined;
		this.msgHandlers = undefined;
		this.corrupt = false;
		this.buff = Buffer.from([]);
		this.errorChannel = errorChannel;
		this.msgHandlers = [
			...messageHandlers
		];
		stream.on('data', (data)=>{
			try {
				this.onDataReceivedFromServer(data);
			} catch(err) {
				this.logError('' + err);
			}
		});
	}
	isCorrupt() {
		return this.corrupt;
	}
	onDataReceivedFromServer(data) {
		if (this.corrupt || !(data instanceof Buffer)) {
			return;
		}
		this.buff = Buffer.concat([
			this.buff,
			data
		]);
		const [
			msgLen,
			contentJSON,
			headerFields
		] = tryParseMessage(this.buff);
		if (msgLen === -2) {
			this.logError('input stream got corrupted');
			this.corrupt = true;
			this.buff = undefined;
			return;
		}
		if (msgLen === -1) {
			return;
		}
		this.buff = this.buff.slice(msgLen);
		if (!(contentJSON instanceof Object)) {
			return;
		}
		for(const msgHandler of this.msgHandlers) {
			msgHandler(contentJSON, headerFields);
		}
	}
	logError(msg) {
		this.errorChannel.appendLine('ERROR in LSPMessageReader: ' + msg);
	}
	static get n4type() {
		return $getReflectionForClass(this, '["LSPMessageReader","LSPMessageReader","n4js-vscode-extension",["f.errorChannel","f.msgHandlers","f.corrupt","f.buff"],{"f.errorChannel":["Final"],"f.msgHandlers":["Final"]}]');
	}
}
function tryParseMessage(buff) {
	const [
		headerLen,
		headerFields
	] = tryParseHeader(buff);
	if (headerLen < 0) {
		return [
			-1,
			null,
			null
		];
	}
	const contentLenAsStr = headerFields.get('Content-Length');
	if (!(typeof contentLenAsStr === 'string')) {
		return [
			-2,
			null,
			null
		];
	}
	const contentLen = parseInt(contentLenAsStr);
	if (contentLen === NaN) {
		return [
			-2,
			null,
			null
		];
	}
	const msgLen = headerLen + contentLen;
	if (buff.length < msgLen) {
		return [
			-1,
			null,
			null
		];
	}
	const contentStr = buff.slice(headerLen, msgLen).toString('utf-8');
	const contentJSON = JSON.parse(contentStr);
	return [
		msgLen,
		contentJSON,
		headerFields
	];
}
function tryParseHeader(buff) {
	const buffStr = buff.toString('ascii');
	let idx = 0;
	const headerFields = new Map();
	while(true) {
		const idxFieldEnd = buffStr.indexOf('\r\n', idx);
		if (idxFieldEnd < 0) {
			break;
		} else if (idxFieldEnd === idx) {
			return [
				idx + 2,
				headerFields
			];
		}
		const field = buffStr.substring(idx, idxFieldEnd);
		const idxNameEnd = field.indexOf(': ');
		if (idxNameEnd >= 0) {
			const fieldName = field.substring(0, idxNameEnd);
			const fieldValue = field.substring(idxNameEnd + 2);
			headerFields.set(fieldName, fieldValue);
		}
		idx = idxFieldEnd + 2;
	}
	return [
		-1,
		null
	];
}
//# sourceMappingURL=LSPMessageReader.map
