// Generated by N4JS transpiler; for copyright see original N4JS source file.

import 'n4js-runtime'

export default class LSPMessageReader extends N4Object {
	constructor(stream, errorChannel, ...lspMessageHandlers) {
		super();
		this.errorChannel = undefined;
		this.messageHandlers = undefined;
		this.buff = Buffer.from([]);
		this.errorChannel = errorChannel;
		this.messageHandlers = [
			...lspMessageHandlers
		];
		stream.on('data', (data)=>{
			try {
				this.onDataReceivedFromServer(data);
			} catch(err) {
				this.logError('' + err);
			}
		});
	}
	isCorrupt() {
		return this.buff === null;
	}
	onDataReceivedFromServer(data) {
		if (this.isCorrupt() || !(data instanceof Buffer)) {
			return;
		}
		this.buff = Buffer.concat([
			this.buff,
			data
		]);
		const [
			msgLen,
			headerFields,
			contentJSON
		] = tryParseMessage(this.buff);
		if (msgLen === -2) {
			this.logError('input stream got corrupted');
			this.buff = null;
			return;
		}
		if (msgLen === -1) {
			return;
		}
		this.buff = this.buff.slice(msgLen);
		if (!(contentJSON instanceof Object)) {
			return;
		}
		for(const msgHandler of this.messageHandlers) {
			msgHandler(contentJSON, headerFields);
		}
	}
	logError(msg) {
		this.errorChannel.appendLine('ERROR in LSPMessageReader: ' + msg);
	}
	static get n4type() {
		return $getReflectionForClass(this, '["LSPMessageReader","LSPMessageReader","n4js-vscode-extension",["f.errorChannel","f.messageHandlers","f.buff"],{"f.errorChannel":["Final"],"f.messageHandlers":["Final"]}]');
	}
}
function tryParseMessage(buff) {
	const [
		headerLen,
		headerFields
	] = tryParseHeader(buff);
	if (headerLen < 0) {
		return [
			-1,
			null,
			null
		];
	}
	const contentLenAsStr = headerFields.get('Content-Length');
	if (!(typeof contentLenAsStr === 'string')) {
		return [
			-2,
			null,
			null
		];
	}
	const contentLen = parseInt(contentLenAsStr);
	if (contentLen === NaN) {
		return [
			-2,
			null,
			null
		];
	}
	const msgLen = headerLen + contentLen;
	if (buff.length < msgLen) {
		return [
			-1,
			null,
			null
		];
	}
	const contentStr = buff.slice(headerLen, msgLen).toString('utf-8');
	const contentJSON = JSON.parse(contentStr);
	return [
		msgLen,
		headerFields,
		contentJSON
	];
}
function tryParseHeader(buff) {
	const buffStr = buff.toString('ascii');
	let idx = 0;
	const headerFields = new Map();
	while(true) {
		const idxFieldEnd = buffStr.indexOf('\r\n', idx);
		if (idxFieldEnd < 0) {
			break;
		} else if (idxFieldEnd === idx) {
			return [
				idx + 2,
				headerFields
			];
		}
		const fieldStr = buffStr.substring(idx, idxFieldEnd);
		const idxNameEnd = fieldStr.indexOf(': ');
		if (idxNameEnd >= 0) {
			const fieldName = fieldStr.substring(0, idxNameEnd);
			const fieldValue = fieldStr.substring(idxNameEnd + 2);
			headerFields.set(fieldName, fieldValue);
		}
		idx = idxFieldEnd + 2;
	}
	return [
		-1,
		null
	];
}
//# sourceMappingURL=LSPMessageReader.map
