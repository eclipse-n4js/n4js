/**
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

// This file contains various special handling for converting runtime library definitions.
// Additional tweaks may be found also in other places; see usage of Options#runtimeLibs in
// file 'cmdLineOpts.n4js' for finding those.

import * as path_lib from "path";
import * as model from "model";
import * as utils from "utils";

const PREAMBLE = `@@Global @@ProvidedByRuntime`;

const SCRIPT_PREFIX = new Map<string,string>([
]);

const SCRIPT_SUFFIX = new Map<string,string>([
	[ "es5.d.ts", `
type ReadonlyArray<T> = Array<T>;

/**
 * See [ECMA6] Section 19.4.
 *
 * A symbol is a unique and immutable data type and may be used as an identifier for object properties. The symbol
 * object is an implicit object wrapper for the symbol primitive data type.
 *
 * TODO in ES6 this is defined to be a property of the global object and a constructor function
 */
export external public class Symbol extends Object {

	/**
	 * Creates a new, primitive symbol.
	 *
	 * @param description A description of the symbol which can be used for debugging but not to access the symbol itself.
	 */
	(description: string = undefined): symbol

	/**
	 * This "well-known" symbol may be used to define the default iterator of an object.
	 *
	 * @see ES6, 19.4.2.4
	 */
	public const iterator: symbol

	/**
	 * This "well-known" symbol may be used to define the default asynchronous iterator of an object.
	 *
	 * @see ES2018, 19.4.2.1
	 */
	public const asyncIterator: symbol

	/**
	 * This "well-known" symbol may be used to customize the behavior of the 'instanceof' operator.
	 *
	 * @see ES6, 19.4.2.2
	 */
	public const hasInstance: symbol

	/**
	 * Returns the shared symbol with the given key from the Javascript engine's shared symbol registry.
	 * Creates a new symbol if not found.
	 *
	 * @see ES6, 19.4.2.1
	 */
	public static for(key: string): symbol

	/**
	 * Returns the key for the given shared symbol if found in the Javascript engine's shared symbol registry.
	 * Otherwise 'undefined' is returned.
	 *
	 * @see ES6, 19.4.2.5
	 */
	public static keyFor(sym: symbol): string
}

/**
 * An iterator over a collection, defining a standard way to produce a sequence of values (either finite
 * or infinite).
 * <p>
 * Note that in ECMAScript 6 this is not a built-in type, but a protocol. This protocol can be implemented
 * by any object respecting some conventions.
 */
export external public interface ~Iterator<out T> {
	/**
	 * A zero arguments function that returns an object with two properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	public abstract next(): IteratorEntry<T>
}

/**
 * Same as interface <code>Iterator</code>, but for asynchronous iteration.
 */
export external public interface ~AsyncIterator<out T> {
	/**
	 * A zero arguments function that returns a promise of an object with two properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	public abstract next(): Promise<IteratorEntry<T>, ?>
}

/**
 * The value returned by an Iterator's method next().
 */
export external public interface ~IteratorEntry<out T> {
	/**
	 * Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 * optionally specifies the return value of the iterator. The return values are explained here.
	 * Has the value false if the iterator was able to produce the next value in the sequence. This is
	 * equivalent of not specifying the done property altogether.
	 */
	public done: boolean;
//	public get done(): boolean
	/**
	 * Any JavaScript value returned by the iterator. Can be omitted when done is true.
	 */
	// TODO dirty hack: to use covariant T as type of field 'value', we make the field final; but usually fields
	// in interfaces cannot be final - only works because no validation in n4ts!
	@Final public value?: T;
	// this would be the alternative, but then we would lose the optionality of 'value':
//	public get value(): T
}

/**
 * An object that can be iterated over. Whenever an object needs to be iterated (such as at the beginning
 * of a for..of loop), its <code>[Symbol.iterator]</code> method is called with no arguments, and the
 * returned iterator is used to obtain the values to be iterated.
 * <p>
 * Note that in ECMAScript 6 this is not a built-in type, but a protocol. This protocol can be implemented
 * by any object respecting some conventions.
 * <p>
 * For asynchronous iteration use interface <code>AsyncIterable</code> instead.
 */
export external public interface ~Iterable<out T> {
	/**
	 * Returns an object conforming to the iteration protocol.
	 */
	public abstract [Symbol.iterator](): Iterator<T>
}

/**
 * Same as interface <code>Iterable</code>, but for asynchronous iteration.
 */
export external public interface ~AsyncIterable<out T> {
	/**
	 * Returns an object conforming to the asynchronous iteration protocol.
	 */
	public abstract [Symbol.asyncIterator](): AsyncIterator<T>
}


/**
 * An iterator over a collection, defining a standard way to produce a sequence of values (either finite
 * or infinite).
 * <p>
 * Note that in ECMAScript 6 this is not a built-in type, but a protocol. This protocol can be implemented
 * by any object respecting some conventions.
 */
export external public interface ~Generator<out TYield, out TReturn, in TNext> extends Iterable<TYield>, Iterator<TYield> {

	/**
	 * A one (optional) argument function. The (optional) argument <code>value</code> is passed to the
	 * current yield expression in the generator function. The return is an <code>IteratorEntry</code>
	 * with two properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	@Override public abstract next(value: TNext = undefined): IteratorEntry<TYield>

	/**
	 * A zero arguments function that returns the <code>this</code> object, conforming to the iterator
	 * interface.
	 * <p>
	 * Note that the iterator can only be iterated once.
	 */
	@Override public abstract [Symbol.iterator](): Generator<TYield, TReturn, TNext>

	/**
	 * A one argument function. The argument <code>exception</code> is thrown at the current yield
	 * expression in the generator function. The return is an <code>IteratorEntry</code> with two
	 * properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	public abstract throw(exception: any): IteratorEntry<TYield>;

    /**
	 * A one (optional) argument function. The (optional) argument <code>value</code> is passed to the
	 * current yield expression in the generator function. The return is an <code>IteratorEntry</code> with
	 * two properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	public abstract return(value: TNext = undefined): IteratorEntry<TReturn>;
}

/**
 * An asynchronous generator object. See interface <code>Generator</code> for details.
 */
export external public interface ~AsyncGenerator<out TYield, out TReturn, in TNext> extends AsyncIterable<TYield>, AsyncIterator<TYield> {

	/**
	 * A one (optional) argument function. The (optional) argument <code>value</code> is passed to the
	 * current yield expression in the generator function. Return a promise of an <code>IteratorEntry</code>
	 * with two properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	@Override public abstract next(value: TNext = undefined): Promise<IteratorEntry<TYield>, ?>

	/**
	 * A zero arguments function that returns the <code>this</code> object, conforming to the asynchronous
	 * iterator interface.
	 * <p>
	 * Note that the iterator can only be iterated once.
	 */
	@Override public abstract [Symbol.asyncIterator](): AsyncGenerator<TYield, TReturn, TNext>

	/**
	 * A one argument function. The argument <code>exception</code> is thrown at the current yield
	 * expression in the generator function. Returns a promise of an <code>IteratorEntry</code> with two
	 * properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	public abstract throw(exception: any): Promise<IteratorEntry<TYield>, any>;

    /**
	 * A one (optional) argument function. The (optional) argument <code>value</code> is passed to the
	 * current yield expression in the generator function. Returns a promise of an <code>IteratorEntry</code> with
	 * two properties:
	 * <ul>
	 * <li>done (boolean)<br>
	 *     Has the value true if the iterator is past the end of the iterated sequence. In this case value
	 *     optionally specifies the return value of the iterator. The return values are explained here.
	 *     Has the value false if the iterator was able to produce the next value in the sequence. This is
	 *     equivalent of not specifying the done property altogether.
	 * <li>value<br>
	 *     any JavaScript value returned by the iterator. Can be omitted when done is true.
	 * </ul>
	 */
	public abstract return(value: TNext = undefined): Promise<IteratorEntry<TReturn>, ?>;
}

/**
 * A promise represents a proxy for a value that is usually not yet known
 * when the promise is created.
 * <p>
 * A promise can exist in either of two states: "pending" and "settled".
 * If the result value of a promise is not yet determined, the promise is
 * "pending". Once the value has been determined, the promise becomes
 * "settled".
 * <p>
 * A promise can either be fulfilled or rejected. A fulfilled promise
 * indicates a successful completion of whatever asynchronous process it
 * encapsulates. A rejected promise indicates erroneous or abnormal completion
 * of the process.
 */
export external public class Promise<out S, out F> extends Object {

	public constructor(
		executor: {function(
			resolveFn:{function(arg: S = undefined):void},
			rejectFn: {function(arg: F = undefined):void}
		): void}
	)

	public <Snew, Fnew> then(
		onFulfilled: {function(arg:S = undefined): union{Snew, Promise<Snew, Fnew>}?},
		onRejected: {function(arg:F = undefined): union{Fnew, Promise<Snew, Fnew>}?} = undefined
	): Promise<Snew, Fnew>

	public <Snew, Fnew> catch(
		onRejected: {function(arg:F = undefined): union{Fnew, Promise<Snew, Fnew>}?}
	): Promise<Snew, Fnew>

	public static <S, F> reject(f: F): Promise<S, F>
	public static <S, F> resolve(
		s: union{
			Promise<S, F>,
			~Object with { then(...args: any): Promise<S, F>; }, // i.e. thenable
			S
		}
	): Promise<S, F>

	public static <T> all(iterable: Iterable<union{Promise<T,?>, T}>): Promise<Array<T>, any>
	public static <T> race(iterable: Iterable<union{Promise<T,?>, T}>): Promise<T, any>
}
	` ] as [string,string]
]);

const CONSTRUCTOR_TYPE_SUFFIX = "Constructor";

const IGNORED_ELEMENTS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// temporarily ignored, because we need our own definition:
		"Symbol", "Promise",
		// stuff defined in primitive_js.n4ts and global.n4ts:
		"NaN", "Infinity", "eval", "parseInt", "parseFloat", "isNaN", "isFinite", "decodeURI", "decodeURIComponent",
		"encodeURI", "encodeURIComponent", "escape", "unescape",
		// read-only types:
		"ReadonlyArray", "TemplateStringsArray",
		// type constructors:
		"Partial", "Required", "Readonly", "Pick", "Record", "Exclude", "Extract", "Omit", "NonNullable",
		"Parameters", "ConstructorParameters", "ReturnType", "InstanceType", "Uppercase", "Lowercase",
		"Capitalize", "Uncapitalize", "Awaited",
		// decorators:
		"ClassDecorator", "PropertyDecorator", "MethodDecorator", "ParameterDecorator",
		// odd stuff:
		"ThisParameterType", "OmitThisParameter", "CallableFunction", "NewableFunction", "PromiseConstructorLike"
	])] as [string, Set<string>]
]);

const POLYFILLS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// FIXME
		// "Boolean", "Number", "String", "Symbol", "Object", "RegExp", "Function", "Array", "Date", "Math", "JSON", "Error"
	])] as [string, Set<string>]
]);

const FINAL_CLASSIFIERS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// FIXME
		// "Boolean", "Number", "String", "Symbol", "RegExp", "Function", "Date", "Math", "JSON"
	])] as [string, Set<string>]
]);

const ADDITIONAL_CODE = new Map<string,Map<string,string[]>>([
	[ "es5.d.ts", new Map<string,string[]>([
		["Object", [
			"public get __proto__(): Object;"
		]] as [string,string[]],
		["Array", [
			"public [Symbol.iterator](): Iterator<T>;"
		]] as [string,string[]]
	])] as [string, Map<string,string[]>]
]);

const MEMBER_REPLACEMENTS = new Map<string,Map<string,string>>([
	[ "es5.d.ts", new Map<string,string>([
		["Object#create", "public static create(proto: Object, props: Object = undefined): Object;"] as [string,string],
		["Object#freeze", "public static <T extends Object> freeze(obj: T): T;"] as [string,string],
		["String#localeCompare", "public localeCompare(that: string, locales: string = undefined, options: any+ = undefined): number;"] as [string,string],
		["String#replace", "public replace(searchValue: union{RegExp, string}, replaceValue: union{string, Function}): string;"] as [string,string],
		["Array#concat", "public concat(...items: union {T, Array<? extends T>}): Array<T>;"] as [string,string],
		["Array#splice", "public splice(start: number = undefined, deleteCount: number = undefined, ...items: T): Array<T>;"] as [string,string],
		["Array#every", "public <ThisT extends Object> every(callback: {function(value: T, index: number, traversedObject: Array<T>)}, thisObject: ThisT = undefined): boolean;"] as [string,string],
		["Array#filter", "public <ThisT extends Object> filter(callback: {function(value: T, index: number, traversedObject: Array<T>) : boolean}, thisObject: ThisT = undefined): Array<T>;"] as [string,string],
		["Array#reduce", "public <MemoT> reduce(callback: {function(previousValue: MemoT, currentValue: T, index: number, traversedObject: Array<T>) : MemoT}, initialValue: MemoT = undefined): MemoT;"] as [string,string],
		["Array#reduceRight", "public <MemoT> reduceRight(callback: {function(previousValue: MemoT, currentValue: T, index: number, traversedObject: Array<T>) : MemoT}, initialValue: MemoT = undefined): MemoT;"] as [string,string],
		["Date#constructor", "public constructor(numberOrStringOrYear: union{string, number} = undefined, month: number = undefined, date: number = undefined, hours: number = undefined, minutes: number = undefined, seconds: number = undefined, ms: number = undefined);"] as [string,string],
		["RegExp#constructor", ""] as [string,string],
		["JSON#stringify", ""] as [string,string]
	])] as [string, Map<string,string>]
]);

export public function isIgnored(filePath: string, elementName: string): boolean {
	const fileName = path_lib.basename(filePath);
	const ignoredNames = IGNORED_ELEMENTS.get(fileName);
	return ignoredNames?.has(elementName);
}

/**
 * Invoked for each script iff in "--runtime-libs" mode. Will modify its top-level elements
 * in various ways (in place).
 *
 * @param script the script to modify.
 */
export public function postProcessRuntimeLib(dtsFileName: string, script: model.Script) {
	handleSimpleConfigurations(dtsFileName, script);
	removeMetaProperties(script);
	removeIgnoredElements(dtsFileName, script);
	handleCtorInstanceTypePattern(script);
	handlePolyfills(dtsFileName, script);
	handleFinalClassifiers(dtsFileName, script);
}

function handleSimpleConfigurations(dtsFileName: string, script: model.Script) {
	// script prefix/suffix
	const prefix = SCRIPT_PREFIX.get(dtsFileName);
	if (PREAMBLE || prefix) {
		script.prefix = utils.trimMultiLineString(PREAMBLE ?? "") + utils.trimMultiLineString(prefix ?? "");
	}
	const suffix = SCRIPT_SUFFIX.get(dtsFileName);
	if (suffix) {
		script.suffix = utils.trimMultiLineString(suffix);
	}
	// additional code for types
	const additionalCode = ADDITIONAL_CODE.get(dtsFileName);
	if (additionalCode && additionalCode.size > 0) {
		for (const elem of script.topLevelElements) {
			if (!(elem instanceof model.Type)) {
				continue;
			}
			const elemName = elem.name;
			if (elemName && additionalCode.has(elemName)) {
				for (const code of additionalCode.get(elemName)) {
					elem.additionalCode.push(code);
				}
			}
		}
	}
	// member replacement
	const memberReplacements = MEMBER_REPLACEMENTS.get(dtsFileName);
	if (memberReplacements && memberReplacements.size > 0) {
		for (const elem of script.topLevelElements) {
			if (!(elem instanceof model.Type)) {
				continue;
			}
			const typeName = elem.name;
			let idx = 0;
			while (idx < elem.members.length) {
				const member = elem.members[idx];
				const memberName = member.kind === model.MemberKind.CTOR ? "constructor" : member.name;
				const key = typeName + "#" + memberName;
				if (memberReplacements.has(key)) {
					const replacement = memberReplacements.get(typeName + "#" + memberName);
					if (replacement !== undefined && replacement !== null) {
						member.replacementCode = replacement;
					} else {
						// null/undefined means: remove the member
						elem.members.splice(idx, 1);
						--idx;
					}
				}
				++idx;
			}
		}
	}
}

function removeMetaProperties(script: model.Script) {
	for (const elem of script.topLevelElements) {
		if (elem instanceof model.Type) {
			const ms = elem.members;
			let i = 0;
			while (i < ms.length) {
				const m = ms[i];
				if ((m.name === "constructor" && m.kind !== model.MemberKind.CTOR)
						|| m.name === "prototype") {
					ms.splice(i, 1);
				} else {
					++i;
				}
			}
		}
	}
}

function removeIgnoredElements(dtsFileName: string, script: model.Script) {
	const ignoredElems = IGNORED_ELEMENTS.get(dtsFileName);
	if (!ignoredElems || ignoredElems.size === 0) {
		return;
	}
	let i = 0;
	const elems = script.topLevelElements;
	while (i < elems.length) {
		const elem = elems[i];
		const elemName = elem.name;
		if (elemName && ignoredElems.has(elemName)) {
			elems.splice(i, 1);
		} else {
			++i;
		}
	}
}

function handleCtorInstanceTypePattern(script: model.Script) {
	const elemsByName = new Map<string,model.ExportableElement[]>();
	for (const elem of script.topLevelElements) {
		const name = elem.name;
		let arr = elemsByName.get(name);
		if (!arr) {
			arr = [];
			elemsByName.set(name, arr);
		}
		arr.push(elem);
	}

	const topLevelElementsToBeRemoved = [] as model.ExportableElement[];

	for (const elem of script.topLevelElements) {
		if (elem instanceof model.Variable) {
			adjustCtorInstanceTypesForVarDecl(elem, elemsByName, topLevelElementsToBeRemoved);
		}
	}

	for (const elem of topLevelElementsToBeRemoved) {
		const idx = script.topLevelElements.indexOf(elem);
		if (idx >= 0) {
			script.topLevelElements.splice(idx, 1);
		}
	}
}

function adjustCtorInstanceTypesForVarDecl(
	varDecl: model.Variable,
	elemsByName: Map<string,model.ExportableElement[]>,
	topLevelElementsToBeRemoved: model.ExportableElement[]) {

	const typeRefStr = varDecl.type?.tsSourceString;
	if (!typeRefStr) {
		return;
	}
	const types = elemsByName.get(typeRefStr)?.filter(elem => elem instanceof model.Type) as model.Type[];
	if (!types || types.length === 0) {
		return;
	}
	if (types.length > 1) {
		// FIXME emit warning!!!
		return;
	}
	const type = types[0];
	if (type.kind !== model.TypeKind.INTERFACE) {
		// FIXME emit warning!!!
		return;
	}
	// look for a corresponding instance type
	let instanceType: model.Type;
	const typeName = type.name;
	if (typeName.endsWith(CONSTRUCTOR_TYPE_SUFFIX)) {
		const instanceTypeName = typeName.substring(0, typeName.length - CONSTRUCTOR_TYPE_SUFFIX.length);
		const instanceTypes = elemsByName.get(instanceTypeName)?.filter(elem => elem instanceof model.Type) as model.Type[];
		if (instanceTypes) {
			for (const instanceTypeCandidate of instanceTypes) {
				if (instanceTypeCandidate.kind === model.TypeKind.INTERFACE) {
					instanceType = instanceTypeCandidate;
					break;
				}
			}
		}
	}
	// change "constructor type" to a class and make all members static
	changeInterfaceToClass(type);
	type.members.forEach(m => m.isStatic = true);
	// merge the "constructor type" into the "instance type" (if any)
	if (instanceType) {
		// change "instance type" to a class
		changeInterfaceToClass(instanceType);
		// move all members of the "constructor type" into the "instance type"
		type.members.forEach(m => instanceType.members.push(m));
		type.members.length = 0;
		// mark the "constructor type" as "to be removed"
		topLevelElementsToBeRemoved.push(type);
	}
	// mark the variable declaration as "to be removed"
	topLevelElementsToBeRemoved.push(varDecl);
}

function handlePolyfills(dtsFileName: string, script: model.Script) {
	const polyfills = POLYFILLS.get(dtsFileName);
	if (!polyfills || polyfills.size === 0) {
		return;
	}
	for (const elem of script.topLevelElements) {
		if (!(elem instanceof model.Type)) {
			continue;
		}
		const elemName = elem.name;
		if (elemName && polyfills.has(elemName)) {
			elem.annotations.push(new model.Annotation("@Polyfill"));
			elem.extends.length = 0;
			elem.extends.push(new model.TypeRef(elemName));
			elem.defSiteStructural = false;
		}
	}
}

function handleFinalClassifiers(dtsFileName: string, script: model.Script) {
	const finalClassifiers = FINAL_CLASSIFIERS.get(dtsFileName);
	if (!finalClassifiers || finalClassifiers.size === 0) {
		return;
	}
	for (const elem of script.topLevelElements) {
		if (!(elem instanceof model.Type)) {
			continue;
		}
		const elemName = elem.name;
		if (elemName && finalClassifiers.has(elemName)) {
			elem.annotations.push(new model.Annotation("@Final"));
		}
	}
}

function changeInterfaceToClass(ifc: model.Type) {
	if (ifc.kind !== model.TypeKind.INTERFACE) {
		throw "ifc is expected to be an interface, but was: " + ifc.kind;
	}
	ifc.kind = model.TypeKind.CLASS;
	ifc.defSiteStructural = false;
	// due to different default accessibilities, we have to make accessibility PUBLIC explicit:
	ifc.members.forEach(m => {
		if (!m.accessibility) {
			m.accessibility = model.Accessibility.PUBLIC;
		}
	});
}
