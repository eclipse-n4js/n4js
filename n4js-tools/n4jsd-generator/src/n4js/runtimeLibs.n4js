/**
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

// This file contains various special handling for converting runtime library definitions.
// Additional tweaks may be found also in other places; see usage of Options#runtimeLibs in
// file 'cmdLineOpts.n4js' for finding those.

import * as model from "model";

const CONSTRUCTOR_TYPE_SUFFIX = "Constructor";


/**
 * Invoked for each script iff in "--runtime-libs" mode. Will modify its top-level elements
 * in various ways (in place).
 *
 * @param script the script to modify.
 */
export public function postProcessRuntimeLib(script: model.Script) {
	const elemsByName = new Map<string,model.ExportableElement[]>();
	for (const elem of script.topLevelElements) {
		const name = elem.name;
		let arr = elemsByName.get(name);
		if (!arr) {
			arr = [];
			elemsByName.set(name, arr);
		}
		arr.push(elem);
	}

	const topLevelElementsToBeRemoved = [] as model.ExportableElement[];

	for (const varDecl of script.topLevelElements.filter(elem => elem instanceof model.Variable) as model.Variable[]) {
		handleCtorInstanceTypePattern(varDecl, elemsByName, topLevelElementsToBeRemoved);
	}

	for (const elem of topLevelElementsToBeRemoved) {
		const idx = script.topLevelElements.indexOf(elem);
		if (idx >= 0) {
			script.topLevelElements.splice(idx, 1);
		}
	}
}

function handleCtorInstanceTypePattern(
	varDecl: model.Variable,
	elemsByName: Map<string,model.ExportableElement[]>,
	topLevelElementsToBeRemoved: model.ExportableElement[]) {

	const typeRefStr = varDecl.type?.tsSourceString;
	if (!typeRefStr) {
		return;
	}
	const types = elemsByName.get(typeRefStr)?.filter(elem => elem instanceof model.Type) as model.Type[];
	if (!types || types.length === 0) {
		return;
	}
	if (types.length > 1) {
		// FIXME emit warning!!!
		return;
	}
	const type = types[0];
	if (type.kind !== model.TypeKind.INTERFACE) {
		// FIXME emit warning!!!
		return;
	}
	// look for a corresponding instance type
	let instanceType: model.Type;
	const typeName = type.name;
	if (typeName.endsWith(CONSTRUCTOR_TYPE_SUFFIX)) {
		const instanceTypeName = typeName.substring(0, typeName.length - CONSTRUCTOR_TYPE_SUFFIX.length);
		const instanceTypes = elemsByName.get(instanceTypeName)?.filter(elem => elem instanceof model.Type) as model.Type[];
		if (instanceTypes && instanceTypes.length === 1) {
			const instanceTypeCandidate = instanceTypes[0];
			if (instanceTypeCandidate.kind === model.TypeKind.INTERFACE) {
				instanceType = instanceTypeCandidate;
			}
		}
	}
	// change "constructor type" to a class and make all members static
	type.kind = model.TypeKind.CLASS;
	type.members.forEach(m => m.isStatic = true);
	// merge the "constructor type" into the "instance type" (if any)
	if (instanceType) {
		// change "instance type" to a class
		instanceType.kind = model.TypeKind.CLASS;
		// move all members of the "constructor type" into the "instance type"
		type.members.forEach(m => instanceType.members.push(m));
		type.members.length = 0;
		// mark the "constructor type" as "to be removed"
		topLevelElementsToBeRemoved.push(type);
	}
	// mark the variable declaration as "to be removed"
	topLevelElementsToBeRemoved.push(varDecl);
}
