/**
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

// This file contains various special handling for converting runtime library definitions.
// Additional tweaks may be found also in other places; see usage of Options#runtimeLibs in
// file 'cmdLineOpts.n4js' for finding those.

import * as path_lib from "path";
import * as model from "model";
import * as utils from "utils";

const PREAMBLE = `@@Global @@ProvidedByRuntime`;

const SCRIPT_PREFIX = new Map<string,string>([
]);

const SCRIPT_SUFFIX = new Map<string,string>([
	[ "es5.d.ts", `
		type ReadonlyArray<T> = Array<T>;

		export external public interface ~Iterator<out T> {
			public abstract next(): IteratorEntry<T>
		}
		
		export external public interface ~AsyncIterator<out T> {
			public abstract next(): Promise<IteratorEntry<T>, ?>
		}
		
		export external public interface ~IteratorEntry<out T> {
			public done: boolean;
			@Final public value?: T;
		}
		
		export external public interface ~Iterable<out T> {
			public abstract [Symbol.iterator](): Iterator<T>
		}
		
		export external public interface ~AsyncIterable<out T> {
			public abstract [Symbol.asyncIterator](): AsyncIterator<T>
		}
		
		export external public interface ~Generator<out TYield, out TReturn, in TNext> extends Iterable<TYield>, Iterator<TYield> {
			@Override public abstract next(value: TNext = undefined): IteratorEntry<TYield>
			@Override public abstract [Symbol.iterator](): Generator<TYield, TReturn, TNext>
			public abstract throw(exception: any): IteratorEntry<TYield>;
			public abstract return(value: TNext = undefined): IteratorEntry<TReturn>;
		}
		
		export external public interface ~AsyncGenerator<out TYield, out TReturn, in TNext> extends AsyncIterable<TYield>, AsyncIterator<TYield> {
			@Override public abstract next(value: TNext = undefined): Promise<IteratorEntry<TYield>, ?>
			@Override public abstract [Symbol.asyncIterator](): AsyncGenerator<TYield, TReturn, TNext>
			public abstract throw(exception: any): Promise<IteratorEntry<TYield>, any>;
			public abstract return(value: TNext = undefined): Promise<IteratorEntry<TReturn>, ?>;
		}
		
		export external public class Promise<out S, out F> extends Object {
		
			public constructor(
				executor: {function(
					resolveFn:{function(arg: S = undefined):void},
					rejectFn: {function(arg: F = undefined):void}
				): void}
			)
		
			public <Snew, Fnew> then(
				onFulfilled: {function(arg:S = undefined): union{Snew, Promise<Snew, Fnew>}?},
				onRejected: {function(arg:F = undefined): union{Fnew, Promise<Snew, Fnew>}?} = undefined
			): Promise<Snew, Fnew>
		
			public <Snew, Fnew> catch(
				onRejected: {function(arg:F = undefined): union{Fnew, Promise<Snew, Fnew>}?}
			): Promise<Snew, Fnew>
		
			public static <S, F> reject(f: F): Promise<S, F>
			public static <S, F> resolve(
				s: union{
					Promise<S, F>,
					~Object with { then(...args: any): Promise<S, F>; }, // i.e. thenable
					S
				}
			): Promise<S, F>
		
			public static <T> all(iterable: Iterable<union{Promise<T,?>, T}>): Promise<Array<T>, any>
			public static <T> race(iterable: Iterable<union{Promise<T,?>, T}>): Promise<T, any>
		}
	` ] as [string,string]
]);

const CONSTRUCTOR_TYPE_SUFFIX = "Constructor";

const IGNORED_ELEMENTS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// stuff defined in primitive_js.n4ts and global.n4ts:
		"NaN", "Infinity", "eval", "parseInt", "parseFloat", "isNaN", "isFinite", "decodeURI", "decodeURIComponent",
		"encodeURI", "encodeURIComponent", "escape", "unescape",
		// read-only types:
		"ReadonlyArray",
		// type constructors:
		"Partial", "Required", "Readonly", "Pick", "Record", "Exclude", "Extract", "Omit", "NonNullable",
		"Parameters", "ConstructorParameters", "ReturnType", "InstanceType", "Uppercase", "Lowercase",
		"Capitalize", "Uncapitalize", "Awaited",
		// decorators:
		"ClassDecorator", "PropertyDecorator", "MethodDecorator", "ParameterDecorator",
		// odd stuff:
		"ThisParameterType", "OmitThisParameter", "CallableFunction", "NewableFunction", "PromiseConstructorLike"
	])] as [string, Set<string>]
]);

const POLYFILLS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// FIXME
		// "Boolean", "Number", "String", "Symbol", "Object", "RegExp", "Function", "Array", "Date", "Math", "JSON", "Error"
	])] as [string, Set<string>]
]);

const FINAL_CLASSIFIERS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// FIXME
		// "Boolean", "Number", "String", "Symbol", "RegExp", "Function", "Date", "Math", "JSON"
	])] as [string, Set<string>]
]);

const ADDITIONAL_CODE = new Map<string,Map<string,string[]>>([
	[ "es5.d.ts", new Map<string,string[]>([
		["Object", [
			"public get __proto__(): Object;"
		]] as [string,string[]],
		["Array", [
			"public [Symbol.iterator](): Iterator<T>;"
		]] as [string,string[]]
	])] as [string, Map<string,string[]>]
]);

export public function isIgnored(filePath: string, elementName: string): boolean {
	const fileName = path_lib.basename(filePath);
	const ignoredNames = IGNORED_ELEMENTS.get(fileName);
	return ignoredNames?.has(elementName);
}

/**
 * Invoked for each script iff in "--runtime-libs" mode. Will modify its top-level elements
 * in various ways (in place).
 *
 * @param script the script to modify.
 */
export public function postProcessRuntimeLib(dtsFileName: string, script: model.Script) {
	handleSimpleConfigurations(dtsFileName, script);
	removeMetaProperties(script);
	removeIgnoredElements(dtsFileName, script);
	handleCtorInstanceTypePattern(script);
	handlePolyfills(dtsFileName, script);
	handleFinalClassifiers(dtsFileName, script);
}

function handleSimpleConfigurations(dtsFileName: string, script: model.Script) {
	const prefix = SCRIPT_PREFIX.get(dtsFileName);
	if (PREAMBLE || prefix) {
		script.prefix = utils.trimMultiLineString(PREAMBLE ?? "") + utils.trimMultiLineString(prefix ?? "");
	}
	const suffix = SCRIPT_SUFFIX.get(dtsFileName);
	if (suffix) {
		script.suffix = utils.trimMultiLineString(suffix);
	}
	const additionalCode = ADDITIONAL_CODE.get(dtsFileName);
	if (additionalCode && additionalCode.size > 0) {
		for (const elem of script.topLevelElements) {
			if (!(elem instanceof model.Type)) {
				continue;
			}
			const elemName = elem.name;
			if (elemName && additionalCode.has(elemName)) {
				for (const code of additionalCode.get(elemName)) {
					elem.additionalCode.push(code);
				}
			}
		}
	}
}

function removeMetaProperties(script: model.Script) {
	for (const elem of script.topLevelElements) {
		if (elem instanceof model.Type) {
			const ms = elem.members;
			let i = 0;
			while (i < ms.length) {
				const m = ms[i];
				if ((m.name === "constructor" && m.kind !== model.MemberKind.CTOR)
						|| m.name === "prototype") {
					ms.splice(i, 1);
				} else {
					++i;
				}
			}
		}
	}
}

function removeIgnoredElements(dtsFileName: string, script: model.Script) {
	const ignoredElems = IGNORED_ELEMENTS.get(dtsFileName);
	if (!ignoredElems || ignoredElems.size === 0) {
		return;
	}
	let i = 0;
	const elems = script.topLevelElements;
	while (i < elems.length) {
		const elem = elems[i];
		const elemName = elem.name;
		if (elemName && ignoredElems.has(elemName)) {
			elems.splice(i, 1);
		} else {
			++i;
		}
	}
}

function handleCtorInstanceTypePattern(script: model.Script) {
	const elemsByName = new Map<string,model.ExportableElement[]>();
	for (const elem of script.topLevelElements) {
		const name = elem.name;
		let arr = elemsByName.get(name);
		if (!arr) {
			arr = [];
			elemsByName.set(name, arr);
		}
		arr.push(elem);
	}

	const topLevelElementsToBeRemoved = [] as model.ExportableElement[];

	for (const elem of script.topLevelElements) {
		if (elem instanceof model.Variable) {
			adjustCtorInstanceTypesForVarDecl(elem, elemsByName, topLevelElementsToBeRemoved);
		}
	}

	for (const elem of topLevelElementsToBeRemoved) {
		const idx = script.topLevelElements.indexOf(elem);
		if (idx >= 0) {
			script.topLevelElements.splice(idx, 1);
		}
	}
}

function adjustCtorInstanceTypesForVarDecl(
	varDecl: model.Variable,
	elemsByName: Map<string,model.ExportableElement[]>,
	topLevelElementsToBeRemoved: model.ExportableElement[]) {

	const typeRefStr = varDecl.type?.tsSourceString;
	if (!typeRefStr) {
		return;
	}
	const types = elemsByName.get(typeRefStr)?.filter(elem => elem instanceof model.Type) as model.Type[];
	if (!types || types.length === 0) {
		return;
	}
	if (types.length > 1) {
		// FIXME emit warning!!!
		return;
	}
	const type = types[0];
	if (type.kind !== model.TypeKind.INTERFACE) {
		// FIXME emit warning!!!
		return;
	}
	// look for a corresponding instance type
	let instanceType: model.Type;
	const typeName = type.name;
	if (typeName.endsWith(CONSTRUCTOR_TYPE_SUFFIX)) {
		const instanceTypeName = typeName.substring(0, typeName.length - CONSTRUCTOR_TYPE_SUFFIX.length);
		const instanceTypes = elemsByName.get(instanceTypeName)?.filter(elem => elem instanceof model.Type) as model.Type[];
		if (instanceTypes) {
			for (const instanceTypeCandidate of instanceTypes) {
				if (instanceTypeCandidate.kind === model.TypeKind.INTERFACE) {
					instanceType = instanceTypeCandidate;
					break;
				}
			}
		}
	}
	// change "constructor type" to a class and make all members static
	changeInterfaceToClass(type);
	type.members.forEach(m => m.isStatic = true);
	// merge the "constructor type" into the "instance type" (if any)
	if (instanceType) {
		// change "instance type" to a class
		changeInterfaceToClass(instanceType);
		// move all members of the "constructor type" into the "instance type"
		type.members.forEach(m => instanceType.members.push(m));
		type.members.length = 0;
		// mark the "constructor type" as "to be removed"
		topLevelElementsToBeRemoved.push(type);
	}
	// mark the variable declaration as "to be removed"
	topLevelElementsToBeRemoved.push(varDecl);
}

function handlePolyfills(dtsFileName: string, script: model.Script) {
	const polyfills = POLYFILLS.get(dtsFileName);
	if (!polyfills || polyfills.size === 0) {
		return;
	}
	for (const elem of script.topLevelElements) {
		if (!(elem instanceof model.Type)) {
			continue;
		}
		const elemName = elem.name;
		if (elemName && polyfills.has(elemName)) {
			elem.annotations.push(new model.Annotation("@Polyfill"));
			elem.extends = new model.TypeRef(elemName);
			elem.defSiteStructural = false;
		}
	}
}

function handleFinalClassifiers(dtsFileName: string, script: model.Script) {
	const finalClassifiers = FINAL_CLASSIFIERS.get(dtsFileName);
	if (!finalClassifiers || finalClassifiers.size === 0) {
		return;
	}
	for (const elem of script.topLevelElements) {
		if (!(elem instanceof model.Type)) {
			continue;
		}
		const elemName = elem.name;
		if (elemName && finalClassifiers.has(elemName)) {
			elem.annotations.push(new model.Annotation("@Final"));
		}
	}
}

function changeInterfaceToClass(ifc: model.Type) {
	if (ifc.kind !== model.TypeKind.INTERFACE) {
		throw "ifc is expected to be an interface, but was: " + ifc.kind;
	}
	ifc.kind = model.TypeKind.CLASS;
	ifc.defSiteStructural = false;
	// due to different default accessibilities, we have to make accessibility PUBLIC explicit:
	ifc.members.forEach(m => {
		if (!m.accessibility) {
			m.accessibility = model.Accessibility.PUBLIC;
		}
	});
}
