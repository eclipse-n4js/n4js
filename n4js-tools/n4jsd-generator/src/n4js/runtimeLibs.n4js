/**
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

// This file contains various special handling for converting runtime library definitions.
// Additional tweaks may be found also in other places; see usage of Options#runtimeLibs in
// file 'cmdLineOpts.n4js' for finding those.

import * as path_lib from "path";
import * as model from "model";
import * as utils from "utils";
import { parseObject, PropertyTypeInfo } from "utilsObjectParsing";

import configUnparsed+ from "runtimeLibsConfig"; // TODO make configurable from command line!


const CONSTRUCTOR_TYPE_SUFFIX = "Constructor";


class GenConfig {
	preamble: string;
	files: Map<string, FileGenConfig> = new Map<string, FileGenConfig>();
}
class FileGenConfig {
	public prefix: string;
	public suffix: string;
	public ignore = new Set<string>();
	public polyfills = new Set<string>();
	public patchMembers = new Map<string, PatchMemberConfig>();
	public appendCode = new Map<string, string>();
}
class PatchMemberConfig {
	public replaceBy: string;
	public addAnnotations: string[];
}
const GEN_CONFIG_TYPE_INFO = new Map<string,PropertyTypeInfo>([
	[ "GenConfig#files",                  new PropertyTypeInfo({ type: FileGenConfig,     collectionType: Map }) ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#ignore",             new PropertyTypeInfo({ type: String,            collectionType: Set }) ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#polyfills",          new PropertyTypeInfo({ type: String,            collectionType: Set }) ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#patchMembers",       new PropertyTypeInfo({ type: PatchMemberConfig, collectionType: Map }) ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#appendCode",         new PropertyTypeInfo({ type: String,            collectionType: Map }) ] as [string,PropertyTypeInfo],
	[ "PatchMemberConfig#addAnnotations", new PropertyTypeInfo({ type: String,            collectionType: Array }) ] as [string,PropertyTypeInfo]
]);


export public function isIgnored(filePath: string, elementName: string): boolean {
	const fileName = path_lib.basename(filePath);
	return getGenConfig().files.get(fileName)?.ignore?.has(elementName);
}

export public class RuntimeLibsError extends Error {}

/**
 * Invoked iff in "--runtime-libs" mode. Will modify its top-level elements in various ways (in place).
 *
 * @param scripts all scripts that were imported from '.d.ts' files.
 */
export public function postProcessRuntimeLibs(scripts: model.Script[]) {
	new RuntimeLibsProcessor(scripts).process();
}

class RuntimeLibsProcessor {

	@Final private scriptsOrdered: model.Script[];
	@Final private knownCtorTypes = new Set<string>();
	@Final private knownInstanceTypes = new Set<string>();
	@Final private identifiedPolyfills = new Set<model.Type>();

	constructor(scripts: model.Script[]) {
		this.scriptsOrdered = getScriptsOrderedAndAsserted(scripts);
	}

	public process() {
		for (const script of this.scriptsOrdered) {
			this.processScript(script);
		}
	}

	private processScript(script: model.Script) {
		this.removeMetaProperties(script);
		this.handleCtorInstanceTypePattern(script);
		this.handleSimpleConfigurations(script);
		this.handlePolyfills(script);
	}

	private handleSimpleConfigurations(script: model.Script) {
		const config = getGenConfig();
		const fileConfig = config.files.get(script.tsFileName);
		// script prefix/suffix
		const preamble = config.preamble;
		const prefix = fileConfig?.prefix;
		if (preamble || prefix) {
			script.prefix = utils.trimMultiLineString(preamble ?? "") + utils.trimMultiLineString(prefix ?? "");
		}
		const suffix = fileConfig?.suffix;
		if (suffix) {
			script.suffix = utils.trimMultiLineString(suffix);
		}
		// member patching
		const patchedMembers = fileConfig?.patchMembers;
		if (patchedMembers && patchedMembers.size > 0) {
			for (const elem of script.topLevelElements) {
				if (!(elem instanceof model.Type)) {
					continue;
				}
				const typeName = elem.name;
				let idx = 0;
				while (idx < elem.members.length) {
					const member = elem.members[idx];
					let memberName;
					if (member.kind === model.MemberKind.CTOR) {
						memberName = "constructor";
					} else if (member.kind === model.MemberKind.CALLABLE_CTOR) {
						memberName = "()";
					} else {
						memberName = member.name;
					}
					const key = typeName + "#" + memberName;
					if (patchedMembers.has(key)) {
						const patchConfig = patchedMembers.get(key);
						if (patchConfig) {
							const replacementStr = patchConfig.replaceBy;
							if (replacementStr !== undefined && replacementStr !== null) {
								member.replacementCode = utils.trimMultiLineString(replacementStr);
							} else {
								for (const annName of patchConfig.addAnnotations ?? []) {
									member.annotations.push(new model.Annotation(annName));
								}
							}
						} else {
							// null/undefined means: remove the member entirely
							elem.members.splice(idx, 1);
							--idx;
						}
					}
					++idx;
				}
			}
		}
		// additional code for types
		const additionalCode = fileConfig?.appendCode;
		if (additionalCode && additionalCode.size > 0) {
			for (const elem of script.topLevelElements) {
				if (!(elem instanceof model.Type)) {
					continue;
				}
				const elemName = elem.name;
				if (elemName && additionalCode.has(elemName)) {
					const code = additionalCode.get(elemName);
					if (code !== undefined && code !== null) {
						elem.additionalCode.push(utils.trimMultiLineString(code));
					}
				}
			}
		}
	}

	private removeMetaProperties(script: model.Script) {
		for (const elem of script.topLevelElements) {
			if (elem instanceof model.Type) {
				const ms = elem.members;
				let i = 0;
				while (i < ms.length) {
					const m = ms[i];
					if ((m.name === "constructor" && m.kind !== model.MemberKind.CTOR)
							|| m.name === "prototype") {
						ms.splice(i, 1);
					} else {
						++i;
					}
				}
			}
		}
	}

	private handleCtorInstanceTypePattern(script: model.Script) {
		const elemsByName = new Map<string,model.ExportableElement[]>();
		for (const elem of script.topLevelElements) {
			const name = elem.name;
			let arr = elemsByName.get(name);
			if (!arr) {
				arr = [];
				elemsByName.set(name, arr);
			}
			arr.push(elem);
		}

		const topLevelElementModifications = new ElementModifications();

		for (const elem of script.topLevelElements) {
			if (elem instanceof model.Type && elem.kind === model.TypeKind.INTERFACE) {
				if (this.knownCtorTypes.has(elem.name)) {
					const ctorType = elem;
					let instanceType = this.findInstanceTypeForCtorType(ctorType, elemsByName);
					if (instanceType && !this.knownInstanceTypes.has(instanceType.name)) {
						instanceType = undefined;
					}
					const adjustedType = this.adjustCtorInstanceTypes(ctorType, instanceType, elemsByName, topLevelElementModifications);
					this.identifiedPolyfills.add(adjustedType);
				}
			}
		}
		for (const elem of script.topLevelElements) {
			if (elem instanceof model.Type && elem.kind === model.TypeKind.INTERFACE) {
				if (this.knownInstanceTypes.has(elem.name)) {
					const instanceType = elem;
					const adjustedType = this.adjustCtorInstanceTypes(undefined, instanceType, elemsByName, topLevelElementModifications);
					this.identifiedPolyfills.add(adjustedType);
				}
			}
		}
		for (const elem of script.topLevelElements) {
			if (elem instanceof model.Variable) {
				this.adjustCtorInstanceTypesForVarDecl(elem, elemsByName, topLevelElementModifications);
			}
		}

		topLevelElementModifications.applyTo(script);
	}

	private adjustCtorInstanceTypesForVarDecl(
		varDecl: model.Variable,
		elemsByName: Map<string,model.ExportableElement[]>,
		topLevelElementModifications: ElementModifications) {

		const typeRefStr = varDecl.type?.tsSourceString;
		if (!typeRefStr) {
			return;
		}
		const types = elemsByName.get(typeRefStr)?.filter(elem => elem instanceof model.Type) as model.Type[];
		if (!types || types.length === 0) {
			return;
		}
		if (types.length > 1) {
			// FIXME emit warning!!!
			return;
		}
		const type = types[0];
		if (type.kind !== model.TypeKind.INTERFACE) {
			// FIXME emit warning!!!
			return;
		}
		// we have identified the ctor/instance type pattern for variable declaration 'varDecl' and interface 'type'
		// --> so, adjust 'varDecl' and 'type' accordingly

		const ctorType = type;
		// look for a corresponding instance type
		let instanceType: model.Type = this.findInstanceTypeForCtorType(ctorType, elemsByName);
		// remember ctorType/instanceType for processing of following files
		this.knownCtorTypes.add(ctorType.name);
		if (instanceType) {
			this.knownInstanceTypes.add(instanceType.name);
		}

		// actually adjust the ctorType/instanceType
		const originalCtorTypeName = ctorType.name;
		this.adjustCtorInstanceTypes(ctorType, instanceType, elemsByName, topLevelElementModifications);
		// mark the variable declaration as "to be removed"
		topLevelElementModifications.toBeRemoved.add(varDecl);
		// add type alias for original ctorType (if any)
		if (ctorType
				&& instanceType
				&& topLevelElementModifications.toBeRemoved.has(ctorType)
				&& instanceType.name !== originalCtorTypeName) {
			const alias = new model.Type();
			alias.kind = model.TypeKind.TYPE_ALIAS;
			alias.exported = true;
			alias.name = originalCtorTypeName;
			alias.aliasedType = model.createNamedTypeRef("constructor{" + instanceType.name + "}");
			topLevelElementModifications.toBeAdded.set(instanceType, alias);
		}
	}

	private adjustCtorInstanceTypes(
		ctorType: model.Type,
		instanceType: model.Type,
		elemsByName: Map<string,model.ExportableElement[]>,
		topLevelElementModifications: ElementModifications): model.Type {

		// change "constructor type" to a class, strip CONSTRUCTOR_TYPE_SUFFIX from its name, and make all members static
		if (ctorType) {
			changeInterfaceToClass(ctorType);
			const ctorTypeName = ctorType.name;
			if (ctorTypeName.endsWith(CONSTRUCTOR_TYPE_SUFFIX)) {
				ctorType.name = ctorTypeName.substring(0, ctorTypeName.length - CONSTRUCTOR_TYPE_SUFFIX.length);
			}
			ctorType.members.forEach(m => m.isStatic = true);
		}
		// change "instance type" to a class
		if (instanceType) {
			changeInterfaceToClass(instanceType);
		}
		// merge the "constructor type" into the "instance type" (if both exist)
		if (ctorType && instanceType) {
			// move all members of the "constructor type" into the "instance type"
			ctorType.members.forEach(m => instanceType.members.push(m));
			ctorType.members.length = 0;
			// mark the "constructor type" as "to be removed"
			topLevelElementModifications.toBeRemoved.add(ctorType);
		}
		// return the "surviving" type
		return instanceType ? instanceType : ctorType;
	}

	private findInstanceTypeForCtorType(ctorType: model.Type, elemsByName: Map<string,model.ExportableElement[]>): model.Type {
		let instanceType: model.Type = undefined;
		const ctorTypeName = ctorType.name;
		if (ctorTypeName.endsWith(CONSTRUCTOR_TYPE_SUFFIX)) {
			const instanceTypeName = ctorTypeName.substring(0, ctorTypeName.length - CONSTRUCTOR_TYPE_SUFFIX.length);
			const instanceTypes = elemsByName.get(instanceTypeName)?.filter(elem => elem instanceof model.Type) as model.Type[];
			if (instanceTypes) {
				for (const instanceTypeCandidate of instanceTypes) {
					if (instanceTypeCandidate.kind === model.TypeKind.INTERFACE) {
						instanceType = instanceTypeCandidate;
						break;
					}
				}
			}
		}
		return instanceType;
	}

	private handlePolyfills(script: model.Script) {
		const fileConfig = getGenConfig().files.get(script.tsFileName);
		const configuredPolyfills = fileConfig?.polyfills ?? new Set<string>();
		if (this.identifiedPolyfills.size === 0 && configuredPolyfills.size === 0) {
			return;
		}
		for (const elem of script.topLevelElements) {
			if (!(elem instanceof model.Type)) {
				continue;
			}
			const elemName = elem.name;
			if (elemName && (this.identifiedPolyfills.has(elem) || configuredPolyfills.has(elemName))) {
				changeToPolyfill(elem);
			}
		}
	}
}

function changeInterfaceToClass(ifc: model.Type) {
	if (ifc.kind !== model.TypeKind.INTERFACE) {
		return;
	}
	ifc.kind = model.TypeKind.CLASS;
	ifc.defSiteStructural = false;
	// due to different default accessibilities, we have to make accessibility PUBLIC explicit:
	ifc.members.forEach(m => {
		if (!m.accessibility) {
			m.accessibility = model.Accessibility.PUBLIC;
		}
	});
}

function changeToPolyfill(type: model.Type) {
	const typeName = type.name;
	if (!typeName) {
		return;
	}
	type.annotations.push(new model.Annotation("@Polyfill"));
	type.extends.length = 0;
	const superTypeRef = model.createNamedTypeRef(type);
	type.extends.push(superTypeRef);
}

/**
 * Returns the given scripts in the order their configuration was defined in GenConfig.
 * In additions, this method performs two assertions:
 * 1) that the GenConfig file contains file configurations for all input files.
 * 2) that an input file exists for all file configurations given in the GenConfig file.
 */
function getScriptsOrderedAndAsserted(scripts: model.Script[]): model.Script[] {
	const fileConfigs = getGenConfig().files;

	const scriptsWithoutGenConfig = [] as model.Script[];
	for (const script of scripts) {
		if (!fileConfigs.has(script.tsFileName)) {
			scriptsWithoutGenConfig.push(script);
		}
	}
	if (scriptsWithoutGenConfig.length > 0) {
		throw new RuntimeLibsError("no generator configuration in config property 'files' found for:\n    "
			+ scriptsWithoutGenConfig.map(s => s.tsFileName + "  (at " + s.tsFilePath + ")").join("\n    "));
	}

	const result: model.Script[] = [];
	const scriptsByName = new Map<string, model.Script>(scripts.map(s => [s.tsFileName, s]));
	const namesWithoutScript = [] as string[];
	for (const name of fileConfigs.keys()) {
		const script = scriptsByName.get(name);
		if (!script) {
			namesWithoutScript.push(name);
		} else {
			result.push(script);
		}
	}
	if (namesWithoutScript.length > 0) {
		throw new RuntimeLibsError("no .d.ts input file found for generator configuration with name(s): "
			+ namesWithoutScript.join(", "));
	}

	return result;
}

let _cachedGenConfig: GenConfig;
function getGenConfig(): GenConfig {
	if (!_cachedGenConfig) {
		try {
			_cachedGenConfig = parseObject(configUnparsed, GenConfig, GEN_CONFIG_TYPE_INFO);
		} catch (err) {
			throw new RuntimeLibsError("error while parsing configuration file for runtime-libs conversion:\n    " + err);
		}
	}
	return _cachedGenConfig;
}

class ElementModifications {
	@Final public toBeRemoved = new Set<model.ExportableElement>();
	/** Map from existing element to the elment that should be added after the existing element. */
	@Final public toBeAdded = new Map<model.ExportableElement, model.ExportableElement>();

	public applyTo(script: model.Script) {
		const topLevelElems = script.topLevelElements;
		let i = 0;
		while (i < topLevelElems.length) {
			const currElem = topLevelElems[i];
			if (this.toBeRemoved.has(currElem)) {
				topLevelElems.splice(i, 1);
			} else {
				++i;
			}
			const newElem = this.toBeAdded.get(currElem);
			if (newElem) {
				topLevelElems.splice(i, 0, newElem);
				++i;
			}
		}
	}
}
