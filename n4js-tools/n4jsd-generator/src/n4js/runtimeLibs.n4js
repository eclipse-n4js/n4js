/**
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

// This file contains various special handling for converting runtime library definitions.
// Additional tweaks may be found also in other places; see usage of Options#runtimeLibs in
// file 'cmdLineOpts.n4js' for finding those.

import * as path_lib from "path";
import * as model from "model";

const PREAMBLE = `@@Global @@ProvidedByRuntime
`;

const CONSTRUCTOR_TYPE_SUFFIX = "Constructor";

const IGNORED_ELEMENTS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// stuff defined in primitive_js.n4ts and global.n4ts:
		"NaN", "Infinity", "eval", "parseInt", "parseFloat", "isNaN", "isFinite", "decodeURI", "decodeURIComponent",
		"encodeURI", "encodeURIComponent", "escape", "unescape",
		// type constructors:
		"Partial", "Required", "Readonly", "Pick", "Record", "Exclude", "Extract", "Omit", "NonNullable",
		"Parameters", "ConstructorParameters", "ReturnType", "InstanceType", "Uppercase", "Lowercase",
		"Capitalize", "Uncapitalize",
		// decorators:
		"ClassDecorator", "PropertyDecorator", "MethodDecorator", "ParameterDecorator",
		// odd stuff:
		"ThisParameterType", "OmitThisParameter", "CallableFunction", "NewableFunction", "PromiseConstructorLike"
	])] as [string, Set<string>]
]);

const POLYFILLS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// FIXME
		// "Boolean", "Number", "String", "Symbol", "Object", "RegExp", "Function", "Array", "Date", "Math", "JSON", "Error"
	])] as [string, Set<string>]
]);

const FINAL_CLASSIFIERS = new Map<string,Set<string>>([
	[ "es5.d.ts", new Set<string>([
		// FIXME
		// "Boolean", "Number", "String", "Symbol", "RegExp", "Function", "Date", "Math", "JSON"
	])] as [string, Set<string>]
]);

export public function isIgnored(filePath: string, elementName: string): boolean {
	const fileName = path_lib.basename(filePath);
	const ignoredNames = IGNORED_ELEMENTS.get(fileName);
	return ignoredNames?.has(elementName);
}

/**
 * Invoked for each script iff in "--runtime-libs" mode. Will modify its top-level elements
 * in various ways (in place).
 *
 * @param script the script to modify.
 */
export public function postProcessRuntimeLib(dtsFileName: string, script: model.Script) {
	script.preamble = PREAMBLE;
	removeMetaProperties(script);
	removeIgnoredElements(dtsFileName, script);
	handleCtorInstanceTypePattern(script);
	handlePolyfills(dtsFileName, script);
	handleFinalClassifiers(dtsFileName, script);
}

function removeMetaProperties(script: model.Script) {
	for (const elem of script.topLevelElements) {
		if (elem instanceof model.Type) {
			const ms = elem.members;
			let i = 0;
			while (i < ms.length) {
				const m = ms[i];
				if ((m.name === "constructor" && m.kind !== model.MemberKind.CTOR)
						|| m.name === "prototype") {
					ms.splice(i, 1);
				} else {
					++i;
				}
			}
		}
	}
}

function removeIgnoredElements(dtsFileName: string, script: model.Script) {
	const ignoredElems = IGNORED_ELEMENTS.get(dtsFileName);
	if (!ignoredElems || ignoredElems.size === 0) {
		return;
	}
	let i = 0;
	const elems = script.topLevelElements;
	while (i < elems.length) {
		const elem = elems[i];
		const elemName = elem.name;
		if (elemName && ignoredElems.has(elemName)) {
			elems.splice(i, 1);
		} else {
			++i;
		}
	}
}

function handleCtorInstanceTypePattern(script: model.Script) {
	const elemsByName = new Map<string,model.ExportableElement[]>();
	for (const elem of script.topLevelElements) {
		const name = elem.name;
		let arr = elemsByName.get(name);
		if (!arr) {
			arr = [];
			elemsByName.set(name, arr);
		}
		arr.push(elem);
	}

	const topLevelElementsToBeRemoved = [] as model.ExportableElement[];

	for (const elem of script.topLevelElements) {
		if (elem instanceof model.Variable) {
			adjustCtorInstanceTypesForVarDecl(elem, elemsByName, topLevelElementsToBeRemoved);
		}
	}

	for (const elem of topLevelElementsToBeRemoved) {
		const idx = script.topLevelElements.indexOf(elem);
		if (idx >= 0) {
			script.topLevelElements.splice(idx, 1);
		}
	}
}

function adjustCtorInstanceTypesForVarDecl(
	varDecl: model.Variable,
	elemsByName: Map<string,model.ExportableElement[]>,
	topLevelElementsToBeRemoved: model.ExportableElement[]) {

	const typeRefStr = varDecl.type?.tsSourceString;
	if (!typeRefStr) {
		return;
	}
	const types = elemsByName.get(typeRefStr)?.filter(elem => elem instanceof model.Type) as model.Type[];
	if (!types || types.length === 0) {
		return;
	}
	if (types.length > 1) {
		// FIXME emit warning!!!
		return;
	}
	const type = types[0];
	if (type.kind !== model.TypeKind.INTERFACE) {
		// FIXME emit warning!!!
		return;
	}
	// look for a corresponding instance type
	let instanceType: model.Type;
	const typeName = type.name;
	if (typeName.endsWith(CONSTRUCTOR_TYPE_SUFFIX)) {
		const instanceTypeName = typeName.substring(0, typeName.length - CONSTRUCTOR_TYPE_SUFFIX.length);
		const instanceTypes = elemsByName.get(instanceTypeName)?.filter(elem => elem instanceof model.Type) as model.Type[];
		if (instanceTypes) {
			for (const instanceTypeCandidate of instanceTypes) {
				if (instanceTypeCandidate.kind === model.TypeKind.INTERFACE) {
					instanceType = instanceTypeCandidate;
					break;
				}
			}
		}
	}
	// change "constructor type" to a class and make all members static
	changeInterfaceToClass(type);
	type.members.forEach(m => m.isStatic = true);
	// merge the "constructor type" into the "instance type" (if any)
	if (instanceType) {
		// change "instance type" to a class
		changeInterfaceToClass(instanceType);
		// move all members of the "constructor type" into the "instance type"
		type.members.forEach(m => instanceType.members.push(m));
		type.members.length = 0;
		// mark the "constructor type" as "to be removed"
		topLevelElementsToBeRemoved.push(type);
	}
	// mark the variable declaration as "to be removed"
	topLevelElementsToBeRemoved.push(varDecl);
}

function handlePolyfills(dtsFileName: string, script: model.Script) {
	const polyfills = POLYFILLS.get(dtsFileName);
	if (!polyfills || polyfills.size === 0) {
		return;
	}
	for (const elem of script.topLevelElements) {
		if (!(elem instanceof model.Type)) {
			continue;
		}
		const elemName = elem.name;
		if (elemName && polyfills.has(elemName)) {
			elem.annotations.push(new model.Annotation("@Polyfill"));
			elem.extends = new model.TypeRef(elemName);
			elem.defSiteStructural = false;
		}
	}
}

function handleFinalClassifiers(dtsFileName: string, script: model.Script) {
	const finalClassifiers = FINAL_CLASSIFIERS.get(dtsFileName);
	if (!finalClassifiers || finalClassifiers.size === 0) {
		return;
	}
	for (const elem of script.topLevelElements) {
		if (!(elem instanceof model.Type)) {
			continue;
		}
		const elemName = elem.name;
		if (elemName && finalClassifiers.has(elemName)) {
			elem.annotations.push(new model.Annotation("@Final"));
		}
	}
}

function changeInterfaceToClass(ifc: model.Type) {
	if (ifc.kind !== model.TypeKind.INTERFACE) {
		throw "ifc is expected to be an interface, but was: " + ifc.kind;
	}
	ifc.kind = model.TypeKind.CLASS;
	ifc.defSiteStructural = false;
	// due to different default accessibilities, we have to make accessibility PUBLIC explicit:
	ifc.members.forEach(m => {
		if (!m.accessibility) {
			m.accessibility = model.Accessibility.PUBLIC;
		}
	});
}
