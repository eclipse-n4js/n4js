/**
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

// This file contains various special handling for converting runtime library definitions.
// Additional tweaks may be found also in other places; see usage of Options#runtimeLibs in
// file 'cmdLineOpts.n4js' for finding those.

import * as path_lib from "path";
import * as model from "model";
import * as utils from "utils";
import { parseObject, PropertyTypeInfo } from "utilsObjectParsing";

import configUnparsed+ from "runtimeLibsConfig"; // TODO make configurable from command line!


const CONSTRUCTOR_TYPE_SUFFIX = "Constructor";


class GenConfig {
	preamble: string;
	files: Map<string, FileGenConfig> = new Map<string, FileGenConfig>();
}
class FileGenConfig {
	public prefix: string;
	public suffix: string;
	public ignore: Set<string> = new Set<string>();
	public polyfills: Set<string> = new Set<string>();
	public patchMembers: Map<string,string> = new Map<string, string>();
	public appendCode: Map<string,string> = new Map<string, string>();
}
const GEN_CONFIG_TYPE_INFO = new Map<string,PropertyTypeInfo>([
	[ "GenConfig#files", { type: FileGenConfig, collectionType: Map } as PropertyTypeInfo ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#ignore", { type: String, collectionType: Set } as PropertyTypeInfo ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#polyfills", { type: String, collectionType: Set } as PropertyTypeInfo ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#patchMembers", { type: String, collectionType: Map } as PropertyTypeInfo ] as [string,PropertyTypeInfo],
	[ "FileGenConfig#appendCode", { type: String, collectionType: Map } as PropertyTypeInfo ] as [string,PropertyTypeInfo]
]);


export public function isIgnored(filePath: string, elementName: string): boolean {
	const fileName = path_lib.basename(filePath);
	return getGenConfig().files.get(fileName)?.ignore?.has(elementName);
}

export public class RuntimeLibsError extends Error {}

/**
 * Invoked iff in "--runtime-libs" mode. Will modify its top-level elements in various ways (in place).
 *
 * @param scripts all scripts that were imported from '.d.ts' files.
 */
export public function postProcessRuntimeLibs(scripts: model.Script[]) {
	new RuntimeLibsProcessor(scripts).process();
}

class RuntimeLibsProcessor {

	@Final private scriptsOrdered: model.Script[];
	@Final private knownCtorInstanceTypes = new Set<string>();

	constructor(scripts: model.Script[]) {
		this.scriptsOrdered = getScriptsOrderedAndAsserted(scripts);
	}

	public process() {
		for (const script of this.scriptsOrdered) {
			this.processScript(script);
		}
	}

	private processScript(script: model.Script) {
		this.removeMetaProperties(script);
		this.removeIgnoredElements(script);
		this.handleCtorInstanceTypePattern(script);

		this.handleSimpleConfigurations(script);
		this.handlePolyfills(script);
	}

	private handleSimpleConfigurations(script: model.Script) {
		const config = getGenConfig();
		const fileConfig = config.files.get(script.tsFileName);
		// script prefix/suffix
		const preamble = config.preamble;
		const prefix = fileConfig?.prefix;
		if (preamble || prefix) {
			script.prefix = utils.trimMultiLineString(preamble ?? "") + utils.trimMultiLineString(prefix ?? "");
		}
		const suffix = fileConfig?.suffix;
		if (suffix) {
			script.suffix = utils.trimMultiLineString(suffix);
		}
		// member patching
		const patchedMembers = fileConfig?.patchMembers;
		if (patchedMembers && patchedMembers.size > 0) {
			for (const elem of script.topLevelElements) {
				if (!(elem instanceof model.Type)) {
					continue;
				}
				const typeName = elem.name;
				let idx = 0;
				while (idx < elem.members.length) {
					const member = elem.members[idx];
					let memberName;
					if (member.kind === model.MemberKind.CTOR) {
						memberName = "constructor";
					} else if (member.kind === model.MemberKind.CALLABLE_CTOR) {
						memberName = "()";
					} else {
						memberName = member.name;
					}
					const key = typeName + "#" + memberName;
					if (patchedMembers.has(key)) {
						const replacement = patchedMembers.get(key);
						if (replacement !== undefined && replacement !== null) {
							member.replacementCode = utils.trimMultiLineString(replacement);
						} else {
							// null/undefined means: remove the member
							elem.members.splice(idx, 1);
							--idx;
						}
					}
					++idx;
				}
			}
		}
		// additional code for types
		const additionalCode = fileConfig?.appendCode;
		if (additionalCode && additionalCode.size > 0) {
			for (const elem of script.topLevelElements) {
				if (!(elem instanceof model.Type)) {
					continue;
				}
				const elemName = elem.name;
				if (elemName && additionalCode.has(elemName)) {
					const code = additionalCode.get(elemName);
					if (code !== undefined && code !== null) {
						elem.additionalCode.push(utils.trimMultiLineString(code));
					}
				}
			}
		}
	}

	private removeMetaProperties(script: model.Script) {
		for (const elem of script.topLevelElements) {
			if (elem instanceof model.Type) {
				const ms = elem.members;
				let i = 0;
				while (i < ms.length) {
					const m = ms[i];
					if ((m.name === "constructor" && m.kind !== model.MemberKind.CTOR)
							|| m.name === "prototype") {
						ms.splice(i, 1);
					} else {
						++i;
					}
				}
			}
		}
	}

	private removeIgnoredElements(script: model.Script) {
		const fileConfig = getGenConfig().files.get(script.tsFileName);
		const ignoredElems = fileConfig?.ignore;
		if (!ignoredElems || ignoredElems.size === 0) {
			return;
		}
		let i = 0;
		const elems = script.topLevelElements;
		while (i < elems.length) {
			const elem = elems[i];
			const elemName = elem.name;
			if (elemName && ignoredElems.has(elemName)) {
				elems.splice(i, 1);
			} else {
				++i;
			}
		}
	}

	private handleCtorInstanceTypePattern(script: model.Script) {
		const elemsByName = new Map<string,model.ExportableElement[]>();
		for (const elem of script.topLevelElements) {
			const name = elem.name;
			let arr = elemsByName.get(name);
			if (!arr) {
				arr = [];
				elemsByName.set(name, arr);
			}
			arr.push(elem);
		}

		const topLevelElementsToBeRemoved = [] as model.ExportableElement[];

		for (const elem of script.topLevelElements) {
			if (elem instanceof model.Variable) {
				this.adjustCtorInstanceTypesForVarDecl(elem, elemsByName, topLevelElementsToBeRemoved);
			}
		}

		for (const elem of topLevelElementsToBeRemoved) {
			const idx = script.topLevelElements.indexOf(elem);
			if (idx >= 0) {
				script.topLevelElements.splice(idx, 1);
			}
		}
	}

	private adjustCtorInstanceTypesForVarDecl(
		varDecl: model.Variable,
		elemsByName: Map<string,model.ExportableElement[]>,
		topLevelElementsToBeRemoved: model.ExportableElement[]) {

		const typeRefStr = varDecl.type?.tsSourceString;
		if (!typeRefStr) {
			return;
		}
		const types = elemsByName.get(typeRefStr)?.filter(elem => elem instanceof model.Type) as model.Type[];
		if (!types || types.length === 0) {
			return;
		}
		if (types.length > 1) {
			// FIXME emit warning!!!
			return;
		}
		const type = types[0];
		if (type.kind !== model.TypeKind.INTERFACE) {
			// FIXME emit warning!!!
			return;
		}
		// look for a corresponding instance type
		let instanceType: model.Type;
		const typeName = type.name;
		if (typeName.endsWith(CONSTRUCTOR_TYPE_SUFFIX)) {
			const instanceTypeName = typeName.substring(0, typeName.length - CONSTRUCTOR_TYPE_SUFFIX.length);
			const instanceTypes = elemsByName.get(instanceTypeName)?.filter(elem => elem instanceof model.Type) as model.Type[];
			if (instanceTypes) {
				for (const instanceTypeCandidate of instanceTypes) {
					if (instanceTypeCandidate.kind === model.TypeKind.INTERFACE) {
						instanceType = instanceTypeCandidate;
						break;
					}
				}
			}
		}
		// change "constructor type" to a class and make all members static
		changeInterfaceToClass(type);
		type.members.forEach(m => m.isStatic = true);
		// merge the "constructor type" into the "instance type" (if any)
		if (instanceType) {
			// change "instance type" to a class
			changeInterfaceToClass(instanceType);
			// move all members of the "constructor type" into the "instance type"
			type.members.forEach(m => instanceType.members.push(m));
			type.members.length = 0;
			// mark the "constructor type" as "to be removed"
			topLevelElementsToBeRemoved.push(type);
		}
		// mark the variable declaration as "to be removed"
		topLevelElementsToBeRemoved.push(varDecl);
	}

	public handlePolyfills(script: model.Script) {
		const fileConfig = getGenConfig().files.get(script.tsFileName);
		const polyfills = fileConfig?.polyfills;
		if (!polyfills || polyfills.size === 0) {
			return;
		}
		for (const elem of script.topLevelElements) {
			if (!(elem instanceof model.Type)) {
				continue;
			}
			const elemName = elem.name;
			if (elemName && polyfills.has(elemName)) {
				elem.annotations.push(new model.Annotation("@Polyfill"));
				elem.extends.length = 0;
				elem.extends.push(new model.TypeRef(elemName));
				elem.defSiteStructural = false;
			}
		}
	}
}

function changeInterfaceToClass(ifc: model.Type) {
	if (ifc.kind !== model.TypeKind.INTERFACE) {
		throw "ifc is expected to be an interface, but was: " + ifc.kind; // note: not a RuntimeLibsError!
	}
	ifc.kind = model.TypeKind.CLASS;
	ifc.defSiteStructural = false;
	// due to different default accessibilities, we have to make accessibility PUBLIC explicit:
	ifc.members.forEach(m => {
		if (!m.accessibility) {
			m.accessibility = model.Accessibility.PUBLIC;
		}
	});
}

/**
 * Returns the given scripts in the order their configuration was defined in GenConfig.
 * In additions, this method performs two assertions:
 * 1) that the GenConfig file contains file configurations for all input files.
 * 2) that an input file exists for all file configurations given in the GenConfig file.
 */
function getScriptsOrderedAndAsserted(scripts: model.Script[]): model.Script[] {
	const fileConfigs = getGenConfig().files;

	const scriptsWithoutGenConfig = [] as model.Script[];
	for (const script of scripts) {
		if (!fileConfigs.has(script.tsFileName)) {
			scriptsWithoutGenConfig.push(script);
		}
	}
	if (scriptsWithoutGenConfig.length > 0) {
		throw new RuntimeLibsError("no generator configuration in config property 'files' found for:\n    "
			+ scriptsWithoutGenConfig.map(s => s.tsFileName + "  (at " + s.tsFilePath + ")").join("\n    "));
	}

	const result: model.Script[] = [];
	const scriptsByName = new Map<string, model.Script>(scripts.map(s => [s.tsFileName, s]));
	const namesWithoutScript = [] as string[];
	for (const name of fileConfigs.keys()) {
		const script = scriptsByName.get(name);
		if (!script) {
			namesWithoutScript.push(name);
		} else {
			result.push(script);
		}
	}
	if (namesWithoutScript.length > 0) {
		throw new RuntimeLibsError("no .d.ts input file found for generator configuration with name(s): "
			+ namesWithoutScript.join(", "));
	}

	return result;
}

let _cachedGenConfig: GenConfig;
function getGenConfig(): GenConfig {
	if (!_cachedGenConfig) {
		try {
			_cachedGenConfig = parseObject(configUnparsed, GenConfig, GEN_CONFIG_TYPE_INFO);
		} catch (err) {
			throw new RuntimeLibsError("error while parsing configuration file for runtime-libs conversion:\n    " + err);
		}
	}
	return _cachedGenConfig;
}
