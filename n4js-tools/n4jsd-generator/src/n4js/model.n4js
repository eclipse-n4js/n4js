/**
 * Copyright (c) 2020 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

import { CodeBuffer } from "CodeBuffer";
import { getGlobalOptions } from "cmdLineOpts";
import * as utils from "utils";

export enum DTSMode {
	NONE,
	MODULE,
	LEGACY
}

export enum Accessibility {
	PUBLIC,
	PROTECTED,
	PRIVATE
}

export class Annotation {
	name: string;

	constructor(name: string =) {
		this.name = name;
	}
}

export interface AnnotatableElement {
	annotations: Annotation[] = [];
}

export class Script {
	tsFileName: string;
	tsFilePath: string;
	mode: DTSMode = DTSMode.NONE;
	prefix?: string;
	suffix?: string;
	imports: Import[] = [];
	topLevelElements: ExportableElement[] = [];
	issues: utils.Issue[] = [];
}

export abstract class Import {
	moduleSpecifier: string;
}

export class DefaultImport extends Import {
	localName: string;
}

export class NamespaceImport extends Import {
	namespaceName: string;
}

export class NamedImport extends Import {
	importedElementName: string;
	aliasName?: string;
}

export abstract class NamedElement {
	name: string;
	jsdoc?: string;
}

export abstract class ExportableElement extends NamedElement {
	exported: boolean;
	exportedAsDefault: boolean;
}

export enum VariableKeyword {
	VAR, LET, CONST
}

export class Variable extends ExportableElement {
	keyword: VariableKeyword;
	type: TypeRef;
}

export class Function extends ExportableElement {
	signatures: Signature[] = [];
}

export enum TypeKind {
	INTERFACE, CLASS, ENUM, TYPE_ALIAS: "type"
}

export enum PrimitiveBasedKind {
	STRING_BASED, NUMBER_BASED
}

export class Type extends ExportableElement implements AnnotatableElement {
	kind: TypeKind;
	defSiteStructural?: boolean;
	primitiveBased?: PrimitiveBasedKind;
	typeParams: string[] = [];
	extends: TypeRef[] = [];
	implements: TypeRef[] = [];
	members: Member[] = [];
	literals: EnumLiteral[] = [];
	aliasedType: TypeRef;
	additionalCode: string[] = [];
}

export class EnumLiteral extends NamedElement {
	value?: string | number;
}

export enum MemberKind {
	CTOR, CALLABLE_CTOR, INDEX_SIGNATURE,
	FIELD, GETTER, SETTER, METHOD
}

export class Member extends NamedElement implements AnnotatableElement {
	kind: MemberKind;
	accessibility: Accessibility;
	isStatic: boolean;
	typeParams: string[] = [];
	/** Will be defined iff this member is a data field or field accessor. */
	type?: TypeRef;
	signatures?: Signature[];
	replacementCode?: string;
}

export class Signature {
	parameters: Parameter[] = [];
	/** Will be undefined iff this signature belongs to a constructor. */
	returnType?: TypeRef;
}

export class Parameter extends NamedElement {
	type: TypeRef;
	isOptional: boolean;
	isVariadic: boolean;
}

export enum TypeRefKind {
	/** Referring to a type by name or alias. Corresponds to ParameterizedTypeRef in N4JS. */
	NAMED,
	LITERAL,
	FUNCTION,
	OBJECT,
	THIS,
	UNION,
	INTERSECTION,
	PARENTHESES,
	// the following are not actually supported on N4JS side:
	PREDICATE,
	MAPPED_TYPE
}

export enum TypeRefOperator {
	KEYOF,
	UNIQUE,
	READONLY
}

export class TypeRef {
	kind: TypeRefKind;
	dynamic: boolean;
	targetTypeName: string;
	targetTypeArgs: TypeRef[] = [];
	signature: Signature;
	members: Member[] = [];
	composedTypeRefs: TypeRef[] = [];
	parenthesizedTypeRef: TypeRef;
	/** The type operators that preceded this type reference on the TypeScript side. */
	tsOperators: TypeRefOperator[] = [];
	/** The type reference as given in the TypeScript source code. */
	tsSourceString: string;

	constructor(tsSourceString: string =) {
		this.tsSourceString = tsSourceString;
	}

	public isBuiltInUndefined(): boolean {
		return this.kind === TypeRefKind.NAMED && this.targetTypeName === "undefined";
	}
	public isComposed(): boolean {
		return this.kind === TypeRefKind.UNION || this.kind === TypeRefKind.INTERSECTION;
	}
}


export function scriptToString(script: Script): string {
    const emitter = new Emitter();
    emitter.emitScript(script);
    return emitter.getCode();
}

class Emitter {

	private buff: CodeBuffer = new CodeBuffer();

	getCode(): string {
		return this.buff.getCode();
	}

	emitScript(script: Script) {
		const buff = this.buff;
		if (script.prefix) {
			buff.pushln(script.prefix);
			buff.pushln(); // separate prefix from main code by one empty line
		}
		if (script.imports.length > 0) {
			script.imports.forEach((elem, idx) => {
				if (idx > 0) {
					buff.pushln();
				}
				this.emitImport(elem);
			});
			buff.pushln();
			buff.pushln();
		}
		script.topLevelElements.forEach((elem, idx) => {
			if (idx > 0) {
				buff.pushln();
				buff.pushln();
			}
			this.emitExportableElement(elem);
		});
		buff.pushln();
		if (script.suffix) {
			buff.pushln(); // separate main code from suffix by one empty line
			buff.pushln(script.suffix);
		}
	}

	emitImport(elem: Import) {
		const buff = this.buff;
		buff.push("import ");
		if (elem instanceof DefaultImport) {
			buff.push(elem.localName, " ");
		} else if (elem instanceof NamespaceImport) {
			buff.push("* as ", elem.namespaceName, " ");
		} else if (elem instanceof NamedImport) {
			buff.push("{ ", elem.importedElementName);
			if (elem.aliasName !== undefined) {
				buff.push(" as ", elem.aliasName);
			}
			buff.push(" } ");
		} else {
			throw "unsupported sub-class of Import";
		}
		buff.push("from \"", elem.moduleSpecifier, "\";");
	}

	emitExportableElement(elem: ExportableElement) {
		if (elem instanceof Variable) {
			this.emitVariable(elem);
		} else if (elem instanceof Function) {
			this.emitFunction(elem);
		} else if (elem instanceof Type) {
			this.emitType(elem);
		} else {
			throw "unsupported sub-type of ExportableElement";
		}
	}

	emitExportKeywordIfNecessary(elem: ExportableElement) {
		const buff = this.buff;
		if (elem.exported) {
			buff.push("export ");
			if (elem.exportedAsDefault) {
				buff.push("default ");
			}
		}
	}

	emitVariable(variable: Variable) {
		const buff = this.buff;
		this.emitDocumentation(variable);
		this.emitExportKeywordIfNecessary(variable);
		buff.push("public ");
		buff.push(variable.keyword.name.toLowerCase());
		buff.push(" ");
		buff.push(variable.name);
		this.emitTypeAnnotation(variable.type);
		buff.push(";");
	}

	emitFunction(fun: Function) {
		const buff = this.buff;
		this.emitDocumentation(fun);
		this.emitExportKeywordIfNecessary(fun);
		buff.push("external ");
		buff.push("public ");
		buff.push("function ");
		buff.push(fun.name);
		this.emitSignature(fun.signatures[0]);
		buff.push(";");
	}

	emitType(type: Type) {
		const buff = this.buff;
		this.emitDocumentation(type);
		this.emitAnnotations(type, true);
		if (type.primitiveBased === PrimitiveBasedKind.STRING_BASED) {
			buff.pushln("@StringBased");
		} else if (type.primitiveBased === PrimitiveBasedKind.NUMBER_BASED) {
			buff.pushln("@NumberBased");
		}
		this.emitExportKeywordIfNecessary(type);
		buff.push("external ");
		buff.push("public ");
		buff.push(type.kind.value.toLowerCase(), " ");
		if (type.defSiteStructural) {
			buff.push("~");
		}
		buff.push(type.name);
		if (type.typeParams.length > 0) {
			buff.push("<", type.typeParams.join(","), ">");
		}
		if (type.extends.length > 0) {
			buff.push(" extends ");
			this.emitTypeRefs(type.extends, true);
		}
		if (type.implements.length > 0) {
			buff.push(" implements ");
			this.emitTypeRefs(type.implements, true);
		}
		if (type.kind === TypeKind.TYPE_ALIAS) {
			buff.push(" = ");
			this.emitTypeRef(type.aliasedType);
			buff.push(";");
		} else {
			buff.push(" {");
			buff.indent();
			let didEmit = false;
			if (type.kind === TypeKind.INTERFACE || type.kind === TypeKind.CLASS) {
				didEmit = this.emitMembers(type.members, type);
			} else if (type.kind === TypeKind.ENUM) {
				didEmit = this.emitEnumLiterals(type.literals, type.primitiveBased === PrimitiveBasedKind.STRING_BASED);
			} else {
				throw "unknown kind of type: " + type.kind;
			}
			for (const code of type.additionalCode) {
				buff.pushln();
				didEmit = this.emitCode(code) || didEmit;
			}
			buff.undent();
			if (didEmit) {
				buff.pushln();
			}
			buff.push("}");
		}
	}

	emitEnumLiterals(literals: EnumLiteral[], isStringBased: boolean): boolean {
		const buff = this.buff;
		let isFirst = true;
		for (const lit of literals) {
			if (!isFirst) {
				buff.push(",");
			}
			buff.pushln();
			this.emitDocumentation(lit);
			buff.push(lit.name);
			if (lit.value !== undefined) {
				buff.push(": ");
				if (typeof lit.value == 'string') {
					buff.push("'" + lit.value + "'"); // TODO escaping!
				} else {
					buff.push("" + lit.value);
				}
			}
			isFirst = false;
		}
		return !isFirst;
	}

	emitMembers(members: Member[], parent: Type =, onePerLine: boolean = true): boolean {
		const buff = this.buff;
		let isFirst = true;
		for (const m of members) {
			if (m.kind === MemberKind.INDEX_SIGNATURE) {
				continue; // ignore index signatures, for now
			}
			if (onePerLine) {
				buff.pushln();
			} else {
				if (!isFirst) {
					buff.push(" ");
				}
			}
			this.emitMember(m, onePerLine, parent);
			isFirst = false;
		}
		return !isFirst;
	}

	emitMember(member: Member, emitDocumentation: boolean, parent: Type =) {
		const buff = this.buff;
		if (emitDocumentation) {
			this.emitDocumentation(member);
		}
		if (member.replacementCode) {
			this.emitCode(member.replacementCode);
			return;
		}
		this.emitAnnotations(member, true);
		if (member.accessibility !== undefined) {
			if (member.kind !== MemberKind.CALLABLE_CTOR) { // TODO how to define accessibility of a callable ctor?
				this.emitAccessibility(member);
				buff.push(" ");
			}
		}
		if (member.isStatic) {
			if (member.kind !== MemberKind.CTOR && member.kind !== MemberKind.CALLABLE_CTOR) {
				buff.push("static ");
			}
		}
		if (member.typeParams.length > 0) {
			if (member.kind !== MemberKind.CTOR && member.kind !== MemberKind.CALLABLE_CTOR) {
				buff.push("<", member.typeParams.join(","), "> ");
			}
		}
		switch(member.kind) {
			case MemberKind.CTOR:
				if (parent && parent.kind === TypeKind.INTERFACE) {
					buff.push("@CovariantConstructor");
					buff.pushln();
				}
				buff.push("constructor");
				this.emitSignature(member.signatures[0], true);
				buff.push(";");
				break;
			case MemberKind.CALLABLE_CTOR:
				this.emitSignature(member.signatures[0]);
				buff.push(";");
				break;
			case MemberKind.FIELD:
				this.emitPropertyName(member.name);
				this.emitTypeAnnotation(member.type);
				buff.push(";");
				break;
			case MemberKind.GETTER:
				buff.push("get ");
				this.emitPropertyName(member.name);
				buff.push("()");
				this.emitTypeAnnotation(member.type);
				buff.push(";");
				break;
			case MemberKind.SETTER:
				buff.push("set ");
				this.emitPropertyName(member.name);
				buff.push("(", "value");
				this.emitTypeAnnotation(member.type);
				buff.push(");");
				break;
			case MemberKind.METHOD:
				this.emitPropertyName(member.name);
				this.emitSignature(member.signatures[0]);
				buff.push(";");
				break;
			default:
				throw "unknown kind of member: " + member.kind;
		}
		if (member.signatures !== undefined && member.signatures.length > 1) {
			buff.push(" // further signatures were omitted");
		}
	}

	emitSignature(sig: Signature, ignoreReturnType: boolean = false) {
		const buff = this.buff;
		buff.push("(");
		let needSep = false;
		for (const param of sig.parameters) {
			if (needSep) {
				buff.push(", ");
			}
			this.emitParameter(param);
			needSep = true;
		}
		buff.push(")");
		if (!ignoreReturnType) {
			this.emitTypeAnnotation(simplifyUnion(sig.returnType));
		}
	}

	emitParameter(param: Parameter) {
		const buff = this.buff;
		if (param.isVariadic) {
			buff.push("...");
		}
		if (param.name === "this") {
			// TypeScript supports "this" as the name of a parameter, but N4JS does not:
			buff.push("_");
		}
		buff.push(param.name);
		this.emitTypeAnnotation(param.type);
		if (param.isOptional) {
			buff.push(" = ");
		}
	}

	emitAccessibility(member: Member) {
		const buff = this.buff;
		if (member.accessibility === undefined) {
			// ignore
		} else if (member.accessibility === Accessibility.PUBLIC) {
			buff.push("public");
		} else if (member.accessibility === Accessibility.PROTECTED) {
			buff.push("protected");
		} else if (member.accessibility === Accessibility.PRIVATE) {
			buff.push("private");
		} else {
			throw "unkown member accessibility: " + member.accessibility?.name;
		}
	}

	emitTypeAnnotation(typeRef: TypeRef, separator: string = ": ") {
		const buff = this.buff;
		if (getGlobalOptions()?.copyTypeRefs) {
			if (typeRef) {
				buff.push(separator);
				this.emitTypeRef(typeRef);
			} else {
				buff.push(separator, "any+");
			}
		} else {
			// note: in "any+ mode" we write out "any+" even in case
			// the type was undeclared on the TypeScript side, because
			// N4JS would infer the type to "any" instead of "any+":
			buff.push(separator, "any+");
		}
	}

	emitTypeRefs(typeRefs: TypeRef[], emitAlways: boolean = false): boolean {
		const buff = this.buff;
		let isFirst = true;
		for (const typeRef of typeRefs) {
			if (!isFirst) {
				buff.push(", ");
			}
			this.emitTypeRef(typeRef, emitAlways);
			isFirst = false;
		}
		return !isFirst;
	}

	emitTypeRef(typeRef: TypeRef, emitAlways: boolean = false) {
		const buff = this.buff;
		if (!(emitAlways || getGlobalOptions()?.copyTypeRefs) || !typeRef) {
			buff.push("any+");
			return;
		}
		switch(typeRef.kind) {
			case TypeRefKind.NAMED:
				this.emitNamedTypeRef(typeRef);
				break;
			case TypeRefKind.LITERAL:
				buff.push(typeRef.tsSourceString);
				break;
			case TypeRefKind.FUNCTION:
				this.emitFunctionTypeRef(typeRef);
				break;
			case TypeRefKind.OBJECT:
				this.emitObjectTypeRef(typeRef);
				break;
			case TypeRefKind.THIS:
				buff.push("this");
				break;
			case TypeRefKind.UNION:
			case TypeRefKind.INTERSECTION:
				this.emitComposedTypeRef(typeRef.kind, typeRef.composedTypeRefs);
				break;
			case TypeRefKind.PARENTHESES:
				buff.push("(");
				this.emitTypeRef(typeRef.parenthesizedTypeRef);
				buff.push(")");
				break;
			case TypeRefKind.PREDICATE:
				buff.push("boolean");
				break;
			case TypeRefKind.MAPPED_TYPE:
				buff.push("Object+");
				break;
			default:
				throw "unsupported TypeRefKind: " + typeRef.kind
		}
	}

	emitNamedTypeRef(typeRef: TypeRef) {
		if (typeRef.kind !== TypeRefKind.NAMED) {
			throw "not a TypeRef of kind TypeRefKind.NAMED, but got: " + typeRef.kind;
		}
		const buff = this.buff;
		buff.push(typeRef.targetTypeName);
		if (typeRef.targetTypeArgs.length > 0) {
			buff.push("<");
			let isFirst = true;
			for (const currTypeArg of typeRef.targetTypeArgs) {
				if (!isFirst) {
					buff.push(",");
				}
				this.emitTypeRef(currTypeArg);
				isFirst = false;
			}
			buff.push(">");
		}
		if (typeRef.dynamic) {
			buff.push("+");
		}
	}

	emitFunctionTypeRef(typeRef: TypeRef) {
		if (typeRef.kind !== TypeRefKind.FUNCTION) {
			throw "not a TypeRef of kind TypeRefKind.FUNCTION, but got: " + typeRef.kind;
		}
		const buff = this.buff;
		this.emitSignature(typeRef.signature, true);
		buff.push("=>");
		const returnType = typeRef.signature.returnType;
		if (returnType) {
			const needParens = returnType.isComposed();
			if (needParens) {
				buff.push("(");
			}
			this.emitTypeRef(returnType);
			if (needParens) {
				buff.push(")");
			}
		} else {
			buff.push("void");
		}
	}

	emitObjectTypeRef(typeRef: TypeRef) {
		if (typeRef.kind !== TypeRefKind.OBJECT) {
			throw "not a TypeRef of kind TypeRefKind.OBJECT, but got: " + typeRef.kind;
		}
		const buff = this.buff;
		buff.push("~Object with { ");
		this.emitMembers(typeRef.members, undefined, false);
		buff.push(" }");
	}

	emitComposedTypeRef(typeRefKind: TypeRefKind, memberTypeRefs: TypeRef[]) {
		const buff = this.buff;
		const spearator = typeRefKind === TypeRefKind.UNION ? " | " : " & ";
		let isFirst = true;
		for (const memberTypeRef of memberTypeRefs) {
			if (!isFirst) {
				buff.push(spearator);
			}
			isFirst = false;
			this.emitTypeRef(memberTypeRef);
		}
	}

	emitAnnotations(annotElem: AnnotatableElement, separateLine = false) {
		for (const ann of annotElem.annotations) {
			this.emitAnnotation(ann, separateLine);
		}
	}

	emitAnnotation(ann: Annotation, separateLine = false) {
		const buff = this.buff;
		const name = ann.name;
		if (!name.startsWith("@")) {
			buff.push("@");
		}
		buff.push(name);
		if (separateLine) {
			buff.pushln();
		} else {
			buff.push(" ");
		}
	}

	emitPropertyName(name: string) {
		const buff = this.buff;
		const legal = utils.isLegalIdentifier(name);
		if (!legal) {
			buff.push('"');
		}
		if (name && name.length > 0) {
			buff.push(name.replace('"', '\\"'));
		}
		if (!legal) {
			buff.push('"');
		}
	}

	emitDocumentation(elem: NamedElement) {
		if (getGlobalOptions()?.noDoc) {
			// do not emit JSDoc comments
			return false;
		}
		const doc = elem.jsdoc;
		if (!doc) {
			return false;
		}
		if (this.emitCode(doc)) {
			this.buff.pushln();
			return true;
		}
		return false;
	}

	emitCode(code: string): boolean {
		if (code === undefined || code === null) {
			return false;
		}
		const buff = this.buff;
		const codeLines = code.split("\n");
		let isFirst = true;
		for (const line of codeLines) {
			if (!isFirst) {
				buff.pushln();
			}
			buff.push(line);
			isFirst = false;
		}
		return !isFirst;
	}
}


export function simplifyUnion(typeRef: TypeRef): TypeRef {
	if (typeRef?.kind !== TypeRefKind.UNION) {
		return typeRef;
	}
	let idx = 0;
	const typeRefs = [...typeRef.composedTypeRefs];
	while (idx < typeRefs.length) {
		const curr = typeRefs[idx];
		if (curr.isBuiltInUndefined()) {
			typeRefs.splice(idx,1);
		} else {
			++idx;
		}
	}
	const len = typeRefs.length;
	if (len === 0) {
		return createUndefined();
	} else if (len === 1) {
		return typeRefs[0];
	} else {
		const result = new TypeRef();
		result.kind = TypeRefKind.UNION;
		for (const typeRef of typeRefs) {
			result.composedTypeRefs.push(typeRef);
		}
		return result;
	}
}

export function createUndefined(): TypeRef {
	const result = new TypeRef();
	result.kind = TypeRefKind.NAMED;
	result.targetTypeName = "undefined";
	return result;
}

export function createAnyPlus(): TypeRef {
	const result = new TypeRef();
	result.kind = TypeRefKind.NAMED;
	result.targetTypeName = "any";
	result.dynamic = true;
	return result;
}
