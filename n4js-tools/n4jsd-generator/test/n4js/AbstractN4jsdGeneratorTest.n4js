/**
 * Copyright (c) 2021 NumberFour AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   NumberFour AG - Initial API and implementation
 */

import * as fs_lib from "fs";
import * as path_lib from "path";
import * as utils from "utils";
import {runN4jsdGenerator} from "generator";
import {Assert} from "org/eclipse/n4js/mangelhaft/assert/Assert";

// must use '_' as prefix of following constants to avoid N4JS warning

/** Same as 'this.getTestFolder()'. Provided for readability. */
export let _ROOT: string = undefined;
/** Same as 'ROOT', but as a relative path based on the current working directory. */
export let _ROOT_RELATIVE: string = undefined;

export public interface ~ModuleDesc {
	/** Module name without file extension. May also be a relative(!) path using '/' as delimiter. */
	name: string;
	/** Content of the module on the TypeScript side (i.e. content of the .d.ts input file). */
	dts: string;
	/**
	 * Expected content of the module on the N4JS side (i.e. expected content of the generated
	 * .n4sjd output file). If omitted, generated output file won't be checked for this module.
	 */
	n4jsd?: string;
}

export public class AbstractN4jsdGeneratorTest {

	loggedErrors: string[] = [];
	loggedIssues: string[] = [];
	loggedInfos: string[] = [];
	loggedMessages: string[] = [];

	@Before
	protected cleanupBefore() {
		this.cleanup();
		_ROOT = this.getTestFolder();
		_ROOT_RELATIVE = path_lib.relative(process.cwd(), _ROOT);
	}

	@After
	protected cleanupAfter() {
		_ROOT = undefined;
		_ROOT_RELATIVE = undefined;
		this.cleanup();
	}

	/** Returns the absolute path to the temporary test folder. */
	protected getTestFolder(): string {
		return process.cwd() + "/test/temp_test_data";
	}

	protected cleanup() {
		fs_lib.rmdirSync(this.getTestFolder(), { recursive: true });
	}

	protected createFile(relativePathAndName: string, content: string) {
		const testFolderPath = this.getTestFolder();
		const pathAndName = testFolderPath + "/" + relativePathAndName;
		let contentAdjusted = utils.trimMultiLineString(content);
		if (contentAdjusted.length > 0) {
			contentAdjusted = contentAdjusted + "\n"; // end non-empty files with an empty line
		}
		utils.mkdirs(path_lib.dirname(pathAndName));
		fs_lib.writeFileSync(pathAndName, contentAdjusted, undefined);
	}

	protected createProject(relativePath: string, projectName: string) {
		const relPathAndName = (relativePath && relativePath.length > 0 ? relativePath + "/" : "")
			+ projectName + "/" + utils.PACKAGE_JSON;
		const obj = {
			"name": projectName,
			"version": "0.0.1",
			"description": "A test project.",
			"author": "Generated by AbstractN4jsdGeneratorTest#createPackageJson().",
			"license": "EPL-1.0",
			"devDependencies": {
				"typescript": "^4.0.5"
			}
		};
		this.createFile(relPathAndName, JSON.stringify(obj, undefined, "\t"));
	}

	protected runN4jsdGenerator(...args: string) {
		this.doRunN4jsdGenerator(args, []);
	}

	protected runN4jsdGeneratorWithErrors(args: string[], ...expectedErrors: string) {
		this.doRunN4jsdGenerator(args, expectedErrors);
	}

	private doRunN4jsdGenerator(args: string[], expectedErrors: string[]) {
		this.runN4jsdGeneratorWithoutCheckingErrors(args);
		if (expectedErrors.length === 0) {
			if (this.loggedErrors.length > 0) {
				Assert.fail("n4js-generator reported one or more unexpected errors:\n" + this.loggedErrors.join("\n"));
			}
		} else {
			if (this.loggedErrors.length === 0) {
				Assert.fail("n4js-generator did not report an error, even though an error was expected");
			}
			const actualErrorsSanitized = this.loggedErrors.map(err => this.relativizePaths(err));
			Assert.deepEqual(actualErrorsSanitized, expectedErrors);
		}
	}

	/**
	 * Runs the generator, updates the 'logged*' fields, but does not check the actually logged messages.
	 * Usually, methods #runN4jsdGenerator() or #runN4jsdGeneratorWithError() should be used instead.
	 */
	protected runN4jsdGeneratorWithoutCheckingErrors(args: string[]) {
		this.loggedErrors.splice(0);
		this.loggedIssues.splice(0);
		this.loggedInfos.splice(0);
		this.loggedMessages.splice(0);
		utils.setLogListener((kind, msg) => {
			switch(kind) {
				case utils.LogKind.ERROR:
					this.loggedErrors.push(msg);
					break;
				case utils.LogKind.ISSUE:
					this.loggedIssues.push(msg);
					break;
				case utils.LogKind.INFO:
					this.loggedInfos.push(msg);
					break;
			}
			this.loggedMessages.push(msg);
		})
		runN4jsdGenerator(args);
		utils.setLogListener(undefined);
	}

	protected assertFileExists(relativePathAndName: string) {
		const testFolderPath = this.getTestFolder();
		const pathAndName = testFolderPath + "/" + relativePathAndName;
		Assert.isTrue(fs_lib.existsSync(pathAndName), "file does not exist: " + pathAndName);
	}

	protected assertFileContent(relativePathAndName: string, expectedContent: string) {
		this.assertFileExists(relativePathAndName);
		const testFolderPath = this.getTestFolder();
		const pathAndName = testFolderPath + "/" + relativePathAndName;
		const actualContent = fs_lib.readFileSync(pathAndName, undefined).toString();
		const actualContentTrimmed = utils.trimMultiLineString(actualContent);
		const expectedContentTrimmed = utils.trimMultiLineString(expectedContent);
		this.assertStringEquals(actualContentTrimmed, expectedContentTrimmed,
			"file does not have the expected content: " + relativePathAndName);
	}

	protected assertConversion(...modules: ModuleDesc) {
		this.doAssertConversion(modules, []);
	}

	protected assertConversionWithErrors(modules: ModuleDesc[], ...expectedErrors: string) {
		this.doAssertConversion(modules, expectedErrors);
	}

	private doAssertConversion(modules: ModuleDesc[], expectedErrors: string[]) {
		Assert.isTrue(modules.length > 0, "at least one module description must be given");
		const projectName = "TestProject";
		this.createProject("input", projectName);
		for (const currModule of modules) {
			const fileName = currModule.name + ".d.ts";
			const path = "input/" + projectName + "/" + fileName;
			this.createFile(path, currModule.dts);
		}
		const args = [ "-f", "-o", _ROOT + "/output", _ROOT + "/input/" + projectName ];
		if (expectedErrors.length === 0) {
			this.doRunN4jsdGenerator(args, []);
		} else {
			this.doRunN4jsdGenerator(args, expectedErrors);
		}
		for (const currModule of modules) {
			if (!currModule.n4jsd) {
				continue; // no expectation given
			}
			const fileName = currModule.name + ".n4jsd";
			const path = "output/@n4jsd/" + projectName + "/" + fileName;
			this.assertFileContent(path, currModule.n4jsd);
		}
	}

	protected assertStringEquals(actual: string, expected: string, message: string = "unexpected string") {
		Assert.equal(actual, expected, message + `
${message}
EXPECTED:
-----------------------------
${expected}
-----------------------------
ACTUAL:
-----------------------------
${actual}
-----------------------------`);
	}

	protected relativizePaths(str: string): string {
		return str.split(_ROOT).join(".../" + path_lib.basename(_ROOT));
	}
}
